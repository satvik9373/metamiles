var kg = Object.defineProperty,
    zg = (t, e, n) => e in t ? kg(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : t[e] = n,
    st = (t, e, n) => zg(t, "symbol" != typeof e ? e + "" : e, n)
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
;
const ns = "164",
    Os = {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2
    },
    Bs = {
        ROTATE: 0,
        PAN: 1,
        DOLLY_PAN: 2,
        DOLLY_ROTATE: 3
    },
    Gg = 0,
    du = 1,
    Hg = 2,
    Jf = 1,
    Vg = 2,
    Si = 3,
    li = 0,
    Bt = 1,
    $t = 2,
    Wt = 0,
    hr = 1,
    br = 2,
    Cc = 3,
    fu = 4,
    Wg = 5,
    ms = 100,
    Xg = 101,
    jg = 102,
    Kg = 103,
    Yg = 104,
    Qg = 200,
    qg = 201,
    Zg = 202,
    Jg = 203,
    Ea = 204,
    Pc = 205,
    $f = 206,
    $g = 207,
    ev = 208,
    tv = 209,
    nv = 210,
    iv = 211,
    sv = 212,
    rv = 213,
    ov = 214,
    av = 0,
    nh = 1,
    lv = 2,
    Ta = 3,
    cv = 4,
    hv = 5,
    uv = 6,
    dv = 7,
    ih = 0,
    fv = 1,
    pv = 2,
    qi = 0,
    mv = 1,
    gv = 2,
    vv = 3,
    yv = 4,
    xv = 5,
    bv = 6,
    Av = 7,
    pu = "attached",
    Sv = "detached",
    ep = 300,
    Ar = 301,
    Sr = 302,
    uo = 303,
    Rc = 304,
    Ga = 306,
    $i = 1e3,
    Yi = 1001,
    Ca = 1002,
    Vt = 1003,
    tp = 1004,
    to = 1005,
    Ht = 1006,
    wa = 1007,
    Ei = 1008,
    Qt = 1009,
    _v = 1010,
    wv = 1011,
    np = 1012,
    ip = 1013,
    Cs = 1014,
    oi = 1015,
    Ha = 1016,
    sp = 1017,
    rp = 1018,
    Dr = 1020,
    Mv = 35902,
    op = 1021,
    Ev = 1022,
    Nn = 1023,
    ap = 1024,
    lp = 1025,
    Ms = 1026,
    Ps = 1027,
    sh = 1028,
    rh = 1029,
    cp = 1030,
    oh = 1031,
    ah = 1033,
    Al = 33776,
    Sl = 33777,
    _l = 33778,
    wl = 33779,
    mu = 35840,
    gu = 35841,
    vu = 35842,
    yu = 35843,
    xu = 36196,
    bu = 37492,
    Au = 37496,
    Su = 37808,
    _u = 37809,
    wu = 37810,
    Mu = 37811,
    Eu = 37812,
    Tu = 37813,
    Cu = 37814,
    Pu = 37815,
    Ru = 37816,
    Du = 37817,
    Iu = 37818,
    Lu = 37819,
    Ou = 37820,
    Bu = 37821,
    Ml = 36492,
    Uu = 36494,
    Nu = 36495,
    Tv = 36283,
    Fu = 36284,
    ku = 36285,
    zu = 36286,
    fo = 2300,
    _r = 2301,
    El = 2302,
    Gu = 2400,
    Hu = 2401,
    Vu = 2402,
    Cv = 2500,
    Pv = 0,
    hp = 1,
    Dc = 2,
    Oi = 3200,
    Rv = 3201,
    Va = 0,
    Dv = 1,
    On = "",
    rt = "srgb",
    Zn = "srgb-linear",
    lh = "display-p3",
    Wa = "display-p3-linear",
    Pa = "linear",
    St = "srgb",
    Ra = "rec709",
    Da = "p3",
    Us = 7680,
    Wu = 519,
    Iv = 512,
    Lv = 513,
    Ov = 514,
    up = 515,
    Bv = 516,
    Uv = 517,
    Nv = 518,
    Fv = 519,
    Ic = 35044,
    Xu = "300 es",
    Ti = 2e3,
    Ia = 2001;
class hi {
    addEventListener(t, e) {
        void 0 === this._listeners && (this._listeners = {});
        const n = this._listeners;
        void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e)
    }
    hasEventListener(t, e) {
        if (void 0 === this._listeners) return !1;
        const n = this._listeners;
        return void 0 !== n[t] && -1 !== n[t].indexOf(e)
    }
    removeEventListener(t, e) {
        if (void 0 === this._listeners) return;
        const n = this._listeners[t];
        if (void 0 !== n) {
            const t = n.indexOf(e); - 1 !== t && n.splice(t, 1)
        }
    }
    dispatchEvent(t) {
        if (void 0 === this._listeners) return;
        const e = this._listeners[t.type];
        if (void 0 !== e) {
            t.target = this;
            const n = e.slice(0);
            for (let e = 0, i = n.length; e < i; e++) n[e].call(this, t);
            t.target = null
        }
    }
}
const ln = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let ju = 1234567;
const ur = Math.PI / 180,
    wr = 180 / Math.PI;

function zn() {
    const t = 4294967295 * Math.random() | 0,
        e = 4294967295 * Math.random() | 0,
        n = 4294967295 * Math.random() | 0,
        i = 4294967295 * Math.random() | 0;
    return (ln[255 & t] + ln[t >> 8 & 255] + ln[t >> 16 & 255] + ln[t >> 24 & 255] + "-" + ln[255 & e] + ln[e >> 8 & 255] + "-" + ln[e >> 16 & 15 | 64] + ln[e >> 24 & 255] + "-" + ln[63 & n | 128] + ln[n >> 8 & 255] + "-" + ln[n >> 16 & 255] + ln[n >> 24 & 255] + ln[255 & i] + ln[i >> 8 & 255] + ln[i >> 16 & 255] + ln[i >> 24 & 255]).toLowerCase()
}

function Ut(t, e, n) {
    return Math.max(e, Math.min(n, t))
}

function ch(t, e) {
    return (t % e + e) % e
}

function kv(t, e, n, i, s) {
    return i + (t - e) * (s - i) / (n - e)
}

function zv(t, e, n) {
    return t !== e ? (n - t) / (e - t) : 0
}

function io(t, e, n) {
    return (1 - n) * t + n * e
}

function Gv(t, e, n, i) {
    return io(t, e, 1 - Math.exp(-n * i))
}

function Hv(t, e = 1) {
    return e - Math.abs(ch(t, 2 * e) - e)
}

function Vv(t, e, n) {
    return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t)
}

function Wv(t, e, n) {
    return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10)
}

function Xv(t, e) {
    return t + Math.floor(Math.random() * (e - t + 1))
}

function jv(t, e) {
    return t + Math.random() * (e - t)
}

function Kv(t) {
    return t * (.5 - Math.random())
}

function Yv(t) {
    void 0 !== t && (ju = t);
    let e = ju += 1831565813;
    return e = Math.imul(e ^ e >>> 15, 1 | e), e ^= e + Math.imul(e ^ e >>> 7, 61 | e), ((e ^ e >>> 14) >>> 0) / 4294967296
}

function Qv(t) {
    return t * ur
}

function qv(t) {
    return t * wr
}

function Zv(t) {
    return !(t & t - 1) && 0 !== t
}

function Jv(t) {
    return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
}

function $v(t) {
    return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
}

function e0(t, e, n, i, s) {
    const r = Math.cos,
        o = Math.sin,
        a = r(n / 2),
        l = o(n / 2),
        c = r((e + i) / 2),
        h = o((e + i) / 2),
        u = r((e - i) / 2),
        d = o((e - i) / 2),
        p = r((i - e) / 2),
        f = o((i - e) / 2);
    switch (s) {
        case "XYX":
            t.set(a * h, l * u, l * d, a * c);
            break;
        case "YZY":
            t.set(l * d, a * h, l * u, a * c);
            break;
        case "ZXZ":
            t.set(l * u, l * d, a * h, a * c);
            break;
        case "XZX":
            t.set(a * h, l * f, l * p, a * c);
            break;
        case "YXY":
            t.set(l * p, a * h, l * f, a * c);
            break;
        case "ZYZ":
            t.set(l * f, l * p, a * h, a * c);
            break;
        default:
            console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + s)
    }
}

function Yn(t, e) {
    switch (e.constructor) {
        case Float32Array:
            return t;
        case Uint32Array:
            return t / 4294967295;
        case Uint16Array:
            return t / 65535;
        case Uint8Array:
            return t / 255;
        case Int32Array:
            return Math.max(t / 2147483647, -1);
        case Int16Array:
            return Math.max(t / 32767, -1);
        case Int8Array:
            return Math.max(t / 127, -1);
        default:
            throw new Error("Invalid component type.")
    }
}

function mt(t, e) {
    switch (e.constructor) {
        case Float32Array:
            return t;
        case Uint32Array:
            return Math.round(4294967295 * t);
        case Uint16Array:
            return Math.round(65535 * t);
        case Uint8Array:
            return Math.round(255 * t);
        case Int32Array:
            return Math.round(2147483647 * t);
        case Int16Array:
            return Math.round(32767 * t);
        case Int8Array:
            return Math.round(127 * t);
        default:
            throw new Error("Invalid component type.")
    }
}
const _i = {
    DEG2RAD: ur,
    RAD2DEG: wr,
    generateUUID: zn,
    clamp: Ut,
    euclideanModulo: ch,
    mapLinear: kv,
    inverseLerp: zv,
    lerp: io,
    damp: Gv,
    pingpong: Hv,
    smoothstep: Vv,
    smootherstep: Wv,
    randInt: Xv,
    randFloat: jv,
    randFloatSpread: Kv,
    seededRandom: Yv,
    degToRad: Qv,
    radToDeg: qv,
    isPowerOfTwo: Zv,
    ceilPowerOfTwo: Jv,
    floorPowerOfTwo: $v,
    setQuaternionFromProperEuler: e0,
    normalize: mt,
    denormalize: Yn
};
class Q {
    constructor(t = 0, e = 0) {
        Q.prototype.isVector2 = !0, this.x = t, this.y = e
    }
    get width() {
        return this.x
    }
    set width(t) {
        this.x = t
    }
    get height() {
        return this.y
    }
    set height(t) {
        this.y = t
    }
    set(t, e) {
        return this.x = t, this.y = e, this
    }
    setScalar(t) {
        return this.x = t, this.y = t, this
    }
    setX(t) {
        return this.x = t, this
    }
    setY(t) {
        return this.y = t, this
    }
    setComponent(t, e) {
        switch (t) {
            case 0:
                this.x = e;
                break;
            case 1:
                this.y = e;
                break;
            default:
                throw new Error("index is out of range: " + t)
        }
        return this
    }
    getComponent(t) {
        switch (t) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw new Error("index is out of range: " + t)
        }
    }
    clone() {
        return new this.constructor(this.x, this.y)
    }
    copy(t) {
        return this.x = t.x, this.y = t.y, this
    }
    add(t) {
        return this.x += t.x, this.y += t.y, this
    }
    addScalar(t) {
        return this.x += t, this.y += t, this
    }
    addVectors(t, e) {
        return this.x = t.x + e.x, this.y = t.y + e.y, this
    }
    addScaledVector(t, e) {
        return this.x += t.x * e, this.y += t.y * e, this
    }
    sub(t) {
        return this.x -= t.x, this.y -= t.y, this
    }
    subScalar(t) {
        return this.x -= t, this.y -= t, this
    }
    subVectors(t, e) {
        return this.x = t.x - e.x, this.y = t.y - e.y, this
    }
    multiply(t) {
        return this.x *= t.x, this.y *= t.y, this
    }
    multiplyScalar(t) {
        return this.x *= t, this.y *= t, this
    }
    divide(t) {
        return this.x /= t.x, this.y /= t.y, this
    }
    divideScalar(t) {
        return this.multiplyScalar(1 / t)
    }
    applyMatrix3(t) {
        const e = this.x,
            n = this.y,
            i = t.elements;
        return this.x = i[0] * e + i[3] * n + i[6], this.y = i[1] * e + i[4] * n + i[7], this
    }
    min(t) {
        return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
    }
    max(t) {
        return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
    }
    clamp(t, e) {
        return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
    }
    clampScalar(t, e) {
        return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this
    }
    clampLength(t, e) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
    }
    floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
    }
    ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
    }
    round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this
    }
    negate() {
        return this.x = -this.x, this.y = -this.y, this
    }
    dot(t) {
        return this.x * t.x + this.y * t.y
    }
    cross(t) {
        return this.x * t.y - this.y * t.x
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI
    }
    angleTo(t) {
        const e = Math.sqrt(this.lengthSq() * t.lengthSq());
        if (0 === e) return Math.PI / 2;
        const n = this.dot(t) / e;
        return Math.acos(Ut(n, -1, 1))
    }
    distanceTo(t) {
        return Math.sqrt(this.distanceToSquared(t))
    }
    distanceToSquared(t) {
        const e = this.x - t.x,
            n = this.y - t.y;
        return e * e + n * n
    }
    manhattanDistanceTo(t) {
        return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
    }
    setLength(t) {
        return this.normalize().multiplyScalar(t)
    }
    lerp(t, e) {
        return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
    }
    lerpVectors(t, e, n) {
        return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this
    }
    equals(t) {
        return t.x === this.x && t.y === this.y
    }
    fromArray(t, e = 0) {
        return this.x = t[e], this.y = t[e + 1], this
    }
    toArray(t = [], e = 0) {
        return t[e] = this.x, t[e + 1] = this.y, t
    }
    fromBufferAttribute(t, e) {
        return this.x = t.getX(e), this.y = t.getY(e), this
    }
    rotateAround(t, e) {
        const n = Math.cos(e),
            i = Math.sin(e),
            s = this.x - t.x,
            r = this.y - t.y;
        return this.x = s * n - r * i + t.x, this.y = s * i + r * n + t.y, this
    }
    random() {
        return this.x = Math.random(), this.y = Math.random(), this
    }*[Symbol.iterator]() {
        yield this.x, yield this.y
    }
}
class We {
    constructor(t, e, n, i, s, r, o, a, l) {
        We.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], void 0 !== t && this.set(t, e, n, i, s, r, o, a, l)
    }
    set(t, e, n, i, s, r, o, a, l) {
        const c = this.elements;
        return c[0] = t, c[1] = i, c[2] = o, c[3] = e, c[4] = s, c[5] = a, c[6] = n, c[7] = r, c[8] = l, this
    }
    identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
    }
    copy(t) {
        const e = this.elements,
            n = t.elements;
        return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this
    }
    extractBasis(t, e, n) {
        return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
    }
    setFromMatrix4(t) {
        const e = t.elements;
        return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
    }
    multiply(t) {
        return this.multiplyMatrices(this, t)
    }
    premultiply(t) {
        return this.multiplyMatrices(t, this)
    }
    multiplyMatrices(t, e) {
        const n = t.elements,
            i = e.elements,
            s = this.elements,
            r = n[0],
            o = n[3],
            a = n[6],
            l = n[1],
            c = n[4],
            h = n[7],
            u = n[2],
            d = n[5],
            p = n[8],
            f = i[0],
            m = i[3],
            g = i[6],
            v = i[1],
            y = i[4],
            x = i[7],
            b = i[2],
            A = i[5],
            S = i[8];
        return s[0] = r * f + o * v + a * b, s[3] = r * m + o * y + a * A, s[6] = r * g + o * x + a * S, s[1] = l * f + c * v + h * b, s[4] = l * m + c * y + h * A, s[7] = l * g + c * x + h * S, s[2] = u * f + d * v + p * b, s[5] = u * m + d * y + p * A, s[8] = u * g + d * x + p * S, this
    }
    multiplyScalar(t) {
        const e = this.elements;
        return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
    }
    determinant() {
        const t = this.elements,
            e = t[0],
            n = t[1],
            i = t[2],
            s = t[3],
            r = t[4],
            o = t[5],
            a = t[6],
            l = t[7],
            c = t[8];
        return e * r * c - e * o * l - n * s * c + n * o * a + i * s * l - i * r * a
    }
    invert() {
        const t = this.elements,
            e = t[0],
            n = t[1],
            i = t[2],
            s = t[3],
            r = t[4],
            o = t[5],
            a = t[6],
            l = t[7],
            c = t[8],
            h = c * r - o * l,
            u = o * a - c * s,
            d = l * s - r * a,
            p = e * h + n * u + i * d;
        if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const f = 1 / p;
        return t[0] = h * f, t[1] = (i * l - c * n) * f, t[2] = (o * n - i * r) * f, t[3] = u * f, t[4] = (c * e - i * a) * f, t[5] = (i * s - o * e) * f, t[6] = d * f, t[7] = (n * a - l * e) * f, t[8] = (r * e - n * s) * f, this
    }
    transpose() {
        let t;
        const e = this.elements;
        return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
    }
    getNormalMatrix(t) {
        return this.setFromMatrix4(t).invert().transpose()
    }
    transposeIntoArray(t) {
        const e = this.elements;
        return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
    }
    setUvTransform(t, e, n, i, s, r, o) {
        const a = Math.cos(s),
            l = Math.sin(s);
        return this.set(n * a, n * l, -n * (a * r + l * o) + r + t, -i * l, i * a, -i * (-l * r + a * o) + o + e, 0, 0, 1), this
    }
    scale(t, e) {
        return this.premultiply(Tl.makeScale(t, e)), this
    }
    rotate(t) {
        return this.premultiply(Tl.makeRotation(-t)), this
    }
    translate(t, e) {
        return this.premultiply(Tl.makeTranslation(t, e)), this
    }
    makeTranslation(t, e) {
        return t.isVector2 ? this.set(1, 0, t.x, 0, 1, t.y, 0, 0, 1) : this.set(1, 0, t, 0, 1, e, 0, 0, 1), this
    }
    makeRotation(t) {
        const e = Math.cos(t),
            n = Math.sin(t);
        return this.set(e, -n, 0, n, e, 0, 0, 0, 1), this
    }
    makeScale(t, e) {
        return this.set(t, 0, 0, 0, e, 0, 0, 0, 1), this
    }
    equals(t) {
        const e = this.elements,
            n = t.elements;
        for (let t = 0; t < 9; t++)
            if (e[t] !== n[t]) return !1;
        return !0
    }
    fromArray(t, e = 0) {
        for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
        return this
    }
    toArray(t = [], e = 0) {
        const n = this.elements;
        return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t
    }
    clone() {
        return (new this.constructor).fromArray(this.elements)
    }
}
const Tl = new We;

function dp(t) {
    for (let e = t.length - 1; e >= 0; --e)
        if (t[e] >= 65535) return !0;
    return !1
}

function po(t) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", t)
}

function t0() {
    const t = po("canvas");
    return t.style.display = "block", t
}
const Ku = {};

function fp(t) {
    t in Ku || (Ku[t] = !0, console.warn(t))
}
const Yu = (new We).set(.8224621, .177538, 0, .0331941, .9668058, 0, .0170827, .0723974, .9105199),
    Qu = (new We).set(1.2249401, -.2249404, 0, -.0420569, 1.0420571, 0, -.0196376, -.0786361, 1.0982735),
    Ro = {
        [Zn]: {
            transfer: Pa,
            primaries: Ra,
            toReference: t => t,
            fromReference: t => t
        },
        [rt]: {
            transfer: St,
            primaries: Ra,
            toReference: t => t.convertSRGBToLinear(),
            fromReference: t => t.convertLinearToSRGB()
        },
        [Wa]: {
            transfer: Pa,
            primaries: Da,
            toReference: t => t.applyMatrix3(Qu),
            fromReference: t => t.applyMatrix3(Yu)
        },
        [lh]: {
            transfer: St,
            primaries: Da,
            toReference: t => t.convertSRGBToLinear().applyMatrix3(Qu),
            fromReference: t => t.applyMatrix3(Yu).convertLinearToSRGB()
        }
    },
    n0 = new Set([Zn, Wa]),
    vt = {
        enabled: !0,
        _workingColorSpace: Zn,
        get workingColorSpace() {
            return this._workingColorSpace
        },
        set workingColorSpace(t) {
            if (!n0.has(t)) throw new Error(`Unsupported working color space, "${t}".`);
            this._workingColorSpace = t
        },
        convert: function(t, e, n) {
            if (!1 === this.enabled || e === n || !e || !n) return t;
            const i = Ro[e].toReference;
            return (0, Ro[n].fromReference)(i(t))
        },
        fromWorkingColorSpace: function(t, e) {
            return this.convert(t, this._workingColorSpace, e)
        },
        toWorkingColorSpace: function(t, e) {
            return this.convert(t, e, this._workingColorSpace)
        },
        getPrimaries: function(t) {
            return Ro[t].primaries
        },
        getTransfer: function(t) {
            return "" === t ? Pa : Ro[t].transfer
        }
    };

function dr(t) {
    return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
}

function Cl(t) {
    return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
}
let Ns;
class i0 {
    static getDataURL(t) {
        if (/^data:/i.test(t.src) || typeof HTMLCanvasElement > "u") return t.src;
        let e;
        if (t instanceof HTMLCanvasElement) e = t;
        else {
            void 0 === Ns && (Ns = po("canvas")), Ns.width = t.width, Ns.height = t.height;
            const n = Ns.getContext("2d");
            t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = Ns
        }
        return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t), e.toDataURL("image/jpeg", .6)) : e.toDataURL("image/png")
    }
    static sRGBToLinear(t) {
        if (typeof HTMLImageElement < "u" && t instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && t instanceof ImageBitmap) {
            const e = po("canvas");
            e.width = t.width, e.height = t.height;
            const n = e.getContext("2d");
            n.drawImage(t, 0, 0, t.width, t.height);
            const i = n.getImageData(0, 0, t.width, t.height),
                s = i.data;
            for (let t = 0; t < s.length; t++) s[t] = 255 * dr(s[t] / 255);
            return n.putImageData(i, 0, 0), e
        }
        if (t.data) {
            const e = t.data.slice(0);
            for (let t = 0; t < e.length; t++) e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[t] = Math.floor(255 * dr(e[t] / 255)) : e[t] = dr(e[t]);
            return {
                data: e,
                width: t.width,
                height: t.height
            }
        }
        return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), t
    }
}
let s0 = 0;
class pp {
    constructor(t = null) {
        this.isSource = !0, Object.defineProperty(this, "id", {
            value: s0++
        }), this.uuid = zn(), this.data = t, this.dataReady = !0, this.version = 0
    }
    set needsUpdate(t) {
        !0 === t && this.version++
    }
    toJSON(t) {
        const e = void 0 === t || "string" == typeof t;
        if (!e && void 0 !== t.images[this.uuid]) return t.images[this.uuid];
        const n = {
                uuid: this.uuid,
                url: ""
            },
            i = this.data;
        if (null !== i) {
            let t;
            if (Array.isArray(i)) {
                t = [];
                for (let e = 0, n = i.length; e < n; e++) i[e].isDataTexture ? t.push(Pl(i[e].image)) : t.push(Pl(i[e]))
            } else t = Pl(i);
            n.url = t
        }
        return e || (t.images[this.uuid] = n), n
    }
}

function Pl(t) {
    return typeof HTMLImageElement < "u" && t instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && t instanceof ImageBitmap ? i0.getDataURL(t) : t.data ? {
        data: Array.from(t.data),
        width: t.width,
        height: t.height,
        type: t.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
}
let r0 = 0;
class wt extends hi {
    constructor(t = wt.DEFAULT_IMAGE, e = wt.DEFAULT_MAPPING, n = Yi, i = Yi, s = Ht, r = Ei, o = Nn, a = Qt, l = wt.DEFAULT_ANISOTROPY, c = "") {
        super(), this.isTexture = !0, Object.defineProperty(this, "id", {
            value: r0++
        }), this.uuid = zn(), this.name = "", this.source = new pp(t), this.mipmaps = [], this.mapping = e, this.channel = 0, this.wrapS = n, this.wrapT = i, this.magFilter = s, this.minFilter = r, this.anisotropy = l, this.format = o, this.internalFormat = null, this.type = a, this.offset = new Q(0, 0), this.repeat = new Q(1, 1), this.center = new Q(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new We, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = c, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0
    }
    get image() {
        return this.source.data
    }
    set image(t = null) {
        this.source.data = t
    }
    updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
    }
    clone() {
        return (new this.constructor).copy(this)
    }
    copy(t) {
        return this.name = t.name, this.source = t.source, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.channel = t.channel, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.colorSpace = t.colorSpace, this.userData = JSON.parse(JSON.stringify(t.userData)), this.needsUpdate = !0, this
    }
    toJSON(t) {
        const e = void 0 === t || "string" == typeof t;
        if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
        const n = {
            metadata: {
                version: 4.6,
                type: "Texture",
                generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(t).uuid,
            mapping: this.mapping,
            channel: this.channel,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            internalFormat: this.internalFormat,
            type: this.type,
            colorSpace: this.colorSpace,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        return Object.keys(this.userData).length > 0 && (n.userData = this.userData), e || (t.textures[this.uuid] = n), n
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    transformUv(t) {
        if (this.mapping !== ep) return t;
        if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
            case $i:
                t.x = t.x - Math.floor(t.x);
                break;
            case Yi:
                t.x = t.x < 0 ? 0 : 1;
                break;
            case Ca:
                1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
        }
        if (t.y < 0 || t.y > 1) switch (this.wrapT) {
            case $i:
                t.y = t.y - Math.floor(t.y);
                break;
            case Yi:
                t.y = t.y < 0 ? 0 : 1;
                break;
            case Ca:
                1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
        }
        return this.flipY && (t.y = 1 - t.y), t
    }
    set needsUpdate(t) {
        !0 === t && (this.version++, this.source.needsUpdate = !0)
    }
    set needsPMREMUpdate(t) {
        !0 === t && this.pmremVersion++
    }
}
wt.DEFAULT_IMAGE = null, wt.DEFAULT_MAPPING = ep, wt.DEFAULT_ANISOTROPY = 1;
class ot {
    constructor(t = 0, e = 0, n = 0, i = 1) {
        ot.prototype.isVector4 = !0, this.x = t, this.y = e, this.z = n, this.w = i
    }
    get width() {
        return this.z
    }
    set width(t) {
        this.z = t
    }
    get height() {
        return this.w
    }
    set height(t) {
        this.w = t
    }
    set(t, e, n, i) {
        return this.x = t, this.y = e, this.z = n, this.w = i, this
    }
    setScalar(t) {
        return this.x = t, this.y = t, this.z = t, this.w = t, this
    }
    setX(t) {
        return this.x = t, this
    }
    setY(t) {
        return this.y = t, this
    }
    setZ(t) {
        return this.z = t, this
    }
    setW(t) {
        return this.w = t, this
    }
    setComponent(t, e) {
        switch (t) {
            case 0:
                this.x = e;
                break;
            case 1:
                this.y = e;
                break;
            case 2:
                this.z = e;
                break;
            case 3:
                this.w = e;
                break;
            default:
                throw new Error("index is out of range: " + t)
        }
        return this
    }
    getComponent(t) {
        switch (t) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw new Error("index is out of range: " + t)
        }
    }
    clone() {
        return new this.constructor(this.x, this.y, this.z, this.w)
    }
    copy(t) {
        return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
    }
    add(t) {
        return this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this
    }
    addScalar(t) {
        return this.x += t, this.y += t, this.z += t, this.w += t, this
    }
    addVectors(t, e) {
        return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
    }
    addScaledVector(t, e) {
        return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
    }
    sub(t) {
        return this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this
    }
    subScalar(t) {
        return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
    }
    subVectors(t, e) {
        return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
    }
    multiply(t) {
        return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this
    }
    multiplyScalar(t) {
        return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
    }
    applyMatrix4(t) {
        const e = this.x,
            n = this.y,
            i = this.z,
            s = this.w,
            r = t.elements;
        return this.x = r[0] * e + r[4] * n + r[8] * i + r[12] * s, this.y = r[1] * e + r[5] * n + r[9] * i + r[13] * s, this.z = r[2] * e + r[6] * n + r[10] * i + r[14] * s, this.w = r[3] * e + r[7] * n + r[11] * i + r[15] * s, this
    }
    divideScalar(t) {
        return this.multiplyScalar(1 / t)
    }
    setAxisAngleFromQuaternion(t) {
        this.w = 2 * Math.acos(t.w);
        const e = Math.sqrt(1 - t.w * t.w);
        return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
    }
    setAxisAngleFromRotationMatrix(t) {
        let e, n, i, s;
        const r = t.elements,
            o = r[0],
            a = r[4],
            l = r[8],
            c = r[1],
            h = r[5],
            u = r[9],
            d = r[2],
            p = r[6],
            f = r[10];
        if (Math.abs(a - c) < .01 && Math.abs(l - d) < .01 && Math.abs(u - p) < .01) {
            if (Math.abs(a + c) < .1 && Math.abs(l + d) < .1 && Math.abs(u + p) < .1 && Math.abs(o + h + f - 3) < .1) return this.set(1, 0, 0, 0), this;
            e = Math.PI;
            const t = (o + 1) / 2,
                r = (h + 1) / 2,
                m = (f + 1) / 2,
                g = (a + c) / 4,
                v = (l + d) / 4,
                y = (u + p) / 4;
            return t > r && t > m ? t < .01 ? (n = 0, i = .707106781, s = .707106781) : (n = Math.sqrt(t), i = g / n, s = v / n) : r > m ? r < .01 ? (n = .707106781, i = 0, s = .707106781) : (i = Math.sqrt(r), n = g / i, s = y / i) : m < .01 ? (n = .707106781, i = .707106781, s = 0) : (s = Math.sqrt(m), n = v / s, i = y / s), this.set(n, i, s, e), this
        }
        let m = Math.sqrt((p - u) * (p - u) + (l - d) * (l - d) + (c - a) * (c - a));
        return Math.abs(m) < .001 && (m = 1), this.x = (p - u) / m, this.y = (l - d) / m, this.z = (c - a) / m, this.w = Math.acos((o + h + f - 1) / 2), this
    }
    min(t) {
        return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
    }
    max(t) {
        return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
    }
    clamp(t, e) {
        return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
    }
    clampScalar(t, e) {
        return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this
    }
    clampLength(t, e) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
    }
    floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
    }
    ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
    }
    round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this
    }
    negate() {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
    }
    dot(t) {
        return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(t) {
        return this.normalize().multiplyScalar(t)
    }
    lerp(t, e) {
        return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
    }
    lerpVectors(t, e, n) {
        return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this.w = t.w + (e.w - t.w) * n, this
    }
    equals(t) {
        return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
    }
    fromArray(t, e = 0) {
        return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
    }
    toArray(t = [], e = 0) {
        return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
    }
    fromBufferAttribute(t, e) {
        return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
    }
    random() {
        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
    }*[Symbol.iterator]() {
        yield this.x, yield this.y, yield this.z, yield this.w
    }
}
class o0 extends hi {
    constructor(t = 1, e = 1, n = {}) {
        super(), this.isRenderTarget = !0, this.width = t, this.height = e, this.depth = 1, this.scissor = new ot(0, 0, t, e), this.scissorTest = !1, this.viewport = new ot(0, 0, t, e);
        const i = {
            width: t,
            height: e,
            depth: 1
        };
        n = Object.assign({
            generateMipmaps: !1,
            internalFormat: null,
            minFilter: Ht,
            depthBuffer: !0,
            stencilBuffer: !1,
            resolveDepthBuffer: !0,
            resolveStencilBuffer: !0,
            depthTexture: null,
            samples: 0,
            count: 1
        }, n);
        const s = new wt(i, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace);
        s.flipY = !1, s.generateMipmaps = n.generateMipmaps, s.internalFormat = n.internalFormat, this.textures = [];
        const r = n.count;
        for (let t = 0; t < r; t++) this.textures[t] = s.clone(), this.textures[t].isRenderTargetTexture = !0;
        this.depthBuffer = n.depthBuffer, this.stencilBuffer = n.stencilBuffer, this.resolveDepthBuffer = n.resolveDepthBuffer, this.resolveStencilBuffer = n.resolveStencilBuffer, this.depthTexture = n.depthTexture, this.samples = n.samples
    }
    get texture() {
        return this.textures[0]
    }
    set texture(t) {
        this.textures[0] = t
    }
    setSize(t, e, n = 1) {
        if (this.width !== t || this.height !== e || this.depth !== n) {
            this.width = t, this.height = e, this.depth = n;
            for (let i = 0, s = this.textures.length; i < s; i++) this.textures[i].image.width = t, this.textures[i].image.height = e, this.textures[i].image.depth = n;
            this.dispose()
        }
        this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
    }
    clone() {
        return (new this.constructor).copy(this)
    }
    copy(t) {
        this.width = t.width, this.height = t.height, this.depth = t.depth, this.scissor.copy(t.scissor), this.scissorTest = t.scissorTest, this.viewport.copy(t.viewport), this.textures.length = 0;
        for (let e = 0, n = t.textures.length; e < n; e++) this.textures[e] = t.textures[e].clone(), this.textures[e].isRenderTargetTexture = !0;
        const e = Object.assign({}, t.texture.image);
        return this.texture.source = new pp(e), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.resolveDepthBuffer = t.resolveDepthBuffer, this.resolveStencilBuffer = t.resolveStencilBuffer, null !== t.depthTexture && (this.depthTexture = t.depthTexture.clone()), this.samples = t.samples, this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
class nn extends o0 {
    constructor(t = 1, e = 1, n = {}) {
        super(t, e, n), this.isWebGLRenderTarget = !0
    }
}
class mp extends wt {
    constructor(t = null, e = 1, n = 1, i = 1) {
        super(null), this.isDataArrayTexture = !0, this.image = {
            data: t,
            width: e,
            height: n,
            depth: i
        }, this.magFilter = Vt, this.minFilter = Vt, this.wrapR = Yi, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
    }
}
class a0 extends wt {
    constructor(t = null, e = 1, n = 1, i = 1) {
        super(null), this.isData3DTexture = !0, this.image = {
            data: t,
            width: e,
            height: n,
            depth: i
        }, this.magFilter = Vt, this.minFilter = Vt, this.wrapR = Yi, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
    }
}
class bt {
    constructor(t = 0, e = 0, n = 0, i = 1) {
        this.isQuaternion = !0, this._x = t, this._y = e, this._z = n, this._w = i
    }
    static slerpFlat(t, e, n, i, s, r, o) {
        let a = n[i + 0],
            l = n[i + 1],
            c = n[i + 2],
            h = n[i + 3];
        const u = s[r + 0],
            d = s[r + 1],
            p = s[r + 2],
            f = s[r + 3];
        if (0 === o) return t[e + 0] = a, t[e + 1] = l, t[e + 2] = c, void(t[e + 3] = h);
        if (1 === o) return t[e + 0] = u, t[e + 1] = d, t[e + 2] = p, void(t[e + 3] = f);
        if (h !== f || a !== u || l !== d || c !== p) {
            let t = 1 - o;
            const e = a * u + l * d + c * p + h * f,
                n = e >= 0 ? 1 : -1,
                i = 1 - e * e;
            if (i > Number.EPSILON) {
                const s = Math.sqrt(i),
                    r = Math.atan2(s, e * n);
                t = Math.sin(t * r) / s, o = Math.sin(o * r) / s
            }
            const s = o * n;
            if (a = a * t + u * s, l = l * t + d * s, c = c * t + p * s, h = h * t + f * s, t === 1 - o) {
                const t = 1 / Math.sqrt(a * a + l * l + c * c + h * h);
                a *= t, l *= t, c *= t, h *= t
            }
        }
        t[e] = a, t[e + 1] = l, t[e + 2] = c, t[e + 3] = h
    }
    static multiplyQuaternionsFlat(t, e, n, i, s, r) {
        const o = n[i],
            a = n[i + 1],
            l = n[i + 2],
            c = n[i + 3],
            h = s[r],
            u = s[r + 1],
            d = s[r + 2],
            p = s[r + 3];
        return t[e] = o * p + c * h + a * d - l * u, t[e + 1] = a * p + c * u + l * h - o * d, t[e + 2] = l * p + c * d + o * u - a * h, t[e + 3] = c * p - o * h - a * u - l * d, t
    }
    get x() {
        return this._x
    }
    set x(t) {
        this._x = t, this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(t) {
        this._y = t, this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(t) {
        this._z = t, this._onChangeCallback()
    }
    get w() {
        return this._w
    }
    set w(t) {
        this._w = t, this._onChangeCallback()
    }
    set(t, e, n, i) {
        return this._x = t, this._y = e, this._z = n, this._w = i, this._onChangeCallback(), this
    }
    clone() {
        return new this.constructor(this._x, this._y, this._z, this._w)
    }
    copy(t) {
        return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this
    }
    setFromEuler(t, e = !0) {
        const n = t._x,
            i = t._y,
            s = t._z,
            r = t._order,
            o = Math.cos,
            a = Math.sin,
            l = o(n / 2),
            c = o(i / 2),
            h = o(s / 2),
            u = a(n / 2),
            d = a(i / 2),
            p = a(s / 2);
        switch (r) {
            case "XYZ":
                this._x = u * c * h + l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h - u * d * p;
                break;
            case "YXZ":
                this._x = u * c * h + l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h + u * d * p;
                break;
            case "ZXY":
                this._x = u * c * h - l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h - u * d * p;
                break;
            case "ZYX":
                this._x = u * c * h - l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h + u * d * p;
                break;
            case "YZX":
                this._x = u * c * h + l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h - u * d * p;
                break;
            case "XZY":
                this._x = u * c * h - l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h + u * d * p;
                break;
            default:
                console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + r)
        }
        return !0 === e && this._onChangeCallback(), this
    }
    setFromAxisAngle(t, e) {
        const n = e / 2,
            i = Math.sin(n);
        return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(n), this._onChangeCallback(), this
    }
    setFromRotationMatrix(t) {
        const e = t.elements,
            n = e[0],
            i = e[4],
            s = e[8],
            r = e[1],
            o = e[5],
            a = e[9],
            l = e[2],
            c = e[6],
            h = e[10],
            u = n + o + h;
        if (u > 0) {
            const t = .5 / Math.sqrt(u + 1);
            this._w = .25 / t, this._x = (c - a) * t, this._y = (s - l) * t, this._z = (r - i) * t
        } else if (n > o && n > h) {
            const t = 2 * Math.sqrt(1 + n - o - h);
            this._w = (c - a) / t, this._x = .25 * t, this._y = (i + r) / t, this._z = (s + l) / t
        } else if (o > h) {
            const t = 2 * Math.sqrt(1 + o - n - h);
            this._w = (s - l) / t, this._x = (i + r) / t, this._y = .25 * t, this._z = (a + c) / t
        } else {
            const t = 2 * Math.sqrt(1 + h - n - o);
            this._w = (r - i) / t, this._x = (s + l) / t, this._y = (a + c) / t, this._z = .25 * t
        }
        return this._onChangeCallback(), this
    }
    setFromUnitVectors(t, e) {
        let n = t.dot(e) + 1;
        return n < Number.EPSILON ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize()
    }
    angleTo(t) {
        return 2 * Math.acos(Math.abs(Ut(this.dot(t), -1, 1)))
    }
    rotateTowards(t, e) {
        const n = this.angleTo(t);
        if (0 === n) return this;
        const i = Math.min(1, e / n);
        return this.slerp(t, i), this
    }
    identity() {
        return this.set(0, 0, 0, 1)
    }
    invert() {
        return this.conjugate()
    }
    conjugate() {
        return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
    }
    dot(t) {
        return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
    }
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    }
    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    }
    normalize() {
        let t = this.length();
        return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this
    }
    multiply(t) {
        return this.multiplyQuaternions(this, t)
    }
    premultiply(t) {
        return this.multiplyQuaternions(t, this)
    }
    multiplyQuaternions(t, e) {
        const n = t._x,
            i = t._y,
            s = t._z,
            r = t._w,
            o = e._x,
            a = e._y,
            l = e._z,
            c = e._w;
        return this._x = n * c + r * o + i * l - s * a, this._y = i * c + r * a + s * o - n * l, this._z = s * c + r * l + n * a - i * o, this._w = r * c - n * o - i * a - s * l, this._onChangeCallback(), this
    }
    slerp(t, e) {
        if (0 === e) return this;
        if (1 === e) return this.copy(t);
        const n = this._x,
            i = this._y,
            s = this._z,
            r = this._w;
        let o = r * t._w + n * t._x + i * t._y + s * t._z;
        if (o < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, o = -o) : this.copy(t), o >= 1) return this._w = r, this._x = n, this._y = i, this._z = s, this;
        const a = 1 - o * o;
        if (a <= Number.EPSILON) {
            const t = 1 - e;
            return this._w = t * r + e * this._w, this._x = t * n + e * this._x, this._y = t * i + e * this._y, this._z = t * s + e * this._z, this.normalize(), this
        }
        const l = Math.sqrt(a),
            c = Math.atan2(l, o),
            h = Math.sin((1 - e) * c) / l,
            u = Math.sin(e * c) / l;
        return this._w = r * h + this._w * u, this._x = n * h + this._x * u, this._y = i * h + this._y * u, this._z = s * h + this._z * u, this._onChangeCallback(), this
    }
    slerpQuaternions(t, e, n) {
        return this.copy(t).slerp(e, n)
    }
    random() {
        const t = 2 * Math.PI * Math.random(),
            e = 2 * Math.PI * Math.random(),
            n = Math.random(),
            i = Math.sqrt(1 - n),
            s = Math.sqrt(n);
        return this.set(i * Math.sin(t), i * Math.cos(t), s * Math.sin(e), s * Math.cos(e))
    }
    equals(t) {
        return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
    }
    fromArray(t, e = 0) {
        return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this
    }
    toArray(t = [], e = 0) {
        return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
    }
    fromBufferAttribute(t, e) {
        return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this._onChangeCallback(), this
    }
    toJSON() {
        return this.toArray()
    }
    _onChange(t) {
        return this._onChangeCallback = t, this
    }
    _onChangeCallback() {}*[Symbol.iterator]() {
        yield this._x, yield this._y, yield this._z, yield this._w
    }
}
class U {
    constructor(t = 0, e = 0, n = 0) {
        U.prototype.isVector3 = !0, this.x = t, this.y = e, this.z = n
    }
    set(t, e, n) {
        return void 0 === n && (n = this.z), this.x = t, this.y = e, this.z = n, this
    }
    setScalar(t) {
        return this.x = t, this.y = t, this.z = t, this
    }
    setX(t) {
        return this.x = t, this
    }
    setY(t) {
        return this.y = t, this
    }
    setZ(t) {
        return this.z = t, this
    }
    setComponent(t, e) {
        switch (t) {
            case 0:
                this.x = e;
                break;
            case 1:
                this.y = e;
                break;
            case 2:
                this.z = e;
                break;
            default:
                throw new Error("index is out of range: " + t)
        }
        return this
    }
    getComponent(t) {
        switch (t) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw new Error("index is out of range: " + t)
        }
    }
    clone() {
        return new this.constructor(this.x, this.y, this.z)
    }
    copy(t) {
        return this.x = t.x, this.y = t.y, this.z = t.z, this
    }
    add(t) {
        return this.x += t.x, this.y += t.y, this.z += t.z, this
    }
    addScalar(t) {
        return this.x += t, this.y += t, this.z += t, this
    }
    addVectors(t, e) {
        return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
    }
    addScaledVector(t, e) {
        return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
    }
    sub(t) {
        return this.x -= t.x, this.y -= t.y, this.z -= t.z, this
    }
    subScalar(t) {
        return this.x -= t, this.y -= t, this.z -= t, this
    }
    subVectors(t, e) {
        return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
    }
    multiply(t) {
        return this.x *= t.x, this.y *= t.y, this.z *= t.z, this
    }
    multiplyScalar(t) {
        return this.x *= t, this.y *= t, this.z *= t, this
    }
    multiplyVectors(t, e) {
        return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
    }
    applyEuler(t) {
        return this.applyQuaternion(qu.setFromEuler(t))
    }
    applyAxisAngle(t, e) {
        return this.applyQuaternion(qu.setFromAxisAngle(t, e))
    }
    applyMatrix3(t) {
        const e = this.x,
            n = this.y,
            i = this.z,
            s = t.elements;
        return this.x = s[0] * e + s[3] * n + s[6] * i, this.y = s[1] * e + s[4] * n + s[7] * i, this.z = s[2] * e + s[5] * n + s[8] * i, this
    }
    applyNormalMatrix(t) {
        return this.applyMatrix3(t).normalize()
    }
    applyMatrix4(t) {
        const e = this.x,
            n = this.y,
            i = this.z,
            s = t.elements,
            r = 1 / (s[3] * e + s[7] * n + s[11] * i + s[15]);
        return this.x = (s[0] * e + s[4] * n + s[8] * i + s[12]) * r, this.y = (s[1] * e + s[5] * n + s[9] * i + s[13]) * r, this.z = (s[2] * e + s[6] * n + s[10] * i + s[14]) * r, this
    }
    applyQuaternion(t) {
        const e = this.x,
            n = this.y,
            i = this.z,
            s = t.x,
            r = t.y,
            o = t.z,
            a = t.w,
            l = 2 * (r * i - o * n),
            c = 2 * (o * e - s * i),
            h = 2 * (s * n - r * e);
        return this.x = e + a * l + r * h - o * c, this.y = n + a * c + o * l - s * h, this.z = i + a * h + s * c - r * l, this
    }
    project(t) {
        return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
    }
    unproject(t) {
        return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
    }
    transformDirection(t) {
        const e = this.x,
            n = this.y,
            i = this.z,
            s = t.elements;
        return this.x = s[0] * e + s[4] * n + s[8] * i, this.y = s[1] * e + s[5] * n + s[9] * i, this.z = s[2] * e + s[6] * n + s[10] * i, this.normalize()
    }
    divide(t) {
        return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
    }
    divideScalar(t) {
        return this.multiplyScalar(1 / t)
    }
    min(t) {
        return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
    }
    max(t) {
        return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
    }
    clamp(t, e) {
        return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
    }
    clampScalar(t, e) {
        return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this
    }
    clampLength(t, e) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
    }
    floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
    }
    ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
    }
    round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this
    }
    negate() {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
    }
    dot(t) {
        return this.x * t.x + this.y * t.y + this.z * t.z
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(t) {
        return this.normalize().multiplyScalar(t)
    }
    lerp(t, e) {
        return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
    }
    lerpVectors(t, e, n) {
        return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this
    }
    cross(t) {
        return this.crossVectors(this, t)
    }
    crossVectors(t, e) {
        const n = t.x,
            i = t.y,
            s = t.z,
            r = e.x,
            o = e.y,
            a = e.z;
        return this.x = i * a - s * o, this.y = s * r - n * a, this.z = n * o - i * r, this
    }
    projectOnVector(t) {
        const e = t.lengthSq();
        if (0 === e) return this.set(0, 0, 0);
        const n = t.dot(this) / e;
        return this.copy(t).multiplyScalar(n)
    }
    projectOnPlane(t) {
        return Rl.copy(this).projectOnVector(t), this.sub(Rl)
    }
    reflect(t) {
        return this.sub(Rl.copy(t).multiplyScalar(2 * this.dot(t)))
    }
    angleTo(t) {
        const e = Math.sqrt(this.lengthSq() * t.lengthSq());
        if (0 === e) return Math.PI / 2;
        const n = this.dot(t) / e;
        return Math.acos(Ut(n, -1, 1))
    }
    distanceTo(t) {
        return Math.sqrt(this.distanceToSquared(t))
    }
    distanceToSquared(t) {
        const e = this.x - t.x,
            n = this.y - t.y,
            i = this.z - t.z;
        return e * e + n * n + i * i
    }
    manhattanDistanceTo(t) {
        return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
    }
    setFromSpherical(t) {
        return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
    }
    setFromSphericalCoords(t, e, n) {
        const i = Math.sin(e) * t;
        return this.x = i * Math.sin(n), this.y = Math.cos(e) * t, this.z = i * Math.cos(n), this
    }
    setFromCylindrical(t) {
        return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
    }
    setFromCylindricalCoords(t, e, n) {
        return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this
    }
    setFromMatrixPosition(t) {
        const e = t.elements;
        return this.x = e[12], this.y = e[13], this.z = e[14], this
    }
    setFromMatrixScale(t) {
        const e = this.setFromMatrixColumn(t, 0).length(),
            n = this.setFromMatrixColumn(t, 1).length(),
            i = this.setFromMatrixColumn(t, 2).length();
        return this.x = e, this.y = n, this.z = i, this
    }
    setFromMatrixColumn(t, e) {
        return this.fromArray(t.elements, 4 * e)
    }
    setFromMatrix3Column(t, e) {
        return this.fromArray(t.elements, 3 * e)
    }
    setFromEuler(t) {
        return this.x = t._x, this.y = t._y, this.z = t._z, this
    }
    setFromColor(t) {
        return this.x = t.r, this.y = t.g, this.z = t.b, this
    }
    equals(t) {
        return t.x === this.x && t.y === this.y && t.z === this.z
    }
    fromArray(t, e = 0) {
        return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
    }
    toArray(t = [], e = 0) {
        return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
    }
    fromBufferAttribute(t, e) {
        return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
    }
    random() {
        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
    }
    randomDirection() {
        const t = Math.random() * Math.PI * 2,
            e = 2 * Math.random() - 1,
            n = Math.sqrt(1 - e * e);
        return this.x = n * Math.cos(t), this.y = e, this.z = n * Math.sin(t), this
    }*[Symbol.iterator]() {
        yield this.x, yield this.y, yield this.z
    }
}
const Rl = new U,
    qu = new bt;
class Tn {
    constructor(t = new U(1 / 0, 1 / 0, 1 / 0), e = new U(-1 / 0, -1 / 0, -1 / 0)) {
        this.isBox3 = !0, this.min = t, this.max = e
    }
    set(t, e) {
        return this.min.copy(t), this.max.copy(e), this
    }
    setFromArray(t) {
        this.makeEmpty();
        for (let e = 0, n = t.length; e < n; e += 3) this.expandByPoint(Wn.fromArray(t, e));
        return this
    }
    setFromBufferAttribute(t) {
        this.makeEmpty();
        for (let e = 0, n = t.count; e < n; e++) this.expandByPoint(Wn.fromBufferAttribute(t, e));
        return this
    }
    setFromPoints(t) {
        this.makeEmpty();
        for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
        return this
    }
    setFromCenterAndSize(t, e) {
        const n = Wn.copy(e).multiplyScalar(.5);
        return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
    }
    setFromObject(t, e = !1) {
        return this.makeEmpty(), this.expandByObject(t, e)
    }
    clone() {
        return (new this.constructor).copy(this)
    }
    copy(t) {
        return this.min.copy(t.min), this.max.copy(t.max), this
    }
    makeEmpty() {
        return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    }
    getCenter(t) {
        return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(t) {
        return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
    }
    expandByPoint(t) {
        return this.min.min(t), this.max.max(t), this
    }
    expandByVector(t) {
        return this.min.sub(t), this.max.add(t), this
    }
    expandByScalar(t) {
        return this.min.addScalar(-t), this.max.addScalar(t), this
    }
    expandByObject(t, e = !1) {
        t.updateWorldMatrix(!1, !1);
        const n = t.geometry;
        if (void 0 !== n) {
            const i = n.getAttribute("position");
            if (!0 === e && void 0 !== i && !0 !== t.isInstancedMesh)
                for (let e = 0, n = i.count; e < n; e++) !0 === t.isMesh ? t.getVertexPosition(e, Wn) : Wn.fromBufferAttribute(i, e), Wn.applyMatrix4(t.matrixWorld), this.expandByPoint(Wn);
            else void 0 !== t.boundingBox ? (null === t.boundingBox && t.computeBoundingBox(), Do.copy(t.boundingBox)) : (null === n.boundingBox && n.computeBoundingBox(), Do.copy(n.boundingBox)), Do.applyMatrix4(t.matrixWorld), this.union(Do)
        }
        const i = t.children;
        for (let t = 0, n = i.length; t < n; t++) this.expandByObject(i[t], e);
        return this
    }
    containsPoint(t) {
        return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
    }
    containsBox(t) {
        return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
    }
    getParameter(t, e) {
        return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
    }
    intersectsBox(t) {
        return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
    }
    intersectsSphere(t) {
        return this.clampPoint(t.center, Wn), Wn.distanceToSquared(t.center) <= t.radius * t.radius
    }
    intersectsPlane(t) {
        let e, n;
        return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant
    }
    intersectsTriangle(t) {
        if (this.isEmpty()) return !1;
        this.getCenter(Hr), Io.subVectors(this.max, Hr), Fs.subVectors(t.a, Hr), ks.subVectors(t.b, Hr), zs.subVectors(t.c, Hr), Fi.subVectors(ks, Fs), ki.subVectors(zs, ks), os.subVectors(Fs, zs);
        let e = [0, -Fi.z, Fi.y, 0, -ki.z, ki.y, 0, -os.z, os.y, Fi.z, 0, -Fi.x, ki.z, 0, -ki.x, os.z, 0, -os.x, -Fi.y, Fi.x, 0, -ki.y, ki.x, 0, -os.y, os.x, 0];
        return !(!Dl(e, Fs, ks, zs, Io) || (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !Dl(e, Fs, ks, zs, Io))) && (Lo.crossVectors(Fi, ki), e = [Lo.x, Lo.y, Lo.z], Dl(e, Fs, ks, zs, Io))
    }
    clampPoint(t, e) {
        return e.copy(t).clamp(this.min, this.max)
    }
    distanceToPoint(t) {
        return this.clampPoint(t, Wn).distanceTo(t)
    }
    getBoundingSphere(t) {
        return this.isEmpty() ? t.makeEmpty() : (this.getCenter(t.center), t.radius = .5 * this.getSize(Wn).length()), t
    }
    intersect(t) {
        return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
    }
    union(t) {
        return this.min.min(t.min), this.max.max(t.max), this
    }
    applyMatrix4(t) {
        return this.isEmpty() || (gi[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), gi[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), gi[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), gi[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), gi[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), gi[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), gi[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), gi[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(gi)), this
    }
    translate(t) {
        return this.min.add(t), this.max.add(t), this
    }
    equals(t) {
        return t.min.equals(this.min) && t.max.equals(this.max)
    }
}
const gi = [new U, new U, new U, new U, new U, new U, new U, new U],
    Wn = new U,
    Do = new Tn,
    Fs = new U,
    ks = new U,
    zs = new U,
    Fi = new U,
    ki = new U,
    os = new U,
    Hr = new U,
    Io = new U,
    Lo = new U,
    as = new U;

function Dl(t, e, n, i, s) {
    for (let r = 0, o = t.length - 3; r <= o; r += 3) {
        as.fromArray(t, r);
        const o = s.x * Math.abs(as.x) + s.y * Math.abs(as.y) + s.z * Math.abs(as.z),
            a = e.dot(as),
            l = n.dot(as),
            c = i.dot(as);
        if (Math.max(-Math.max(a, l, c), Math.min(a, l, c)) > o) return !1
    }
    return !0
}
const l0 = new Tn,
    Vr = new U,
    Il = new U;
class Hn {
    constructor(t = new U, e = -1) {
        this.isSphere = !0, this.center = t, this.radius = e
    }
    set(t, e) {
        return this.center.copy(t), this.radius = e, this
    }
    setFromPoints(t, e) {
        const n = this.center;
        void 0 !== e ? n.copy(e) : l0.setFromPoints(t).getCenter(n);
        let i = 0;
        for (let e = 0, s = t.length; e < s; e++) i = Math.max(i, n.distanceToSquared(t[e]));
        return this.radius = Math.sqrt(i), this
    }
    copy(t) {
        return this.center.copy(t.center), this.radius = t.radius, this
    }
    isEmpty() {
        return this.radius < 0
    }
    makeEmpty() {
        return this.center.set(0, 0, 0), this.radius = -1, this
    }
    containsPoint(t) {
        return t.distanceToSquared(this.center) <= this.radius * this.radius
    }
    distanceToPoint(t) {
        return t.distanceTo(this.center) - this.radius
    }
    intersectsSphere(t) {
        const e = this.radius + t.radius;
        return t.center.distanceToSquared(this.center) <= e * e
    }
    intersectsBox(t) {
        return t.intersectsSphere(this)
    }
    intersectsPlane(t) {
        return Math.abs(t.distanceToPoint(this.center)) <= this.radius
    }
    clampPoint(t, e) {
        const n = this.center.distanceToSquared(t);
        return e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
    }
    getBoundingBox(t) {
        return this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t)
    }
    applyMatrix4(t) {
        return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
    }
    translate(t) {
        return this.center.add(t), this
    }
    expandByPoint(t) {
        if (this.isEmpty()) return this.center.copy(t), this.radius = 0, this;
        Vr.subVectors(t, this.center);
        const e = Vr.lengthSq();
        if (e > this.radius * this.radius) {
            const t = Math.sqrt(e),
                n = .5 * (t - this.radius);
            this.center.addScaledVector(Vr, n / t), this.radius += n
        }
        return this
    }
    union(t) {
        return t.isEmpty() ? this : this.isEmpty() ? (this.copy(t), this) : (!0 === this.center.equals(t.center) ? this.radius = Math.max(this.radius, t.radius) : (Il.subVectors(t.center, this.center).setLength(t.radius), this.expandByPoint(Vr.copy(t.center).add(Il)), this.expandByPoint(Vr.copy(t.center).sub(Il))), this)
    }
    equals(t) {
        return t.center.equals(this.center) && t.radius === this.radius
    }
    clone() {
        return (new this.constructor).copy(this)
    }
}
const vi = new U,
    Ll = new U,
    Oo = new U,
    zi = new U,
    Ol = new U,
    Bo = new U,
    Bl = new U;
class Ir {
    constructor(t = new U, e = new U(0, 0, -1)) {
        this.origin = t, this.direction = e
    }
    set(t, e) {
        return this.origin.copy(t), this.direction.copy(e), this
    }
    copy(t) {
        return this.origin.copy(t.origin), this.direction.copy(t.direction), this
    }
    at(t, e) {
        return e.copy(this.origin).addScaledVector(this.direction, t)
    }
    lookAt(t) {
        return this.direction.copy(t).sub(this.origin).normalize(), this
    }
    recast(t) {
        return this.origin.copy(this.at(t, vi)), this
    }
    closestPointToPoint(t, e) {
        e.subVectors(t, this.origin);
        const n = e.dot(this.direction);
        return n < 0 ? e.copy(this.origin) : e.copy(this.origin).addScaledVector(this.direction, n)
    }
    distanceToPoint(t) {
        return Math.sqrt(this.distanceSqToPoint(t))
    }
    distanceSqToPoint(t) {
        const e = vi.subVectors(t, this.origin).dot(this.direction);
        return e < 0 ? this.origin.distanceToSquared(t) : (vi.copy(this.origin).addScaledVector(this.direction, e), vi.distanceToSquared(t))
    }
    distanceSqToSegment(t, e, n, i) {
        Ll.copy(t).add(e).multiplyScalar(.5), Oo.copy(e).sub(t).normalize(), zi.copy(this.origin).sub(Ll);
        const s = .5 * t.distanceTo(e),
            r = -this.direction.dot(Oo),
            o = zi.dot(this.direction),
            a = -zi.dot(Oo),
            l = zi.lengthSq(),
            c = Math.abs(1 - r * r);
        let h, u, d, p;
        if (c > 0)
            if (h = r * a - o, u = r * o - a, p = s * c, h >= 0)
                if (u >= -p)
                    if (u <= p) {
                        const t = 1 / c;
                        h *= t, u *= t, d = h * (h + r * u + 2 * o) + u * (r * h + u + 2 * a) + l
                    } else u = s, h = Math.max(0, -(r * u + o)), d = -h * h + u * (u + 2 * a) + l;
        else u = -s, h = Math.max(0, -(r * u + o)), d = -h * h + u * (u + 2 * a) + l;
        else u <= -p ? (h = Math.max(0, -(-r * s + o)), u = h > 0 ? -s : Math.min(Math.max(-s, -a), s), d = -h * h + u * (u + 2 * a) + l) : u <= p ? (h = 0, u = Math.min(Math.max(-s, -a), s), d = u * (u + 2 * a) + l) : (h = Math.max(0, -(r * s + o)), u = h > 0 ? s : Math.min(Math.max(-s, -a), s), d = -h * h + u * (u + 2 * a) + l);
        else u = r > 0 ? -s : s, h = Math.max(0, -(r * u + o)), d = -h * h + u * (u + 2 * a) + l;
        return n && n.copy(this.origin).addScaledVector(this.direction, h), i && i.copy(Ll).addScaledVector(Oo, u), d
    }
    intersectSphere(t, e) {
        vi.subVectors(t.center, this.origin);
        const n = vi.dot(this.direction),
            i = vi.dot(vi) - n * n,
            s = t.radius * t.radius;
        if (i > s) return null;
        const r = Math.sqrt(s - i),
            o = n - r,
            a = n + r;
        return a < 0 ? null : o < 0 ? this.at(a, e) : this.at(o, e)
    }
    intersectsSphere(t) {
        return this.distanceSqToPoint(t.center) <= t.radius * t.radius
    }
    distanceToPlane(t) {
        const e = t.normal.dot(this.direction);
        if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
        const n = -(this.origin.dot(t.normal) + t.constant) / e;
        return n >= 0 ? n : null
    }
    intersectPlane(t, e) {
        const n = this.distanceToPlane(t);
        return null === n ? null : this.at(n, e)
    }
    intersectsPlane(t) {
        const e = t.distanceToPoint(this.origin);
        return 0 === e || t.normal.dot(this.direction) * e < 0
    }
    intersectBox(t, e) {
        let n, i, s, r, o, a;
        const l = 1 / this.direction.x,
            c = 1 / this.direction.y,
            h = 1 / this.direction.z,
            u = this.origin;
        return l >= 0 ? (n = (t.min.x - u.x) * l, i = (t.max.x - u.x) * l) : (n = (t.max.x - u.x) * l, i = (t.min.x - u.x) * l), c >= 0 ? (s = (t.min.y - u.y) * c, r = (t.max.y - u.y) * c) : (s = (t.max.y - u.y) * c, r = (t.min.y - u.y) * c), n > r || s > i || ((s > n || isNaN(n)) && (n = s), (r < i || isNaN(i)) && (i = r), h >= 0 ? (o = (t.min.z - u.z) * h, a = (t.max.z - u.z) * h) : (o = (t.max.z - u.z) * h, a = (t.min.z - u.z) * h), n > a || o > i) || ((o > n || n != n) && (n = o), (a < i || i != i) && (i = a), i < 0) ? null : this.at(n >= 0 ? n : i, e)
    }
    intersectsBox(t) {
        return null !== this.intersectBox(t, vi)
    }
    intersectTriangle(t, e, n, i, s) {
        Ol.subVectors(e, t), Bo.subVectors(n, t), Bl.crossVectors(Ol, Bo);
        let r, o = this.direction.dot(Bl);
        if (o > 0) {
            if (i) return null;
            r = 1
        } else {
            if (!(o < 0)) return null;
            r = -1, o = -o
        }
        zi.subVectors(this.origin, t);
        const a = r * this.direction.dot(Bo.crossVectors(zi, Bo));
        if (a < 0) return null;
        const l = r * this.direction.dot(Ol.cross(zi));
        if (l < 0 || a + l > o) return null;
        const c = -r * zi.dot(Bl);
        return c < 0 ? null : this.at(c / o, s)
    }
    applyMatrix4(t) {
        return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
    }
    equals(t) {
        return t.origin.equals(this.origin) && t.direction.equals(this.direction)
    }
    clone() {
        return (new this.constructor).copy(this)
    }
}
class Xe {
    constructor(t, e, n, i, s, r, o, a, l, c, h, u, d, p, f, m) {
        Xe.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], void 0 !== t && this.set(t, e, n, i, s, r, o, a, l, c, h, u, d, p, f, m)
    }
    set(t, e, n, i, s, r, o, a, l, c, h, u, d, p, f, m) {
        const g = this.elements;
        return g[0] = t, g[4] = e, g[8] = n, g[12] = i, g[1] = s, g[5] = r, g[9] = o, g[13] = a, g[2] = l, g[6] = c, g[10] = h, g[14] = u, g[3] = d, g[7] = p, g[11] = f, g[15] = m, this
    }
    identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
    }
    clone() {
        return (new Xe).fromArray(this.elements)
    }
    copy(t) {
        const e = this.elements,
            n = t.elements;
        return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this
    }
    copyPosition(t) {
        const e = this.elements,
            n = t.elements;
        return e[12] = n[12], e[13] = n[13], e[14] = n[14], this
    }
    setFromMatrix3(t) {
        const e = t.elements;
        return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this
    }
    extractBasis(t, e, n) {
        return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
    }
    makeBasis(t, e, n) {
        return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this
    }
    extractRotation(t) {
        const e = this.elements,
            n = t.elements,
            i = 1 / Gs.setFromMatrixColumn(t, 0).length(),
            s = 1 / Gs.setFromMatrixColumn(t, 1).length(),
            r = 1 / Gs.setFromMatrixColumn(t, 2).length();
        return e[0] = n[0] * i, e[1] = n[1] * i, e[2] = n[2] * i, e[3] = 0, e[4] = n[4] * s, e[5] = n[5] * s, e[6] = n[6] * s, e[7] = 0, e[8] = n[8] * r, e[9] = n[9] * r, e[10] = n[10] * r, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
    }
    makeRotationFromEuler(t) {
        const e = this.elements,
            n = t.x,
            i = t.y,
            s = t.z,
            r = Math.cos(n),
            o = Math.sin(n),
            a = Math.cos(i),
            l = Math.sin(i),
            c = Math.cos(s),
            h = Math.sin(s);
        if ("XYZ" === t.order) {
            const t = r * c,
                n = r * h,
                i = o * c,
                s = o * h;
            e[0] = a * c, e[4] = -a * h, e[8] = l, e[1] = n + i * l, e[5] = t - s * l, e[9] = -o * a, e[2] = s - t * l, e[6] = i + n * l, e[10] = r * a
        } else if ("YXZ" === t.order) {
            const t = a * c,
                n = a * h,
                i = l * c,
                s = l * h;
            e[0] = t + s * o, e[4] = i * o - n, e[8] = r * l, e[1] = r * h, e[5] = r * c, e[9] = -o, e[2] = n * o - i, e[6] = s + t * o, e[10] = r * a
        } else if ("ZXY" === t.order) {
            const t = a * c,
                n = a * h,
                i = l * c,
                s = l * h;
            e[0] = t - s * o, e[4] = -r * h, e[8] = i + n * o, e[1] = n + i * o, e[5] = r * c, e[9] = s - t * o, e[2] = -r * l, e[6] = o, e[10] = r * a
        } else if ("ZYX" === t.order) {
            const t = r * c,
                n = r * h,
                i = o * c,
                s = o * h;
            e[0] = a * c, e[4] = i * l - n, e[8] = t * l + s, e[1] = a * h, e[5] = s * l + t, e[9] = n * l - i, e[2] = -l, e[6] = o * a, e[10] = r * a
        } else if ("YZX" === t.order) {
            const t = r * a,
                n = r * l,
                i = o * a,
                s = o * l;
            e[0] = a * c, e[4] = s - t * h, e[8] = i * h + n, e[1] = h, e[5] = r * c, e[9] = -o * c, e[2] = -l * c, e[6] = n * h + i, e[10] = t - s * h
        } else if ("XZY" === t.order) {
            const t = r * a,
                n = r * l,
                i = o * a,
                s = o * l;
            e[0] = a * c, e[4] = -h, e[8] = l * c, e[1] = t * h + s, e[5] = r * c, e[9] = n * h - i, e[2] = i * h - n, e[6] = o * c, e[10] = s * h + t
        }
        return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
    }
    makeRotationFromQuaternion(t) {
        return this.compose(c0, t, h0)
    }
    lookAt(t, e, n) {
        const i = this.elements;
        return bn.subVectors(t, e), 0 === bn.lengthSq() && (bn.z = 1), bn.normalize(), Gi.crossVectors(n, bn), 0 === Gi.lengthSq() && (1 === Math.abs(n.z) ? bn.x += 1e-4 : bn.z += 1e-4, bn.normalize(), Gi.crossVectors(n, bn)), Gi.normalize(), Uo.crossVectors(bn, Gi), i[0] = Gi.x, i[4] = Uo.x, i[8] = bn.x, i[1] = Gi.y, i[5] = Uo.y, i[9] = bn.y, i[2] = Gi.z, i[6] = Uo.z, i[10] = bn.z, this
    }
    multiply(t) {
        return this.multiplyMatrices(this, t)
    }
    premultiply(t) {
        return this.multiplyMatrices(t, this)
    }
    multiplyMatrices(t, e) {
        const n = t.elements,
            i = e.elements,
            s = this.elements,
            r = n[0],
            o = n[4],
            a = n[8],
            l = n[12],
            c = n[1],
            h = n[5],
            u = n[9],
            d = n[13],
            p = n[2],
            f = n[6],
            m = n[10],
            g = n[14],
            v = n[3],
            y = n[7],
            x = n[11],
            b = n[15],
            A = i[0],
            S = i[4],
            w = i[8],
            _ = i[12],
            M = i[1],
            T = i[5],
            E = i[9],
            C = i[13],
            R = i[2],
            P = i[6],
            D = i[10],
            I = i[14],
            L = i[3],
            U = i[7],
            O = i[11],
            B = i[15];
        return s[0] = r * A + o * M + a * R + l * L, s[4] = r * S + o * T + a * P + l * U, s[8] = r * w + o * E + a * D + l * O, s[12] = r * _ + o * C + a * I + l * B, s[1] = c * A + h * M + u * R + d * L, s[5] = c * S + h * T + u * P + d * U, s[9] = c * w + h * E + u * D + d * O, s[13] = c * _ + h * C + u * I + d * B, s[2] = p * A + f * M + m * R + g * L, s[6] = p * S + f * T + m * P + g * U, s[10] = p * w + f * E + m * D + g * O, s[14] = p * _ + f * C + m * I + g * B, s[3] = v * A + y * M + x * R + b * L, s[7] = v * S + y * T + x * P + b * U, s[11] = v * w + y * E + x * D + b * O, s[15] = v * _ + y * C + x * I + b * B, this
    }
    multiplyScalar(t) {
        const e = this.elements;
        return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
    }
    determinant() {
        const t = this.elements,
            e = t[0],
            n = t[4],
            i = t[8],
            s = t[12],
            r = t[1],
            o = t[5],
            a = t[9],
            l = t[13],
            c = t[2],
            h = t[6],
            u = t[10],
            d = t[14];
        return t[3] * (+s * a * h - i * l * h - s * o * u + n * l * u + i * o * d - n * a * d) + t[7] * (+e * a * d - e * l * u + s * r * u - i * r * d + i * l * c - s * a * c) + t[11] * (+e * l * h - e * o * d - s * r * h + n * r * d + s * o * c - n * l * c) + t[15] * (-i * o * c - e * a * h + e * o * u + i * r * h - n * r * u + n * a * c)
    }
    transpose() {
        const t = this.elements;
        let e;
        return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
    }
    setPosition(t, e, n) {
        const i = this.elements;
        return t.isVector3 ? (i[12] = t.x, i[13] = t.y, i[14] = t.z) : (i[12] = t, i[13] = e, i[14] = n), this
    }
    invert() {
        const t = this.elements,
            e = t[0],
            n = t[1],
            i = t[2],
            s = t[3],
            r = t[4],
            o = t[5],
            a = t[6],
            l = t[7],
            c = t[8],
            h = t[9],
            u = t[10],
            d = t[11],
            p = t[12],
            f = t[13],
            m = t[14],
            g = t[15],
            v = h * m * l - f * u * l + f * a * d - o * m * d - h * a * g + o * u * g,
            y = p * u * l - c * m * l - p * a * d + r * m * d + c * a * g - r * u * g,
            x = c * f * l - p * h * l + p * o * d - r * f * d - c * o * g + r * h * g,
            b = p * h * a - c * f * a - p * o * u + r * f * u + c * o * m - r * h * m,
            A = e * v + n * y + i * x + s * b;
        if (0 === A) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const S = 1 / A;
        return t[0] = v * S, t[1] = (f * u * s - h * m * s - f * i * d + n * m * d + h * i * g - n * u * g) * S, t[2] = (o * m * s - f * a * s + f * i * l - n * m * l - o * i * g + n * a * g) * S, t[3] = (h * a * s - o * u * s - h * i * l + n * u * l + o * i * d - n * a * d) * S, t[4] = y * S, t[5] = (c * m * s - p * u * s + p * i * d - e * m * d - c * i * g + e * u * g) * S, t[6] = (p * a * s - r * m * s - p * i * l + e * m * l + r * i * g - e * a * g) * S, t[7] = (r * u * s - c * a * s + c * i * l - e * u * l - r * i * d + e * a * d) * S, t[8] = x * S, t[9] = (p * h * s - c * f * s - p * n * d + e * f * d + c * n * g - e * h * g) * S, t[10] = (r * f * s - p * o * s + p * n * l - e * f * l - r * n * g + e * o * g) * S, t[11] = (c * o * s - r * h * s - c * n * l + e * h * l + r * n * d - e * o * d) * S, t[12] = b * S, t[13] = (c * f * i - p * h * i + p * n * u - e * f * u - c * n * m + e * h * m) * S, t[14] = (p * o * i - r * f * i - p * n * a + e * f * a + r * n * m - e * o * m) * S, t[15] = (r * h * i - c * o * i + c * n * a - e * h * a - r * n * u + e * o * u) * S, this
    }
    scale(t) {
        const e = this.elements,
            n = t.x,
            i = t.y,
            s = t.z;
        return e[0] *= n, e[4] *= i, e[8] *= s, e[1] *= n, e[5] *= i, e[9] *= s, e[2] *= n, e[6] *= i, e[10] *= s, e[3] *= n, e[7] *= i, e[11] *= s, this
    }
    getMaxScaleOnAxis() {
        const t = this.elements,
            e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
            n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
            i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
        return Math.sqrt(Math.max(e, n, i))
    }
    makeTranslation(t, e, n) {
        return t.isVector3 ? this.set(1, 0, 0, t.x, 0, 1, 0, t.y, 0, 0, 1, t.z, 0, 0, 0, 1) : this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this
    }
    makeRotationX(t) {
        const e = Math.cos(t),
            n = Math.sin(t);
        return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
    }
    makeRotationY(t) {
        const e = Math.cos(t),
            n = Math.sin(t);
        return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
    }
    makeRotationZ(t) {
        const e = Math.cos(t),
            n = Math.sin(t);
        return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
    }
    makeRotationAxis(t, e) {
        const n = Math.cos(e),
            i = Math.sin(e),
            s = 1 - n,
            r = t.x,
            o = t.y,
            a = t.z,
            l = s * r,
            c = s * o;
        return this.set(l * r + n, l * o - i * a, l * a + i * o, 0, l * o + i * a, c * o + n, c * a - i * r, 0, l * a - i * o, c * a + i * r, s * a * a + n, 0, 0, 0, 0, 1), this
    }
    makeScale(t, e, n) {
        return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
    }
    makeShear(t, e, n, i, s, r) {
        return this.set(1, n, s, 0, t, 1, r, 0, e, i, 1, 0, 0, 0, 0, 1), this
    }
    compose(t, e, n) {
        const i = this.elements,
            s = e._x,
            r = e._y,
            o = e._z,
            a = e._w,
            l = s + s,
            c = r + r,
            h = o + o,
            u = s * l,
            d = s * c,
            p = s * h,
            f = r * c,
            m = r * h,
            g = o * h,
            v = a * l,
            y = a * c,
            x = a * h,
            b = n.x,
            A = n.y,
            S = n.z;
        return i[0] = (1 - (f + g)) * b, i[1] = (d + x) * b, i[2] = (p - y) * b, i[3] = 0, i[4] = (d - x) * A, i[5] = (1 - (u + g)) * A, i[6] = (m + v) * A, i[7] = 0, i[8] = (p + y) * S, i[9] = (m - v) * S, i[10] = (1 - (u + f)) * S, i[11] = 0, i[12] = t.x, i[13] = t.y, i[14] = t.z, i[15] = 1, this
    }
    decompose(t, e, n) {
        const i = this.elements;
        let s = Gs.set(i[0], i[1], i[2]).length();
        const r = Gs.set(i[4], i[5], i[6]).length(),
            o = Gs.set(i[8], i[9], i[10]).length();
        this.determinant() < 0 && (s = -s), t.x = i[12], t.y = i[13], t.z = i[14], Xn.copy(this);
        const a = 1 / s,
            l = 1 / r,
            c = 1 / o;
        return Xn.elements[0] *= a, Xn.elements[1] *= a, Xn.elements[2] *= a, Xn.elements[4] *= l, Xn.elements[5] *= l, Xn.elements[6] *= l, Xn.elements[8] *= c, Xn.elements[9] *= c, Xn.elements[10] *= c, e.setFromRotationMatrix(Xn), n.x = s, n.y = r, n.z = o, this
    }
    makePerspective(t, e, n, i, s, r, o = Ti) {
        const a = this.elements,
            l = 2 * s / (e - t),
            c = 2 * s / (n - i),
            h = (e + t) / (e - t),
            u = (n + i) / (n - i);
        let d, p;
        if (o === Ti) d = -(r + s) / (r - s), p = -2 * r * s / (r - s);
        else {
            if (o !== Ia) throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + o);
            d = -r / (r - s), p = -r * s / (r - s)
        }
        return a[0] = l, a[4] = 0, a[8] = h, a[12] = 0, a[1] = 0, a[5] = c, a[9] = u, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = d, a[14] = p, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
    }
    makeOrthographic(t, e, n, i, s, r, o = Ti) {
        const a = this.elements,
            l = 1 / (e - t),
            c = 1 / (n - i),
            h = 1 / (r - s),
            u = (e + t) * l,
            d = (n + i) * c;
        let p, f;
        if (o === Ti) p = (r + s) * h, f = -2 * h;
        else {
            if (o !== Ia) throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + o);
            p = s * h, f = -1 * h
        }
        return a[0] = 2 * l, a[4] = 0, a[8] = 0, a[12] = -u, a[1] = 0, a[5] = 2 * c, a[9] = 0, a[13] = -d, a[2] = 0, a[6] = 0, a[10] = f, a[14] = -p, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
    }
    equals(t) {
        const e = this.elements,
            n = t.elements;
        for (let t = 0; t < 16; t++)
            if (e[t] !== n[t]) return !1;
        return !0
    }
    fromArray(t, e = 0) {
        for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
        return this
    }
    toArray(t = [], e = 0) {
        const n = this.elements;
        return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t
    }
}
const Gs = new U,
    Xn = new Xe,
    c0 = new U(0, 0, 0),
    h0 = new U(1, 1, 1),
    Gi = new U,
    Uo = new U,
    bn = new U,
    Zu = new Xe,
    Ju = new bt;
class Gn {
    constructor(t = 0, e = 0, n = 0, i = Gn.DEFAULT_ORDER) {
        this.isEuler = !0, this._x = t, this._y = e, this._z = n, this._order = i
    }
    get x() {
        return this._x
    }
    set x(t) {
        this._x = t, this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(t) {
        this._y = t, this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(t) {
        this._z = t, this._onChangeCallback()
    }
    get order() {
        return this._order
    }
    set order(t) {
        this._order = t, this._onChangeCallback()
    }
    set(t, e, n, i = this._order) {
        return this._x = t, this._y = e, this._z = n, this._order = i, this._onChangeCallback(), this
    }
    clone() {
        return new this.constructor(this._x, this._y, this._z, this._order)
    }
    copy(t) {
        return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this
    }
    setFromRotationMatrix(t, e = this._order, n = !0) {
        const i = t.elements,
            s = i[0],
            r = i[4],
            o = i[8],
            a = i[1],
            l = i[5],
            c = i[9],
            h = i[2],
            u = i[6],
            d = i[10];
        switch (e) {
            case "XYZ":
                this._y = Math.asin(Ut(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, d), this._z = Math.atan2(-r, s)) : (this._x = Math.atan2(u, l), this._z = 0);
                break;
            case "YXZ":
                this._x = Math.asin(-Ut(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(o, d), this._z = Math.atan2(a, l)) : (this._y = Math.atan2(-h, s), this._z = 0);
                break;
            case "ZXY":
                this._x = Math.asin(Ut(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(-h, d), this._z = Math.atan2(-r, l)) : (this._y = 0, this._z = Math.atan2(a, s));
                break;
            case "ZYX":
                this._y = Math.asin(-Ut(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(u, d), this._z = Math.atan2(a, s)) : (this._x = 0, this._z = Math.atan2(-r, l));
                break;
            case "YZX":
                this._z = Math.asin(Ut(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-h, s)) : (this._x = 0, this._y = Math.atan2(o, d));
                break;
            case "XZY":
                this._z = Math.asin(-Ut(r, -1, 1)), Math.abs(r) < .9999999 ? (this._x = Math.atan2(u, l), this._y = Math.atan2(o, s)) : (this._x = Math.atan2(-c, d), this._y = 0);
                break;
            default:
                console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
        }
        return this._order = e, !0 === n && this._onChangeCallback(), this
    }
    setFromQuaternion(t, e, n) {
        return Zu.makeRotationFromQuaternion(t), this.setFromRotationMatrix(Zu, e, n)
    }
    setFromVector3(t, e = this._order) {
        return this.set(t.x, t.y, t.z, e)
    }
    reorder(t) {
        return Ju.setFromEuler(this), this.setFromQuaternion(Ju, t)
    }
    equals(t) {
        return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
    }
    fromArray(t) {
        return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this
    }
    toArray(t = [], e = 0) {
        return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
    }
    _onChange(t) {
        return this._onChangeCallback = t, this
    }
    _onChangeCallback() {}*[Symbol.iterator]() {
        yield this._x, yield this._y, yield this._z, yield this._order
    }
}
Gn.DEFAULT_ORDER = "XYZ";
class hh {
    constructor() {
        this.mask = 1
    }
    set(t) {
        this.mask = 1 << t >>> 0
    }
    enable(t) {
        this.mask |= 1 << t
    }
    enableAll() {
        this.mask = -1
    }
    toggle(t) {
        this.mask ^= 1 << t
    }
    disable(t) {
        this.mask &= ~(1 << t)
    }
    disableAll() {
        this.mask = 0
    }
    test(t) {
        return !!(this.mask & t.mask)
    }
    isEnabled(t) {
        return !!(this.mask & 1 << t)
    }
}
let u0 = 0;
const $u = new U,
    Hs = new bt,
    yi = new Xe,
    No = new U,
    Wr = new U,
    d0 = new U,
    f0 = new bt,
    ed = new U(1, 0, 0),
    td = new U(0, 1, 0),
    nd = new U(0, 0, 1),
    id = {
        type: "added"
    },
    p0 = {
        type: "removed"
    },
    Vs = {
        type: "childadded",
        child: null
    },
    Ul = {
        type: "childremoved",
        child: null
    };
class ct extends hi {
    constructor() {
        super(), this.isObject3D = !0, Object.defineProperty(this, "id", {
            value: u0++
        }), this.uuid = zn(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = ct.DEFAULT_UP.clone();
        const t = new U,
            e = new Gn,
            n = new bt,
            i = new U(1, 1, 1);
        e._onChange((function() {
            n.setFromEuler(e, !1)
        })), n._onChange((function() {
            e.setFromQuaternion(n, void 0, !1)
        })), Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: n
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: i
            },
            modelViewMatrix: {
                value: new Xe
            },
            normalMatrix: {
                value: new We
            }
        }), this.matrix = new Xe, this.matrixWorld = new Xe, this.matrixAutoUpdate = ct.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = ct.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new hh, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
    }
    onBeforeShadow() {}
    onAfterShadow() {}
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(t) {
        this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale)
    }
    applyQuaternion(t) {
        return this.quaternion.premultiply(t), this
    }
    setRotationFromAxisAngle(t, e) {
        this.quaternion.setFromAxisAngle(t, e)
    }
    setRotationFromEuler(t) {
        this.quaternion.setFromEuler(t, !0)
    }
    setRotationFromMatrix(t) {
        this.quaternion.setFromRotationMatrix(t)
    }
    setRotationFromQuaternion(t) {
        this.quaternion.copy(t)
    }
    rotateOnAxis(t, e) {
        return Hs.setFromAxisAngle(t, e), this.quaternion.multiply(Hs), this
    }
    rotateOnWorldAxis(t, e) {
        return Hs.setFromAxisAngle(t, e), this.quaternion.premultiply(Hs), this
    }
    rotateX(t) {
        return this.rotateOnAxis(ed, t)
    }
    rotateY(t) {
        return this.rotateOnAxis(td, t)
    }
    rotateZ(t) {
        return this.rotateOnAxis(nd, t)
    }
    translateOnAxis(t, e) {
        return $u.copy(t).applyQuaternion(this.quaternion), this.position.add($u.multiplyScalar(e)), this
    }
    translateX(t) {
        return this.translateOnAxis(ed, t)
    }
    translateY(t) {
        return this.translateOnAxis(td, t)
    }
    translateZ(t) {
        return this.translateOnAxis(nd, t)
    }
    localToWorld(t) {
        return this.updateWorldMatrix(!0, !1), t.applyMatrix4(this.matrixWorld)
    }
    worldToLocal(t) {
        return this.updateWorldMatrix(!0, !1), t.applyMatrix4(yi.copy(this.matrixWorld).invert())
    }
    lookAt(t, e, n) {
        t.isVector3 ? No.copy(t) : No.set(t, e, n);
        const i = this.parent;
        this.updateWorldMatrix(!0, !1), Wr.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? yi.lookAt(Wr, No, this.up) : yi.lookAt(No, Wr, this.up), this.quaternion.setFromRotationMatrix(yi), i && (yi.extractRotation(i.matrixWorld), Hs.setFromRotationMatrix(yi), this.quaternion.premultiply(Hs.invert()))
    }
    add(t) {
        if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
            return this
        }
        return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (t.removeFromParent(), t.parent = this, this.children.push(t), t.dispatchEvent(id), Vs.child = t, this.dispatchEvent(Vs), Vs.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
    }
    remove(t) {
        if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);
            return this
        }
        const e = this.children.indexOf(t);
        return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(p0), Ul.child = t, this.dispatchEvent(Ul), Ul.child = null), this
    }
    removeFromParent() {
        const t = this.parent;
        return null !== t && t.remove(this), this
    }
    clear() {
        return this.remove(...this.children)
    }
    attach(t) {
        return this.updateWorldMatrix(!0, !1), yi.copy(this.matrixWorld).invert(), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), yi.multiply(t.parent.matrixWorld)), t.applyMatrix4(yi), t.removeFromParent(), t.parent = this, this.children.push(t), t.updateWorldMatrix(!1, !0), t.dispatchEvent(id), Vs.child = t, this.dispatchEvent(Vs), Vs.child = null, this
    }
    getObjectById(t) {
        return this.getObjectByProperty("id", t)
    }
    getObjectByName(t) {
        return this.getObjectByProperty("name", t)
    }
    getObjectByProperty(t, e) {
        if (this[t] === e) return this;
        for (let n = 0, i = this.children.length; n < i; n++) {
            const i = this.children[n].getObjectByProperty(t, e);
            if (void 0 !== i) return i
        }
    }
    getObjectsByProperty(t, e, n = []) {
        this[t] === e && n.push(this);
        const i = this.children;
        for (let s = 0, r = i.length; s < r; s++) i[s].getObjectsByProperty(t, e, n);
        return n
    }
    getWorldPosition(t) {
        return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld)
    }
    getWorldQuaternion(t) {
        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Wr, t, d0), t
    }
    getWorldScale(t) {
        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Wr, f0, t), t
    }
    getWorldDirection(t) {
        this.updateWorldMatrix(!0, !1);
        const e = this.matrixWorld.elements;
        return t.set(e[8], e[9], e[10]).normalize()
    }
    raycast() {}
    traverse(t) {
        t(this);
        const e = this.children;
        for (let n = 0, i = e.length; n < i; n++) e[n].traverse(t)
    }
    traverseVisible(t) {
        if (!1 === this.visible) return;
        t(this);
        const e = this.children;
        for (let n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t)
    }
    traverseAncestors(t) {
        const e = this.parent;
        null !== e && (t(e), e.traverseAncestors(t))
    }
    updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
    }
    updateMatrixWorld(t) {
        this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
        const e = this.children;
        for (let n = 0, i = e.length; n < i; n++) {
            const i = e[n];
            (!0 === i.matrixWorldAutoUpdate || !0 === t) && i.updateMatrixWorld(t)
        }
    }
    updateWorldMatrix(t, e) {
        const n = this.parent;
        if (!0 === t && null !== n && !0 === n.matrixWorldAutoUpdate && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) {
            const t = this.children;
            for (let e = 0, n = t.length; e < n; e++) {
                const n = t[e];
                !0 === n.matrixWorldAutoUpdate && n.updateWorldMatrix(!1, !0)
            }
        }
    }
    toJSON(t) {
        const e = void 0 === t || "string" == typeof t,
            n = {};
        e && (t = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
        }, n.metadata = {
            version: 4.6,
            type: "Object",
            generator: "Object3D.toJSON"
        });
        const i = {};

        function s(e, n) {
            return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid
        }
        if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), !0 === this.castShadow && (i.castShadow = !0), !0 === this.receiveShadow && (i.receiveShadow = !0), !1 === this.visible && (i.visible = !1), !1 === this.frustumCulled && (i.frustumCulled = !1), 0 !== this.renderOrder && (i.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), i.up = this.up.toArray(), !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (i.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (i.type = "BatchedMesh", i.perObjectFrustumCulled = this.perObjectFrustumCulled, i.sortObjects = this.sortObjects, i.drawRanges = this._drawRanges, i.reservedRanges = this._reservedRanges, i.visibility = this._visibility, i.active = this._active, i.bounds = this._bounds.map((t => ({
                boxInitialized: t.boxInitialized,
                boxMin: t.box.min.toArray(),
                boxMax: t.box.max.toArray(),
                sphereInitialized: t.sphereInitialized,
                sphereRadius: t.sphere.radius,
                sphereCenter: t.sphere.center.toArray()
            }))), i.maxGeometryCount = this._maxGeometryCount, i.maxVertexCount = this._maxVertexCount, i.maxIndexCount = this._maxIndexCount, i.geometryInitialized = this._geometryInitialized, i.geometryCount = this._geometryCount, i.matricesTexture = this._matricesTexture.toJSON(t), null !== this.boundingSphere && (i.boundingSphere = {
                center: i.boundingSphere.center.toArray(),
                radius: i.boundingSphere.radius
            }), null !== this.boundingBox && (i.boundingBox = {
                min: i.boundingBox.min.toArray(),
                max: i.boundingBox.max.toArray()
            })), this.isScene) this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(t).uuid)), this.environment && this.environment.isTexture && !0 !== this.environment.isRenderTargetTexture && (i.environment = this.environment.toJSON(t).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
            i.geometry = s(t.geometries, this.geometry);
            const e = this.geometry.parameters;
            if (void 0 !== e && void 0 !== e.shapes) {
                const n = e.shapes;
                if (Array.isArray(n))
                    for (let e = 0, i = n.length; e < i; e++) {
                        const i = n[e];
                        s(t.shapes, i)
                    } else s(t.shapes, n)
            }
        }
        if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (s(t.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), void 0 !== this.material)
            if (Array.isArray(this.material)) {
                const e = [];
                for (let n = 0, i = this.material.length; n < i; n++) e.push(s(t.materials, this.material[n]));
                i.material = e
            } else i.material = s(t.materials, this.material);
        if (this.children.length > 0) {
            i.children = [];
            for (let e = 0; e < this.children.length; e++) i.children.push(this.children[e].toJSON(t).object)
        }
        if (this.animations.length > 0) {
            i.animations = [];
            for (let e = 0; e < this.animations.length; e++) {
                const n = this.animations[e];
                i.animations.push(s(t.animations, n))
            }
        }
        if (e) {
            const e = r(t.geometries),
                i = r(t.materials),
                s = r(t.textures),
                o = r(t.images),
                a = r(t.shapes),
                l = r(t.skeletons),
                c = r(t.animations),
                h = r(t.nodes);
            e.length > 0 && (n.geometries = e), i.length > 0 && (n.materials = i), s.length > 0 && (n.textures = s), o.length > 0 && (n.images = o), a.length > 0 && (n.shapes = a), l.length > 0 && (n.skeletons = l), c.length > 0 && (n.animations = c), h.length > 0 && (n.nodes = h)
        }
        return n.object = i, n;

        function r(t) {
            const e = [];
            for (const n in t) {
                const i = t[n];
                delete i.metadata, e.push(i)
            }
            return e
        }
    }
    clone(t) {
        return (new this.constructor).copy(this, t)
    }
    copy(t, e = !0) {
        if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.animations = t.animations.slice(), this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e)
            for (let e = 0; e < t.children.length; e++) {
                const n = t.children[e];
                this.add(n.clone())
            }
        return this
    }
}
ct.DEFAULT_UP = new U(0, 1, 0), ct.DEFAULT_MATRIX_AUTO_UPDATE = !0, ct.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const jn = new U,
    xi = new U,
    Nl = new U,
    bi = new U,
    Ws = new U,
    Xs = new U,
    sd = new U,
    Fl = new U,
    kl = new U,
    zl = new U;
class Bn {
    constructor(t = new U, e = new U, n = new U) {
        this.a = t, this.b = e, this.c = n
    }
    static getNormal(t, e, n, i) {
        i.subVectors(n, e), jn.subVectors(t, e), i.cross(jn);
        const s = i.lengthSq();
        return s > 0 ? i.multiplyScalar(1 / Math.sqrt(s)) : i.set(0, 0, 0)
    }
    static getBarycoord(t, e, n, i, s) {
        jn.subVectors(i, e), xi.subVectors(n, e), Nl.subVectors(t, e);
        const r = jn.dot(jn),
            o = jn.dot(xi),
            a = jn.dot(Nl),
            l = xi.dot(xi),
            c = xi.dot(Nl),
            h = r * l - o * o;
        if (0 === h) return s.set(0, 0, 0), null;
        const u = 1 / h,
            d = (l * a - o * c) * u,
            p = (r * c - o * a) * u;
        return s.set(1 - d - p, p, d)
    }
    static containsPoint(t, e, n, i) {
        return null !== this.getBarycoord(t, e, n, i, bi) && (bi.x >= 0 && bi.y >= 0 && bi.x + bi.y <= 1)
    }
    static getInterpolation(t, e, n, i, s, r, o, a) {
        return null === this.getBarycoord(t, e, n, i, bi) ? (a.x = 0, a.y = 0, "z" in a && (a.z = 0), "w" in a && (a.w = 0), null) : (a.setScalar(0), a.addScaledVector(s, bi.x), a.addScaledVector(r, bi.y), a.addScaledVector(o, bi.z), a)
    }
    static isFrontFacing(t, e, n, i) {
        return jn.subVectors(n, e), xi.subVectors(t, e), jn.cross(xi).dot(i) < 0
    }
    set(t, e, n) {
        return this.a.copy(t), this.b.copy(e), this.c.copy(n), this
    }
    setFromPointsAndIndices(t, e, n, i) {
        return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this
    }
    setFromAttributeAndIndices(t, e, n, i) {
        return this.a.fromBufferAttribute(t, e), this.b.fromBufferAttribute(t, n), this.c.fromBufferAttribute(t, i), this
    }
    clone() {
        return (new this.constructor).copy(this)
    }
    copy(t) {
        return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
    }
    getArea() {
        return jn.subVectors(this.c, this.b), xi.subVectors(this.a, this.b), .5 * jn.cross(xi).length()
    }
    getMidpoint(t) {
        return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    }
    getNormal(t) {
        return Bn.getNormal(this.a, this.b, this.c, t)
    }
    getPlane(t) {
        return t.setFromCoplanarPoints(this.a, this.b, this.c)
    }
    getBarycoord(t, e) {
        return Bn.getBarycoord(t, this.a, this.b, this.c, e)
    }
    getInterpolation(t, e, n, i, s) {
        return Bn.getInterpolation(t, this.a, this.b, this.c, e, n, i, s)
    }
    containsPoint(t) {
        return Bn.containsPoint(t, this.a, this.b, this.c)
    }
    isFrontFacing(t) {
        return Bn.isFrontFacing(this.a, this.b, this.c, t)
    }
    intersectsBox(t) {
        return t.intersectsTriangle(this)
    }
    closestPointToPoint(t, e) {
        const n = this.a,
            i = this.b,
            s = this.c;
        let r, o;
        Ws.subVectors(i, n), Xs.subVectors(s, n), Fl.subVectors(t, n);
        const a = Ws.dot(Fl),
            l = Xs.dot(Fl);
        if (a <= 0 && l <= 0) return e.copy(n);
        kl.subVectors(t, i);
        const c = Ws.dot(kl),
            h = Xs.dot(kl);
        if (c >= 0 && h <= c) return e.copy(i);
        const u = a * h - c * l;
        if (u <= 0 && a >= 0 && c <= 0) return r = a / (a - c), e.copy(n).addScaledVector(Ws, r);
        zl.subVectors(t, s);
        const d = Ws.dot(zl),
            p = Xs.dot(zl);
        if (p >= 0 && d <= p) return e.copy(s);
        const f = d * l - a * p;
        if (f <= 0 && l >= 0 && p <= 0) return o = l / (l - p), e.copy(n).addScaledVector(Xs, o);
        const m = c * p - d * h;
        if (m <= 0 && h - c >= 0 && d - p >= 0) return sd.subVectors(s, i), o = (h - c) / (h - c + (d - p)), e.copy(i).addScaledVector(sd, o);
        const g = 1 / (m + f + u);
        return r = f * g, o = u * g, e.copy(n).addScaledVector(Ws, r).addScaledVector(Xs, o)
    }
    equals(t) {
        return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
    }
}
const gp = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    },
    Hi = {
        h: 0,
        s: 0,
        l: 0
    },
    Fo = {
        h: 0,
        s: 0,
        l: 0
    };

function Gl(t, e, n) {
    return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
}
class Le {
    constructor(t, e, n) {
        return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(t, e, n)
    }
    set(t, e, n) {
        if (void 0 === e && void 0 === n) {
            const e = t;
            e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e)
        } else this.setRGB(t, e, n);
        return this
    }
    setScalar(t) {
        return this.r = t, this.g = t, this.b = t, this
    }
    setHex(t, e = rt) {
        return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, vt.toWorkingColorSpace(this, e), this
    }
    setRGB(t, e, n, i = vt.workingColorSpace) {
        return this.r = t, this.g = e, this.b = n, vt.toWorkingColorSpace(this, i), this
    }
    setHSL(t, e, n, i = vt.workingColorSpace) {
        if (t = ch(t, 1), e = Ut(e, 0, 1), n = Ut(n, 0, 1), 0 === e) this.r = this.g = this.b = n;
        else {
            const i = n <= .5 ? n * (1 + e) : n + e - n * e,
                s = 2 * n - i;
            this.r = Gl(s, i, t + 1 / 3), this.g = Gl(s, i, t), this.b = Gl(s, i, t - 1 / 3)
        }
        return vt.toWorkingColorSpace(this, i), this
    }
    setStyle(t, e = rt) {
        function n(e) {
            void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
        }
        let i;
        if (i = /^(\w+)\(([^\)]*)\)/.exec(t)) {
            let s;
            const r = i[1],
                o = i[2];
            switch (r) {
                case "rgb":
                case "rgba":
                    if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return n(s[4]), this.setRGB(Math.min(255, parseInt(s[1], 10)) / 255, Math.min(255, parseInt(s[2], 10)) / 255, Math.min(255, parseInt(s[3], 10)) / 255, e);
                    if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return n(s[4]), this.setRGB(Math.min(100, parseInt(s[1], 10)) / 100, Math.min(100, parseInt(s[2], 10)) / 100, Math.min(100, parseInt(s[3], 10)) / 100, e);
                    break;
                case "hsl":
                case "hsla":
                    if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return n(s[4]), this.setHSL(parseFloat(s[1]) / 360, parseFloat(s[2]) / 100, parseFloat(s[3]) / 100, e);
                    break;
                default:
                    console.warn("THREE.Color: Unknown color model " + t)
            }
        } else if (i = /^\#([A-Fa-f\d]+)$/.exec(t)) {
            const n = i[1],
                s = n.length;
            if (3 === s) return this.setRGB(parseInt(n.charAt(0), 16) / 15, parseInt(n.charAt(1), 16) / 15, parseInt(n.charAt(2), 16) / 15, e);
            if (6 === s) return this.setHex(parseInt(n, 16), e);
            console.warn("THREE.Color: Invalid hex color " + t)
        } else if (t && t.length > 0) return this.setColorName(t, e);
        return this
    }
    setColorName(t, e = rt) {
        const n = gp[t.toLowerCase()];
        return void 0 !== n ? this.setHex(n, e) : console.warn("THREE.Color: Unknown color " + t), this
    }
    clone() {
        return new this.constructor(this.r, this.g, this.b)
    }
    copy(t) {
        return this.r = t.r, this.g = t.g, this.b = t.b, this
    }
    copySRGBToLinear(t) {
        return this.r = dr(t.r), this.g = dr(t.g), this.b = dr(t.b), this
    }
    copyLinearToSRGB(t) {
        return this.r = Cl(t.r), this.g = Cl(t.g), this.b = Cl(t.b), this
    }
    convertSRGBToLinear() {
        return this.copySRGBToLinear(this), this
    }
    convertLinearToSRGB() {
        return this.copyLinearToSRGB(this), this
    }
    getHex(t = rt) {
        return vt.fromWorkingColorSpace(cn.copy(this), t), 65536 * Math.round(Ut(255 * cn.r, 0, 255)) + 256 * Math.round(Ut(255 * cn.g, 0, 255)) + Math.round(Ut(255 * cn.b, 0, 255))
    }
    getHexString(t = rt) {
        return ("000000" + this.getHex(t).toString(16)).slice(-6)
    }
    getHSL(t, e = vt.workingColorSpace) {
        vt.fromWorkingColorSpace(cn.copy(this), e);
        const n = cn.r,
            i = cn.g,
            s = cn.b,
            r = Math.max(n, i, s),
            o = Math.min(n, i, s);
        let a, l;
        const c = (o + r) / 2;
        if (o === r) a = 0, l = 0;
        else {
            const t = r - o;
            switch (l = c <= .5 ? t / (r + o) : t / (2 - r - o), r) {
                case n:
                    a = (i - s) / t + (i < s ? 6 : 0);
                    break;
                case i:
                    a = (s - n) / t + 2;
                    break;
                case s:
                    a = (n - i) / t + 4
            }
            a /= 6
        }
        return t.h = a, t.s = l, t.l = c, t
    }
    getRGB(t, e = vt.workingColorSpace) {
        return vt.fromWorkingColorSpace(cn.copy(this), e), t.r = cn.r, t.g = cn.g, t.b = cn.b, t
    }
    getStyle(t = rt) {
        vt.fromWorkingColorSpace(cn.copy(this), t);
        const e = cn.r,
            n = cn.g,
            i = cn.b;
        return t !== rt ? `color(${t} ${e.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(255*e)},${Math.round(255*n)},${Math.round(255*i)})`
    }
    offsetHSL(t, e, n) {
        return this.getHSL(Hi), this.setHSL(Hi.h + t, Hi.s + e, Hi.l + n)
    }
    add(t) {
        return this.r += t.r, this.g += t.g, this.b += t.b, this
    }
    addColors(t, e) {
        return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
    }
    addScalar(t) {
        return this.r += t, this.g += t, this.b += t, this
    }
    sub(t) {
        return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
    }
    multiply(t) {
        return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
    }
    multiplyScalar(t) {
        return this.r *= t, this.g *= t, this.b *= t, this
    }
    lerp(t, e) {
        return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
    }
    lerpColors(t, e, n) {
        return this.r = t.r + (e.r - t.r) * n, this.g = t.g + (e.g - t.g) * n, this.b = t.b + (e.b - t.b) * n, this
    }
    lerpHSL(t, e) {
        this.getHSL(Hi), t.getHSL(Fo);
        const n = io(Hi.h, Fo.h, e),
            i = io(Hi.s, Fo.s, e),
            s = io(Hi.l, Fo.l, e);
        return this.setHSL(n, i, s), this
    }
    setFromVector3(t) {
        return this.r = t.x, this.g = t.y, this.b = t.z, this
    }
    applyMatrix3(t) {
        const e = this.r,
            n = this.g,
            i = this.b,
            s = t.elements;
        return this.r = s[0] * e + s[3] * n + s[6] * i, this.g = s[1] * e + s[4] * n + s[7] * i, this.b = s[2] * e + s[5] * n + s[8] * i, this
    }
    equals(t) {
        return t.r === this.r && t.g === this.g && t.b === this.b
    }
    fromArray(t, e = 0) {
        return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
    }
    toArray(t = [], e = 0) {
        return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
    }
    fromBufferAttribute(t, e) {
        return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), this
    }
    toJSON() {
        return this.getHex()
    }*[Symbol.iterator]() {
        yield this.r, yield this.g, yield this.b
    }
}
const cn = new Le;
Le.NAMES = gp;
let m0 = 0;
class en extends hi {
    constructor() {
        super(), this.isMaterial = !0, Object.defineProperty(this, "id", {
            value: m0++
        }), this.uuid = zn(), this.name = "", this.type = "Material", this.blending = 1, this.side = li, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = Ea, this.blendDst = Pc, this.blendEquation = ms, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Le(0, 0, 0), this.blendAlpha = 0, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = Wu, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Us, this.stencilZFail = Us, this.stencilZPass = Us, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
    }
    get alphaTest() {
        return this._alphaTest
    }
    set alphaTest(t) {
        this._alphaTest > 0 != t > 0 && this.version++, this._alphaTest = t
    }
    onBuild() {}
    onBeforeRender() {}
    onBeforeCompile() {}
    customProgramCacheKey() {
        return this.onBeforeCompile.toString()
    }
    setValues(t) {
        if (void 0 !== t)
            for (const e in t) {
                const n = t[e];
                if (void 0 === n) {
                    console.warn(`THREE.Material: parameter '${e}' has value of undefined.`);
                    continue
                }
                const i = this[e];
                void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[e] = n : console.warn(`THREE.Material: '${e}' is not a property of THREE.${this.type}.`)
            }
    }
    toJSON(t) {
        const e = void 0 === t || "string" == typeof t;
        e && (t = {
            textures: {},
            images: {}
        });
        const n = {
            metadata: {
                version: 4.6,
                type: "Material",
                generator: "Material.toJSON"
            }
        };

        function i(t) {
            const e = [];
            for (const n in t) {
                const i = t[n];
                delete i.metadata, e.push(i)
            }
            return e
        }
        if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), void 0 !== this.sheen && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), void 0 !== this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), void 0 !== this.dispersion && (n.dispersion = this.dispersion), void 0 !== this.iridescence && (n.iridescence = this.iridescence), void 0 !== this.iridescenceIOR && (n.iridescenceIOR = this.iridescenceIOR), void 0 !== this.iridescenceThicknessRange && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(t).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(t).uuid), void 0 !== this.anisotropy && (n.anisotropy = this.anisotropy), void 0 !== this.anisotropyRotation && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(t).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapRotation && (n.envMapRotation = this.envMapRotation.toArray()), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(t).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(t).uuid), void 0 !== this.attenuationDistance && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), this.side !== li && (n.side = this.side), !0 === this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = !0), this.blendSrc !== Ea && (n.blendSrc = this.blendSrc), this.blendDst !== Pc && (n.blendDst = this.blendDst), this.blendEquation !== ms && (n.blendEquation = this.blendEquation), null !== this.blendSrcAlpha && (n.blendSrcAlpha = this.blendSrcAlpha), null !== this.blendDstAlpha && (n.blendDstAlpha = this.blendDstAlpha), null !== this.blendEquationAlpha && (n.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()), 0 !== this.blendAlpha && (n.blendAlpha = this.blendAlpha), 3 !== this.depthFunc && (n.depthFunc = this.depthFunc), !1 === this.depthTest && (n.depthTest = this.depthTest), !1 === this.depthWrite && (n.depthWrite = this.depthWrite), !1 === this.colorWrite && (n.colorWrite = this.colorWrite), 255 !== this.stencilWriteMask && (n.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== Wu && (n.stencilFunc = this.stencilFunc), 0 !== this.stencilRef && (n.stencilRef = this.stencilRef), 255 !== this.stencilFuncMask && (n.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== Us && (n.stencilFail = this.stencilFail), this.stencilZFail !== Us && (n.stencilZFail = this.stencilZFail), this.stencilZPass !== Us && (n.stencilZPass = this.stencilZPass), !0 === this.stencilWrite && (n.stencilWrite = this.stencilWrite), void 0 !== this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), void 0 !== this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaHash && (n.alphaHash = !0), !0 === this.alphaToCoverage && (n.alphaToCoverage = !0), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = !0), !0 === this.forceSinglePass && (n.forceSinglePass = !0), !0 === this.wireframe && (n.wireframe = !0), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (n.flatShading = !0), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), !1 === this.fog && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData), e) {
            const e = i(t.textures),
                s = i(t.images);
            e.length > 0 && (n.textures = e), s.length > 0 && (n.images = s)
        }
        return n
    }
    clone() {
        return (new this.constructor).copy(this)
    }
    copy(t) {
        this.name = t.name, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.blendColor.copy(t.blendColor), this.blendAlpha = t.blendAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
        const e = t.clippingPlanes;
        let n = null;
        if (null !== e) {
            const t = e.length;
            n = new Array(t);
            for (let i = 0; i !== t; ++i) n[i] = e[i].clone()
        }
        return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaHash = t.alphaHash, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.forceSinglePass = t.forceSinglePass, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    set needsUpdate(t) {
        !0 === t && this.version++
    }
}
class At extends en {
    constructor(t) {
        super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new Le(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Gn, this.combine = ih, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(t)
    }
    copy(t) {
        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapRotation.copy(t.envMapRotation), this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.fog = t.fog, this
    }
}
const kt = new U,
    ko = new Q;
class Xt {
    constructor(t, e, n = !1) {
        if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.isBufferAttribute = !0, this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = n, this.usage = Ic, this._updateRange = {
            offset: 0,
            count: -1
        }, this.updateRanges = [], this.gpuType = oi, this.version = 0
    }
    onUploadCallback() {}
    set needsUpdate(t) {
        !0 === t && this.version++
    }
    get updateRange() {
        return fp("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange
    }
    setUsage(t) {
        return this.usage = t, this
    }
    addUpdateRange(t, e) {
        this.updateRanges.push({
            start: t,
            count: e
        })
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0
    }
    copy(t) {
        return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this.gpuType = t.gpuType, this
    }
    copyAt(t, e, n) {
        t *= this.itemSize, n *= e.itemSize;
        for (let i = 0, s = this.itemSize; i < s; i++) this.array[t + i] = e.array[n + i];
        return this
    }
    copyArray(t) {
        return this.array.set(t), this
    }
    applyMatrix3(t) {
        if (2 === this.itemSize)
            for (let e = 0, n = this.count; e < n; e++) ko.fromBufferAttribute(this, e), ko.applyMatrix3(t), this.setXY(e, ko.x, ko.y);
        else if (3 === this.itemSize)
            for (let e = 0, n = this.count; e < n; e++) kt.fromBufferAttribute(this, e), kt.applyMatrix3(t), this.setXYZ(e, kt.x, kt.y, kt.z);
        return this
    }
    applyMatrix4(t) {
        for (let e = 0, n = this.count; e < n; e++) kt.fromBufferAttribute(this, e), kt.applyMatrix4(t), this.setXYZ(e, kt.x, kt.y, kt.z);
        return this
    }
    applyNormalMatrix(t) {
        for (let e = 0, n = this.count; e < n; e++) kt.fromBufferAttribute(this, e), kt.applyNormalMatrix(t), this.setXYZ(e, kt.x, kt.y, kt.z);
        return this
    }
    transformDirection(t) {
        for (let e = 0, n = this.count; e < n; e++) kt.fromBufferAttribute(this, e), kt.transformDirection(t), this.setXYZ(e, kt.x, kt.y, kt.z);
        return this
    }
    set(t, e = 0) {
        return this.array.set(t, e), this
    }
    getComponent(t, e) {
        let n = this.array[t * this.itemSize + e];
        return this.normalized && (n = Yn(n, this.array)), n
    }
    setComponent(t, e, n) {
        return this.normalized && (n = mt(n, this.array)), this.array[t * this.itemSize + e] = n, this
    }
    getX(t) {
        let e = this.array[t * this.itemSize];
        return this.normalized && (e = Yn(e, this.array)), e
    }
    setX(t, e) {
        return this.normalized && (e = mt(e, this.array)), this.array[t * this.itemSize] = e, this
    }
    getY(t) {
        let e = this.array[t * this.itemSize + 1];
        return this.normalized && (e = Yn(e, this.array)), e
    }
    setY(t, e) {
        return this.normalized && (e = mt(e, this.array)), this.array[t * this.itemSize + 1] = e, this
    }
    getZ(t) {
        let e = this.array[t * this.itemSize + 2];
        return this.normalized && (e = Yn(e, this.array)), e
    }
    setZ(t, e) {
        return this.normalized && (e = mt(e, this.array)), this.array[t * this.itemSize + 2] = e, this
    }
    getW(t) {
        let e = this.array[t * this.itemSize + 3];
        return this.normalized && (e = Yn(e, this.array)), e
    }
    setW(t, e) {
        return this.normalized && (e = mt(e, this.array)), this.array[t * this.itemSize + 3] = e, this
    }
    setXY(t, e, n) {
        return t *= this.itemSize, this.normalized && (e = mt(e, this.array), n = mt(n, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this
    }
    setXYZ(t, e, n, i) {
        return t *= this.itemSize, this.normalized && (e = mt(e, this.array), n = mt(n, this.array), i = mt(i, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this
    }
    setXYZW(t, e, n, i, s) {
        return t *= this.itemSize, this.normalized && (e = mt(e, this.array), n = mt(n, this.array), i = mt(i, this.array), s = mt(s, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this.array[t + 3] = s, this
    }
    onUpload(t) {
        return this.onUploadCallback = t, this
    }
    clone() {
        return new this.constructor(this.array, this.itemSize).copy(this)
    }
    toJSON() {
        const t = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
        };
        return "" !== this.name && (t.name = this.name), this.usage !== Ic && (t.usage = this.usage), t
    }
}
class vp extends Xt {
    constructor(t, e, n) {
        super(new Uint16Array(t), e, n)
    }
}
class yp extends Xt {
    constructor(t, e, n) {
        super(new Uint32Array(t), e, n)
    }
}
class Fe extends Xt {
    constructor(t, e, n) {
        super(new Float32Array(t), e, n)
    }
}
let g0 = 0;
const Rn = new Xe,
    Hl = new ct,
    js = new U,
    An = new Tn,
    Xr = new Tn,
    Yt = new U;
class ht extends hi {
    constructor() {
        super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {
            value: g0++
        }), this.uuid = zn(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
            start: 0,
            count: 1 / 0
        }, this.userData = {}
    }
    getIndex() {
        return this.index
    }
    setIndex(t) {
        return Array.isArray(t) ? this.index = new(dp(t) ? yp : vp)(t, 1) : this.index = t, this
    }
    getAttribute(t) {
        return this.attributes[t]
    }
    setAttribute(t, e) {
        return this.attributes[t] = e, this
    }
    deleteAttribute(t) {
        return delete this.attributes[t], this
    }
    hasAttribute(t) {
        return void 0 !== this.attributes[t]
    }
    addGroup(t, e, n = 0) {
        this.groups.push({
            start: t,
            count: e,
            materialIndex: n
        })
    }
    clearGroups() {
        this.groups = []
    }
    setDrawRange(t, e) {
        this.drawRange.start = t, this.drawRange.count = e
    }
    applyMatrix4(t) {
        const e = this.attributes.position;
        void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0);
        const n = this.attributes.normal;
        if (void 0 !== n) {
            const e = (new We).getNormalMatrix(t);
            n.applyNormalMatrix(e), n.needsUpdate = !0
        }
        const i = this.attributes.tangent;
        return void 0 !== i && (i.transformDirection(t), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
    }
    applyQuaternion(t) {
        return Rn.makeRotationFromQuaternion(t), this.applyMatrix4(Rn), this
    }
    rotateX(t) {
        return Rn.makeRotationX(t), this.applyMatrix4(Rn), this
    }
    rotateY(t) {
        return Rn.makeRotationY(t), this.applyMatrix4(Rn), this
    }
    rotateZ(t) {
        return Rn.makeRotationZ(t), this.applyMatrix4(Rn), this
    }
    translate(t, e, n) {
        return Rn.makeTranslation(t, e, n), this.applyMatrix4(Rn), this
    }
    scale(t, e, n) {
        return Rn.makeScale(t, e, n), this.applyMatrix4(Rn), this
    }
    lookAt(t) {
        return Hl.lookAt(t), Hl.updateMatrix(), this.applyMatrix4(Hl.matrix), this
    }
    center() {
        return this.computeBoundingBox(), this.boundingBox.getCenter(js).negate(), this.translate(js.x, js.y, js.z), this
    }
    setFromPoints(t) {
        const e = [];
        for (let n = 0, i = t.length; n < i; n++) {
            const i = t[n];
            e.push(i.x, i.y, i.z || 0)
        }
        return this.setAttribute("position", new Fe(e, 3)), this
    }
    computeBoundingBox() {
        null === this.boundingBox && (this.boundingBox = new Tn);
        const t = this.attributes.position,
            e = this.morphAttributes.position;
        if (t && t.isGLBufferAttribute) return console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), void this.boundingBox.set(new U(-1 / 0, -1 / 0, -1 / 0), new U(1 / 0, 1 / 0, 1 / 0));
        if (void 0 !== t) {
            if (this.boundingBox.setFromBufferAttribute(t), e)
                for (let t = 0, n = e.length; t < n; t++) {
                    const n = e[t];
                    An.setFromBufferAttribute(n), this.morphTargetsRelative ? (Yt.addVectors(this.boundingBox.min, An.min), this.boundingBox.expandByPoint(Yt), Yt.addVectors(this.boundingBox.max, An.max), this.boundingBox.expandByPoint(Yt)) : (this.boundingBox.expandByPoint(An.min), this.boundingBox.expandByPoint(An.max))
                }
        } else this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
    }
    computeBoundingSphere() {
        null === this.boundingSphere && (this.boundingSphere = new Hn);
        const t = this.attributes.position,
            e = this.morphAttributes.position;
        if (t && t.isGLBufferAttribute) return console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), void this.boundingSphere.set(new U, 1 / 0);
        if (t) {
            const n = this.boundingSphere.center;
            if (An.setFromBufferAttribute(t), e)
                for (let t = 0, n = e.length; t < n; t++) {
                    const n = e[t];
                    Xr.setFromBufferAttribute(n), this.morphTargetsRelative ? (Yt.addVectors(An.min, Xr.min), An.expandByPoint(Yt), Yt.addVectors(An.max, Xr.max), An.expandByPoint(Yt)) : (An.expandByPoint(Xr.min), An.expandByPoint(Xr.max))
                }
            An.getCenter(n);
            let i = 0;
            for (let e = 0, s = t.count; e < s; e++) Yt.fromBufferAttribute(t, e), i = Math.max(i, n.distanceToSquared(Yt));
            if (e)
                for (let s = 0, r = e.length; s < r; s++) {
                    const r = e[s],
                        o = this.morphTargetsRelative;
                    for (let e = 0, s = r.count; e < s; e++) Yt.fromBufferAttribute(r, e), o && (js.fromBufferAttribute(t, e), Yt.add(js)), i = Math.max(i, n.distanceToSquared(Yt))
                }
            this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
        }
    }
    computeTangents() {
        const t = this.index,
            e = this.attributes;
        if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
        const n = e.position,
            i = e.normal,
            s = e.uv;
        !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new Xt(new Float32Array(4 * n.count), 4));
        const r = this.getAttribute("tangent"),
            o = [],
            a = [];
        for (let t = 0; t < n.count; t++) o[t] = new U, a[t] = new U;
        const l = new U,
            c = new U,
            h = new U,
            u = new Q,
            d = new Q,
            p = new Q,
            f = new U,
            m = new U;

        function g(t, e, i) {
            l.fromBufferAttribute(n, t), c.fromBufferAttribute(n, e), h.fromBufferAttribute(n, i), u.fromBufferAttribute(s, t), d.fromBufferAttribute(s, e), p.fromBufferAttribute(s, i), c.sub(l), h.sub(l), d.sub(u), p.sub(u);
            const r = 1 / (d.x * p.y - p.x * d.y);
            isFinite(r) && (f.copy(c).multiplyScalar(p.y).addScaledVector(h, -d.y).multiplyScalar(r), m.copy(h).multiplyScalar(d.x).addScaledVector(c, -p.x).multiplyScalar(r), o[t].add(f), o[e].add(f), o[i].add(f), a[t].add(m), a[e].add(m), a[i].add(m))
        }
        let v = this.groups;
        0 === v.length && (v = [{
            start: 0,
            count: t.count
        }]);
        for (let e = 0, n = v.length; e < n; ++e) {
            const n = v[e],
                i = n.start;
            for (let e = i, s = i + n.count; e < s; e += 3) g(t.getX(e + 0), t.getX(e + 1), t.getX(e + 2))
        }
        const y = new U,
            x = new U,
            b = new U,
            A = new U;

        function S(t) {
            b.fromBufferAttribute(i, t), A.copy(b);
            const e = o[t];
            y.copy(e), y.sub(b.multiplyScalar(b.dot(e))).normalize(), x.crossVectors(A, e);
            const n = x.dot(a[t]) < 0 ? -1 : 1;
            r.setXYZW(t, y.x, y.y, y.z, n)
        }
        for (let e = 0, n = v.length; e < n; ++e) {
            const n = v[e],
                i = n.start;
            for (let e = i, s = i + n.count; e < s; e += 3) S(t.getX(e + 0)), S(t.getX(e + 1)), S(t.getX(e + 2))
        }
    }
    computeVertexNormals() {
        const t = this.index,
            e = this.getAttribute("position");
        if (void 0 !== e) {
            let n = this.getAttribute("normal");
            if (void 0 === n) n = new Xt(new Float32Array(3 * e.count), 3), this.setAttribute("normal", n);
            else
                for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
            const i = new U,
                s = new U,
                r = new U,
                o = new U,
                a = new U,
                l = new U,
                c = new U,
                h = new U;
            if (t)
                for (let u = 0, d = t.count; u < d; u += 3) {
                    const d = t.getX(u + 0),
                        p = t.getX(u + 1),
                        f = t.getX(u + 2);
                    i.fromBufferAttribute(e, d), s.fromBufferAttribute(e, p), r.fromBufferAttribute(e, f), c.subVectors(r, s), h.subVectors(i, s), c.cross(h), o.fromBufferAttribute(n, d), a.fromBufferAttribute(n, p), l.fromBufferAttribute(n, f), o.add(c), a.add(c), l.add(c), n.setXYZ(d, o.x, o.y, o.z), n.setXYZ(p, a.x, a.y, a.z), n.setXYZ(f, l.x, l.y, l.z)
                } else
                    for (let t = 0, o = e.count; t < o; t += 3) i.fromBufferAttribute(e, t + 0), s.fromBufferAttribute(e, t + 1), r.fromBufferAttribute(e, t + 2), c.subVectors(r, s), h.subVectors(i, s), c.cross(h), n.setXYZ(t + 0, c.x, c.y, c.z), n.setXYZ(t + 1, c.x, c.y, c.z), n.setXYZ(t + 2, c.x, c.y, c.z);
            this.normalizeNormals(), n.needsUpdate = !0
        }
    }
    normalizeNormals() {
        const t = this.attributes.normal;
        for (let e = 0, n = t.count; e < n; e++) Yt.fromBufferAttribute(t, e), Yt.normalize(), t.setXYZ(e, Yt.x, Yt.y, Yt.z)
    }
    toNonIndexed() {
        function t(t, e) {
            const n = t.array,
                i = t.itemSize,
                s = t.normalized,
                r = new n.constructor(e.length * i);
            let o = 0,
                a = 0;
            for (let s = 0, l = e.length; s < l; s++) {
                o = t.isInterleavedBufferAttribute ? e[s] * t.data.stride + t.offset : e[s] * i;
                for (let t = 0; t < i; t++) r[a++] = n[o++]
            }
            return new Xt(r, i, s)
        }
        if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
        const e = new ht,
            n = this.index.array,
            i = this.attributes;
        for (const s in i) {
            const r = t(i[s], n);
            e.setAttribute(s, r)
        }
        const s = this.morphAttributes;
        for (const i in s) {
            const r = [],
                o = s[i];
            for (let e = 0, i = o.length; e < i; e++) {
                const i = t(o[e], n);
                r.push(i)
            }
            e.morphAttributes[i] = r
        }
        e.morphTargetsRelative = this.morphTargetsRelative;
        const r = this.groups;
        for (let t = 0, n = r.length; t < n; t++) {
            const n = r[t];
            e.addGroup(n.start, n.count, n.materialIndex)
        }
        return e
    }
    toJSON() {
        const t = {
            metadata: {
                version: 4.6,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
            }
        };
        if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) {
            const e = this.parameters;
            for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
            return t
        }
        t.data = {
            attributes: {}
        };
        const e = this.index;
        null !== e && (t.data.index = {
            type: e.array.constructor.name,
            array: Array.prototype.slice.call(e.array)
        });
        const n = this.attributes;
        for (const e in n) {
            const i = n[e];
            t.data.attributes[e] = i.toJSON(t.data)
        }
        const i = {};
        let s = !1;
        for (const e in this.morphAttributes) {
            const n = this.morphAttributes[e],
                r = [];
            for (let e = 0, i = n.length; e < i; e++) {
                const i = n[e];
                r.push(i.toJSON(t.data))
            }
            r.length > 0 && (i[e] = r, s = !0)
        }
        s && (t.data.morphAttributes = i, t.data.morphTargetsRelative = this.morphTargetsRelative);
        const r = this.groups;
        r.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(r)));
        const o = this.boundingSphere;
        return null !== o && (t.data.boundingSphere = {
            center: o.center.toArray(),
            radius: o.radius
        }), t
    }
    clone() {
        return (new this.constructor).copy(this)
    }
    copy(t) {
        this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
        const e = {};
        this.name = t.name;
        const n = t.index;
        null !== n && this.setIndex(n.clone(e));
        const i = t.attributes;
        for (const t in i) {
            const n = i[t];
            this.setAttribute(t, n.clone(e))
        }
        const s = t.morphAttributes;
        for (const t in s) {
            const n = [],
                i = s[t];
            for (let t = 0, s = i.length; t < s; t++) n.push(i[t].clone(e));
            this.morphAttributes[t] = n
        }
        this.morphTargetsRelative = t.morphTargetsRelative;
        const r = t.groups;
        for (let t = 0, e = r.length; t < e; t++) {
            const e = r[t];
            this.addGroup(e.start, e.count, e.materialIndex)
        }
        const o = t.boundingBox;
        null !== o && (this.boundingBox = o.clone());
        const a = t.boundingSphere;
        return null !== a && (this.boundingSphere = a.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
const rd = new Xe,
    ls = new Ir,
    zo = new Hn,
    od = new U,
    Ks = new U,
    Ys = new U,
    Qs = new U,
    Vl = new U,
    Go = new U,
    Ho = new Q,
    Vo = new Q,
    Wo = new Q,
    ad = new U,
    ld = new U,
    cd = new U,
    Xo = new U,
    jo = new U;
class be extends ct {
    constructor(t = new ht, e = new At) {
        super(), this.isMesh = !0, this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets()
    }
    copy(t, e) {
        return super.copy(t, e), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes,
            e = Object.keys(t);
        if (e.length > 0) {
            const n = t[e[0]];
            if (void 0 !== n) {
                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                for (let t = 0, e = n.length; t < e; t++) {
                    const e = n[t].name || String(t);
                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[e] = t
                }
            }
        }
    }
    getVertexPosition(t, e) {
        const n = this.geometry,
            i = n.attributes.position,
            s = n.morphAttributes.position,
            r = n.morphTargetsRelative;
        e.fromBufferAttribute(i, t);
        const o = this.morphTargetInfluences;
        if (s && o) {
            Go.set(0, 0, 0);
            for (let n = 0, i = s.length; n < i; n++) {
                const i = o[n],
                    a = s[n];
                0 !== i && (Vl.fromBufferAttribute(a, t), r ? Go.addScaledVector(Vl, i) : Go.addScaledVector(Vl.sub(e), i))
            }
            e.add(Go)
        }
        return e
    }
    raycast(t, e) {
        const n = this.geometry,
            i = this.material,
            s = this.matrixWorld;
        void 0 !== i && (null === n.boundingSphere && n.computeBoundingSphere(), zo.copy(n.boundingSphere), zo.applyMatrix4(s), ls.copy(t.ray).recast(t.near), (!1 !== zo.containsPoint(ls.origin) || !(null === ls.intersectSphere(zo, od) || ls.origin.distanceToSquared(od) > (t.far - t.near) ** 2)) && (rd.copy(s).invert(), ls.copy(t.ray).applyMatrix4(rd), (null === n.boundingBox || !1 !== ls.intersectsBox(n.boundingBox)) && this._computeIntersections(t, e, ls)))
    }
    _computeIntersections(t, e, n) {
        let i;
        const s = this.geometry,
            r = this.material,
            o = s.index,
            a = s.attributes.position,
            l = s.attributes.uv,
            c = s.attributes.uv1,
            h = s.attributes.normal,
            u = s.groups,
            d = s.drawRange;
        if (null !== o)
            if (Array.isArray(r))
                for (let s = 0, a = u.length; s < a; s++) {
                    const a = u[s],
                        p = r[a.materialIndex];
                    for (let s = Math.max(a.start, d.start), r = Math.min(o.count, Math.min(a.start + a.count, d.start + d.count)); s < r; s += 3) {
                        i = Ko(this, p, t, n, l, c, h, o.getX(s), o.getX(s + 1), o.getX(s + 2)), i && (i.faceIndex = Math.floor(s / 3), i.face.materialIndex = a.materialIndex, e.push(i))
                    }
                } else {
                    for (let s = Math.max(0, d.start), a = Math.min(o.count, d.start + d.count); s < a; s += 3) {
                        i = Ko(this, r, t, n, l, c, h, o.getX(s), o.getX(s + 1), o.getX(s + 2)), i && (i.faceIndex = Math.floor(s / 3), e.push(i))
                    }
                } else if (void 0 !== a)
                    if (Array.isArray(r))
                        for (let s = 0, o = u.length; s < o; s++) {
                            const o = u[s],
                                p = r[o.materialIndex];
                            for (let s = Math.max(o.start, d.start), r = Math.min(a.count, Math.min(o.start + o.count, d.start + d.count)); s < r; s += 3) {
                                i = Ko(this, p, t, n, l, c, h, s, s + 1, s + 2), i && (i.faceIndex = Math.floor(s / 3), i.face.materialIndex = o.materialIndex, e.push(i))
                            }
                        } else {
                            for (let s = Math.max(0, d.start), o = Math.min(a.count, d.start + d.count); s < o; s += 3) {
                                i = Ko(this, r, t, n, l, c, h, s, s + 1, s + 2), i && (i.faceIndex = Math.floor(s / 3), e.push(i))
                            }
                        }
    }
}

function v0(t, e, n, i, s, r, o, a) {
    let l;
    if (l = e.side === Bt ? i.intersectTriangle(o, r, s, !0, a) : i.intersectTriangle(s, r, o, e.side === li, a), null === l) return null;
    jo.copy(a), jo.applyMatrix4(t.matrixWorld);
    const c = n.ray.origin.distanceTo(jo);
    return c < n.near || c > n.far ? null : {
        distance: c,
        point: jo.clone(),
        object: t
    }
}

function Ko(t, e, n, i, s, r, o, a, l, c) {
    t.getVertexPosition(a, Ks), t.getVertexPosition(l, Ys), t.getVertexPosition(c, Qs);
    const h = v0(t, e, n, i, Ks, Ys, Qs, Xo);
    if (h) {
        s && (Ho.fromBufferAttribute(s, a), Vo.fromBufferAttribute(s, l), Wo.fromBufferAttribute(s, c), h.uv = Bn.getInterpolation(Xo, Ks, Ys, Qs, Ho, Vo, Wo, new Q)), r && (Ho.fromBufferAttribute(r, a), Vo.fromBufferAttribute(r, l), Wo.fromBufferAttribute(r, c), h.uv1 = Bn.getInterpolation(Xo, Ks, Ys, Qs, Ho, Vo, Wo, new Q)), o && (ad.fromBufferAttribute(o, a), ld.fromBufferAttribute(o, l), cd.fromBufferAttribute(o, c), h.normal = Bn.getInterpolation(Xo, Ks, Ys, Qs, ad, ld, cd, new U), h.normal.dot(i.direction) > 0 && h.normal.multiplyScalar(-1));
        const t = {
            a: a,
            b: l,
            c: c,
            normal: new U,
            materialIndex: 0
        };
        Bn.getNormal(Ks, Ys, Qs, t.normal), h.face = t
    }
    return h
}
class Sn extends ht {
    constructor(t = 1, e = 1, n = 1, i = 1, s = 1, r = 1) {
        super(), this.type = "BoxGeometry", this.parameters = {
            width: t,
            height: e,
            depth: n,
            widthSegments: i,
            heightSegments: s,
            depthSegments: r
        };
        const o = this;
        i = Math.floor(i), s = Math.floor(s), r = Math.floor(r);
        const a = [],
            l = [],
            c = [],
            h = [];
        let u = 0,
            d = 0;

        function p(t, e, n, i, s, r, p, f, m, g, v) {
            const y = r / m,
                x = p / g,
                b = r / 2,
                A = p / 2,
                S = f / 2,
                w = m + 1,
                _ = g + 1;
            let M = 0,
                T = 0;
            const E = new U;
            for (let r = 0; r < _; r++) {
                const o = r * x - A;
                for (let a = 0; a < w; a++) {
                    const u = a * y - b;
                    E[t] = u * i, E[e] = o * s, E[n] = S, l.push(E.x, E.y, E.z), E[t] = 0, E[e] = 0, E[n] = f > 0 ? 1 : -1, c.push(E.x, E.y, E.z), h.push(a / m), h.push(1 - r / g), M += 1
                }
            }
            for (let t = 0; t < g; t++)
                for (let e = 0; e < m; e++) {
                    const n = u + e + w * t,
                        i = u + e + w * (t + 1),
                        s = u + (e + 1) + w * (t + 1),
                        r = u + (e + 1) + w * t;
                    a.push(n, i, r), a.push(i, s, r), T += 6
                }
            o.addGroup(d, T, v), d += T, u += M
        }
        p("z", "y", "x", -1, -1, n, e, t, r, s, 0), p("z", "y", "x", 1, -1, n, e, -t, r, s, 1), p("x", "z", "y", 1, 1, t, n, e, i, r, 2), p("x", "z", "y", 1, -1, t, n, -e, i, r, 3), p("x", "y", "z", 1, -1, t, e, n, i, s, 4), p("x", "y", "z", -1, -1, t, e, -n, i, s, 5), this.setIndex(a), this.setAttribute("position", new Fe(l, 3)), this.setAttribute("normal", new Fe(c, 3)), this.setAttribute("uv", new Fe(h, 2))
    }
    copy(t) {
        return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
    }
    static fromJSON(t) {
        return new Sn(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments)
    }
}

function Mr(t) {
    const e = {};
    for (const n in t) {
        e[n] = {};
        for (const i in t[n]) {
            const s = t[n][i];
            s && (s.isColor || s.isMatrix3 || s.isMatrix4 || s.isVector2 || s.isVector3 || s.isVector4 || s.isTexture || s.isQuaternion) ? s.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[n][i] = null) : e[n][i] = s.clone() : Array.isArray(s) ? e[n][i] = s.slice() : e[n][i] = s
        }
    }
    return e
}

function dn(t) {
    const e = {};
    for (let n = 0; n < t.length; n++) {
        const i = Mr(t[n]);
        for (const t in i) e[t] = i[t]
    }
    return e
}

function y0(t) {
    const e = [];
    for (let n = 0; n < t.length; n++) e.push(t[n].clone());
    return e
}

function xp(t) {
    const e = t.getRenderTarget();
    return null === e ? t.outputColorSpace : !0 === e.isXRRenderTarget ? e.texture.colorSpace : vt.workingColorSpace
}
const Lc = {
    clone: Mr,
    merge: dn
};
var x0 = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
    b0 = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
class It extends en {
    constructor(t) {
        super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = x0, this.fragmentShader = b0, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
            clipCullDistance: !1,
            multiDraw: !1
        }, this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv1: [0, 0]
        }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== t && this.setValues(t)
    }
    copy(t) {
        return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = Mr(t.uniforms), this.uniformsGroups = y0(t.uniformsGroups), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.fog = t.fog, this.lights = t.lights, this.clipping = t.clipping, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this
    }
    toJSON(t) {
        const e = super.toJSON(t);
        e.glslVersion = this.glslVersion, e.uniforms = {};
        for (const n in this.uniforms) {
            const i = this.uniforms[n].value;
            i && i.isTexture ? e.uniforms[n] = {
                type: "t",
                value: i.toJSON(t).uuid
            } : i && i.isColor ? e.uniforms[n] = {
                type: "c",
                value: i.getHex()
            } : i && i.isVector2 ? e.uniforms[n] = {
                type: "v2",
                value: i.toArray()
            } : i && i.isVector3 ? e.uniforms[n] = {
                type: "v3",
                value: i.toArray()
            } : i && i.isVector4 ? e.uniforms[n] = {
                type: "v4",
                value: i.toArray()
            } : i && i.isMatrix3 ? e.uniforms[n] = {
                type: "m3",
                value: i.toArray()
            } : i && i.isMatrix4 ? e.uniforms[n] = {
                type: "m4",
                value: i.toArray()
            } : e.uniforms[n] = {
                value: i
            }
        }
        Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, e.lights = this.lights, e.clipping = this.clipping;
        const n = {};
        for (const t in this.extensions) !0 === this.extensions[t] && (n[t] = !0);
        return Object.keys(n).length > 0 && (e.extensions = n), e
    }
}
class uh extends ct {
    constructor() {
        super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Xe, this.projectionMatrix = new Xe, this.projectionMatrixInverse = new Xe, this.coordinateSystem = Ti
    }
    copy(t, e) {
        return super.copy(t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this.coordinateSystem = t.coordinateSystem, this
    }
    getWorldDirection(t) {
        return super.getWorldDirection(t).negate()
    }
    updateMatrixWorld(t) {
        super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    updateWorldMatrix(t, e) {
        super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    clone() {
        return (new this.constructor).copy(this)
    }
}
const Vi = new U,
    hd = new Q,
    ud = new Q;
class Pt extends uh {
    constructor(t = 50, e = 1, n = .1, i = 2e3) {
        super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
    }
    copy(t, e) {
        return super.copy(t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
    }
    setFocalLength(t) {
        const e = .5 * this.getFilmHeight() / t;
        this.fov = 2 * wr * Math.atan(e), this.updateProjectionMatrix()
    }
    getFocalLength() {
        const t = Math.tan(.5 * ur * this.fov);
        return .5 * this.getFilmHeight() / t
    }
    getEffectiveFOV() {
        return 2 * wr * Math.atan(Math.tan(.5 * ur * this.fov) / this.zoom)
    }
    getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1)
    }
    getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1)
    }
    getViewBounds(t, e, n) {
        Vi.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse), e.set(Vi.x, Vi.y).multiplyScalar(-t / Vi.z), Vi.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse), n.set(Vi.x, Vi.y).multiplyScalar(-t / Vi.z)
    }
    getViewSize(t, e) {
        return this.getViewBounds(t, hd, ud), e.subVectors(ud, hd)
    }
    setViewOffset(t, e, n, i, s, r) {
        this.aspect = t / e, null === this.view && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = s, this.view.height = r, this.updateProjectionMatrix()
    }
    clearViewOffset() {
        null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const t = this.near;
        let e = t * Math.tan(.5 * ur * this.fov) / this.zoom,
            n = 2 * e,
            i = this.aspect * n,
            s = -.5 * i;
        const r = this.view;
        if (null !== this.view && this.view.enabled) {
            const t = r.fullWidth,
                o = r.fullHeight;
            s += r.offsetX * i / t, e -= r.offsetY * n / o, i *= r.width / t, n *= r.height / o
        }
        const o = this.filmOffset;
        0 !== o && (s += t * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + i, e, e - n, t, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(t) {
        const e = super.toJSON(t);
        return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
    }
}
const qs = -90,
    Zs = 1;
class A0 extends ct {
    constructor(t, e, n) {
        super(), this.type = "CubeCamera", this.renderTarget = n, this.coordinateSystem = null, this.activeMipmapLevel = 0;
        const i = new Pt(qs, 1, t, e);
        i.layers = this.layers, this.add(i);
        const s = new Pt(qs, 1, t, e);
        s.layers = this.layers, this.add(s);
        const r = new Pt(qs, 1, t, e);
        r.layers = this.layers, this.add(r);
        const o = new Pt(qs, 1, t, e);
        o.layers = this.layers, this.add(o);
        const a = new Pt(qs, 1, t, e);
        a.layers = this.layers, this.add(a);
        const l = new Pt(qs, 1, t, e);
        l.layers = this.layers, this.add(l)
    }
    updateCoordinateSystem() {
        const t = this.coordinateSystem,
            e = this.children.concat(),
            [n, i, s, r, o, a] = e;
        for (const t of e) this.remove(t);
        if (t === Ti) n.up.set(0, 1, 0), n.lookAt(1, 0, 0), i.up.set(0, 1, 0), i.lookAt(-1, 0, 0), s.up.set(0, 0, -1), s.lookAt(0, 1, 0), r.up.set(0, 0, 1), r.lookAt(0, -1, 0), o.up.set(0, 1, 0), o.lookAt(0, 0, 1), a.up.set(0, 1, 0), a.lookAt(0, 0, -1);
        else {
            if (t !== Ia) throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + t);
            n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), i.up.set(0, -1, 0), i.lookAt(1, 0, 0), s.up.set(0, 0, 1), s.lookAt(0, 1, 0), r.up.set(0, 0, -1), r.lookAt(0, -1, 0), o.up.set(0, -1, 0), o.lookAt(0, 0, 1), a.up.set(0, -1, 0), a.lookAt(0, 0, -1)
        }
        for (const t of e) this.add(t), t.updateMatrixWorld()
    }
    update(t, e) {
        null === this.parent && this.updateMatrixWorld();
        const {
            renderTarget: n,
            activeMipmapLevel: i
        } = this;
        this.coordinateSystem !== t.coordinateSystem && (this.coordinateSystem = t.coordinateSystem, this.updateCoordinateSystem());
        const [s, r, o, a, l, c] = this.children, h = t.getRenderTarget(), u = t.getActiveCubeFace(), d = t.getActiveMipmapLevel(), p = t.xr.enabled;
        t.xr.enabled = !1;
        const f = n.texture.generateMipmaps;
        n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0, i), t.render(e, s), t.setRenderTarget(n, 1, i), t.render(e, r), t.setRenderTarget(n, 2, i), t.render(e, o), t.setRenderTarget(n, 3, i), t.render(e, a), t.setRenderTarget(n, 4, i), t.render(e, l), n.texture.generateMipmaps = f, t.setRenderTarget(n, 5, i), t.render(e, c), t.setRenderTarget(h, u, d), t.xr.enabled = p, n.texture.needsPMREMUpdate = !0
    }
}
class bp extends wt {
    constructor(t, e, n, i, s, r, o, a, l, c) {
        super(t = void 0 !== t ? t : [], e = void 0 !== e ? e : Ar, n, i, s, r, o, a, l, c), this.isCubeTexture = !0, this.flipY = !1
    }
    get images() {
        return this.image
    }
    set images(t) {
        this.image = t
    }
}
class S0 extends nn {
    constructor(t = 1, e = {}) {
        super(t, t, e), this.isWebGLCubeRenderTarget = !0;
        const n = {
                width: t,
                height: t,
                depth: 1
            },
            i = [n, n, n, n, n, n];
        this.texture = new bp(i, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps, this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : Ht
    }
    fromEquirectangularTexture(t, e) {
        this.texture.type = e.type, this.texture.colorSpace = e.colorSpace, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
        const n = {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
            },
            i = new Sn(5, 5, 5),
            s = new It({
                name: "CubemapFromEquirect",
                uniforms: Mr(n.uniforms),
                vertexShader: n.vertexShader,
                fragmentShader: n.fragmentShader,
                side: Bt,
                blending: 0
            });
        s.uniforms.tEquirect.value = e;
        const r = new be(i, s),
            o = e.minFilter;
        return e.minFilter === Ei && (e.minFilter = Ht), new A0(1, 10, this).update(t, r), e.minFilter = o, r.geometry.dispose(), r.material.dispose(), this
    }
    clear(t, e, n, i) {
        const s = t.getRenderTarget();
        for (let s = 0; s < 6; s++) t.setRenderTarget(this, s), t.clear(e, n, i);
        t.setRenderTarget(s)
    }
}
const Wl = new U,
    _0 = new U,
    w0 = new We;
class ji {
    constructor(t = new U(1, 0, 0), e = 0) {
        this.isPlane = !0, this.normal = t, this.constant = e
    }
    set(t, e) {
        return this.normal.copy(t), this.constant = e, this
    }
    setComponents(t, e, n, i) {
        return this.normal.set(t, e, n), this.constant = i, this
    }
    setFromNormalAndCoplanarPoint(t, e) {
        return this.normal.copy(t), this.constant = -e.dot(this.normal), this
    }
    setFromCoplanarPoints(t, e, n) {
        const i = Wl.subVectors(n, e).cross(_0.subVectors(t, e)).normalize();
        return this.setFromNormalAndCoplanarPoint(i, t), this
    }
    copy(t) {
        return this.normal.copy(t.normal), this.constant = t.constant, this
    }
    normalize() {
        const t = 1 / this.normal.length();
        return this.normal.multiplyScalar(t), this.constant *= t, this
    }
    negate() {
        return this.constant *= -1, this.normal.negate(), this
    }
    distanceToPoint(t) {
        return this.normal.dot(t) + this.constant
    }
    distanceToSphere(t) {
        return this.distanceToPoint(t.center) - t.radius
    }
    projectPoint(t, e) {
        return e.copy(t).addScaledVector(this.normal, -this.distanceToPoint(t))
    }
    intersectLine(t, e) {
        const n = t.delta(Wl),
            i = this.normal.dot(n);
        if (0 === i) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
        const s = -(t.start.dot(this.normal) + this.constant) / i;
        return s < 0 || s > 1 ? null : e.copy(t.start).addScaledVector(n, s)
    }
    intersectsLine(t) {
        const e = this.distanceToPoint(t.start),
            n = this.distanceToPoint(t.end);
        return e < 0 && n > 0 || n < 0 && e > 0
    }
    intersectsBox(t) {
        return t.intersectsPlane(this)
    }
    intersectsSphere(t) {
        return t.intersectsPlane(this)
    }
    coplanarPoint(t) {
        return t.copy(this.normal).multiplyScalar(-this.constant)
    }
    applyMatrix4(t, e) {
        const n = e || w0.getNormalMatrix(t),
            i = this.coplanarPoint(Wl).applyMatrix4(t),
            s = this.normal.applyMatrix3(n).normalize();
        return this.constant = -i.dot(s), this
    }
    translate(t) {
        return this.constant -= t.dot(this.normal), this
    }
    equals(t) {
        return t.normal.equals(this.normal) && t.constant === this.constant
    }
    clone() {
        return (new this.constructor).copy(this)
    }
}
const cs = new Hn,
    Yo = new U;
class dh {
    constructor(t = new ji, e = new ji, n = new ji, i = new ji, s = new ji, r = new ji) {
        this.planes = [t, e, n, i, s, r]
    }
    set(t, e, n, i, s, r) {
        const o = this.planes;
        return o[0].copy(t), o[1].copy(e), o[2].copy(n), o[3].copy(i), o[4].copy(s), o[5].copy(r), this
    }
    copy(t) {
        const e = this.planes;
        for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
        return this
    }
    setFromProjectionMatrix(t, e = Ti) {
        const n = this.planes,
            i = t.elements,
            s = i[0],
            r = i[1],
            o = i[2],
            a = i[3],
            l = i[4],
            c = i[5],
            h = i[6],
            u = i[7],
            d = i[8],
            p = i[9],
            f = i[10],
            m = i[11],
            g = i[12],
            v = i[13],
            y = i[14],
            x = i[15];
        if (n[0].setComponents(a - s, u - l, m - d, x - g).normalize(), n[1].setComponents(a + s, u + l, m + d, x + g).normalize(), n[2].setComponents(a + r, u + c, m + p, x + v).normalize(), n[3].setComponents(a - r, u - c, m - p, x - v).normalize(), n[4].setComponents(a - o, u - h, m - f, x - y).normalize(), e === Ti) n[5].setComponents(a + o, u + h, m + f, x + y).normalize();
        else {
            if (e !== Ia) throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + e);
            n[5].setComponents(o, h, f, y).normalize()
        }
        return this
    }
    intersectsObject(t) {
        if (void 0 !== t.boundingSphere) null === t.boundingSphere && t.computeBoundingSphere(), cs.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);
        else {
            const e = t.geometry;
            null === e.boundingSphere && e.computeBoundingSphere(), cs.copy(e.boundingSphere).applyMatrix4(t.matrixWorld)
        }
        return this.intersectsSphere(cs)
    }
    intersectsSprite(t) {
        return cs.center.set(0, 0, 0), cs.radius = .7071067811865476, cs.applyMatrix4(t.matrixWorld), this.intersectsSphere(cs)
    }
    intersectsSphere(t) {
        const e = this.planes,
            n = t.center,
            i = -t.radius;
        for (let t = 0; t < 6; t++)
            if (e[t].distanceToPoint(n) < i) return !1;
        return !0
    }
    intersectsBox(t) {
        const e = this.planes;
        for (let n = 0; n < 6; n++) {
            const i = e[n];
            if (Yo.x = i.normal.x > 0 ? t.max.x : t.min.x, Yo.y = i.normal.y > 0 ? t.max.y : t.min.y, Yo.z = i.normal.z > 0 ? t.max.z : t.min.z, i.distanceToPoint(Yo) < 0) return !1
        }
        return !0
    }
    containsPoint(t) {
        const e = this.planes;
        for (let n = 0; n < 6; n++)
            if (e[n].distanceToPoint(t) < 0) return !1;
        return !0
    }
    clone() {
        return (new this.constructor).copy(this)
    }
}

function Ap() {
    let t = null,
        e = !1,
        n = null,
        i = null;

    function s(e, r) {
        n(e, r), i = t.requestAnimationFrame(s)
    }
    return {
        start: function() {
            !0 !== e && null !== n && (i = t.requestAnimationFrame(s), e = !0)
        },
        stop: function() {
            t.cancelAnimationFrame(i), e = !1
        },
        setAnimationLoop: function(t) {
            n = t
        },
        setContext: function(e) {
            t = e
        }
    }
}

function M0(t) {
    const e = new WeakMap;
    return {
        get: function(t) {
            return t.isInterleavedBufferAttribute && (t = t.data), e.get(t)
        },
        remove: function(n) {
            n.isInterleavedBufferAttribute && (n = n.data);
            const i = e.get(n);
            i && (t.deleteBuffer(i.buffer), e.delete(n))
        },
        update: function(n, i) {
            if (n.isGLBufferAttribute) {
                const t = e.get(n);
                return void((!t || t.version < n.version) && e.set(n, {
                    buffer: n.buffer,
                    type: n.type,
                    bytesPerElement: n.elementSize,
                    version: n.version
                }))
            }
            n.isInterleavedBufferAttribute && (n = n.data);
            const s = e.get(n);
            if (void 0 === s) e.set(n, function(e, n) {
                const i = e.array,
                    s = e.usage,
                    r = i.byteLength,
                    o = t.createBuffer();
                let a;
                if (t.bindBuffer(n, o), t.bufferData(n, i, s), e.onUploadCallback(), i instanceof Float32Array) a = t.FLOAT;
                else if (i instanceof Uint16Array) a = e.isFloat16BufferAttribute ? t.HALF_FLOAT : t.UNSIGNED_SHORT;
                else if (i instanceof Int16Array) a = t.SHORT;
                else if (i instanceof Uint32Array) a = t.UNSIGNED_INT;
                else if (i instanceof Int32Array) a = t.INT;
                else if (i instanceof Int8Array) a = t.BYTE;
                else if (i instanceof Uint8Array) a = t.UNSIGNED_BYTE;
                else {
                    if (!(i instanceof Uint8ClampedArray)) throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + i);
                    a = t.UNSIGNED_BYTE
                }
                return {
                    buffer: o,
                    type: a,
                    bytesPerElement: i.BYTES_PER_ELEMENT,
                    version: e.version,
                    size: r
                }
            }(n, i));
            else if (s.version < n.version) {
                if (s.size !== n.array.byteLength) throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
                (function(e, n, i) {
                    const s = n.array,
                        r = n._updateRange,
                        o = n.updateRanges;
                    if (t.bindBuffer(i, e), -1 === r.count && 0 === o.length && t.bufferSubData(i, 0, s), 0 !== o.length) {
                        for (let e = 0, n = o.length; e < n; e++) {
                            const n = o[e];
                            t.bufferSubData(i, n.start * s.BYTES_PER_ELEMENT, s, n.start, n.count)
                        }
                        n.clearUpdateRanges()
                    } - 1 !== r.count && (t.bufferSubData(i, r.offset * s.BYTES_PER_ELEMENT, s, r.offset, r.count), r.count = -1), n.onUploadCallback()
                })(s.buffer, n, i), s.version = n.version
            }
        }
    }
}
class Ot extends ht {
    constructor(t = 1, e = 1, n = 1, i = 1) {
        super(), this.type = "PlaneGeometry", this.parameters = {
            width: t,
            height: e,
            widthSegments: n,
            heightSegments: i
        };
        const s = t / 2,
            r = e / 2,
            o = Math.floor(n),
            a = Math.floor(i),
            l = o + 1,
            c = a + 1,
            h = t / o,
            u = e / a,
            d = [],
            p = [],
            f = [],
            m = [];
        for (let t = 0; t < c; t++) {
            const e = t * u - r;
            for (let n = 0; n < l; n++) {
                const i = n * h - s;
                p.push(i, -e, 0), f.push(0, 0, 1), m.push(n / o), m.push(1 - t / a)
            }
        }
        for (let t = 0; t < a; t++)
            for (let e = 0; e < o; e++) {
                const n = e + l * t,
                    i = e + l * (t + 1),
                    s = e + 1 + l * (t + 1),
                    r = e + 1 + l * t;
                d.push(n, i, r), d.push(i, s, r)
            }
        this.setIndex(d), this.setAttribute("position", new Fe(p, 3)), this.setAttribute("normal", new Fe(f, 3)), this.setAttribute("uv", new Fe(m, 2))
    }
    copy(t) {
        return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
    }
    static fromJSON(t) {
        return new Ot(t.width, t.height, t.widthSegments, t.heightSegments)
    }
}
var E0 = "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",
    T0 = "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif",
    C0 = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",
    P0 = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
    R0 = "#ifdef USE_ALPHATEST\n\t#ifdef ALPHA_TO_COVERAGE\n\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\tif ( diffuseColor.a < alphaTest ) discard;\n\t#endif\n#endif",
    D0 = "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
    I0 = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
    L0 = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
    O0 = "#ifdef USE_BATCHING\n\tattribute float batchId;\n\tuniform highp sampler2D batchingTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",
    B0 = "#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( batchId );\n#endif",
    U0 = "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif",
    N0 = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
    F0 = "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",
    k0 = "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",
    z0 = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
    G0 = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#ifdef ALPHA_TO_COVERAGE\n\t\tfloat distanceToPlane, distanceGradient;\n\t\tfloat clipOpacity = 1.0;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\tif ( clipOpacity == 0.0 ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tfloat unionClipOpacity = 1.0;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\t\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tclipOpacity *= 1.0 - unionClipOpacity;\n\t\t#endif\n\t\tdiffuseColor.a *= clipOpacity;\n\t\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tbool clipped = true;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tif ( clipped ) discard;\n\t\t#endif\n\t#endif\n#endif",
    H0 = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
    V0 = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
    W0 = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
    X0 = "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
    j0 = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
    K0 = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
    Y0 = "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
    Q0 = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",
    q0 = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
    Z0 = "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
    J0 = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
    $0 = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",
    ey = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
    ty = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
    ny = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
    iy = "\nconst mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(\n\tvec3( 0.8224621, 0.177538, 0.0 ),\n\tvec3( 0.0331941, 0.9668058, 0.0 ),\n\tvec3( 0.0170827, 0.0723974, 0.9105199 )\n);\nconst mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.2249401, - 0.2249404, 0.0 ),\n\tvec3( - 0.0420569, 1.0420571, 0.0 ),\n\tvec3( - 0.0196376, - 0.0786361, 1.0982735 )\n);\nvec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );\n}\nvec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );\n}\nvec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn sRGBTransferOETF( value );\n}",
    sy = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
    ry = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform mat3 envMapRotation;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
    oy = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
    ay = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
    ly = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
    cy = "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
    hy = "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
    uy = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
    dy = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
    fy = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",
    py = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
    my = "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
    gy = "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",
    vy = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( LEGACY_LIGHTS )\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#else\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
    yy = "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",
    xy = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
    by = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",
    Ay = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
    Sy = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",
    _y = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n\tmaterial.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif",
    wy = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\tfloat dispersion;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
    My = "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
    Ey = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
    Ty = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif",
    Cy = "#if defined( USE_LOGDEPTHBUF )\n\tgl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
    Py = "#if defined( USE_LOGDEPTHBUF )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
    Ry = "#ifdef USE_LOGDEPTHBUF\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
    Dy = "#ifdef USE_LOGDEPTHBUF\n\tvFragDepth = 1.0 + gl_Position.w;\n\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif",
    Iy = "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
    Ly = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
    Oy = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
    By = "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
    Uy = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
    Ny = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
    Fy = "#ifdef USE_INSTANCING_MORPH\n\tfloat morphTargetInfluences[MORPHTARGETS_COUNT];\n\tfloat morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tmorphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n\t}\n#endif",
    ky = "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
    zy = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
    Gy = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_INSTANCING_MORPH\n\t\tuniform float morphTargetBaseInfluence;\n\t#endif\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\t#ifndef USE_INSTANCING_MORPH\n\t\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\t#endif\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
    Hy = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
    Vy = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;",
    Wy = "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
    Xy = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
    jy = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
    Ky = "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
    Yy = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",
    Qy = "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif",
    qy = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",
    Zy = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",
    Jy = "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
    $y = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
    ex = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",
    tx = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
    nx = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
    ix = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
    sx = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
    rx = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
    ox = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
    ax = "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tfloat shadow = 1.0;\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\t\n\t\tfloat lightToPositionLength = length( lightToPosition );\n\t\tif ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n\t\t\tfloat dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\t\tdp += shadowBias;\n\t\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\t\tshadow = (\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t\t) * ( 1.0 / 9.0 );\n\t\t\t#else\n\t\t\t\tshadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n#endif",
    lx = "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
    cx = "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",
    hx = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
    ux = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
    dx = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",
    fx = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
    px = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
    mx = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
    gx = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
    vx = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
    yx = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor *= toneMappingExposure;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\tcolor = clamp( color, 0.0, 1.0 );\n\treturn color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n\tconst float StartCompression = 0.8 - 0.04;\n\tconst float Desaturation = 0.15;\n\tcolor *= toneMappingExposure;\n\tfloat x = min( color.r, min( color.g, color.b ) );\n\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n\tcolor -= offset;\n\tfloat peak = max( color.r, max( color.g, color.b ) );\n\tif ( peak < StartCompression ) return color;\n\tfloat d = 1. - StartCompression;\n\tfloat newPeak = 1. - d * d / ( peak + d - StartCompression );\n\tcolor *= newPeak / peak;\n\tfloat g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n\treturn mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
    xx = "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",
    bx = "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec4 transmittedLight;\n\t\tvec3 transmittance;\n\t\t#ifdef USE_DISPERSION\n\t\t\tfloat halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n\t\t\tvec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n\t\t\tfor ( int i = 0; i < 3; i ++ ) {\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\t\trefractionCoords += 1.0;\n\t\t\t\trefractionCoords /= 2.0;\n\t\t\n\t\t\t\tvec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n\t\t\t\ttransmittedLight[ i ] = transmissionSample[ i ];\n\t\t\t\ttransmittedLight.a += transmissionSample.a;\n\t\t\t\ttransmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n\t\t\t}\n\t\t\ttransmittedLight.a /= 3.0;\n\t\t\n\t\t#else\n\t\t\n\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\trefractionCoords += 1.0;\n\t\t\trefractionCoords /= 2.0;\n\t\t\ttransmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\t\ttransmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\t\n\t\t#endif\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",
    Ax = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
    Sx = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
    _x = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",
    wx = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";
const Mx = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
    Ex = "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
    Tx = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
    Cx = "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
    Px = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
    Rx = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
    Dx = "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
    Ix = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
    Lx = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
    Ox = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
    Bx = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
    Ux = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
    Nx = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
    Fx = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
    kx = "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
    zx = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    Gx = "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
    Hx = "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    Vx = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
    Wx = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    Xx = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
    jx = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
    Kx = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
    Yx = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    Qx = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
    qx = "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n\tuniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    Zx = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
    Jx = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    $x = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
    eb = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
    tb = "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
    nb = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
    ib = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
    sb = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
    Ze = {
        alphahash_fragment: E0,
        alphahash_pars_fragment: T0,
        alphamap_fragment: C0,
        alphamap_pars_fragment: P0,
        alphatest_fragment: R0,
        alphatest_pars_fragment: D0,
        aomap_fragment: I0,
        aomap_pars_fragment: L0,
        batching_pars_vertex: O0,
        batching_vertex: B0,
        begin_vertex: U0,
        beginnormal_vertex: N0,
        bsdfs: F0,
        iridescence_fragment: k0,
        bumpmap_pars_fragment: z0,
        clipping_planes_fragment: G0,
        clipping_planes_pars_fragment: H0,
        clipping_planes_pars_vertex: V0,
        clipping_planes_vertex: W0,
        color_fragment: X0,
        color_pars_fragment: j0,
        color_pars_vertex: K0,
        color_vertex: Y0,
        common: Q0,
        cube_uv_reflection_fragment: q0,
        defaultnormal_vertex: Z0,
        displacementmap_pars_vertex: J0,
        displacementmap_vertex: $0,
        emissivemap_fragment: ey,
        emissivemap_pars_fragment: ty,
        colorspace_fragment: ny,
        colorspace_pars_fragment: iy,
        envmap_fragment: sy,
        envmap_common_pars_fragment: ry,
        envmap_pars_fragment: oy,
        envmap_pars_vertex: ay,
        envmap_physical_pars_fragment: yy,
        envmap_vertex: ly,
        fog_vertex: cy,
        fog_pars_vertex: hy,
        fog_fragment: uy,
        fog_pars_fragment: dy,
        gradientmap_pars_fragment: fy,
        lightmap_pars_fragment: py,
        lights_lambert_fragment: my,
        lights_lambert_pars_fragment: gy,
        lights_pars_begin: vy,
        lights_toon_fragment: xy,
        lights_toon_pars_fragment: by,
        lights_phong_fragment: Ay,
        lights_phong_pars_fragment: Sy,
        lights_physical_fragment: _y,
        lights_physical_pars_fragment: wy,
        lights_fragment_begin: My,
        lights_fragment_maps: Ey,
        lights_fragment_end: Ty,
        logdepthbuf_fragment: Cy,
        logdepthbuf_pars_fragment: Py,
        logdepthbuf_pars_vertex: Ry,
        logdepthbuf_vertex: Dy,
        map_fragment: Iy,
        map_pars_fragment: Ly,
        map_particle_fragment: Oy,
        map_particle_pars_fragment: By,
        metalnessmap_fragment: Uy,
        metalnessmap_pars_fragment: Ny,
        morphinstance_vertex: Fy,
        morphcolor_vertex: ky,
        morphnormal_vertex: zy,
        morphtarget_pars_vertex: Gy,
        morphtarget_vertex: Hy,
        normal_fragment_begin: Vy,
        normal_fragment_maps: Wy,
        normal_pars_fragment: Xy,
        normal_pars_vertex: jy,
        normal_vertex: Ky,
        normalmap_pars_fragment: Yy,
        clearcoat_normal_fragment_begin: Qy,
        clearcoat_normal_fragment_maps: qy,
        clearcoat_pars_fragment: Zy,
        iridescence_pars_fragment: Jy,
        opaque_fragment: $y,
        packing: ex,
        premultiplied_alpha_fragment: tx,
        project_vertex: nx,
        dithering_fragment: ix,
        dithering_pars_fragment: sx,
        roughnessmap_fragment: rx,
        roughnessmap_pars_fragment: ox,
        shadowmap_pars_fragment: ax,
        shadowmap_pars_vertex: lx,
        shadowmap_vertex: cx,
        shadowmask_pars_fragment: hx,
        skinbase_vertex: ux,
        skinning_pars_vertex: dx,
        skinning_vertex: fx,
        skinnormal_vertex: px,
        specularmap_fragment: mx,
        specularmap_pars_fragment: gx,
        tonemapping_fragment: vx,
        tonemapping_pars_fragment: yx,
        transmission_fragment: xx,
        transmission_pars_fragment: bx,
        uv_pars_fragment: Ax,
        uv_pars_vertex: Sx,
        uv_vertex: _x,
        worldpos_vertex: wx,
        background_vert: Mx,
        background_frag: Ex,
        backgroundCube_vert: Tx,
        backgroundCube_frag: Cx,
        cube_vert: Px,
        cube_frag: Rx,
        depth_vert: Dx,
        depth_frag: Ix,
        distanceRGBA_vert: Lx,
        distanceRGBA_frag: Ox,
        equirect_vert: Bx,
        equirect_frag: Ux,
        linedashed_vert: Nx,
        linedashed_frag: Fx,
        meshbasic_vert: kx,
        meshbasic_frag: zx,
        meshlambert_vert: Gx,
        meshlambert_frag: Hx,
        meshmatcap_vert: Vx,
        meshmatcap_frag: Wx,
        meshnormal_vert: Xx,
        meshnormal_frag: jx,
        meshphong_vert: Kx,
        meshphong_frag: Yx,
        meshphysical_vert: Qx,
        meshphysical_frag: qx,
        meshtoon_vert: Zx,
        meshtoon_frag: Jx,
        points_vert: $x,
        points_frag: eb,
        shadow_vert: tb,
        shadow_frag: nb,
        sprite_vert: ib,
        sprite_frag: sb
    },
    Te = {
        common: {
            diffuse: {
                value: new Le(16777215)
            },
            opacity: {
                value: 1
            },
            map: {
                value: null
            },
            mapTransform: {
                value: new We
            },
            alphaMap: {
                value: null
            },
            alphaMapTransform: {
                value: new We
            },
            alphaTest: {
                value: 0
            }
        },
        specularmap: {
            specularMap: {
                value: null
            },
            specularMapTransform: {
                value: new We
            }
        },
        envmap: {
            envMap: {
                value: null
            },
            envMapRotation: {
                value: new We
            },
            flipEnvMap: {
                value: -1
            },
            reflectivity: {
                value: 1
            },
            ior: {
                value: 1.5
            },
            refractionRatio: {
                value: .98
            }
        },
        aomap: {
            aoMap: {
                value: null
            },
            aoMapIntensity: {
                value: 1
            },
            aoMapTransform: {
                value: new We
            }
        },
        lightmap: {
            lightMap: {
                value: null
            },
            lightMapIntensity: {
                value: 1
            },
            lightMapTransform: {
                value: new We
            }
        },
        bumpmap: {
            bumpMap: {
                value: null
            },
            bumpMapTransform: {
                value: new We
            },
            bumpScale: {
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                value: null
            },
            normalMapTransform: {
                value: new We
            },
            normalScale: {
                value: new Q(1, 1)
            }
        },
        displacementmap: {
            displacementMap: {
                value: null
            },
            displacementMapTransform: {
                value: new We
            },
            displacementScale: {
                value: 1
            },
            displacementBias: {
                value: 0
            }
        },
        emissivemap: {
            emissiveMap: {
                value: null
            },
            emissiveMapTransform: {
                value: new We
            }
        },
        metalnessmap: {
            metalnessMap: {
                value: null
            },
            metalnessMapTransform: {
                value: new We
            }
        },
        roughnessmap: {
            roughnessMap: {
                value: null
            },
            roughnessMapTransform: {
                value: new We
            }
        },
        gradientmap: {
            gradientMap: {
                value: null
            }
        },
        fog: {
            fogDensity: {
                value: 25e-5
            },
            fogNear: {
                value: 1
            },
            fogFar: {
                value: 2e3
            },
            fogColor: {
                value: new Le(16777215)
            }
        },
        lights: {
            ambientLightColor: {
                value: []
            },
            lightProbe: {
                value: []
            },
            directionalLights: {
                value: [],
                properties: {
                    direction: {},
                    color: {}
                }
            },
            directionalLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            directionalShadowMap: {
                value: []
            },
            directionalShadowMatrix: {
                value: []
            },
            spotLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {}
                }
            },
            spotLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            spotLightMap: {
                value: []
            },
            spotShadowMap: {
                value: []
            },
            spotLightMatrix: {
                value: []
            },
            pointLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {}
                }
            },
            pointLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {}
                }
            },
            pointShadowMap: {
                value: []
            },
            pointShadowMatrix: {
                value: []
            },
            hemisphereLights: {
                value: [],
                properties: {
                    direction: {},
                    skyColor: {},
                    groundColor: {}
                }
            },
            rectAreaLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    width: {},
                    height: {}
                }
            },
            ltc_1: {
                value: null
            },
            ltc_2: {
                value: null
            }
        },
        points: {
            diffuse: {
                value: new Le(16777215)
            },
            opacity: {
                value: 1
            },
            size: {
                value: 1
            },
            scale: {
                value: 1
            },
            map: {
                value: null
            },
            alphaMap: {
                value: null
            },
            alphaMapTransform: {
                value: new We
            },
            alphaTest: {
                value: 0
            },
            uvTransform: {
                value: new We
            }
        },
        sprite: {
            diffuse: {
                value: new Le(16777215)
            },
            opacity: {
                value: 1
            },
            center: {
                value: new Q(.5, .5)
            },
            rotation: {
                value: 0
            },
            map: {
                value: null
            },
            mapTransform: {
                value: new We
            },
            alphaMap: {
                value: null
            },
            alphaMapTransform: {
                value: new We
            },
            alphaTest: {
                value: 0
            }
        }
    },
    ni = {
        basic: {
            uniforms: dn([Te.common, Te.specularmap, Te.envmap, Te.aomap, Te.lightmap, Te.fog]),
            vertexShader: Ze.meshbasic_vert,
            fragmentShader: Ze.meshbasic_frag
        },
        lambert: {
            uniforms: dn([Te.common, Te.specularmap, Te.envmap, Te.aomap, Te.lightmap, Te.emissivemap, Te.bumpmap, Te.normalmap, Te.displacementmap, Te.fog, Te.lights, {
                emissive: {
                    value: new Le(0)
                }
            }]),
            vertexShader: Ze.meshlambert_vert,
            fragmentShader: Ze.meshlambert_frag
        },
        phong: {
            uniforms: dn([Te.common, Te.specularmap, Te.envmap, Te.aomap, Te.lightmap, Te.emissivemap, Te.bumpmap, Te.normalmap, Te.displacementmap, Te.fog, Te.lights, {
                emissive: {
                    value: new Le(0)
                },
                specular: {
                    value: new Le(1118481)
                },
                shininess: {
                    value: 30
                }
            }]),
            vertexShader: Ze.meshphong_vert,
            fragmentShader: Ze.meshphong_frag
        },
        standard: {
            uniforms: dn([Te.common, Te.envmap, Te.aomap, Te.lightmap, Te.emissivemap, Te.bumpmap, Te.normalmap, Te.displacementmap, Te.roughnessmap, Te.metalnessmap, Te.fog, Te.lights, {
                emissive: {
                    value: new Le(0)
                },
                roughness: {
                    value: 1
                },
                metalness: {
                    value: 0
                },
                envMapIntensity: {
                    value: 1
                }
            }]),
            vertexShader: Ze.meshphysical_vert,
            fragmentShader: Ze.meshphysical_frag
        },
        toon: {
            uniforms: dn([Te.common, Te.aomap, Te.lightmap, Te.emissivemap, Te.bumpmap, Te.normalmap, Te.displacementmap, Te.gradientmap, Te.fog, Te.lights, {
                emissive: {
                    value: new Le(0)
                }
            }]),
            vertexShader: Ze.meshtoon_vert,
            fragmentShader: Ze.meshtoon_frag
        },
        matcap: {
            uniforms: dn([Te.common, Te.bumpmap, Te.normalmap, Te.displacementmap, Te.fog, {
                matcap: {
                    value: null
                }
            }]),
            vertexShader: Ze.meshmatcap_vert,
            fragmentShader: Ze.meshmatcap_frag
        },
        points: {
            uniforms: dn([Te.points, Te.fog]),
            vertexShader: Ze.points_vert,
            fragmentShader: Ze.points_frag
        },
        dashed: {
            uniforms: dn([Te.common, Te.fog, {
                scale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                totalSize: {
                    value: 2
                }
            }]),
            vertexShader: Ze.linedashed_vert,
            fragmentShader: Ze.linedashed_frag
        },
        depth: {
            uniforms: dn([Te.common, Te.displacementmap]),
            vertexShader: Ze.depth_vert,
            fragmentShader: Ze.depth_frag
        },
        normal: {
            uniforms: dn([Te.common, Te.bumpmap, Te.normalmap, Te.displacementmap, {
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: Ze.meshnormal_vert,
            fragmentShader: Ze.meshnormal_frag
        },
        sprite: {
            uniforms: dn([Te.sprite, Te.fog]),
            vertexShader: Ze.sprite_vert,
            fragmentShader: Ze.sprite_frag
        },
        background: {
            uniforms: {
                uvTransform: {
                    value: new We
                },
                t2D: {
                    value: null
                },
                backgroundIntensity: {
                    value: 1
                }
            },
            vertexShader: Ze.background_vert,
            fragmentShader: Ze.background_frag
        },
        backgroundCube: {
            uniforms: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                },
                backgroundBlurriness: {
                    value: 0
                },
                backgroundIntensity: {
                    value: 1
                },
                backgroundRotation: {
                    value: new We
                }
            },
            vertexShader: Ze.backgroundCube_vert,
            fragmentShader: Ze.backgroundCube_frag
        },
        cube: {
            uniforms: {
                tCube: {
                    value: null
                },
                tFlip: {
                    value: -1
                },
                opacity: {
                    value: 1
                }
            },
            vertexShader: Ze.cube_vert,
            fragmentShader: Ze.cube_frag
        },
        equirect: {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: Ze.equirect_vert,
            fragmentShader: Ze.equirect_frag
        },
        distanceRGBA: {
            uniforms: dn([Te.common, Te.displacementmap, {
                referencePosition: {
                    value: new U
                },
                nearDistance: {
                    value: 1
                },
                farDistance: {
                    value: 1e3
                }
            }]),
            vertexShader: Ze.distanceRGBA_vert,
            fragmentShader: Ze.distanceRGBA_frag
        },
        shadow: {
            uniforms: dn([Te.lights, Te.fog, {
                color: {
                    value: new Le(0)
                },
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: Ze.shadow_vert,
            fragmentShader: Ze.shadow_frag
        }
    };
ni.physical = {
    uniforms: dn([ni.standard.uniforms, {
        clearcoat: {
            value: 0
        },
        clearcoatMap: {
            value: null
        },
        clearcoatMapTransform: {
            value: new We
        },
        clearcoatNormalMap: {
            value: null
        },
        clearcoatNormalMapTransform: {
            value: new We
        },
        clearcoatNormalScale: {
            value: new Q(1, 1)
        },
        clearcoatRoughness: {
            value: 0
        },
        clearcoatRoughnessMap: {
            value: null
        },
        clearcoatRoughnessMapTransform: {
            value: new We
        },
        dispersion: {
            value: 0
        },
        iridescence: {
            value: 0
        },
        iridescenceMap: {
            value: null
        },
        iridescenceMapTransform: {
            value: new We
        },
        iridescenceIOR: {
            value: 1.3
        },
        iridescenceThicknessMinimum: {
            value: 100
        },
        iridescenceThicknessMaximum: {
            value: 400
        },
        iridescenceThicknessMap: {
            value: null
        },
        iridescenceThicknessMapTransform: {
            value: new We
        },
        sheen: {
            value: 0
        },
        sheenColor: {
            value: new Le(0)
        },
        sheenColorMap: {
            value: null
        },
        sheenColorMapTransform: {
            value: new We
        },
        sheenRoughness: {
            value: 1
        },
        sheenRoughnessMap: {
            value: null
        },
        sheenRoughnessMapTransform: {
            value: new We
        },
        transmission: {
            value: 0
        },
        transmissionMap: {
            value: null
        },
        transmissionMapTransform: {
            value: new We
        },
        transmissionSamplerSize: {
            value: new Q
        },
        transmissionSamplerMap: {
            value: null
        },
        thickness: {
            value: 0
        },
        thicknessMap: {
            value: null
        },
        thicknessMapTransform: {
            value: new We
        },
        attenuationDistance: {
            value: 0
        },
        attenuationColor: {
            value: new Le(0)
        },
        specularColor: {
            value: new Le(1, 1, 1)
        },
        specularColorMap: {
            value: null
        },
        specularColorMapTransform: {
            value: new We
        },
        specularIntensity: {
            value: 1
        },
        specularIntensityMap: {
            value: null
        },
        specularIntensityMapTransform: {
            value: new We
        },
        anisotropyVector: {
            value: new Q
        },
        anisotropyMap: {
            value: null
        },
        anisotropyMapTransform: {
            value: new We
        }
    }]),
    vertexShader: Ze.meshphysical_vert,
    fragmentShader: Ze.meshphysical_frag
};
const Qo = {
        r: 0,
        b: 0,
        g: 0
    },
    hs = new Gn,
    rb = new Xe;

function ob(t, e, n, i, s, r, o) {
    const a = new Le(0);
    let l, c, h = !0 === r ? 0 : 1,
        u = null,
        d = 0,
        p = null;

    function f(t) {
        let i = !0 === t.isScene ? t.background : null;
        return i && i.isTexture && (i = (t.backgroundBlurriness > 0 ? n : e).get(i)), i
    }

    function m(e, n) {
        e.getRGB(Qo, xp(t)), i.buffers.color.setClear(Qo.r, Qo.g, Qo.b, n, o)
    }
    return {
        getClearColor: function() {
            return a
        },
        setClearColor: function(t, e = 1) {
            a.set(t), h = e, m(a, h)
        },
        getClearAlpha: function() {
            return h
        },
        setClearAlpha: function(t) {
            h = t, m(a, h)
        },
        render: function(e) {
            let n = !1;
            const s = f(e);
            null === s ? m(a, h) : s && s.isColor && (m(s, 1), n = !0);
            const r = t.xr.getEnvironmentBlendMode();
            "additive" === r ? i.buffers.color.setClear(0, 0, 0, 1, o) : "alpha-blend" === r && i.buffers.color.setClear(0, 0, 0, 0, o), (t.autoClear || n) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil)
        },
        addToRenderList: function(e, n) {
            const i = f(n);
            i && (i.isCubeTexture || i.mapping === Ga) ? (void 0 === c && (c = new be(new Sn(1, 1, 1), new It({
                name: "BackgroundCubeMaterial",
                uniforms: Mr(ni.backgroundCube.uniforms),
                vertexShader: ni.backgroundCube.vertexShader,
                fragmentShader: ni.backgroundCube.fragmentShader,
                side: Bt,
                depthTest: !1,
                depthWrite: !1,
                fog: !1
            })), c.geometry.deleteAttribute("normal"), c.geometry.deleteAttribute("uv"), c.onBeforeRender = function(t, e, n) {
                this.matrixWorld.copyPosition(n.matrixWorld)
            }, Object.defineProperty(c.material, "envMap", {
                get: function() {
                    return this.uniforms.envMap.value
                }
            }), s.update(c)), hs.copy(n.backgroundRotation), hs.x *= -1, hs.y *= -1, hs.z *= -1, i.isCubeTexture && !1 === i.isRenderTargetTexture && (hs.y *= -1, hs.z *= -1), c.material.uniforms.envMap.value = i, c.material.uniforms.flipEnvMap.value = i.isCubeTexture && !1 === i.isRenderTargetTexture ? -1 : 1, c.material.uniforms.backgroundBlurriness.value = n.backgroundBlurriness, c.material.uniforms.backgroundIntensity.value = n.backgroundIntensity, c.material.uniforms.backgroundRotation.value.setFromMatrix4(rb.makeRotationFromEuler(hs)), c.material.toneMapped = vt.getTransfer(i.colorSpace) !== St, (u !== i || d !== i.version || p !== t.toneMapping) && (c.material.needsUpdate = !0, u = i, d = i.version, p = t.toneMapping), c.layers.enableAll(), e.unshift(c, c.geometry, c.material, 0, 0, null)) : i && i.isTexture && (void 0 === l && (l = new be(new Ot(2, 2), new It({
                name: "BackgroundMaterial",
                uniforms: Mr(ni.background.uniforms),
                vertexShader: ni.background.vertexShader,
                fragmentShader: ni.background.fragmentShader,
                side: li,
                depthTest: !1,
                depthWrite: !1,
                fog: !1
            })), l.geometry.deleteAttribute("normal"), Object.defineProperty(l.material, "map", {
                get: function() {
                    return this.uniforms.t2D.value
                }
            }), s.update(l)), l.material.uniforms.t2D.value = i, l.material.uniforms.backgroundIntensity.value = n.backgroundIntensity, l.material.toneMapped = vt.getTransfer(i.colorSpace) !== St, !0 === i.matrixAutoUpdate && i.updateMatrix(), l.material.uniforms.uvTransform.value.copy(i.matrix), (u !== i || d !== i.version || p !== t.toneMapping) && (l.material.needsUpdate = !0, u = i, d = i.version, p = t.toneMapping), l.layers.enableAll(), e.unshift(l, l.geometry, l.material, 0, 0, null))
        }
    }
}

function ab(t, e) {
    const n = t.getParameter(t.MAX_VERTEX_ATTRIBS),
        i = {},
        s = c(null);
    let r = s,
        o = !1;

    function a(e) {
        return t.bindVertexArray(e)
    }

    function l(e) {
        return t.deleteVertexArray(e)
    }

    function c(t) {
        const e = [],
            i = [],
            s = [];
        for (let t = 0; t < n; t++) e[t] = 0, i[t] = 0, s[t] = 0;
        return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: e,
            enabledAttributes: i,
            attributeDivisors: s,
            object: t,
            attributes: {},
            index: null
        }
    }

    function h() {
        const t = r.newAttributes;
        for (let e = 0, n = t.length; e < n; e++) t[e] = 0
    }

    function u(t) {
        d(t, 0)
    }

    function d(e, n) {
        const i = r.newAttributes,
            s = r.enabledAttributes,
            o = r.attributeDivisors;
        i[e] = 1, 0 === s[e] && (t.enableVertexAttribArray(e), s[e] = 1), o[e] !== n && (t.vertexAttribDivisor(e, n), o[e] = n)
    }

    function p() {
        const e = r.newAttributes,
            n = r.enabledAttributes;
        for (let i = 0, s = n.length; i < s; i++) n[i] !== e[i] && (t.disableVertexAttribArray(i), n[i] = 0)
    }

    function f(e, n, i, s, r, o, a) {
        !0 === a ? t.vertexAttribIPointer(e, n, i, r, o) : t.vertexAttribPointer(e, n, i, s, r, o)
    }

    function m() {
        g(), o = !0, r !== s && (r = s, a(r.object))
    }

    function g() {
        s.geometry = null, s.program = null, s.wireframe = !1
    }
    return {
        setup: function(n, s, l, m, g) {
            let v = !1;
            const y = function(e, n, s) {
                const r = !0 === s.wireframe;
                let o = i[e.id];
                void 0 === o && (o = {}, i[e.id] = o);
                let a = o[n.id];
                void 0 === a && (a = {}, o[n.id] = a);
                let l = a[r];
                return void 0 === l && (l = c(t.createVertexArray()), a[r] = l), l
            }(m, l, s);
            r !== y && (r = y, a(r.object)), v = function(t, e, n, i) {
                const s = r.attributes,
                    o = e.attributes;
                let a = 0;
                const l = n.getAttributes();
                for (const e in l)
                    if (l[e].location >= 0) {
                        const n = s[e];
                        let i = o[e];
                        if (void 0 === i && ("instanceMatrix" === e && t.instanceMatrix && (i = t.instanceMatrix), "instanceColor" === e && t.instanceColor && (i = t.instanceColor)), void 0 === n || n.attribute !== i || i && n.data !== i.data) return !0;
                        a++
                    }
                return r.attributesNum !== a || r.index !== i
            }(n, m, l, g), v && function(t, e, n, i) {
                const s = {},
                    o = e.attributes;
                let a = 0;
                const l = n.getAttributes();
                for (const e in l)
                    if (l[e].location >= 0) {
                        let n = o[e];
                        void 0 === n && ("instanceMatrix" === e && t.instanceMatrix && (n = t.instanceMatrix), "instanceColor" === e && t.instanceColor && (n = t.instanceColor));
                        const i = {};
                        i.attribute = n, n && n.data && (i.data = n.data), s[e] = i, a++
                    }
                r.attributes = s, r.attributesNum = a, r.index = i
            }(n, m, l, g), null !== g && e.update(g, t.ELEMENT_ARRAY_BUFFER), (v || o) && (o = !1, function(n, i, s, r) {
                h();
                const o = r.attributes,
                    a = s.getAttributes(),
                    l = i.defaultAttributeValues;
                for (const i in a) {
                    const s = a[i];
                    if (s.location >= 0) {
                        let a = o[i];
                        if (void 0 === a && ("instanceMatrix" === i && n.instanceMatrix && (a = n.instanceMatrix), "instanceColor" === i && n.instanceColor && (a = n.instanceColor)), void 0 !== a) {
                            const i = a.normalized,
                                o = a.itemSize,
                                l = e.get(a);
                            if (void 0 === l) continue;
                            const c = l.buffer,
                                h = l.type,
                                p = l.bytesPerElement,
                                m = h === t.INT || h === t.UNSIGNED_INT || a.gpuType === ip;
                            if (a.isInterleavedBufferAttribute) {
                                const e = a.data,
                                    l = e.stride,
                                    g = a.offset;
                                if (e.isInstancedInterleavedBuffer) {
                                    for (let t = 0; t < s.locationSize; t++) d(s.location + t, e.meshPerAttribute);
                                    !0 !== n.isInstancedMesh && void 0 === r._maxInstanceCount && (r._maxInstanceCount = e.meshPerAttribute * e.count)
                                } else
                                    for (let t = 0; t < s.locationSize; t++) u(s.location + t);
                                t.bindBuffer(t.ARRAY_BUFFER, c);
                                for (let t = 0; t < s.locationSize; t++) f(s.location + t, o / s.locationSize, h, i, l * p, (g + o / s.locationSize * t) * p, m)
                            } else {
                                if (a.isInstancedBufferAttribute) {
                                    for (let t = 0; t < s.locationSize; t++) d(s.location + t, a.meshPerAttribute);
                                    !0 !== n.isInstancedMesh && void 0 === r._maxInstanceCount && (r._maxInstanceCount = a.meshPerAttribute * a.count)
                                } else
                                    for (let t = 0; t < s.locationSize; t++) u(s.location + t);
                                t.bindBuffer(t.ARRAY_BUFFER, c);
                                for (let t = 0; t < s.locationSize; t++) f(s.location + t, o / s.locationSize, h, i, o * p, o / s.locationSize * t * p, m)
                            }
                        } else if (void 0 !== l) {
                            const e = l[i];
                            if (void 0 !== e) switch (e.length) {
                                case 2:
                                    t.vertexAttrib2fv(s.location, e);
                                    break;
                                case 3:
                                    t.vertexAttrib3fv(s.location, e);
                                    break;
                                case 4:
                                    t.vertexAttrib4fv(s.location, e);
                                    break;
                                default:
                                    t.vertexAttrib1fv(s.location, e)
                            }
                        }
                    }
                }
                p()
            }(n, s, l, m), null !== g && t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, e.get(g).buffer))
        },
        reset: m,
        resetDefaultState: g,
        dispose: function() {
            m();
            for (const t in i) {
                const e = i[t];
                for (const t in e) {
                    const n = e[t];
                    for (const t in n) l(n[t].object), delete n[t];
                    delete e[t]
                }
                delete i[t]
            }
        },
        releaseStatesOfGeometry: function(t) {
            if (void 0 === i[t.id]) return;
            const e = i[t.id];
            for (const t in e) {
                const n = e[t];
                for (const t in n) l(n[t].object), delete n[t];
                delete e[t]
            }
            delete i[t.id]
        },
        releaseStatesOfProgram: function(t) {
            for (const e in i) {
                const n = i[e];
                if (void 0 === n[t.id]) continue;
                const s = n[t.id];
                for (const t in s) l(s[t].object), delete s[t];
                delete n[t.id]
            }
        },
        initAttributes: h,
        enableAttribute: u,
        disableUnusedAttributes: p
    }
}

function lb(t, e, n) {
    let i;

    function s(e, s, r) {
        0 !== r && (t.drawArraysInstanced(i, e, s, r), n.update(s, i, r))
    }
    this.setMode = function(t) {
        i = t
    }, this.render = function(e, s) {
        t.drawArrays(i, e, s), n.update(s, i, 1)
    }, this.renderInstances = s, this.renderMultiDraw = function(t, s, r) {
        if (0 === r) return;
        const o = e.get("WEBGL_multi_draw");
        if (null === o)
            for (let e = 0; e < r; e++) this.render(t[e], s[e]);
        else {
            o.multiDrawArraysWEBGL(i, t, 0, s, 0, r);
            let e = 0;
            for (let t = 0; t < r; t++) e += s[t];
            n.update(e, i, 1)
        }
    }, this.renderMultiDrawInstances = function(t, r, o, a) {
        if (0 === o) return;
        const l = e.get("WEBGL_multi_draw");
        if (null === l)
            for (let e = 0; e < t.length; e++) s(t[e], r[e], a[e]);
        else {
            l.multiDrawArraysInstancedWEBGL(i, t, 0, r, 0, a, 0, o);
            let e = 0;
            for (let t = 0; t < o; t++) e += r[t];
            for (let t = 0; t < a.length; t++) n.update(e, i, a[t])
        }
    }
}

function cb(t, e, n, i) {
    let s;

    function r(e) {
        if ("highp" === e) {
            if (t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision > 0) return "highp";
            e = "mediump"
        }
        return "mediump" === e && t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
    }
    let o = void 0 !== n.precision ? n.precision : "highp";
    const a = r(o);
    a !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", a, "instead."), o = a);
    const l = !0 === n.logarithmicDepthBuffer,
        c = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
        h = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
    return {
        isWebGL2: !0,
        getMaxAnisotropy: function() {
            if (void 0 !== s) return s;
            if (!0 === e.has("EXT_texture_filter_anisotropic")) {
                const n = e.get("EXT_texture_filter_anisotropic");
                s = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
            } else s = 0;
            return s
        },
        getMaxPrecision: r,
        textureFormatReadable: function(e) {
            return !(e !== Nn && i.convert(e) !== t.getParameter(t.IMPLEMENTATION_COLOR_READ_FORMAT))
        },
        textureTypeReadable: function(n) {
            const s = n === Ha && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
            return !(n !== Qt && i.convert(n) !== t.getParameter(t.IMPLEMENTATION_COLOR_READ_TYPE) && n !== oi && !s)
        },
        precision: o,
        logarithmicDepthBuffer: l,
        maxTextures: c,
        maxVertexTextures: h,
        maxTextureSize: t.getParameter(t.MAX_TEXTURE_SIZE),
        maxCubemapSize: t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
        maxAttributes: t.getParameter(t.MAX_VERTEX_ATTRIBS),
        maxVertexUniforms: t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),
        maxVaryings: t.getParameter(t.MAX_VARYING_VECTORS),
        maxFragmentUniforms: t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),
        vertexTextures: h > 0,
        maxSamples: t.getParameter(t.MAX_SAMPLES)
    }
}

function hb(t) {
    const e = this;
    let n = null,
        i = 0,
        s = !1,
        r = !1;
    const o = new ji,
        a = new We,
        l = {
            value: null,
            needsUpdate: !1
        };

    function c(t, n, i, s) {
        const r = null !== t ? t.length : 0;
        let c = null;
        if (0 !== r) {
            if (c = l.value, !0 !== s || null === c) {
                const e = i + 4 * r,
                    s = n.matrixWorldInverse;
                a.getNormalMatrix(s), (null === c || c.length < e) && (c = new Float32Array(e));
                for (let e = 0, n = i; e !== r; ++e, n += 4) o.copy(t[e]).applyMatrix4(s, a), o.normal.toArray(c, n), c[n + 3] = o.constant
            }
            l.value = c, l.needsUpdate = !0
        }
        return e.numPlanes = r, e.numIntersection = 0, c
    }
    this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(t, e) {
        const n = 0 !== t.length || e || 0 !== i || s;
        return s = e, i = t.length, n
    }, this.beginShadows = function() {
        r = !0, c(null)
    }, this.endShadows = function() {
        r = !1
    }, this.setGlobalState = function(t, e) {
        n = c(t, e, 0)
    }, this.setState = function(o, a, h) {
        const u = o.clippingPlanes,
            d = o.clipIntersection,
            p = o.clipShadows,
            f = t.get(o);
        if (!s || null === u || 0 === u.length || r && !p) r ? c(null) : (l.value !== n && (l.value = n, l.needsUpdate = i > 0), e.numPlanes = i, e.numIntersection = 0);
        else {
            const t = r ? 0 : i,
                e = 4 * t;
            let s = f.clippingState || null;
            l.value = s, s = c(u, a, e, h);
            for (let t = 0; t !== e; ++t) s[t] = n[t];
            f.clippingState = s, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += t
        }
    }
}

function ub(t) {
    let e = new WeakMap;

    function n(t, e) {
        return e === uo ? t.mapping = Ar : e === Rc && (t.mapping = Sr), t
    }

    function i(t) {
        const n = t.target;
        n.removeEventListener("dispose", i);
        const s = e.get(n);
        void 0 !== s && (e.delete(n), s.dispose())
    }
    return {
        get: function(s) {
            if (s && s.isTexture) {
                const r = s.mapping;
                if (r === uo || r === Rc) {
                    if (e.has(s)) {
                        return n(e.get(s).texture, s.mapping)
                    } {
                        const r = s.image;
                        if (r && r.height > 0) {
                            const o = new S0(r.height);
                            return o.fromEquirectangularTexture(t, s), e.set(s, o), s.addEventListener("dispose", i), n(o.texture, s.mapping)
                        }
                        return null
                    }
                }
            }
            return s
        },
        dispose: function() {
            e = new WeakMap
        }
    }
}
class Ci extends uh {
    constructor(t = -1, e = 1, n = 1, i = -1, s = .1, r = 2e3) {
        super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = n, this.bottom = i, this.near = s, this.far = r, this.updateProjectionMatrix()
    }
    copy(t, e) {
        return super.copy(t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
    }
    setViewOffset(t, e, n, i, s, r) {
        null === this.view && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = s, this.view.height = r, this.updateProjectionMatrix()
    }
    clearViewOffset() {
        null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const t = (this.right - this.left) / (2 * this.zoom),
            e = (this.top - this.bottom) / (2 * this.zoom),
            n = (this.right + this.left) / 2,
            i = (this.top + this.bottom) / 2;
        let s = n - t,
            r = n + t,
            o = i + e,
            a = i - e;
        if (null !== this.view && this.view.enabled) {
            const t = (this.right - this.left) / this.view.fullWidth / this.zoom,
                e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            s += t * this.view.offsetX, r = s + t * this.view.width, o -= e * this.view.offsetY, a = o - e * this.view.height
        }
        this.projectionMatrix.makeOrthographic(s, r, o, a, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(t) {
        const e = super.toJSON(t);
        return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
    }
}
const or = 4,
    dd = [.125, .215, .35, .446, .526, .582],
    gs = 20,
    Xl = new Ci,
    fd = new Le;
let jl = null,
    Kl = 0,
    Yl = 0,
    Ql = !1;
const ps = (1 + Math.sqrt(5)) / 2,
    Js = 1 / ps,
    pd = [new U(-ps, Js, 0), new U(ps, Js, 0), new U(-Js, 0, ps), new U(Js, 0, ps), new U(0, ps, -Js), new U(0, ps, Js), new U(-1, 1, -1), new U(1, 1, -1), new U(-1, 1, 1), new U(1, 1, 1)];
class md {
    constructor(t) {
        this._renderer = t, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial)
    }
    fromScene(t, e = 0, n = .1, i = 100) {
        jl = this._renderer.getRenderTarget(), Kl = this._renderer.getActiveCubeFace(), Yl = this._renderer.getActiveMipmapLevel(), Ql = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(256);
        const s = this._allocateTargets();
        return s.depthBuffer = !0, this._sceneToCubeUV(t, n, i, s), e > 0 && this._blur(s, 0, 0, e), this._applyPMREM(s), this._cleanup(s), s
    }
    fromEquirectangular(t, e = null) {
        return this._fromTexture(t, e)
    }
    fromCubemap(t, e = null) {
        return this._fromTexture(t, e)
    }
    compileCubemapShader() {
        null === this._cubemapMaterial && (this._cubemapMaterial = yd(), this._compileMaterial(this._cubemapMaterial))
    }
    compileEquirectangularShader() {
        null === this._equirectMaterial && (this._equirectMaterial = vd(), this._compileMaterial(this._equirectMaterial))
    }
    dispose() {
        this._dispose(), null !== this._cubemapMaterial && this._cubemapMaterial.dispose(), null !== this._equirectMaterial && this._equirectMaterial.dispose()
    }
    _setSize(t) {
        this._lodMax = Math.floor(Math.log2(t)), this._cubeSize = Math.pow(2, this._lodMax)
    }
    _dispose() {
        null !== this._blurMaterial && this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
        for (let t = 0; t < this._lodPlanes.length; t++) this._lodPlanes[t].dispose()
    }
    _cleanup(t) {
        this._renderer.setRenderTarget(jl, Kl, Yl), this._renderer.xr.enabled = Ql, t.scissorTest = !1, qo(t, 0, 0, t.width, t.height)
    }
    _fromTexture(t, e) {
        t.mapping === Ar || t.mapping === Sr ? this._setSize(0 === t.image.length ? 16 : t.image[0].width || t.image[0].image.width) : this._setSize(t.image.width / 4), jl = this._renderer.getRenderTarget(), Kl = this._renderer.getActiveCubeFace(), Yl = this._renderer.getActiveMipmapLevel(), Ql = this._renderer.xr.enabled, this._renderer.xr.enabled = !1;
        const n = e || this._allocateTargets();
        return this._textureToCubeUV(t, n), this._applyPMREM(n), this._cleanup(n), n
    }
    _allocateTargets() {
        const t = 3 * Math.max(this._cubeSize, 112),
            e = 4 * this._cubeSize,
            n = {
                magFilter: Ht,
                minFilter: Ht,
                generateMipmaps: !1,
                type: Ha,
                format: Nn,
                colorSpace: Zn,
                depthBuffer: !1
            },
            i = gd(t, e, n);
        if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== t || this._pingPongRenderTarget.height !== e) {
            null !== this._pingPongRenderTarget && this._dispose(), this._pingPongRenderTarget = gd(t, e, n);
            const {
                _lodMax: i
            } = this;
            ({
                sizeLods: this._sizeLods,
                lodPlanes: this._lodPlanes,
                sigmas: this._sigmas
            } = db(i)), this._blurMaterial = fb(i, t, e)
        }
        return i
    }
    _compileMaterial(t) {
        const e = new be(this._lodPlanes[0], t);
        this._renderer.compile(e, Xl)
    }
    _sceneToCubeUV(t, e, n, i) {
        const s = new Pt(90, 1, e, n),
            r = [1, -1, 1, 1, 1, 1],
            o = [1, 1, 1, -1, -1, -1],
            a = this._renderer,
            l = a.autoClear,
            c = a.toneMapping;
        a.getClearColor(fd), a.toneMapping = qi, a.autoClear = !1;
        const h = new At({
                name: "PMREM.Background",
                side: Bt,
                depthWrite: !1,
                depthTest: !1
            }),
            u = new be(new Sn, h);
        let d = !1;
        const p = t.background;
        p ? p.isColor && (h.color.copy(p), t.background = null, d = !0) : (h.color.copy(fd), d = !0);
        for (let e = 0; e < 6; e++) {
            const n = e % 3;
            0 === n ? (s.up.set(0, r[e], 0), s.lookAt(o[e], 0, 0)) : 1 === n ? (s.up.set(0, 0, r[e]), s.lookAt(0, o[e], 0)) : (s.up.set(0, r[e], 0), s.lookAt(0, 0, o[e]));
            const l = this._cubeSize;
            qo(i, n * l, e > 2 ? l : 0, l, l), a.setRenderTarget(i), d && a.render(u, s), a.render(t, s)
        }
        u.geometry.dispose(), u.material.dispose(), a.toneMapping = c, a.autoClear = l, t.background = p
    }
    _textureToCubeUV(t, e) {
        const n = this._renderer,
            i = t.mapping === Ar || t.mapping === Sr;
        i ? (null === this._cubemapMaterial && (this._cubemapMaterial = yd()), this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === t.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = vd());
        const s = i ? this._cubemapMaterial : this._equirectMaterial,
            r = new be(this._lodPlanes[0], s);
        s.uniforms.envMap.value = t;
        const o = this._cubeSize;
        qo(e, 0, 0, 3 * o, 2 * o), n.setRenderTarget(e), n.render(r, Xl)
    }
    _applyPMREM(t) {
        const e = this._renderer,
            n = e.autoClear;
        e.autoClear = !1;
        const i = this._lodPlanes.length;
        for (let e = 1; e < i; e++) {
            const n = Math.sqrt(this._sigmas[e] * this._sigmas[e] - this._sigmas[e - 1] * this._sigmas[e - 1]),
                s = pd[(i - e - 1) % pd.length];
            this._blur(t, e - 1, e, n, s)
        }
        e.autoClear = n
    }
    _blur(t, e, n, i, s) {
        const r = this._pingPongRenderTarget;
        this._halfBlur(t, r, e, n, i, "latitudinal", s), this._halfBlur(r, t, n, n, i, "longitudinal", s)
    }
    _halfBlur(t, e, n, i, s, r, o) {
        const a = this._renderer,
            l = this._blurMaterial;
        "latitudinal" !== r && "longitudinal" !== r && console.error("blur direction must be either latitudinal or longitudinal!");
        const c = new be(this._lodPlanes[i], l),
            h = l.uniforms,
            u = this._sizeLods[n] - 1,
            d = isFinite(s) ? Math.PI / (2 * u) : 2 * Math.PI / 39,
            p = s / d,
            f = isFinite(s) ? 1 + Math.floor(3 * p) : 20;
        f > 20 && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`);
        const m = [];
        let g = 0;
        for (let t = 0; t < 20; ++t) {
            const e = t / p,
                n = Math.exp(-e * e / 2);
            m.push(n), 0 === t ? g += n : t < f && (g += 2 * n)
        }
        for (let t = 0; t < m.length; t++) m[t] = m[t] / g;
        h.envMap.value = t.texture, h.samples.value = f, h.weights.value = m, h.latitudinal.value = "latitudinal" === r, o && (h.poleAxis.value = o);
        const {
            _lodMax: v
        } = this;
        h.dTheta.value = d, h.mipInt.value = v - n;
        const y = this._sizeLods[i];
        qo(e, 3 * y * (i > v - 4 ? i - v + 4 : 0), 4 * (this._cubeSize - y), 3 * y, 2 * y), a.setRenderTarget(e), a.render(c, Xl)
    }
}

function db(t) {
    const e = [],
        n = [],
        i = [];
    let s = t;
    const r = t - 4 + 1 + dd.length;
    for (let o = 0; o < r; o++) {
        const r = Math.pow(2, s);
        n.push(r);
        let a = 1 / r;
        o > t - 4 ? a = dd[o - t + 4 - 1] : 0 === o && (a = 0), i.push(a);
        const l = 1 / (r - 2),
            c = -l,
            h = 1 + l,
            u = [c, c, h, c, h, h, c, c, h, h, c, h],
            d = 6,
            p = 6,
            f = 3,
            m = 2,
            g = 1,
            v = new Float32Array(f * p * d),
            y = new Float32Array(m * p * d),
            x = new Float32Array(g * p * d);
        for (let t = 0; t < d; t++) {
            const e = t % 3 * 2 / 3 - 1,
                n = t > 2 ? 0 : -1,
                i = [e, n, 0, e + 2 / 3, n, 0, e + 2 / 3, n + 1, 0, e, n, 0, e + 2 / 3, n + 1, 0, e, n + 1, 0];
            v.set(i, f * p * t), y.set(u, m * p * t);
            const s = [t, t, t, t, t, t];
            x.set(s, g * p * t)
        }
        const b = new ht;
        b.setAttribute("position", new Xt(v, f)), b.setAttribute("uv", new Xt(y, m)), b.setAttribute("faceIndex", new Xt(x, g)), e.push(b), s > 4 && s--
    }
    return {
        lodPlanes: e,
        sizeLods: n,
        sigmas: i
    }
}

function gd(t, e, n) {
    const i = new nn(t, e, n);
    return i.texture.mapping = Ga, i.texture.name = "PMREM.cubeUv", i.scissorTest = !0, i
}

function qo(t, e, n, i, s) {
    t.viewport.set(e, n, i, s), t.scissor.set(e, n, i, s)
}

function fb(t, e, n) {
    const i = new Float32Array(20),
        s = new U(0, 1, 0);
    return new It({
        name: "SphericalGaussianBlur",
        defines: {
            n: 20,
            CUBEUV_TEXEL_WIDTH: 1 / e,
            CUBEUV_TEXEL_HEIGHT: 1 / n,
            CUBEUV_MAX_MIP: `${t}.0`
        },
        uniforms: {
            envMap: {
                value: null
            },
            samples: {
                value: 1
            },
            weights: {
                value: i
            },
            latitudinal: {
                value: !1
            },
            dTheta: {
                value: 0
            },
            mipInt: {
                value: 0
            },
            poleAxis: {
                value: s
            }
        },
        vertexShader: fh(),
        fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
        blending: 0,
        depthTest: !1,
        depthWrite: !1
    })
}

function vd() {
    return new It({
        name: "EquirectangularToCubeUV",
        uniforms: {
            envMap: {
                value: null
            }
        },
        vertexShader: fh(),
        fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
        blending: 0,
        depthTest: !1,
        depthWrite: !1
    })
}

function yd() {
    return new It({
        name: "CubemapToCubeUV",
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            }
        },
        vertexShader: fh(),
        fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
        blending: 0,
        depthTest: !1,
        depthWrite: !1
    })
}

function fh() {
    return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"
}

function pb(t) {
    let e = new WeakMap,
        n = null;

    function i(t) {
        const n = t.target;
        n.removeEventListener("dispose", i);
        const s = e.get(n);
        void 0 !== s && (e.delete(n), s.dispose())
    }
    return {
        get: function(s) {
            if (s && s.isTexture) {
                const r = s.mapping,
                    o = r === uo || r === Rc,
                    a = r === Ar || r === Sr;
                if (o || a) {
                    let r = e.get(s);
                    const l = void 0 !== r ? r.texture.pmremVersion : 0;
                    if (s.isRenderTargetTexture && s.pmremVersion !== l) return null === n && (n = new md(t)), r = o ? n.fromEquirectangular(s, r) : n.fromCubemap(s, r), r.texture.pmremVersion = s.pmremVersion, e.set(s, r), r.texture;
                    if (void 0 !== r) return r.texture; {
                        const l = s.image;
                        return o && l && l.height > 0 || a && l && function(t) {
                            let e = 0;
                            const n = 6;
                            for (let i = 0; i < n; i++) void 0 !== t[i] && e++;
                            return e === n
                        }(l) ? (null === n && (n = new md(t)), r = o ? n.fromEquirectangular(s) : n.fromCubemap(s), r.texture.pmremVersion = s.pmremVersion, e.set(s, r), s.addEventListener("dispose", i), r.texture) : null
                    }
                }
            }
            return s
        },
        dispose: function() {
            e = new WeakMap, null !== n && (n.dispose(), n = null)
        }
    }
}

function mb(t) {
    const e = {};

    function n(n) {
        if (void 0 !== e[n]) return e[n];
        let i;
        switch (n) {
            case "WEBGL_depth_texture":
                i = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                break;
            case "EXT_texture_filter_anisotropic":
                i = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                break;
            case "WEBGL_compressed_texture_s3tc":
                i = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                break;
            case "WEBGL_compressed_texture_pvrtc":
                i = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                break;
            default:
                i = t.getExtension(n)
        }
        return e[n] = i, i
    }
    return {
        has: function(t) {
            return null !== n(t)
        },
        init: function() {
            n("EXT_color_buffer_float"), n("WEBGL_clip_cull_distance"), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float"), n("WEBGL_multisampled_render_to_texture"), n("WEBGL_render_shared_exponent")
        },
        get: function(t) {
            const e = n(t);
            return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), e
        }
    }
}

function gb(t, e, n, i) {
    const s = {},
        r = new WeakMap;

    function o(t) {
        const a = t.target;
        null !== a.index && e.remove(a.index);
        for (const t in a.attributes) e.remove(a.attributes[t]);
        for (const t in a.morphAttributes) {
            const n = a.morphAttributes[t];
            for (let t = 0, i = n.length; t < i; t++) e.remove(n[t])
        }
        a.removeEventListener("dispose", o), delete s[a.id];
        const l = r.get(a);
        l && (e.remove(l), r.delete(a)), i.releaseStatesOfGeometry(a), !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount, n.memory.geometries--
    }

    function a(t) {
        const n = [],
            i = t.index,
            s = t.attributes.position;
        let o = 0;
        if (null !== i) {
            const t = i.array;
            o = i.version;
            for (let e = 0, i = t.length; e < i; e += 3) {
                const i = t[e + 0],
                    s = t[e + 1],
                    r = t[e + 2];
                n.push(i, s, s, r, r, i)
            }
        } else {
            if (void 0 === s) return; {
                const t = s.array;
                o = s.version;
                for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
                    const t = e + 0,
                        i = e + 1,
                        s = e + 2;
                    n.push(t, i, i, s, s, t)
                }
            }
        }
        const a = new(dp(n) ? yp : vp)(n, 1);
        a.version = o;
        const l = r.get(t);
        l && e.remove(l), r.set(t, a)
    }
    return {
        get: function(t, e) {
            return !0 === s[e.id] || (e.addEventListener("dispose", o), s[e.id] = !0, n.memory.geometries++), e
        },
        update: function(n) {
            const i = n.attributes;
            for (const n in i) e.update(i[n], t.ARRAY_BUFFER);
            const s = n.morphAttributes;
            for (const n in s) {
                const i = s[n];
                for (let n = 0, s = i.length; n < s; n++) e.update(i[n], t.ARRAY_BUFFER)
            }
        },
        getWireframeAttribute: function(t) {
            const e = r.get(t);
            if (e) {
                const n = t.index;
                null !== n && e.version < n.version && a(t)
            } else a(t);
            return r.get(t)
        }
    }
}

function vb(t, e, n) {
    let i, s, r;

    function o(e, o, a) {
        0 !== a && (t.drawElementsInstanced(i, o, s, e * r, a), n.update(o, i, a))
    }
    this.setMode = function(t) {
        i = t
    }, this.setIndex = function(t) {
        s = t.type, r = t.bytesPerElement
    }, this.render = function(e, o) {
        t.drawElements(i, o, s, e * r), n.update(o, i, 1)
    }, this.renderInstances = o, this.renderMultiDraw = function(t, o, a) {
        if (0 === a) return;
        const l = e.get("WEBGL_multi_draw");
        if (null === l)
            for (let e = 0; e < a; e++) this.render(t[e] / r, o[e]);
        else {
            l.multiDrawElementsWEBGL(i, o, 0, s, t, 0, a);
            let e = 0;
            for (let t = 0; t < a; t++) e += o[t];
            n.update(e, i, 1)
        }
    }, this.renderMultiDrawInstances = function(t, a, l, c) {
        if (0 === l) return;
        const h = e.get("WEBGL_multi_draw");
        if (null === h)
            for (let e = 0; e < t.length; e++) o(t[e] / r, a[e], c[e]);
        else {
            h.multiDrawElementsInstancedWEBGL(i, a, 0, s, t, 0, c, 0, l);
            let e = 0;
            for (let t = 0; t < l; t++) e += a[t];
            for (let t = 0; t < c.length; t++) n.update(e, i, c[t])
        }
    }
}

function yb(t) {
    const e = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
    };
    return {
        memory: {
            geometries: 0,
            textures: 0
        },
        render: e,
        programs: null,
        autoReset: !0,
        reset: function() {
            e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0
        },
        update: function(n, i, s) {
            switch (e.calls++, i) {
                case t.TRIANGLES:
                    e.triangles += s * (n / 3);
                    break;
                case t.LINES:
                    e.lines += s * (n / 2);
                    break;
                case t.LINE_STRIP:
                    e.lines += s * (n - 1);
                    break;
                case t.LINE_LOOP:
                    e.lines += s * n;
                    break;
                case t.POINTS:
                    e.points += s * n;
                    break;
                default:
                    console.error("THREE.WebGLInfo: Unknown draw mode:", i)
            }
        }
    }
}

function xb(t, e, n) {
    const i = new WeakMap,
        s = new ot;
    return {
        update: function(r, o, a) {
            const l = r.morphTargetInfluences,
                c = o.morphAttributes.position || o.morphAttributes.normal || o.morphAttributes.color,
                h = void 0 !== c ? c.length : 0;
            let u = i.get(o);
            if (void 0 === u || u.count !== h) {
                let t = function() {
                    v.dispose(), i.delete(o), o.removeEventListener("dispose", t)
                };
                void 0 !== u && u.texture.dispose();
                const n = void 0 !== o.morphAttributes.position,
                    r = void 0 !== o.morphAttributes.normal,
                    a = void 0 !== o.morphAttributes.color,
                    l = o.morphAttributes.position || [],
                    c = o.morphAttributes.normal || [],
                    d = o.morphAttributes.color || [];
                let p = 0;
                !0 === n && (p = 1), !0 === r && (p = 2), !0 === a && (p = 3);
                let f = o.attributes.position.count * p,
                    m = 1;
                f > e.maxTextureSize && (m = Math.ceil(f / e.maxTextureSize), f = e.maxTextureSize);
                const g = new Float32Array(f * m * 4 * h),
                    v = new mp(g, f, m, h);
                v.type = oi, v.needsUpdate = !0;
                const y = 4 * p;
                for (let t = 0; t < h; t++) {
                    const e = l[t],
                        i = c[t],
                        o = d[t],
                        h = f * m * 4 * t;
                    for (let t = 0; t < e.count; t++) {
                        const l = t * y;
                        !0 === n && (s.fromBufferAttribute(e, t), g[h + l + 0] = s.x, g[h + l + 1] = s.y, g[h + l + 2] = s.z, g[h + l + 3] = 0), !0 === r && (s.fromBufferAttribute(i, t), g[h + l + 4] = s.x, g[h + l + 5] = s.y, g[h + l + 6] = s.z, g[h + l + 7] = 0), !0 === a && (s.fromBufferAttribute(o, t), g[h + l + 8] = s.x, g[h + l + 9] = s.y, g[h + l + 10] = s.z, g[h + l + 11] = 4 === o.itemSize ? s.w : 1)
                    }
                }
                u = {
                    count: h,
                    texture: v,
                    size: new Q(f, m)
                }, i.set(o, u), o.addEventListener("dispose", t)
            }
            if (!0 === r.isInstancedMesh && null !== r.morphTexture) a.getUniforms().setValue(t, "morphTexture", r.morphTexture, n);
            else {
                let e = 0;
                for (let t = 0; t < l.length; t++) e += l[t];
                const n = o.morphTargetsRelative ? 1 : 1 - e;
                a.getUniforms().setValue(t, "morphTargetBaseInfluence", n), a.getUniforms().setValue(t, "morphTargetInfluences", l)
            }
            a.getUniforms().setValue(t, "morphTargetsTexture", u.texture, n), a.getUniforms().setValue(t, "morphTargetsTextureSize", u.size)
        }
    }
}

function bb(t, e, n, i) {
    let s = new WeakMap;

    function r(t) {
        const e = t.target;
        e.removeEventListener("dispose", r), n.remove(e.instanceMatrix), null !== e.instanceColor && n.remove(e.instanceColor)
    }
    return {
        update: function(o) {
            const a = i.render.frame,
                l = o.geometry,
                c = e.get(o, l);
            if (s.get(c) !== a && (e.update(c), s.set(c, a)), o.isInstancedMesh && (!1 === o.hasEventListener("dispose", r) && o.addEventListener("dispose", r), s.get(o) !== a && (n.update(o.instanceMatrix, t.ARRAY_BUFFER), null !== o.instanceColor && n.update(o.instanceColor, t.ARRAY_BUFFER), s.set(o, a))), o.isSkinnedMesh) {
                const t = o.skeleton;
                s.get(t) !== a && (t.update(), s.set(t, a))
            }
            return c
        },
        dispose: function() {
            s = new WeakMap
        }
    }
}
class ph extends wt {
    constructor(t, e, n, i, s, r, o, a, l, c) {
        if ((c = void 0 !== c ? c : Ms) !== Ms && c !== Ps) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        void 0 === n && c === Ms && (n = Cs), void 0 === n && c === Ps && (n = Dr), super(null, i, s, r, o, a, c, n, l), this.isDepthTexture = !0, this.image = {
            width: t,
            height: e
        }, this.magFilter = void 0 !== o ? o : Vt, this.minFilter = void 0 !== a ? a : Vt, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null
    }
    copy(t) {
        return super.copy(t), this.compareFunction = t.compareFunction, this
    }
    toJSON(t) {
        const e = super.toJSON(t);
        return null !== this.compareFunction && (e.compareFunction = this.compareFunction), e
    }
}
const Sp = new wt,
    _p = new ph(1, 1);
_p.compareFunction = up;
const wp = new mp,
    Mp = new a0,
    Ep = new bp,
    xd = [],
    bd = [],
    Ad = new Float32Array(16),
    Sd = new Float32Array(9),
    _d = new Float32Array(4);

function Lr(t, e, n) {
    const i = t[0];
    if (i <= 0 || i > 0) return t;
    const s = e * n;
    let r = xd[s];
    if (void 0 === r && (r = new Float32Array(s), xd[s] = r), 0 !== e) {
        i.toArray(r, 0);
        for (let i = 1, s = 0; i !== e; ++i) s += n, t[i].toArray(r, s)
    }
    return r
}

function jt(t, e) {
    if (t.length !== e.length) return !1;
    for (let n = 0, i = t.length; n < i; n++)
        if (t[n] !== e[n]) return !1;
    return !0
}

function Kt(t, e) {
    for (let n = 0, i = e.length; n < i; n++) t[n] = e[n]
}

function Xa(t, e) {
    let n = bd[e];
    void 0 === n && (n = new Int32Array(e), bd[e] = n);
    for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
    return n
}

function Ab(t, e) {
    const n = this.cache;
    n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e)
}

function Sb(t, e) {
    const n = this.cache;
    if (void 0 !== e.x)(n[0] !== e.x || n[1] !== e.y) && (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
    else {
        if (jt(n, e)) return;
        t.uniform2fv(this.addr, e), Kt(n, e)
    }
}

function _b(t, e) {
    const n = this.cache;
    if (void 0 !== e.x)(n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) && (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
    else if (void 0 !== e.r)(n[0] !== e.r || n[1] !== e.g || n[2] !== e.b) && (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);
    else {
        if (jt(n, e)) return;
        t.uniform3fv(this.addr, e), Kt(n, e)
    }
}

function wb(t, e) {
    const n = this.cache;
    if (void 0 !== e.x)(n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) && (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
    else {
        if (jt(n, e)) return;
        t.uniform4fv(this.addr, e), Kt(n, e)
    }
}

function Mb(t, e) {
    const n = this.cache,
        i = e.elements;
    if (void 0 === i) {
        if (jt(n, e)) return;
        t.uniformMatrix2fv(this.addr, !1, e), Kt(n, e)
    } else {
        if (jt(n, i)) return;
        _d.set(i), t.uniformMatrix2fv(this.addr, !1, _d), Kt(n, i)
    }
}

function Eb(t, e) {
    const n = this.cache,
        i = e.elements;
    if (void 0 === i) {
        if (jt(n, e)) return;
        t.uniformMatrix3fv(this.addr, !1, e), Kt(n, e)
    } else {
        if (jt(n, i)) return;
        Sd.set(i), t.uniformMatrix3fv(this.addr, !1, Sd), Kt(n, i)
    }
}

function Tb(t, e) {
    const n = this.cache,
        i = e.elements;
    if (void 0 === i) {
        if (jt(n, e)) return;
        t.uniformMatrix4fv(this.addr, !1, e), Kt(n, e)
    } else {
        if (jt(n, i)) return;
        Ad.set(i), t.uniformMatrix4fv(this.addr, !1, Ad), Kt(n, i)
    }
}

function Cb(t, e) {
    const n = this.cache;
    n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e)
}

function Pb(t, e) {
    const n = this.cache;
    if (void 0 !== e.x)(n[0] !== e.x || n[1] !== e.y) && (t.uniform2i(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
    else {
        if (jt(n, e)) return;
        t.uniform2iv(this.addr, e), Kt(n, e)
    }
}

function Rb(t, e) {
    const n = this.cache;
    if (void 0 !== e.x)(n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) && (t.uniform3i(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
    else {
        if (jt(n, e)) return;
        t.uniform3iv(this.addr, e), Kt(n, e)
    }
}

function Db(t, e) {
    const n = this.cache;
    if (void 0 !== e.x)(n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) && (t.uniform4i(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
    else {
        if (jt(n, e)) return;
        t.uniform4iv(this.addr, e), Kt(n, e)
    }
}

function Ib(t, e) {
    const n = this.cache;
    n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e)
}

function Lb(t, e) {
    const n = this.cache;
    if (void 0 !== e.x)(n[0] !== e.x || n[1] !== e.y) && (t.uniform2ui(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
    else {
        if (jt(n, e)) return;
        t.uniform2uiv(this.addr, e), Kt(n, e)
    }
}

function Ob(t, e) {
    const n = this.cache;
    if (void 0 !== e.x)(n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) && (t.uniform3ui(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
    else {
        if (jt(n, e)) return;
        t.uniform3uiv(this.addr, e), Kt(n, e)
    }
}

function Bb(t, e) {
    const n = this.cache;
    if (void 0 !== e.x)(n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) && (t.uniform4ui(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
    else {
        if (jt(n, e)) return;
        t.uniform4uiv(this.addr, e), Kt(n, e)
    }
}

function Ub(t, e, n) {
    const i = this.cache,
        s = n.allocateTextureUnit();
    i[0] !== s && (t.uniform1i(this.addr, s), i[0] = s);
    const r = this.type === t.SAMPLER_2D_SHADOW ? _p : Sp;
    n.setTexture2D(e || r, s)
}

function Nb(t, e, n) {
    const i = this.cache,
        s = n.allocateTextureUnit();
    i[0] !== s && (t.uniform1i(this.addr, s), i[0] = s), n.setTexture3D(e || Mp, s)
}

function Fb(t, e, n) {
    const i = this.cache,
        s = n.allocateTextureUnit();
    i[0] !== s && (t.uniform1i(this.addr, s), i[0] = s), n.setTextureCube(e || Ep, s)
}

function kb(t, e, n) {
    const i = this.cache,
        s = n.allocateTextureUnit();
    i[0] !== s && (t.uniform1i(this.addr, s), i[0] = s), n.setTexture2DArray(e || wp, s)
}

function zb(t) {
    switch (t) {
        case 5126:
            return Ab;
        case 35664:
            return Sb;
        case 35665:
            return _b;
        case 35666:
            return wb;
        case 35674:
            return Mb;
        case 35675:
            return Eb;
        case 35676:
            return Tb;
        case 5124:
        case 35670:
            return Cb;
        case 35667:
        case 35671:
            return Pb;
        case 35668:
        case 35672:
            return Rb;
        case 35669:
        case 35673:
            return Db;
        case 5125:
            return Ib;
        case 36294:
            return Lb;
        case 36295:
            return Ob;
        case 36296:
            return Bb;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
            return Ub;
        case 35679:
        case 36299:
        case 36307:
            return Nb;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
            return Fb;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
            return kb
    }
}

function Gb(t, e) {
    t.uniform1fv(this.addr, e)
}

function Hb(t, e) {
    const n = Lr(e, this.size, 2);
    t.uniform2fv(this.addr, n)
}

function Vb(t, e) {
    const n = Lr(e, this.size, 3);
    t.uniform3fv(this.addr, n)
}

function Wb(t, e) {
    const n = Lr(e, this.size, 4);
    t.uniform4fv(this.addr, n)
}

function Xb(t, e) {
    const n = Lr(e, this.size, 4);
    t.uniformMatrix2fv(this.addr, !1, n)
}

function jb(t, e) {
    const n = Lr(e, this.size, 9);
    t.uniformMatrix3fv(this.addr, !1, n)
}

function Kb(t, e) {
    const n = Lr(e, this.size, 16);
    t.uniformMatrix4fv(this.addr, !1, n)
}

function Yb(t, e) {
    t.uniform1iv(this.addr, e)
}

function Qb(t, e) {
    t.uniform2iv(this.addr, e)
}

function qb(t, e) {
    t.uniform3iv(this.addr, e)
}

function Zb(t, e) {
    t.uniform4iv(this.addr, e)
}

function Jb(t, e) {
    t.uniform1uiv(this.addr, e)
}

function $b(t, e) {
    t.uniform2uiv(this.addr, e)
}

function eA(t, e) {
    t.uniform3uiv(this.addr, e)
}

function tA(t, e) {
    t.uniform4uiv(this.addr, e)
}

function nA(t, e, n) {
    const i = this.cache,
        s = e.length,
        r = Xa(n, s);
    jt(i, r) || (t.uniform1iv(this.addr, r), Kt(i, r));
    for (let t = 0; t !== s; ++t) n.setTexture2D(e[t] || Sp, r[t])
}

function iA(t, e, n) {
    const i = this.cache,
        s = e.length,
        r = Xa(n, s);
    jt(i, r) || (t.uniform1iv(this.addr, r), Kt(i, r));
    for (let t = 0; t !== s; ++t) n.setTexture3D(e[t] || Mp, r[t])
}

function sA(t, e, n) {
    const i = this.cache,
        s = e.length,
        r = Xa(n, s);
    jt(i, r) || (t.uniform1iv(this.addr, r), Kt(i, r));
    for (let t = 0; t !== s; ++t) n.setTextureCube(e[t] || Ep, r[t])
}

function rA(t, e, n) {
    const i = this.cache,
        s = e.length,
        r = Xa(n, s);
    jt(i, r) || (t.uniform1iv(this.addr, r), Kt(i, r));
    for (let t = 0; t !== s; ++t) n.setTexture2DArray(e[t] || wp, r[t])
}

function oA(t) {
    switch (t) {
        case 5126:
            return Gb;
        case 35664:
            return Hb;
        case 35665:
            return Vb;
        case 35666:
            return Wb;
        case 35674:
            return Xb;
        case 35675:
            return jb;
        case 35676:
            return Kb;
        case 5124:
        case 35670:
            return Yb;
        case 35667:
        case 35671:
            return Qb;
        case 35668:
        case 35672:
            return qb;
        case 35669:
        case 35673:
            return Zb;
        case 5125:
            return Jb;
        case 36294:
            return $b;
        case 36295:
            return eA;
        case 36296:
            return tA;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
            return nA;
        case 35679:
        case 36299:
        case 36307:
            return iA;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
            return sA;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
            return rA
    }
}
class aA {
    constructor(t, e, n) {
        this.id = t, this.addr = n, this.cache = [], this.type = e.type, this.setValue = zb(e.type)
    }
}
class lA {
    constructor(t, e, n) {
        this.id = t, this.addr = n, this.cache = [], this.type = e.type, this.size = e.size, this.setValue = oA(e.type)
    }
}
class cA {
    constructor(t) {
        this.id = t, this.seq = [], this.map = {}
    }
    setValue(t, e, n) {
        const i = this.seq;
        for (let s = 0, r = i.length; s !== r; ++s) {
            const r = i[s];
            r.setValue(t, e[r.id], n)
        }
    }
}
const ql = /(\w+)(\])?(\[|\.)?/g;

function wd(t, e) {
    t.seq.push(e), t.map[e.id] = e
}

function hA(t, e, n) {
    const i = t.name,
        s = i.length;
    for (ql.lastIndex = 0;;) {
        const r = ql.exec(i),
            o = ql.lastIndex;
        let a = r[1];
        const l = "]" === r[2],
            c = r[3];
        if (l && (a |= 0), void 0 === c || "[" === c && o + 2 === s) {
            wd(n, void 0 === c ? new aA(a, t, e) : new lA(a, t, e));
            break
        } {
            let t = n.map[a];
            void 0 === t && (t = new cA(a), wd(n, t)), n = t
        }
    }
}
class Ma {
    constructor(t, e) {
        this.seq = [], this.map = {};
        const n = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
        for (let i = 0; i < n; ++i) {
            const n = t.getActiveUniform(e, i);
            hA(n, t.getUniformLocation(e, n.name), this)
        }
    }
    setValue(t, e, n, i) {
        const s = this.map[e];
        void 0 !== s && s.setValue(t, n, i)
    }
    setOptional(t, e, n) {
        const i = e[n];
        void 0 !== i && this.setValue(t, n, i)
    }
    static upload(t, e, n, i) {
        for (let s = 0, r = e.length; s !== r; ++s) {
            const r = e[s],
                o = n[r.id];
            !1 !== o.needsUpdate && r.setValue(t, o.value, i)
        }
    }
    static seqWithValue(t, e) {
        const n = [];
        for (let i = 0, s = t.length; i !== s; ++i) {
            const s = t[i];
            s.id in e && n.push(s)
        }
        return n
    }
}

function Md(t, e, n) {
    const i = t.createShader(e);
    return t.shaderSource(i, n), t.compileShader(i), i
}
const uA = 37297;
let dA = 0;

function fA(t, e) {
    const n = t.split("\n"),
        i = [],
        s = Math.max(e - 6, 0),
        r = Math.min(e + 6, n.length);
    for (let t = s; t < r; t++) {
        const s = t + 1;
        i.push(`${s===e?">":" "} ${s}: ${n[t]}`)
    }
    return i.join("\n")
}

function pA(t) {
    const e = vt.getPrimaries(vt.workingColorSpace),
        n = vt.getPrimaries(t);
    let i;
    switch (e === n ? i = "" : e === Da && n === Ra ? i = "LinearDisplayP3ToLinearSRGB" : e === Ra && n === Da && (i = "LinearSRGBToLinearDisplayP3"), t) {
        case Zn:
        case Wa:
            return [i, "LinearTransferOETF"];
        case rt:
        case lh:
            return [i, "sRGBTransferOETF"];
        default:
            return console.warn("THREE.WebGLProgram: Unsupported color space:", t), [i, "LinearTransferOETF"]
    }
}

function Ed(t, e, n) {
    const i = t.getShaderParameter(e, t.COMPILE_STATUS),
        s = t.getShaderInfoLog(e).trim();
    if (i && "" === s) return "";
    const r = /ERROR: 0:(\d+)/.exec(s);
    if (r) {
        const i = parseInt(r[1]);
        return n.toUpperCase() + "\n\n" + s + "\n\n" + fA(t.getShaderSource(e), i)
    }
    return s
}

function mA(t, e) {
    const n = pA(e);
    return `vec4 ${t}( vec4 value ) { return ${n[0]}( ${n[1]}( value ) ); }`
}

function gA(t, e) {
    let n;
    switch (e) {
        case mv:
            n = "Linear";
            break;
        case gv:
            n = "Reinhard";
            break;
        case vv:
            n = "OptimizedCineon";
            break;
        case yv:
            n = "ACESFilmic";
            break;
        case bv:
            n = "AgX";
            break;
        case Av:
            n = "Neutral";
            break;
        case xv:
            n = "Custom";
            break;
        default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear"
    }
    return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
}

function vA(t) {
    return [t.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", t.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(no).join("\n")
}

function yA(t) {
    const e = [];
    for (const n in t) {
        const i = t[n];
        !1 !== i && e.push("#define " + n + " " + i)
    }
    return e.join("\n")
}

function xA(t, e) {
    const n = {},
        i = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES);
    for (let s = 0; s < i; s++) {
        const i = t.getActiveAttrib(e, s),
            r = i.name;
        let o = 1;
        i.type === t.FLOAT_MAT2 && (o = 2), i.type === t.FLOAT_MAT3 && (o = 3), i.type === t.FLOAT_MAT4 && (o = 4), n[r] = {
            type: i.type,
            location: t.getAttribLocation(e, r),
            locationSize: o
        }
    }
    return n
}

function no(t) {
    return "" !== t
}

function Td(t, e) {
    const n = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
    return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
}

function Cd(t, e) {
    return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
}
const bA = /^[ \t]*#include +<([\w\d./]+)>/gm;

function Oc(t) {
    return t.replace(bA, SA)
}
const AA = new Map;

function SA(t, e) {
    let n = Ze[e];
    if (void 0 === n) {
        const t = AA.get(e);
        if (void 0 === t) throw new Error("Can not resolve #include <" + e + ">");
        n = Ze[t], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, t)
    }
    return Oc(n)
}
const _A = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

function Pd(t) {
    return t.replace(_A, wA)
}

function wA(t, e, n, i) {
    let s = "";
    for (let t = parseInt(e); t < parseInt(n); t++) s += i.replace(/\[\s*i\s*\]/g, "[ " + t + " ]").replace(/UNROLLED_LOOP_INDEX/g, t);
    return s
}

function Rd(t) {
    let e = `precision ${t.precision} float;\n\tprecision ${t.precision} int;\n\tprecision ${t.precision} sampler2D;\n\tprecision ${t.precision} samplerCube;\n\tprecision ${t.precision} sampler3D;\n\tprecision ${t.precision} sampler2DArray;\n\tprecision ${t.precision} sampler2DShadow;\n\tprecision ${t.precision} samplerCubeShadow;\n\tprecision ${t.precision} sampler2DArrayShadow;\n\tprecision ${t.precision} isampler2D;\n\tprecision ${t.precision} isampler3D;\n\tprecision ${t.precision} isamplerCube;\n\tprecision ${t.precision} isampler2DArray;\n\tprecision ${t.precision} usampler2D;\n\tprecision ${t.precision} usampler3D;\n\tprecision ${t.precision} usamplerCube;\n\tprecision ${t.precision} usampler2DArray;\n\t`;
    return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e
}

function MA(t) {
    let e = "SHADOWMAP_TYPE_BASIC";
    return t.shadowMapType === Jf ? e = "SHADOWMAP_TYPE_PCF" : t.shadowMapType === Vg ? e = "SHADOWMAP_TYPE_PCF_SOFT" : t.shadowMapType === Si && (e = "SHADOWMAP_TYPE_VSM"), e
}

function EA(t) {
    let e = "ENVMAP_TYPE_CUBE";
    if (t.envMap) switch (t.envMapMode) {
        case Ar:
        case Sr:
            e = "ENVMAP_TYPE_CUBE";
            break;
        case Ga:
            e = "ENVMAP_TYPE_CUBE_UV"
    }
    return e
}

function TA(t) {
    let e = "ENVMAP_MODE_REFLECTION";
    if (t.envMap && t.envMapMode === Sr) e = "ENVMAP_MODE_REFRACTION";
    return e
}

function CA(t) {
    let e = "ENVMAP_BLENDING_NONE";
    if (t.envMap) switch (t.combine) {
        case ih:
            e = "ENVMAP_BLENDING_MULTIPLY";
            break;
        case fv:
            e = "ENVMAP_BLENDING_MIX";
            break;
        case pv:
            e = "ENVMAP_BLENDING_ADD"
    }
    return e
}

function PA(t) {
    const e = t.envMapCubeUVHeight;
    if (null === e) return null;
    const n = Math.log2(e) - 2,
        i = 1 / e;
    return {
        texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
        texelHeight: i,
        maxMip: n
    }
}

function RA(t, e, n, i) {
    const s = t.getContext(),
        r = n.defines;
    let o = n.vertexShader,
        a = n.fragmentShader;
    const l = MA(n),
        c = EA(n),
        h = TA(n),
        u = CA(n),
        d = PA(n),
        p = vA(n),
        f = yA(r),
        m = s.createProgram();
    let g, v, y = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
    n.isRawShaderMaterial ? (g = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, f].filter(no).join("\n"), g.length > 0 && (g += "\n"), v = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, f].filter(no).join("\n"), v.length > 0 && (v += "\n")) : (g = [Rd(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, f, n.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", n.batching ? "#define USE_BATCHING" : "", n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + h : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.mapUv ? "#define MAP_UV " + n.mapUv : "", n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "", n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "", n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "", n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "", n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "", n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "", n.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv : "", n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "", n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "", n.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv : "", n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "", n.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv : "", n.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv : "", n.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv : "", n.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv : "", n.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv : "", n.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv : "", n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "", n.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv : "", n.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv : "", n.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv : "", n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphColors ? "#define USE_MORPHCOLORS" : "", n.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "", n.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.useLegacyLights ? "#define LEGACY_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "\tuniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "\tattribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "\tattribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "\tattribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(no).join("\n"), v = [Rd(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, f, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + h : "", n.envMap ? "#define " + u : "", d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "", d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "", d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.dispersion ? "#define USE_DISPERSION" : "", n.iridescence ? "#define USE_IRIDESCENCE" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.useLegacyLights ? "#define LEGACY_LIGHTS" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== qi ? "#define TONE_MAPPING" : "", n.toneMapping !== qi ? Ze.tonemapping_pars_fragment : "", n.toneMapping !== qi ? gA("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.opaque ? "#define OPAQUE" : "", Ze.colorspace_pars_fragment, mA("linearToOutputTexel", n.outputColorSpace), n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(no).join("\n")), o = Oc(o), o = Td(o, n), o = Cd(o, n), a = Oc(a), a = Td(a, n), a = Cd(a, n), o = Pd(o), a = Pd(a), !0 !== n.isRawShaderMaterial && (y = "#version 300 es\n", g = [p, "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g, v = ["#define varying in", n.glslVersion === Xu ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === Xu ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v);
    const x = y + g + o,
        b = y + v + a,
        A = Md(s, s.VERTEX_SHADER, x),
        S = Md(s, s.FRAGMENT_SHADER, b);

    function w(e) {
        if (t.debug.checkShaderErrors) {
            const n = s.getProgramInfoLog(m).trim(),
                i = s.getShaderInfoLog(A).trim(),
                r = s.getShaderInfoLog(S).trim();
            let o = !0,
                a = !0;
            if (!1 === s.getProgramParameter(m, s.LINK_STATUS))
                if (o = !1, "function" == typeof t.debug.onShaderError) t.debug.onShaderError(s, m, A, S);
                else {
                    const t = Ed(s, A, "vertex"),
                        i = Ed(s, S, "fragment");
                    console.error("THREE.WebGLProgram: Shader Error " + s.getError() + " - VALIDATE_STATUS " + s.getProgramParameter(m, s.VALIDATE_STATUS) + "\n\nMaterial Name: " + e.name + "\nMaterial Type: " + e.type + "\n\nProgram Info Log: " + n + "\n" + t + "\n" + i)
                }
            else "" !== n ? console.warn("THREE.WebGLProgram: Program Info Log:", n) : ("" === i || "" === r) && (a = !1);
            a && (e.diagnostics = {
                runnable: o,
                programLog: n,
                vertexShader: {
                    log: i,
                    prefix: g
                },
                fragmentShader: {
                    log: r,
                    prefix: v
                }
            })
        }
        s.deleteShader(A), s.deleteShader(S), _ = new Ma(s, m), M = xA(s, m)
    }
    let _, M;
    s.attachShader(m, A), s.attachShader(m, S), void 0 !== n.index0AttributeName ? s.bindAttribLocation(m, 0, n.index0AttributeName) : !0 === n.morphTargets && s.bindAttribLocation(m, 0, "position"), s.linkProgram(m), this.getUniforms = function() {
        return void 0 === _ && w(this), _
    }, this.getAttributes = function() {
        return void 0 === M && w(this), M
    };
    let T = !1 === n.rendererExtensionParallelShaderCompile;
    return this.isReady = function() {
        return !1 === T && (T = s.getProgramParameter(m, uA)), T
    }, this.destroy = function() {
        i.releaseStatesOfProgram(this), s.deleteProgram(m), this.program = void 0
    }, this.type = n.shaderType, this.name = n.shaderName, this.id = dA++, this.cacheKey = e, this.usedTimes = 1, this.program = m, this.vertexShader = A, this.fragmentShader = S, this
}
let DA = 0;
class IA {
    constructor() {
        this.shaderCache = new Map, this.materialCache = new Map
    }
    update(t) {
        const e = t.vertexShader,
            n = t.fragmentShader,
            i = this._getShaderStage(e),
            s = this._getShaderStage(n),
            r = this._getShaderCacheForMaterial(t);
        return !1 === r.has(i) && (r.add(i), i.usedTimes++), !1 === r.has(s) && (r.add(s), s.usedTimes++), this
    }
    remove(t) {
        const e = this.materialCache.get(t);
        for (const t of e) t.usedTimes--, 0 === t.usedTimes && this.shaderCache.delete(t.code);
        return this.materialCache.delete(t), this
    }
    getVertexShaderID(t) {
        return this._getShaderStage(t.vertexShader).id
    }
    getFragmentShaderID(t) {
        return this._getShaderStage(t.fragmentShader).id
    }
    dispose() {
        this.shaderCache.clear(), this.materialCache.clear()
    }
    _getShaderCacheForMaterial(t) {
        const e = this.materialCache;
        let n = e.get(t);
        return void 0 === n && (n = new Set, e.set(t, n)), n
    }
    _getShaderStage(t) {
        const e = this.shaderCache;
        let n = e.get(t);
        return void 0 === n && (n = new LA(t), e.set(t, n)), n
    }
}
class LA {
    constructor(t) {
        this.id = DA++, this.code = t, this.usedTimes = 0
    }
}

function OA(t, e, n, i, s, r, o) {
    const a = new hh,
        l = new IA,
        c = new Set,
        h = [],
        u = s.logarithmicDepthBuffer,
        d = s.vertexTextures;
    let p = s.precision;
    const f = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
    };

    function m(t) {
        return c.add(t), 0 === t ? "uv" : `uv${t}`
    }
    return {
        getParameters: function(r, a, h, g, v) {
            const y = g.fog,
                x = v.geometry,
                b = r.isMeshStandardMaterial ? g.environment : null,
                A = (r.isMeshStandardMaterial ? n : e).get(r.envMap || b),
                S = A && A.mapping === Ga ? A.image.height : null,
                w = f[r.type];
            null !== r.precision && (p = s.getMaxPrecision(r.precision), p !== r.precision && console.warn("THREE.WebGLProgram.getParameters:", r.precision, "not supported, using", p, "instead."));
            const _ = x.morphAttributes.position || x.morphAttributes.normal || x.morphAttributes.color,
                M = void 0 !== _ ? _.length : 0;
            let T, E, C, R, P = 0;
            if (void 0 !== x.morphAttributes.position && (P = 1), void 0 !== x.morphAttributes.normal && (P = 2), void 0 !== x.morphAttributes.color && (P = 3), w) {
                const t = ni[w];
                T = t.vertexShader, E = t.fragmentShader
            } else T = r.vertexShader, E = r.fragmentShader, l.update(r), C = l.getVertexShaderID(r), R = l.getFragmentShaderID(r);
            const D = t.getRenderTarget(),
                I = !0 === v.isInstancedMesh,
                L = !0 === v.isBatchedMesh,
                U = !!r.map,
                O = !!r.matcap,
                B = !!A,
                N = !!r.aoMap,
                F = !!r.lightMap,
                k = !!r.bumpMap,
                z = !!r.normalMap,
                G = !!r.displacementMap,
                H = !!r.emissiveMap,
                V = !!r.metalnessMap,
                W = !!r.roughnessMap,
                j = r.anisotropy > 0,
                X = r.clearcoat > 0,
                Q = r.dispersion > 0,
                K = r.iridescence > 0,
                Y = r.sheen > 0,
                q = r.transmission > 0,
                Z = j && !!r.anisotropyMap,
                J = X && !!r.clearcoatMap,
                $ = X && !!r.clearcoatNormalMap,
                tt = X && !!r.clearcoatRoughnessMap,
                et = K && !!r.iridescenceMap,
                nt = K && !!r.iridescenceThicknessMap,
                it = Y && !!r.sheenColorMap,
                st = Y && !!r.sheenRoughnessMap,
                rt = !!r.specularMap,
                ot = !!r.specularColorMap,
                at = !!r.specularIntensityMap,
                lt = q && !!r.transmissionMap,
                ct = q && !!r.thicknessMap,
                ht = !!r.gradientMap,
                ut = !!r.alphaMap,
                dt = r.alphaTest > 0,
                pt = !!r.alphaHash,
                ft = !!r.extensions;
            let mt = qi;
            r.toneMapped && (null === D || !0 === D.isXRRenderTarget) && (mt = t.toneMapping);
            const gt = {
                shaderID: w,
                shaderType: r.type,
                shaderName: r.name,
                vertexShader: T,
                fragmentShader: E,
                defines: r.defines,
                customVertexShaderID: C,
                customFragmentShaderID: R,
                isRawShaderMaterial: !0 === r.isRawShaderMaterial,
                glslVersion: r.glslVersion,
                precision: p,
                batching: L,
                instancing: I,
                instancingColor: I && null !== v.instanceColor,
                instancingMorph: I && null !== v.morphTexture,
                supportsVertexTextures: d,
                outputColorSpace: null === D ? t.outputColorSpace : !0 === D.isXRRenderTarget ? D.texture.colorSpace : Zn,
                alphaToCoverage: !!r.alphaToCoverage,
                map: U,
                matcap: O,
                envMap: B,
                envMapMode: B && A.mapping,
                envMapCubeUVHeight: S,
                aoMap: N,
                lightMap: F,
                bumpMap: k,
                normalMap: z,
                displacementMap: d && G,
                emissiveMap: H,
                normalMapObjectSpace: z && 1 === r.normalMapType,
                normalMapTangentSpace: z && 0 === r.normalMapType,
                metalnessMap: V,
                roughnessMap: W,
                anisotropy: j,
                anisotropyMap: Z,
                clearcoat: X,
                clearcoatMap: J,
                clearcoatNormalMap: $,
                clearcoatRoughnessMap: tt,
                dispersion: Q,
                iridescence: K,
                iridescenceMap: et,
                iridescenceThicknessMap: nt,
                sheen: Y,
                sheenColorMap: it,
                sheenRoughnessMap: st,
                specularMap: rt,
                specularColorMap: ot,
                specularIntensityMap: at,
                transmission: q,
                transmissionMap: lt,
                thicknessMap: ct,
                gradientMap: ht,
                opaque: !1 === r.transparent && 1 === r.blending && !1 === r.alphaToCoverage,
                alphaMap: ut,
                alphaTest: dt,
                alphaHash: pt,
                combine: r.combine,
                mapUv: U && m(r.map.channel),
                aoMapUv: N && m(r.aoMap.channel),
                lightMapUv: F && m(r.lightMap.channel),
                bumpMapUv: k && m(r.bumpMap.channel),
                normalMapUv: z && m(r.normalMap.channel),
                displacementMapUv: G && m(r.displacementMap.channel),
                emissiveMapUv: H && m(r.emissiveMap.channel),
                metalnessMapUv: V && m(r.metalnessMap.channel),
                roughnessMapUv: W && m(r.roughnessMap.channel),
                anisotropyMapUv: Z && m(r.anisotropyMap.channel),
                clearcoatMapUv: J && m(r.clearcoatMap.channel),
                clearcoatNormalMapUv: $ && m(r.clearcoatNormalMap.channel),
                clearcoatRoughnessMapUv: tt && m(r.clearcoatRoughnessMap.channel),
                iridescenceMapUv: et && m(r.iridescenceMap.channel),
                iridescenceThicknessMapUv: nt && m(r.iridescenceThicknessMap.channel),
                sheenColorMapUv: it && m(r.sheenColorMap.channel),
                sheenRoughnessMapUv: st && m(r.sheenRoughnessMap.channel),
                specularMapUv: rt && m(r.specularMap.channel),
                specularColorMapUv: ot && m(r.specularColorMap.channel),
                specularIntensityMapUv: at && m(r.specularIntensityMap.channel),
                transmissionMapUv: lt && m(r.transmissionMap.channel),
                thicknessMapUv: ct && m(r.thicknessMap.channel),
                alphaMapUv: ut && m(r.alphaMap.channel),
                vertexTangents: !!x.attributes.tangent && (z || j),
                vertexColors: r.vertexColors,
                vertexAlphas: !0 === r.vertexColors && !!x.attributes.color && 4 === x.attributes.color.itemSize,
                pointsUvs: !0 === v.isPoints && !!x.attributes.uv && (U || ut),
                fog: !!y,
                useFog: !0 === r.fog,
                fogExp2: !!y && y.isFogExp2,
                flatShading: !0 === r.flatShading,
                sizeAttenuation: !0 === r.sizeAttenuation,
                logarithmicDepthBuffer: u,
                skinning: !0 === v.isSkinnedMesh,
                morphTargets: void 0 !== x.morphAttributes.position,
                morphNormals: void 0 !== x.morphAttributes.normal,
                morphColors: void 0 !== x.morphAttributes.color,
                morphTargetsCount: M,
                morphTextureStride: P,
                numDirLights: a.directional.length,
                numPointLights: a.point.length,
                numSpotLights: a.spot.length,
                numSpotLightMaps: a.spotLightMap.length,
                numRectAreaLights: a.rectArea.length,
                numHemiLights: a.hemi.length,
                numDirLightShadows: a.directionalShadowMap.length,
                numPointLightShadows: a.pointShadowMap.length,
                numSpotLightShadows: a.spotShadowMap.length,
                numSpotLightShadowsWithMaps: a.numSpotLightShadowsWithMaps,
                numLightProbes: a.numLightProbes,
                numClippingPlanes: o.numPlanes,
                numClipIntersection: o.numIntersection,
                dithering: r.dithering,
                shadowMapEnabled: t.shadowMap.enabled && h.length > 0,
                shadowMapType: t.shadowMap.type,
                toneMapping: mt,
                useLegacyLights: t._useLegacyLights,
                decodeVideoTexture: U && !0 === r.map.isVideoTexture && vt.getTransfer(r.map.colorSpace) === St,
                premultipliedAlpha: r.premultipliedAlpha,
                doubleSided: 2 === r.side,
                flipSided: r.side === Bt,
                useDepthPacking: r.depthPacking >= 0,
                depthPacking: r.depthPacking || 0,
                index0AttributeName: r.index0AttributeName,
                extensionClipCullDistance: ft && !0 === r.extensions.clipCullDistance && i.has("WEBGL_clip_cull_distance"),
                extensionMultiDraw: ft && !0 === r.extensions.multiDraw && i.has("WEBGL_multi_draw"),
                rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"),
                customProgramCacheKey: r.customProgramCacheKey()
            };
            return gt.vertexUv1s = c.has(1), gt.vertexUv2s = c.has(2), gt.vertexUv3s = c.has(3), c.clear(), gt
        },
        getProgramCacheKey: function(e) {
            const n = [];
            if (e.shaderID ? n.push(e.shaderID) : (n.push(e.customVertexShaderID), n.push(e.customFragmentShaderID)), void 0 !== e.defines)
                for (const t in e.defines) n.push(t), n.push(e.defines[t]);
            return !1 === e.isRawShaderMaterial && (function(t, e) {
                t.push(e.precision), t.push(e.outputColorSpace), t.push(e.envMapMode), t.push(e.envMapCubeUVHeight), t.push(e.mapUv), t.push(e.alphaMapUv), t.push(e.lightMapUv), t.push(e.aoMapUv), t.push(e.bumpMapUv), t.push(e.normalMapUv), t.push(e.displacementMapUv), t.push(e.emissiveMapUv), t.push(e.metalnessMapUv), t.push(e.roughnessMapUv), t.push(e.anisotropyMapUv), t.push(e.clearcoatMapUv), t.push(e.clearcoatNormalMapUv), t.push(e.clearcoatRoughnessMapUv), t.push(e.iridescenceMapUv), t.push(e.iridescenceThicknessMapUv), t.push(e.sheenColorMapUv), t.push(e.sheenRoughnessMapUv), t.push(e.specularMapUv), t.push(e.specularColorMapUv), t.push(e.specularIntensityMapUv), t.push(e.transmissionMapUv), t.push(e.thicknessMapUv), t.push(e.combine), t.push(e.fogExp2), t.push(e.sizeAttenuation), t.push(e.morphTargetsCount), t.push(e.morphAttributeCount), t.push(e.numDirLights), t.push(e.numPointLights), t.push(e.numSpotLights), t.push(e.numSpotLightMaps), t.push(e.numHemiLights), t.push(e.numRectAreaLights), t.push(e.numDirLightShadows), t.push(e.numPointLightShadows), t.push(e.numSpotLightShadows), t.push(e.numSpotLightShadowsWithMaps), t.push(e.numLightProbes), t.push(e.shadowMapType), t.push(e.toneMapping), t.push(e.numClippingPlanes), t.push(e.numClipIntersection), t.push(e.depthPacking)
            }(n, e), function(t, e) {
                a.disableAll(), e.supportsVertexTextures && a.enable(0), e.instancing && a.enable(1), e.instancingColor && a.enable(2), e.instancingMorph && a.enable(3), e.matcap && a.enable(4), e.envMap && a.enable(5), e.normalMapObjectSpace && a.enable(6), e.normalMapTangentSpace && a.enable(7), e.clearcoat && a.enable(8), e.iridescence && a.enable(9), e.alphaTest && a.enable(10), e.vertexColors && a.enable(11), e.vertexAlphas && a.enable(12), e.vertexUv1s && a.enable(13), e.vertexUv2s && a.enable(14), e.vertexUv3s && a.enable(15), e.vertexTangents && a.enable(16), e.anisotropy && a.enable(17), e.alphaHash && a.enable(18), e.batching && a.enable(19), e.dispersion && a.enable(20), t.push(a.mask), a.disableAll(), e.fog && a.enable(0), e.useFog && a.enable(1), e.flatShading && a.enable(2), e.logarithmicDepthBuffer && a.enable(3), e.skinning && a.enable(4), e.morphTargets && a.enable(5), e.morphNormals && a.enable(6), e.morphColors && a.enable(7), e.premultipliedAlpha && a.enable(8), e.shadowMapEnabled && a.enable(9), e.useLegacyLights && a.enable(10), e.doubleSided && a.enable(11), e.flipSided && a.enable(12), e.useDepthPacking && a.enable(13), e.dithering && a.enable(14), e.transmission && a.enable(15), e.sheen && a.enable(16), e.opaque && a.enable(17), e.pointsUvs && a.enable(18), e.decodeVideoTexture && a.enable(19), e.alphaToCoverage && a.enable(20), t.push(a.mask)
            }(n, e), n.push(t.outputColorSpace)), n.push(e.customProgramCacheKey), n.join()
        },
        getUniforms: function(t) {
            const e = f[t.type];
            let n;
            if (e) {
                const t = ni[e];
                n = Lc.clone(t.uniforms)
            } else n = t.uniforms;
            return n
        },
        acquireProgram: function(e, n) {
            let i;
            for (let t = 0, e = h.length; t < e; t++) {
                const e = h[t];
                if (e.cacheKey === n) {
                    i = e, ++i.usedTimes;
                    break
                }
            }
            return void 0 === i && (i = new RA(t, n, e, r), h.push(i)), i
        },
        releaseProgram: function(t) {
            if (0 == --t.usedTimes) {
                const e = h.indexOf(t);
                h[e] = h[h.length - 1], h.pop(), t.destroy()
            }
        },
        releaseShaderCache: function(t) {
            l.remove(t)
        },
        programs: h,
        dispose: function() {
            l.dispose()
        }
    }
}

function BA() {
    let t = new WeakMap;
    return {
        get: function(e) {
            let n = t.get(e);
            return void 0 === n && (n = {}, t.set(e, n)), n
        },
        remove: function(e) {
            t.delete(e)
        },
        update: function(e, n, i) {
            t.get(e)[n] = i
        },
        dispose: function() {
            t = new WeakMap
        }
    }
}

function UA(t, e) {
    return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
}

function Dd(t, e) {
    return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
}

function Id() {
    const t = [];
    let e = 0;
    const n = [],
        i = [],
        s = [];

    function r(n, i, s, r, o, a) {
        let l = t[e];
        return void 0 === l ? (l = {
            id: n.id,
            object: n,
            geometry: i,
            material: s,
            groupOrder: r,
            renderOrder: n.renderOrder,
            z: o,
            group: a
        }, t[e] = l) : (l.id = n.id, l.object = n, l.geometry = i, l.material = s, l.groupOrder = r, l.renderOrder = n.renderOrder, l.z = o, l.group = a), e++, l
    }
    return {
        opaque: n,
        transmissive: i,
        transparent: s,
        init: function() {
            e = 0, n.length = 0, i.length = 0, s.length = 0
        },
        push: function(t, e, o, a, l, c) {
            const h = r(t, e, o, a, l, c);
            o.transmission > 0 ? i.push(h) : !0 === o.transparent ? s.push(h) : n.push(h)
        },
        unshift: function(t, e, o, a, l, c) {
            const h = r(t, e, o, a, l, c);
            o.transmission > 0 ? i.unshift(h) : !0 === o.transparent ? s.unshift(h) : n.unshift(h)
        },
        finish: function() {
            for (let n = e, i = t.length; n < i; n++) {
                const e = t[n];
                if (null === e.id) break;
                e.id = null, e.object = null, e.geometry = null, e.material = null, e.group = null
            }
        },
        sort: function(t, e) {
            n.length > 1 && n.sort(t || UA), i.length > 1 && i.sort(e || Dd), s.length > 1 && s.sort(e || Dd)
        }
    }
}

function NA() {
    let t = new WeakMap;
    return {
        get: function(e, n) {
            const i = t.get(e);
            let s;
            return void 0 === i ? (s = new Id, t.set(e, [s])) : n >= i.length ? (s = new Id, i.push(s)) : s = i[n], s
        },
        dispose: function() {
            t = new WeakMap
        }
    }
}

function FA() {
    const t = {};
    return {
        get: function(e) {
            if (void 0 !== t[e.id]) return t[e.id];
            let n;
            switch (e.type) {
                case "DirectionalLight":
                    n = {
                        direction: new U,
                        color: new Le
                    };
                    break;
                case "SpotLight":
                    n = {
                        position: new U,
                        direction: new U,
                        color: new Le,
                        distance: 0,
                        coneCos: 0,
                        penumbraCos: 0,
                        decay: 0
                    };
                    break;
                case "PointLight":
                    n = {
                        position: new U,
                        color: new Le,
                        distance: 0,
                        decay: 0
                    };
                    break;
                case "HemisphereLight":
                    n = {
                        direction: new U,
                        skyColor: new Le,
                        groundColor: new Le
                    };
                    break;
                case "RectAreaLight":
                    n = {
                        color: new Le,
                        position: new U,
                        halfWidth: new U,
                        halfHeight: new U
                    }
            }
            return t[e.id] = n, n
        }
    }
}

function kA() {
    const t = {};
    return {
        get: function(e) {
            if (void 0 !== t[e.id]) return t[e.id];
            let n;
            switch (e.type) {
                case "DirectionalLight":
                case "SpotLight":
                    n = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Q
                    };
                    break;
                case "PointLight":
                    n = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Q,
                        shadowCameraNear: 1,
                        shadowCameraFar: 1e3
                    }
            }
            return t[e.id] = n, n
        }
    }
}
let zA = 0;

function GA(t, e) {
    return (e.castShadow ? 2 : 0) - (t.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (t.map ? 1 : 0)
}

function HA(t) {
    const e = new FA,
        n = kA(),
        i = {
            version: 0,
            hash: {
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                numDirectionalShadows: -1,
                numPointShadows: -1,
                numSpotShadows: -1,
                numSpotMaps: -1,
                numLightProbes: -1
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotLightMap: [],
            spotShadow: [],
            spotShadowMap: [],
            spotLightMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
            numSpotLightShadowsWithMaps: 0,
            numLightProbes: 0
        };
    for (let t = 0; t < 9; t++) i.probe.push(new U);
    const s = new U,
        r = new Xe,
        o = new Xe;
    return {
        setup: function(s, r) {
            let o = 0,
                a = 0,
                l = 0;
            for (let t = 0; t < 9; t++) i.probe[t].set(0, 0, 0);
            let c = 0,
                h = 0,
                u = 0,
                d = 0,
                p = 0,
                f = 0,
                m = 0,
                g = 0,
                v = 0,
                y = 0,
                x = 0;
            s.sort(GA);
            const b = !0 === r ? Math.PI : 1;
            for (let t = 0, r = s.length; t < r; t++) {
                const r = s[t],
                    A = r.color,
                    S = r.intensity,
                    w = r.distance,
                    _ = r.shadow && r.shadow.map ? r.shadow.map.texture : null;
                if (r.isAmbientLight) o += A.r * S * b, a += A.g * S * b, l += A.b * S * b;
                else if (r.isLightProbe) {
                    for (let t = 0; t < 9; t++) i.probe[t].addScaledVector(r.sh.coefficients[t], S);
                    x++
                } else if (r.isDirectionalLight) {
                    const t = e.get(r);
                    if (t.color.copy(r.color).multiplyScalar(r.intensity * b), r.castShadow) {
                        const t = r.shadow,
                            e = n.get(r);
                        e.shadowBias = t.bias, e.shadowNormalBias = t.normalBias, e.shadowRadius = t.radius, e.shadowMapSize = t.mapSize, i.directionalShadow[c] = e, i.directionalShadowMap[c] = _, i.directionalShadowMatrix[c] = r.shadow.matrix, f++
                    }
                    i.directional[c] = t, c++
                } else if (r.isSpotLight) {
                    const t = e.get(r);
                    t.position.setFromMatrixPosition(r.matrixWorld), t.color.copy(A).multiplyScalar(S * b), t.distance = w, t.coneCos = Math.cos(r.angle), t.penumbraCos = Math.cos(r.angle * (1 - r.penumbra)), t.decay = r.decay, i.spot[u] = t;
                    const s = r.shadow;
                    if (r.map && (i.spotLightMap[v] = r.map, v++, s.updateMatrices(r), r.castShadow && y++), i.spotLightMatrix[u] = s.matrix, r.castShadow) {
                        const t = n.get(r);
                        t.shadowBias = s.bias, t.shadowNormalBias = s.normalBias, t.shadowRadius = s.radius, t.shadowMapSize = s.mapSize, i.spotShadow[u] = t, i.spotShadowMap[u] = _, g++
                    }
                    u++
                } else if (r.isRectAreaLight) {
                    const t = e.get(r);
                    t.color.copy(A).multiplyScalar(S), t.halfWidth.set(.5 * r.width, 0, 0), t.halfHeight.set(0, .5 * r.height, 0), i.rectArea[d] = t, d++
                } else if (r.isPointLight) {
                    const t = e.get(r);
                    if (t.color.copy(r.color).multiplyScalar(r.intensity * b), t.distance = r.distance, t.decay = r.decay, r.castShadow) {
                        const t = r.shadow,
                            e = n.get(r);
                        e.shadowBias = t.bias, e.shadowNormalBias = t.normalBias, e.shadowRadius = t.radius, e.shadowMapSize = t.mapSize, e.shadowCameraNear = t.camera.near, e.shadowCameraFar = t.camera.far, i.pointShadow[h] = e, i.pointShadowMap[h] = _, i.pointShadowMatrix[h] = r.shadow.matrix, m++
                    }
                    i.point[h] = t, h++
                } else if (r.isHemisphereLight) {
                    const t = e.get(r);
                    t.skyColor.copy(r.color).multiplyScalar(S * b), t.groundColor.copy(r.groundColor).multiplyScalar(S * b), i.hemi[p] = t, p++
                }
            }
            d > 0 && (!0 === t.has("OES_texture_float_linear") ? (i.rectAreaLTC1 = Te.LTC_FLOAT_1, i.rectAreaLTC2 = Te.LTC_FLOAT_2) : (i.rectAreaLTC1 = Te.LTC_HALF_1, i.rectAreaLTC2 = Te.LTC_HALF_2)), i.ambient[0] = o, i.ambient[1] = a, i.ambient[2] = l;
            const A = i.hash;
            (A.directionalLength !== c || A.pointLength !== h || A.spotLength !== u || A.rectAreaLength !== d || A.hemiLength !== p || A.numDirectionalShadows !== f || A.numPointShadows !== m || A.numSpotShadows !== g || A.numSpotMaps !== v || A.numLightProbes !== x) && (i.directional.length = c, i.spot.length = u, i.rectArea.length = d, i.point.length = h, i.hemi.length = p, i.directionalShadow.length = f, i.directionalShadowMap.length = f, i.pointShadow.length = m, i.pointShadowMap.length = m, i.spotShadow.length = g, i.spotShadowMap.length = g, i.directionalShadowMatrix.length = f, i.pointShadowMatrix.length = m, i.spotLightMatrix.length = g + v - y, i.spotLightMap.length = v, i.numSpotLightShadowsWithMaps = y, i.numLightProbes = x, A.directionalLength = c, A.pointLength = h, A.spotLength = u, A.rectAreaLength = d, A.hemiLength = p, A.numDirectionalShadows = f, A.numPointShadows = m, A.numSpotShadows = g, A.numSpotMaps = v, A.numLightProbes = x, i.version = zA++)
        },
        setupView: function(t, e) {
            let n = 0,
                a = 0,
                l = 0,
                c = 0,
                h = 0;
            const u = e.matrixWorldInverse;
            for (let e = 0, d = t.length; e < d; e++) {
                const d = t[e];
                if (d.isDirectionalLight) {
                    const t = i.directional[n];
                    t.direction.setFromMatrixPosition(d.matrixWorld), s.setFromMatrixPosition(d.target.matrixWorld), t.direction.sub(s), t.direction.transformDirection(u), n++
                } else if (d.isSpotLight) {
                    const t = i.spot[l];
                    t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(u), t.direction.setFromMatrixPosition(d.matrixWorld), s.setFromMatrixPosition(d.target.matrixWorld), t.direction.sub(s), t.direction.transformDirection(u), l++
                } else if (d.isRectAreaLight) {
                    const t = i.rectArea[c];
                    t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(u), o.identity(), r.copy(d.matrixWorld), r.premultiply(u), o.extractRotation(r), t.halfWidth.set(.5 * d.width, 0, 0), t.halfHeight.set(0, .5 * d.height, 0), t.halfWidth.applyMatrix4(o), t.halfHeight.applyMatrix4(o), c++
                } else if (d.isPointLight) {
                    const t = i.point[a];
                    t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(u), a++
                } else if (d.isHemisphereLight) {
                    const t = i.hemi[h];
                    t.direction.setFromMatrixPosition(d.matrixWorld), t.direction.transformDirection(u), h++
                }
            }
        },
        state: i
    }
}

function Ld(t) {
    const e = new HA(t),
        n = [],
        i = [];
    const s = {
        lightsArray: n,
        shadowsArray: i,
        camera: null,
        lights: e,
        transmissionRenderTarget: {}
    };
    return {
        init: function(t) {
            s.camera = t, n.length = 0, i.length = 0
        },
        state: s,
        setupLights: function(t) {
            e.setup(n, t)
        },
        setupLightsView: function(t) {
            e.setupView(n, t)
        },
        pushLight: function(t) {
            n.push(t)
        },
        pushShadow: function(t) {
            i.push(t)
        }
    }
}

function VA(t) {
    let e = new WeakMap;
    return {
        get: function(n, i = 0) {
            const s = e.get(n);
            let r;
            return void 0 === s ? (r = new Ld(t), e.set(n, [r])) : i >= s.length ? (r = new Ld(t), s.push(r)) : r = s[i], r
        },
        dispose: function() {
            e = new WeakMap
        }
    }
}
class WA extends en {
    constructor(t) {
        super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = Oi, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(t)
    }
    copy(t) {
        return super.copy(t), this.depthPacking = t.depthPacking, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
    }
}
class XA extends en {
    constructor(t) {
        super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(t)
    }
    copy(t) {
        return super.copy(t), this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
    }
}
const jA = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
    KA = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";

function YA(t, e, n) {
    let i = new dh;
    const s = new Q,
        r = new Q,
        o = new ot,
        a = new WA({
            depthPacking: Rv
        }),
        l = new XA,
        c = {},
        h = n.maxTextureSize,
        u = {
            [li]: Bt,
            [Bt]: li,
            [$t]: 2
        },
        d = new It({
            defines: {
                VSM_SAMPLES: 8
            },
            uniforms: {
                shadow_pass: {
                    value: null
                },
                resolution: {
                    value: new Q
                },
                radius: {
                    value: 4
                }
            },
            vertexShader: jA,
            fragmentShader: KA
        }),
        p = d.clone();
    p.defines.HORIZONTAL_PASS = 1;
    const f = new ht;
    f.setAttribute("position", new Xt(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
    const m = new be(f, d),
        g = this;
    this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = Jf;
    let v = this.type;

    function y(n, i) {
        const r = e.update(m);
        d.defines.VSM_SAMPLES !== n.blurSamples && (d.defines.VSM_SAMPLES = n.blurSamples, p.defines.VSM_SAMPLES = n.blurSamples, d.needsUpdate = !0, p.needsUpdate = !0), null === n.mapPass && (n.mapPass = new nn(s.x, s.y)), d.uniforms.shadow_pass.value = n.map.texture, d.uniforms.resolution.value = n.mapSize, d.uniforms.radius.value = n.radius, t.setRenderTarget(n.mapPass), t.clear(), t.renderBufferDirect(i, null, r, d, m, null), p.uniforms.shadow_pass.value = n.mapPass.texture, p.uniforms.resolution.value = n.mapSize, p.uniforms.radius.value = n.radius, t.setRenderTarget(n.map), t.clear(), t.renderBufferDirect(i, null, r, p, m, null)
    }

    function x(e, n, i, s) {
        let r = null;
        const o = !0 === i.isPointLight ? e.customDistanceMaterial : e.customDepthMaterial;
        if (void 0 !== o) r = o;
        else if (r = !0 === i.isPointLight ? l : a, t.localClippingEnabled && !0 === n.clipShadows && Array.isArray(n.clippingPlanes) && 0 !== n.clippingPlanes.length || n.displacementMap && 0 !== n.displacementScale || n.alphaMap && n.alphaTest > 0 || n.map && n.alphaTest > 0) {
            const t = r.uuid,
                e = n.uuid;
            let i = c[t];
            void 0 === i && (i = {}, c[t] = i);
            let s = i[e];
            void 0 === s && (s = r.clone(), i[e] = s, n.addEventListener("dispose", A)), r = s
        }
        if (r.visible = n.visible, r.wireframe = n.wireframe, r.side = s === Si ? null !== n.shadowSide ? n.shadowSide : n.side : null !== n.shadowSide ? n.shadowSide : u[n.side], r.alphaMap = n.alphaMap, r.alphaTest = n.alphaTest, r.map = n.map, r.clipShadows = n.clipShadows, r.clippingPlanes = n.clippingPlanes, r.clipIntersection = n.clipIntersection, r.displacementMap = n.displacementMap, r.displacementScale = n.displacementScale, r.displacementBias = n.displacementBias, r.wireframeLinewidth = n.wireframeLinewidth, r.linewidth = n.linewidth, !0 === i.isPointLight && !0 === r.isMeshDistanceMaterial) {
            t.properties.get(r).light = i
        }
        return r
    }

    function b(n, s, r, o, a) {
        if (!1 === n.visible) return;
        if (n.layers.test(s.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && a === Si) && (!n.frustumCulled || i.intersectsObject(n))) {
            n.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, n.matrixWorld);
            const i = e.update(n),
                l = n.material;
            if (Array.isArray(l)) {
                const e = i.groups;
                for (let c = 0, h = e.length; c < h; c++) {
                    const h = e[c],
                        u = l[h.materialIndex];
                    if (u && u.visible) {
                        const e = x(n, u, o, a);
                        n.onBeforeShadow(t, n, s, r, i, e, h), t.renderBufferDirect(r, null, i, e, n, h), n.onAfterShadow(t, n, s, r, i, e, h)
                    }
                }
            } else if (l.visible) {
                const e = x(n, l, o, a);
                n.onBeforeShadow(t, n, s, r, i, e, null), t.renderBufferDirect(r, null, i, e, n, null), n.onAfterShadow(t, n, s, r, i, e, null)
            }
        }
        const l = n.children;
        for (let t = 0, e = l.length; t < e; t++) b(l[t], s, r, o, a)
    }

    function A(t) {
        t.target.removeEventListener("dispose", A);
        for (const e in c) {
            const n = c[e],
                i = t.target.uuid;
            i in n && (n[i].dispose(), delete n[i])
        }
    }
    this.render = function(e, n, a) {
        if (!1 === g.enabled || !1 === g.autoUpdate && !1 === g.needsUpdate || 0 === e.length) return;
        const l = t.getRenderTarget(),
            c = t.getActiveCubeFace(),
            u = t.getActiveMipmapLevel(),
            d = t.state;
        d.setBlending(0), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1);
        const p = v !== Si && this.type === Si,
            f = v === Si && this.type !== Si;
        for (let l = 0, c = e.length; l < c; l++) {
            const c = e[l],
                u = c.shadow;
            if (void 0 === u) {
                console.warn("THREE.WebGLShadowMap:", c, "has no shadow.");
                continue
            }
            if (!1 === u.autoUpdate && !1 === u.needsUpdate) continue;
            s.copy(u.mapSize);
            const m = u.getFrameExtents();
            if (s.multiply(m), r.copy(u.mapSize), (s.x > h || s.y > h) && (s.x > h && (r.x = Math.floor(h / m.x), s.x = r.x * m.x, u.mapSize.x = r.x), s.y > h && (r.y = Math.floor(h / m.y), s.y = r.y * m.y, u.mapSize.y = r.y)), null === u.map || !0 === p || !0 === f) {
                const t = this.type !== Si ? {
                    minFilter: Vt,
                    magFilter: Vt
                } : {};
                null !== u.map && u.map.dispose(), u.map = new nn(s.x, s.y, t), u.map.texture.name = c.name + ".shadowMap", u.camera.updateProjectionMatrix()
            }
            t.setRenderTarget(u.map), t.clear();
            const g = u.getViewportCount();
            for (let t = 0; t < g; t++) {
                const e = u.getViewport(t);
                o.set(r.x * e.x, r.y * e.y, r.x * e.z, r.y * e.w), d.viewport(o), u.updateMatrices(c, t), i = u.getFrustum(), b(n, a, u.camera, c, this.type)
            }!0 !== u.isPointLightShadow && this.type === Si && y(u, a), u.needsUpdate = !1
        }
        v = this.type, g.needsUpdate = !1, t.setRenderTarget(l, c, u)
    }
}

function QA(t) {
    const e = new function() {
            let e = !1;
            const n = new ot;
            let i = null;
            const s = new ot(0, 0, 0, 0);
            return {
                setMask: function(n) {
                    i !== n && !e && (t.colorMask(n, n, n, n), i = n)
                },
                setLocked: function(t) {
                    e = t
                },
                setClear: function(e, i, r, o, a) {
                    !0 === a && (e *= o, i *= o, r *= o), n.set(e, i, r, o), !1 === s.equals(n) && (t.clearColor(e, i, r, o), s.copy(n))
                },
                reset: function() {
                    e = !1, i = null, s.set(-1, 0, 0, 0)
                }
            }
        },
        n = new function() {
            let e = !1,
                n = null,
                i = null,
                s = null;
            return {
                setTest: function(e) {
                    e ? k(t.DEPTH_TEST) : z(t.DEPTH_TEST)
                },
                setMask: function(i) {
                    n !== i && !e && (t.depthMask(i), n = i)
                },
                setFunc: function(e) {
                    if (i !== e) {
                        switch (e) {
                            case 0:
                                t.depthFunc(t.NEVER);
                                break;
                            case 1:
                                t.depthFunc(t.ALWAYS);
                                break;
                            case 2:
                                t.depthFunc(t.LESS);
                                break;
                            case 3:
                            default:
                                t.depthFunc(t.LEQUAL);
                                break;
                            case 4:
                                t.depthFunc(t.EQUAL);
                                break;
                            case 5:
                                t.depthFunc(t.GEQUAL);
                                break;
                            case 6:
                                t.depthFunc(t.GREATER);
                                break;
                            case 7:
                                t.depthFunc(t.NOTEQUAL)
                        }
                        i = e
                    }
                },
                setLocked: function(t) {
                    e = t
                },
                setClear: function(e) {
                    s !== e && (t.clearDepth(e), s = e)
                },
                reset: function() {
                    e = !1, n = null, i = null, s = null
                }
            }
        },
        i = new function() {
            let e = !1,
                n = null,
                i = null,
                s = null,
                r = null,
                o = null,
                a = null,
                l = null,
                c = null;
            return {
                setTest: function(n) {
                    e || (n ? k(t.STENCIL_TEST) : z(t.STENCIL_TEST))
                },
                setMask: function(i) {
                    n !== i && !e && (t.stencilMask(i), n = i)
                },
                setFunc: function(e, n, o) {
                    (i !== e || s !== n || r !== o) && (t.stencilFunc(e, n, o), i = e, s = n, r = o)
                },
                setOp: function(e, n, i) {
                    (o !== e || a !== n || l !== i) && (t.stencilOp(e, n, i), o = e, a = n, l = i)
                },
                setLocked: function(t) {
                    e = t
                },
                setClear: function(e) {
                    c !== e && (t.clearStencil(e), c = e)
                },
                reset: function() {
                    e = !1, n = null, i = null, s = null, r = null, o = null, a = null, l = null, c = null
                }
            }
        },
        s = new WeakMap,
        r = new WeakMap;
    let o = {},
        a = {},
        l = new WeakMap,
        c = [],
        h = null,
        u = !1,
        d = null,
        p = null,
        f = null,
        m = null,
        g = null,
        v = null,
        y = null,
        x = new Le(0, 0, 0),
        b = 0,
        A = !1,
        S = null,
        w = null,
        _ = null,
        M = null,
        T = null;
    const E = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    let C = !1,
        R = 0;
    const P = t.getParameter(t.VERSION); - 1 !== P.indexOf("WebGL") ? (R = parseFloat(/^WebGL (\d)/.exec(P)[1]), C = R >= 1) : -1 !== P.indexOf("OpenGL ES") && (R = parseFloat(/^OpenGL ES (\d)/.exec(P)[1]), C = R >= 2);
    let D = null,
        I = {};
    const L = t.getParameter(t.SCISSOR_BOX),
        U = t.getParameter(t.VIEWPORT),
        O = (new ot).fromArray(L),
        B = (new ot).fromArray(U);

    function N(e, n, i, s) {
        const r = new Uint8Array(4),
            o = t.createTexture();
        t.bindTexture(e, o), t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST);
        for (let o = 0; o < i; o++) e === t.TEXTURE_3D || e === t.TEXTURE_2D_ARRAY ? t.texImage3D(n, 0, t.RGBA, 1, 1, s, 0, t.RGBA, t.UNSIGNED_BYTE, r) : t.texImage2D(n + o, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, r);
        return o
    }
    const F = {};

    function k(e) {
        !0 !== o[e] && (t.enable(e), o[e] = !0)
    }

    function z(e) {
        !1 !== o[e] && (t.disable(e), o[e] = !1)
    }
    F[t.TEXTURE_2D] = N(t.TEXTURE_2D, t.TEXTURE_2D, 1), F[t.TEXTURE_CUBE_MAP] = N(t.TEXTURE_CUBE_MAP, t.TEXTURE_CUBE_MAP_POSITIVE_X, 6), F[t.TEXTURE_2D_ARRAY] = N(t.TEXTURE_2D_ARRAY, t.TEXTURE_2D_ARRAY, 1, 1), F[t.TEXTURE_3D] = N(t.TEXTURE_3D, t.TEXTURE_3D, 1, 1), e.setClear(0, 0, 0, 1), n.setClear(1), i.setClear(0), k(t.DEPTH_TEST), n.setFunc(3), W(!1), j(1), k(t.CULL_FACE), V(0);
    const G = {
        [ms]: t.FUNC_ADD,
        [Xg]: t.FUNC_SUBTRACT,
        [jg]: t.FUNC_REVERSE_SUBTRACT
    };
    G[Kg] = t.MIN, G[Yg] = t.MAX;
    const H = {
        [Qg]: t.ZERO,
        [qg]: t.ONE,
        [Zg]: t.SRC_COLOR,
        [Ea]: t.SRC_ALPHA,
        [nv]: t.SRC_ALPHA_SATURATE,
        [ev]: t.DST_COLOR,
        [$f]: t.DST_ALPHA,
        [Jg]: t.ONE_MINUS_SRC_COLOR,
        [Pc]: t.ONE_MINUS_SRC_ALPHA,
        [tv]: t.ONE_MINUS_DST_COLOR,
        [$g]: t.ONE_MINUS_DST_ALPHA,
        [iv]: t.CONSTANT_COLOR,
        [sv]: t.ONE_MINUS_CONSTANT_COLOR,
        [rv]: t.CONSTANT_ALPHA,
        [ov]: t.ONE_MINUS_CONSTANT_ALPHA
    };

    function V(e, n, i, s, r, o, a, l, c, h) {
        if (0 !== e) {
            if (!1 === u && (k(t.BLEND), u = !0), 5 === e) r = r || n, o = o || i, a = a || s, (n !== p || r !== g) && (t.blendEquationSeparate(G[n], G[r]), p = n, g = r), (i !== f || s !== m || o !== v || a !== y) && (t.blendFuncSeparate(H[i], H[s], H[o], H[a]), f = i, m = s, v = o, y = a), (!1 === l.equals(x) || c !== b) && (t.blendColor(l.r, l.g, l.b, c), x.copy(l), b = c), d = e, A = !1;
            else if (e !== d || h !== A) {
                if ((p !== ms || g !== ms) && (t.blendEquation(t.FUNC_ADD), p = ms, g = ms), h) switch (e) {
                    case 1:
                        t.blendFuncSeparate(t.ONE, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA);
                        break;
                    case 2:
                        t.blendFunc(t.ONE, t.ONE);
                        break;
                    case 3:
                        t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE);
                        break;
                    case 4:
                        t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", e)
                } else switch (e) {
                    case 1:
                        t.blendFuncSeparate(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA);
                        break;
                    case 2:
                        t.blendFunc(t.SRC_ALPHA, t.ONE);
                        break;
                    case 3:
                        t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE);
                        break;
                    case 4:
                        t.blendFunc(t.ZERO, t.SRC_COLOR);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", e)
                }
                f = null, m = null, v = null, y = null, x.set(0, 0, 0), b = 0, d = e, A = h
            }
        } else !0 === u && (z(t.BLEND), u = !1)
    }

    function W(e) {
        S !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW), S = e)
    }

    function j(e) {
        0 !== e ? (k(t.CULL_FACE), e !== w && (1 === e ? t.cullFace(t.BACK) : 2 === e ? t.cullFace(t.FRONT) : t.cullFace(t.FRONT_AND_BACK))) : z(t.CULL_FACE), w = e
    }

    function X(e, n, i) {
        e ? (k(t.POLYGON_OFFSET_FILL), (M !== n || T !== i) && (t.polygonOffset(n, i), M = n, T = i)) : z(t.POLYGON_OFFSET_FILL)
    }
    return {
        buffers: {
            color: e,
            depth: n,
            stencil: i
        },
        enable: k,
        disable: z,
        bindFramebuffer: function(e, n) {
            return a[e] !== n && (t.bindFramebuffer(e, n), a[e] = n, e === t.DRAW_FRAMEBUFFER && (a[t.FRAMEBUFFER] = n), e === t.FRAMEBUFFER && (a[t.DRAW_FRAMEBUFFER] = n), !0)
        },
        drawBuffers: function(e, n) {
            let i = c,
                s = !1;
            if (e) {
                i = l.get(n), void 0 === i && (i = [], l.set(n, i));
                const r = e.textures;
                if (i.length !== r.length || i[0] !== t.COLOR_ATTACHMENT0) {
                    for (let e = 0, n = r.length; e < n; e++) i[e] = t.COLOR_ATTACHMENT0 + e;
                    i.length = r.length, s = !0
                }
            } else i[0] !== t.BACK && (i[0] = t.BACK, s = !0);
            s && t.drawBuffers(i)
        },
        useProgram: function(e) {
            return h !== e && (t.useProgram(e), h = e, !0)
        },
        setBlending: V,
        setMaterial: function(s, r) {
            2 === s.side ? z(t.CULL_FACE) : k(t.CULL_FACE);
            let o = s.side === Bt;
            r && (o = !o), W(o), 1 === s.blending && !1 === s.transparent ? V(0) : V(s.blending, s.blendEquation, s.blendSrc, s.blendDst, s.blendEquationAlpha, s.blendSrcAlpha, s.blendDstAlpha, s.blendColor, s.blendAlpha, s.premultipliedAlpha), n.setFunc(s.depthFunc), n.setTest(s.depthTest), n.setMask(s.depthWrite), e.setMask(s.colorWrite);
            const a = s.stencilWrite;
            i.setTest(a), a && (i.setMask(s.stencilWriteMask), i.setFunc(s.stencilFunc, s.stencilRef, s.stencilFuncMask), i.setOp(s.stencilFail, s.stencilZFail, s.stencilZPass)), X(s.polygonOffset, s.polygonOffsetFactor, s.polygonOffsetUnits), !0 === s.alphaToCoverage ? k(t.SAMPLE_ALPHA_TO_COVERAGE) : z(t.SAMPLE_ALPHA_TO_COVERAGE)
        },
        setFlipSided: W,
        setCullFace: j,
        setLineWidth: function(e) {
            e !== _ && (C && t.lineWidth(e), _ = e)
        },
        setPolygonOffset: X,
        setScissorTest: function(e) {
            e ? k(t.SCISSOR_TEST) : z(t.SCISSOR_TEST)
        },
        activeTexture: function(e) {
            void 0 === e && (e = t.TEXTURE0 + E - 1), D !== e && (t.activeTexture(e), D = e)
        },
        bindTexture: function(e, n, i) {
            void 0 === i && (i = null === D ? t.TEXTURE0 + E - 1 : D);
            let s = I[i];
            void 0 === s && (s = {
                type: void 0,
                texture: void 0
            }, I[i] = s), (s.type !== e || s.texture !== n) && (D !== i && (t.activeTexture(i), D = i), t.bindTexture(e, n || F[e]), s.type = e, s.texture = n)
        },
        unbindTexture: function() {
            const e = I[D];
            void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0)
        },
        compressedTexImage2D: function() {
            try {
                t.compressedTexImage2D.apply(t, arguments)
            } catch (t) {
                console.error("THREE.WebGLState:", t)
            }
        },
        compressedTexImage3D: function() {
            try {
                t.compressedTexImage3D.apply(t, arguments)
            } catch (t) {
                console.error("THREE.WebGLState:", t)
            }
        },
        texImage2D: function() {
            try {
                t.texImage2D.apply(t, arguments)
            } catch (t) {
                console.error("THREE.WebGLState:", t)
            }
        },
        texImage3D: function() {
            try {
                t.texImage3D.apply(t, arguments)
            } catch (t) {
                console.error("THREE.WebGLState:", t)
            }
        },
        updateUBOMapping: function(e, n) {
            let i = r.get(n);
            void 0 === i && (i = new WeakMap, r.set(n, i));
            let s = i.get(e);
            void 0 === s && (s = t.getUniformBlockIndex(n, e.name), i.set(e, s))
        },
        uniformBlockBinding: function(e, n) {
            const i = r.get(n).get(e);
            s.get(n) !== i && (t.uniformBlockBinding(n, i, e.__bindingPointIndex), s.set(n, i))
        },
        texStorage2D: function() {
            try {
                t.texStorage2D.apply(t, arguments)
            } catch (t) {
                console.error("THREE.WebGLState:", t)
            }
        },
        texStorage3D: function() {
            try {
                t.texStorage3D.apply(t, arguments)
            } catch (t) {
                console.error("THREE.WebGLState:", t)
            }
        },
        texSubImage2D: function() {
            try {
                t.texSubImage2D.apply(t, arguments)
            } catch (t) {
                console.error("THREE.WebGLState:", t)
            }
        },
        texSubImage3D: function() {
            try {
                t.texSubImage3D.apply(t, arguments)
            } catch (t) {
                console.error("THREE.WebGLState:", t)
            }
        },
        compressedTexSubImage2D: function() {
            try {
                t.compressedTexSubImage2D.apply(t, arguments)
            } catch (t) {
                console.error("THREE.WebGLState:", t)
            }
        },
        compressedTexSubImage3D: function() {
            try {
                t.compressedTexSubImage3D.apply(t, arguments)
            } catch (t) {
                console.error("THREE.WebGLState:", t)
            }
        },
        scissor: function(e) {
            !1 === O.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), O.copy(e))
        },
        viewport: function(e) {
            !1 === B.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), B.copy(e))
        },
        reset: function() {
            t.disable(t.BLEND), t.disable(t.CULL_FACE), t.disable(t.DEPTH_TEST), t.disable(t.POLYGON_OFFSET_FILL), t.disable(t.SCISSOR_TEST), t.disable(t.STENCIL_TEST), t.disable(t.SAMPLE_ALPHA_TO_COVERAGE), t.blendEquation(t.FUNC_ADD), t.blendFunc(t.ONE, t.ZERO), t.blendFuncSeparate(t.ONE, t.ZERO, t.ONE, t.ZERO), t.blendColor(0, 0, 0, 0), t.colorMask(!0, !0, !0, !0), t.clearColor(0, 0, 0, 0), t.depthMask(!0), t.depthFunc(t.LESS), t.clearDepth(1), t.stencilMask(4294967295), t.stencilFunc(t.ALWAYS, 0, 4294967295), t.stencilOp(t.KEEP, t.KEEP, t.KEEP), t.clearStencil(0), t.cullFace(t.BACK), t.frontFace(t.CCW), t.polygonOffset(0, 0), t.activeTexture(t.TEXTURE0), t.bindFramebuffer(t.FRAMEBUFFER, null), t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null), t.bindFramebuffer(t.READ_FRAMEBUFFER, null), t.useProgram(null), t.lineWidth(1), t.scissor(0, 0, t.canvas.width, t.canvas.height), t.viewport(0, 0, t.canvas.width, t.canvas.height), o = {}, D = null, I = {}, a = {}, l = new WeakMap, c = [], h = null, u = !1, d = null, p = null, f = null, m = null, g = null, v = null, y = null, x = new Le(0, 0, 0), b = 0, A = !1, S = null, w = null, _ = null, M = null, T = null, O.set(0, 0, t.canvas.width, t.canvas.height), B.set(0, 0, t.canvas.width, t.canvas.height), e.reset(), n.reset(), i.reset()
        }
    }
}

function qA(t, e, n, i, s, r, o) {
    const a = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null,
        l = !(typeof navigator > "u") && /OculusBrowser/g.test(navigator.userAgent),
        c = new Q,
        h = new WeakMap;
    let u;
    const d = new WeakMap;
    let p = !1;
    try {
        p = typeof OffscreenCanvas < "u" && null !== new OffscreenCanvas(1, 1).getContext("2d")
    } catch {}

    function f(t, e) {
        return p ? new OffscreenCanvas(t, e) : po("canvas")
    }

    function m(t, e, n) {
        let i = 1;
        const s = k(t);
        if ((s.width > n || s.height > n) && (i = n / Math.max(s.width, s.height)), i < 1) {
            if (typeof HTMLImageElement < "u" && t instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && t instanceof ImageBitmap || typeof VideoFrame < "u" && t instanceof VideoFrame) {
                const n = Math.floor(i * s.width),
                    r = Math.floor(i * s.height);
                void 0 === u && (u = f(n, r));
                const o = e ? f(n, r) : u;
                return o.width = n, o.height = r, o.getContext("2d").drawImage(t, 0, 0, n, r), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + s.width + "x" + s.height + ") to (" + n + "x" + r + ")."), o
            }
            return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + s.width + "x" + s.height + ")."), t
        }
        return t
    }

    function g(t) {
        return t.generateMipmaps && t.minFilter !== Vt && t.minFilter !== Ht
    }

    function v(e) {
        t.generateMipmap(e)
    }

    function y(n, i, s, r, o = !1) {
        if (null !== n) {
            if (void 0 !== t[n]) return t[n];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
        }
        let a = i;
        if (i === t.RED && (s === t.FLOAT && (a = t.R32F), s === t.HALF_FLOAT && (a = t.R16F), s === t.UNSIGNED_BYTE && (a = t.R8)), i === t.RED_INTEGER && (s === t.UNSIGNED_BYTE && (a = t.R8UI), s === t.UNSIGNED_SHORT && (a = t.R16UI), s === t.UNSIGNED_INT && (a = t.R32UI), s === t.BYTE && (a = t.R8I), s === t.SHORT && (a = t.R16I), s === t.INT && (a = t.R32I)), i === t.RG && (s === t.FLOAT && (a = t.RG32F), s === t.HALF_FLOAT && (a = t.RG16F), s === t.UNSIGNED_BYTE && (a = t.RG8)), i === t.RG_INTEGER && (s === t.UNSIGNED_BYTE && (a = t.RG8UI), s === t.UNSIGNED_SHORT && (a = t.RG16UI), s === t.UNSIGNED_INT && (a = t.RG32UI), s === t.BYTE && (a = t.RG8I), s === t.SHORT && (a = t.RG16I), s === t.INT && (a = t.RG32I)), i === t.RGB && s === t.UNSIGNED_INT_5_9_9_9_REV && (a = t.RGB9_E5), i === t.RGBA) {
            const e = o ? Pa : vt.getTransfer(r);
            s === t.FLOAT && (a = t.RGBA32F), s === t.HALF_FLOAT && (a = t.RGBA16F), s === t.UNSIGNED_BYTE && (a = e === St ? t.SRGB8_ALPHA8 : t.RGBA8), s === t.UNSIGNED_SHORT_4_4_4_4 && (a = t.RGBA4), s === t.UNSIGNED_SHORT_5_5_5_1 && (a = t.RGB5_A1)
        }
        return (a === t.R16F || a === t.R32F || a === t.RG16F || a === t.RG32F || a === t.RGBA16F || a === t.RGBA32F) && e.get("EXT_color_buffer_float"), a
    }

    function x(t, e) {
        return !0 === g(t) || t.isFramebufferTexture && t.minFilter !== Vt && t.minFilter !== Ht ? Math.log2(Math.max(e.width, e.height)) + 1 : void 0 !== t.mipmaps && t.mipmaps.length > 0 ? t.mipmaps.length : t.isCompressedTexture && Array.isArray(t.image) ? e.mipmaps.length : 1
    }

    function b(t) {
        const e = t.target;
        e.removeEventListener("dispose", b),
            function(t) {
                const e = i.get(t);
                if (void 0 === e.__webglInit) return;
                const n = t.source,
                    s = d.get(n);
                if (s) {
                    const i = s[e.__cacheKey];
                    i.usedTimes--, 0 === i.usedTimes && S(t), 0 === Object.keys(s).length && d.delete(n)
                }
                i.remove(t)
            }(e), e.isVideoTexture && h.delete(e)
    }

    function A(e) {
        const n = e.target;
        n.removeEventListener("dispose", A),
            function(e) {
                const n = i.get(e);
                if (e.depthTexture && e.depthTexture.dispose(), e.isWebGLCubeRenderTarget)
                    for (let e = 0; e < 6; e++) {
                        if (Array.isArray(n.__webglFramebuffer[e]))
                            for (let i = 0; i < n.__webglFramebuffer[e].length; i++) t.deleteFramebuffer(n.__webglFramebuffer[e][i]);
                        else t.deleteFramebuffer(n.__webglFramebuffer[e]);
                        n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer[e])
                    } else {
                        if (Array.isArray(n.__webglFramebuffer))
                            for (let e = 0; e < n.__webglFramebuffer.length; e++) t.deleteFramebuffer(n.__webglFramebuffer[e]);
                        else t.deleteFramebuffer(n.__webglFramebuffer);
                        if (n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer), n.__webglMultisampledFramebuffer && t.deleteFramebuffer(n.__webglMultisampledFramebuffer), n.__webglColorRenderbuffer)
                            for (let e = 0; e < n.__webglColorRenderbuffer.length; e++) n.__webglColorRenderbuffer[e] && t.deleteRenderbuffer(n.__webglColorRenderbuffer[e]);
                        n.__webglDepthRenderbuffer && t.deleteRenderbuffer(n.__webglDepthRenderbuffer)
                    }
                const s = e.textures;
                for (let e = 0, n = s.length; e < n; e++) {
                    const n = i.get(s[e]);
                    n.__webglTexture && (t.deleteTexture(n.__webglTexture), o.memory.textures--), i.remove(s[e])
                }
                i.remove(e)
            }(n)
    }

    function S(e) {
        const n = i.get(e);
        t.deleteTexture(n.__webglTexture);
        const s = e.source;
        delete d.get(s)[n.__cacheKey], o.memory.textures--
    }
    let w = 0;

    function _(e, s) {
        const r = i.get(e);
        if (e.isVideoTexture && function(t) {
                const e = o.render.frame;
                h.get(t) !== e && (h.set(t, e), t.update())
            }(e), !1 === e.isRenderTargetTexture && e.version > 0 && r.__version !== e.version) {
            const t = e.image;
            if (null === t) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            else {
                if (!1 !== t.complete) return void P(r, e, s);
                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
            }
        }
        n.bindTexture(t.TEXTURE_2D, r.__webglTexture, t.TEXTURE0 + s)
    }
    const M = {
            [$i]: t.REPEAT,
            [Yi]: t.CLAMP_TO_EDGE,
            [Ca]: t.MIRRORED_REPEAT
        },
        T = {
            [Vt]: t.NEAREST,
            [tp]: t.NEAREST_MIPMAP_NEAREST,
            [to]: t.NEAREST_MIPMAP_LINEAR,
            [Ht]: t.LINEAR,
            [wa]: t.LINEAR_MIPMAP_NEAREST,
            [Ei]: t.LINEAR_MIPMAP_LINEAR
        },
        E = {
            [Iv]: t.NEVER,
            [Fv]: t.ALWAYS,
            [Lv]: t.LESS,
            [up]: t.LEQUAL,
            [Ov]: t.EQUAL,
            [Nv]: t.GEQUAL,
            [Bv]: t.GREATER,
            [Uv]: t.NOTEQUAL
        };

    function C(n, r) {
        if (r.type === oi && !1 === e.has("OES_texture_float_linear") && (r.magFilter === Ht || r.magFilter === wa || r.magFilter === to || r.magFilter === Ei || r.minFilter === Ht || r.minFilter === wa || r.minFilter === to || r.minFilter === Ei) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), t.texParameteri(n, t.TEXTURE_WRAP_S, M[r.wrapS]), t.texParameteri(n, t.TEXTURE_WRAP_T, M[r.wrapT]), (n === t.TEXTURE_3D || n === t.TEXTURE_2D_ARRAY) && t.texParameteri(n, t.TEXTURE_WRAP_R, M[r.wrapR]), t.texParameteri(n, t.TEXTURE_MAG_FILTER, T[r.magFilter]), t.texParameteri(n, t.TEXTURE_MIN_FILTER, T[r.minFilter]), r.compareFunction && (t.texParameteri(n, t.TEXTURE_COMPARE_MODE, t.COMPARE_REF_TO_TEXTURE), t.texParameteri(n, t.TEXTURE_COMPARE_FUNC, E[r.compareFunction])), !0 === e.has("EXT_texture_filter_anisotropic")) {
            if (r.magFilter === Vt || r.minFilter !== to && r.minFilter !== Ei || r.type === oi && !1 === e.has("OES_texture_float_linear")) return;
            if (r.anisotropy > 1 || i.get(r).__currentAnisotropy) {
                const o = e.get("EXT_texture_filter_anisotropic");
                t.texParameterf(n, o.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(r.anisotropy, s.getMaxAnisotropy())), i.get(r).__currentAnisotropy = r.anisotropy
            }
        }
    }

    function R(e, n) {
        let i = !1;
        void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", b));
        const s = n.source;
        let r = d.get(s);
        void 0 === r && (r = {}, d.set(s, r));
        const a = function(t) {
            const e = [];
            return e.push(t.wrapS), e.push(t.wrapT), e.push(t.wrapR || 0), e.push(t.magFilter), e.push(t.minFilter), e.push(t.anisotropy), e.push(t.internalFormat), e.push(t.format), e.push(t.type), e.push(t.generateMipmaps), e.push(t.premultiplyAlpha), e.push(t.flipY), e.push(t.unpackAlignment), e.push(t.colorSpace), e.join()
        }(n);
        if (a !== e.__cacheKey) {
            void 0 === r[a] && (r[a] = {
                texture: t.createTexture(),
                usedTimes: 0
            }, o.memory.textures++, i = !0), r[a].usedTimes++;
            const s = r[e.__cacheKey];
            void 0 !== s && (r[e.__cacheKey].usedTimes--, 0 === s.usedTimes && S(n)), e.__cacheKey = a, e.__webglTexture = r[a].texture
        }
        return i
    }

    function P(e, o, a) {
        let l = t.TEXTURE_2D;
        (o.isDataArrayTexture || o.isCompressedArrayTexture) && (l = t.TEXTURE_2D_ARRAY), o.isData3DTexture && (l = t.TEXTURE_3D);
        const c = R(e, o),
            h = o.source;
        n.bindTexture(l, e.__webglTexture, t.TEXTURE0 + a);
        const u = i.get(h);
        if (h.version !== u.__version || !0 === c) {
            n.activeTexture(t.TEXTURE0 + a);
            const e = vt.getPrimaries(vt.workingColorSpace),
                i = "" === o.colorSpace ? null : vt.getPrimaries(o.colorSpace),
                d = "" === o.colorSpace || e === i ? t.NONE : t.BROWSER_DEFAULT_WEBGL;
            t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, o.flipY), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, o.premultiplyAlpha), t.pixelStorei(t.UNPACK_ALIGNMENT, o.unpackAlignment), t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, d);
            let p = m(o.image, !1, s.maxTextureSize);
            p = F(o, p);
            const f = r.convert(o.format, o.colorSpace),
                b = r.convert(o.type);
            let A, S = y(o.internalFormat, f, b, o.colorSpace, o.isVideoTexture);
            C(l, o);
            const w = o.mipmaps,
                _ = !0 !== o.isVideoTexture,
                M = void 0 === u.__version || !0 === c,
                T = h.dataReady,
                E = x(o, p);
            if (o.isDepthTexture) S = t.DEPTH_COMPONENT16, o.type === oi ? S = t.DEPTH_COMPONENT32F : o.type === Cs ? S = t.DEPTH_COMPONENT24 : o.type === Dr && (S = t.DEPTH24_STENCIL8), M && (_ ? n.texStorage2D(t.TEXTURE_2D, 1, S, p.width, p.height) : n.texImage2D(t.TEXTURE_2D, 0, S, p.width, p.height, 0, f, b, null));
            else if (o.isDataTexture)
                if (w.length > 0) {
                    _ && M && n.texStorage2D(t.TEXTURE_2D, E, S, w[0].width, w[0].height);
                    for (let e = 0, i = w.length; e < i; e++) A = w[e], _ ? T && n.texSubImage2D(t.TEXTURE_2D, e, 0, 0, A.width, A.height, f, b, A.data) : n.texImage2D(t.TEXTURE_2D, e, S, A.width, A.height, 0, f, b, A.data);
                    o.generateMipmaps = !1
                } else _ ? (M && n.texStorage2D(t.TEXTURE_2D, E, S, p.width, p.height), T && n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, p.width, p.height, f, b, p.data)) : n.texImage2D(t.TEXTURE_2D, 0, S, p.width, p.height, 0, f, b, p.data);
            else if (o.isCompressedTexture)
                if (o.isCompressedArrayTexture) {
                    _ && M && n.texStorage3D(t.TEXTURE_2D_ARRAY, E, S, w[0].width, w[0].height, p.depth);
                    for (let e = 0, i = w.length; e < i; e++) A = w[e], o.format !== Nn ? null !== f ? _ ? T && n.compressedTexSubImage3D(t.TEXTURE_2D_ARRAY, e, 0, 0, 0, A.width, A.height, p.depth, f, A.data, 0, 0) : n.compressedTexImage3D(t.TEXTURE_2D_ARRAY, e, S, A.width, A.height, p.depth, 0, A.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : _ ? T && n.texSubImage3D(t.TEXTURE_2D_ARRAY, e, 0, 0, 0, A.width, A.height, p.depth, f, b, A.data) : n.texImage3D(t.TEXTURE_2D_ARRAY, e, S, A.width, A.height, p.depth, 0, f, b, A.data)
                } else {
                    _ && M && n.texStorage2D(t.TEXTURE_2D, E, S, w[0].width, w[0].height);
                    for (let e = 0, i = w.length; e < i; e++) A = w[e], o.format !== Nn ? null !== f ? _ ? T && n.compressedTexSubImage2D(t.TEXTURE_2D, e, 0, 0, A.width, A.height, f, A.data) : n.compressedTexImage2D(t.TEXTURE_2D, e, S, A.width, A.height, 0, A.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : _ ? T && n.texSubImage2D(t.TEXTURE_2D, e, 0, 0, A.width, A.height, f, b, A.data) : n.texImage2D(t.TEXTURE_2D, e, S, A.width, A.height, 0, f, b, A.data)
                }
            else if (o.isDataArrayTexture) _ ? (M && n.texStorage3D(t.TEXTURE_2D_ARRAY, E, S, p.width, p.height, p.depth), T && n.texSubImage3D(t.TEXTURE_2D_ARRAY, 0, 0, 0, 0, p.width, p.height, p.depth, f, b, p.data)) : n.texImage3D(t.TEXTURE_2D_ARRAY, 0, S, p.width, p.height, p.depth, 0, f, b, p.data);
            else if (o.isData3DTexture) _ ? (M && n.texStorage3D(t.TEXTURE_3D, E, S, p.width, p.height, p.depth), T && n.texSubImage3D(t.TEXTURE_3D, 0, 0, 0, 0, p.width, p.height, p.depth, f, b, p.data)) : n.texImage3D(t.TEXTURE_3D, 0, S, p.width, p.height, p.depth, 0, f, b, p.data);
            else if (o.isFramebufferTexture) {
                if (M)
                    if (_) n.texStorage2D(t.TEXTURE_2D, E, S, p.width, p.height);
                    else {
                        let e = p.width,
                            i = p.height;
                        for (let s = 0; s < E; s++) n.texImage2D(t.TEXTURE_2D, s, S, e, i, 0, f, b, null), e >>= 1, i >>= 1
                    }
            } else if (w.length > 0) {
                if (_ && M) {
                    const e = k(w[0]);
                    n.texStorage2D(t.TEXTURE_2D, E, S, e.width, e.height)
                }
                for (let e = 0, i = w.length; e < i; e++) A = w[e], _ ? T && n.texSubImage2D(t.TEXTURE_2D, e, 0, 0, f, b, A) : n.texImage2D(t.TEXTURE_2D, e, S, f, b, A);
                o.generateMipmaps = !1
            } else if (_) {
                if (M) {
                    const e = k(p);
                    n.texStorage2D(t.TEXTURE_2D, E, S, e.width, e.height)
                }
                T && n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, f, b, p)
            } else n.texImage2D(t.TEXTURE_2D, 0, S, f, b, p);
            g(o) && v(l), u.__version = h.version, o.onUpdate && o.onUpdate(o)
        }
        e.__version = o.version
    }

    function D(e, s, o, l, c, h) {
        const u = r.convert(o.format, o.colorSpace),
            d = r.convert(o.type),
            p = y(o.internalFormat, u, d, o.colorSpace);
        if (!i.get(s).__hasExternalTextures) {
            const e = Math.max(1, s.width >> h),
                i = Math.max(1, s.height >> h);
            c === t.TEXTURE_3D || c === t.TEXTURE_2D_ARRAY ? n.texImage3D(c, h, p, e, i, s.depth, 0, u, d, null) : n.texImage2D(c, h, p, e, i, 0, u, d, null)
        }
        n.bindFramebuffer(t.FRAMEBUFFER, e), N(s) ? a.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, l, c, i.get(o).__webglTexture, 0, B(s)) : (c === t.TEXTURE_2D || c >= t.TEXTURE_CUBE_MAP_POSITIVE_X && c <= t.TEXTURE_CUBE_MAP_NEGATIVE_Z) && t.framebufferTexture2D(t.FRAMEBUFFER, l, c, i.get(o).__webglTexture, h), n.bindFramebuffer(t.FRAMEBUFFER, null)
    }

    function I(e, n, i) {
        if (t.bindRenderbuffer(t.RENDERBUFFER, e), n.depthBuffer && !n.stencilBuffer) {
            let s = t.DEPTH_COMPONENT24;
            if (i || N(n)) {
                const e = n.depthTexture;
                e && e.isDepthTexture && (e.type === oi ? s = t.DEPTH_COMPONENT32F : e.type === Cs && (s = t.DEPTH_COMPONENT24));
                const i = B(n);
                N(n) ? a.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, i, s, n.width, n.height) : t.renderbufferStorageMultisample(t.RENDERBUFFER, i, s, n.width, n.height)
            } else t.renderbufferStorage(t.RENDERBUFFER, s, n.width, n.height);
            t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, e)
        } else if (n.depthBuffer && n.stencilBuffer) {
            const s = B(n);
            i && !1 === N(n) ? t.renderbufferStorageMultisample(t.RENDERBUFFER, s, t.DEPTH24_STENCIL8, n.width, n.height) : N(n) ? a.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, s, t.DEPTH24_STENCIL8, n.width, n.height) : t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_STENCIL, n.width, n.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, e)
        } else {
            const e = n.textures;
            for (let s = 0; s < e.length; s++) {
                const o = e[s],
                    l = r.convert(o.format, o.colorSpace),
                    c = r.convert(o.type),
                    h = y(o.internalFormat, l, c, o.colorSpace),
                    u = B(n);
                i && !1 === N(n) ? t.renderbufferStorageMultisample(t.RENDERBUFFER, u, h, n.width, n.height) : N(n) ? a.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, u, h, n.width, n.height) : t.renderbufferStorage(t.RENDERBUFFER, h, n.width, n.height)
            }
        }
        t.bindRenderbuffer(t.RENDERBUFFER, null)
    }

    function L(e) {
        const s = i.get(e),
            r = !0 === e.isWebGLCubeRenderTarget;
        if (e.depthTexture && !s.__autoAllocateDepthBuffer) {
            if (r) throw new Error("target.depthTexture not supported in Cube render targets");
            ! function(e, s) {
                if (s && s.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                if (n.bindFramebuffer(t.FRAMEBUFFER, e), !s.depthTexture || !s.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                (!i.get(s.depthTexture).__webglTexture || s.depthTexture.image.width !== s.width || s.depthTexture.image.height !== s.height) && (s.depthTexture.image.width = s.width, s.depthTexture.image.height = s.height, s.depthTexture.needsUpdate = !0), _(s.depthTexture, 0);
                const r = i.get(s.depthTexture).__webglTexture,
                    o = B(s);
                if (s.depthTexture.format === Ms) N(s) ? a.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, r, 0, o) : t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, r, 0);
                else {
                    if (s.depthTexture.format !== Ps) throw new Error("Unknown depthTexture format");
                    N(s) ? a.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, r, 0, o) : t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, r, 0)
                }
            }(s.__webglFramebuffer, e)
        } else if (r) {
            s.__webglDepthbuffer = [];
            for (let i = 0; i < 6; i++) n.bindFramebuffer(t.FRAMEBUFFER, s.__webglFramebuffer[i]), s.__webglDepthbuffer[i] = t.createRenderbuffer(), I(s.__webglDepthbuffer[i], e, !1)
        } else n.bindFramebuffer(t.FRAMEBUFFER, s.__webglFramebuffer), s.__webglDepthbuffer = t.createRenderbuffer(), I(s.__webglDepthbuffer, e, !1);
        n.bindFramebuffer(t.FRAMEBUFFER, null)
    }
    const U = [],
        O = [];

    function B(t) {
        return Math.min(s.maxSamples, t.samples)
    }

    function N(t) {
        const n = i.get(t);
        return t.samples > 0 && !0 === e.has("WEBGL_multisampled_render_to_texture") && !1 !== n.__useRenderToTexture
    }

    function F(t, e) {
        const n = t.colorSpace,
            i = t.format,
            s = t.type;
        return !0 === t.isCompressedTexture || !0 === t.isVideoTexture || n !== Zn && "" !== n && (vt.getTransfer(n) === St ? (i !== Nn || s !== Qt) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", n)), e
    }

    function k(t) {
        return typeof HTMLImageElement < "u" && t instanceof HTMLImageElement ? (c.width = t.naturalWidth || t.width, c.height = t.naturalHeight || t.height) : typeof VideoFrame < "u" && t instanceof VideoFrame ? (c.width = t.displayWidth, c.height = t.displayHeight) : (c.width = t.width, c.height = t.height), c
    }
    this.allocateTextureUnit = function() {
        const t = w;
        return t >= s.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + s.maxTextures), w += 1, t
    }, this.resetTextureUnits = function() {
        w = 0
    }, this.setTexture2D = _, this.setTexture2DArray = function(e, s) {
        const r = i.get(e);
        e.version > 0 && r.__version !== e.version ? P(r, e, s) : n.bindTexture(t.TEXTURE_2D_ARRAY, r.__webglTexture, t.TEXTURE0 + s)
    }, this.setTexture3D = function(e, s) {
        const r = i.get(e);
        e.version > 0 && r.__version !== e.version ? P(r, e, s) : n.bindTexture(t.TEXTURE_3D, r.__webglTexture, t.TEXTURE0 + s)
    }, this.setTextureCube = function(e, o) {
        const a = i.get(e);
        e.version > 0 && a.__version !== e.version ? function(e, o, a) {
            if (6 !== o.image.length) return;
            const l = R(e, o),
                c = o.source;
            n.bindTexture(t.TEXTURE_CUBE_MAP, e.__webglTexture, t.TEXTURE0 + a);
            const h = i.get(c);
            if (c.version !== h.__version || !0 === l) {
                n.activeTexture(t.TEXTURE0 + a);
                const e = vt.getPrimaries(vt.workingColorSpace),
                    i = "" === o.colorSpace ? null : vt.getPrimaries(o.colorSpace),
                    u = "" === o.colorSpace || e === i ? t.NONE : t.BROWSER_DEFAULT_WEBGL;
                t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, o.flipY), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, o.premultiplyAlpha), t.pixelStorei(t.UNPACK_ALIGNMENT, o.unpackAlignment), t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, u);
                const d = o.isCompressedTexture || o.image[0].isCompressedTexture,
                    p = o.image[0] && o.image[0].isDataTexture,
                    f = [];
                for (let t = 0; t < 6; t++) f[t] = d || p ? p ? o.image[t].image : o.image[t] : m(o.image[t], !0, s.maxCubemapSize), f[t] = F(o, f[t]);
                const b = f[0],
                    A = r.convert(o.format, o.colorSpace),
                    S = r.convert(o.type),
                    w = y(o.internalFormat, A, S, o.colorSpace),
                    _ = !0 !== o.isVideoTexture,
                    M = void 0 === h.__version || !0 === l,
                    T = c.dataReady;
                let E, R = x(o, b);
                if (C(t.TEXTURE_CUBE_MAP, o), d) {
                    _ && M && n.texStorage2D(t.TEXTURE_CUBE_MAP, R, w, b.width, b.height);
                    for (let e = 0; e < 6; e++) {
                        E = f[e].mipmaps;
                        for (let i = 0; i < E.length; i++) {
                            const s = E[i];
                            o.format !== Nn ? null !== A ? _ ? T && n.compressedTexSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i, 0, 0, s.width, s.height, A, s.data) : n.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i, w, s.width, s.height, 0, s.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : _ ? T && n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i, 0, 0, s.width, s.height, A, S, s.data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i, w, s.width, s.height, 0, A, S, s.data)
                        }
                    }
                } else {
                    if (E = o.mipmaps, _ && M) {
                        E.length > 0 && R++;
                        const e = k(f[0]);
                        n.texStorage2D(t.TEXTURE_CUBE_MAP, R, w, e.width, e.height)
                    }
                    for (let e = 0; e < 6; e++)
                        if (p) {
                            _ ? T && n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, 0, 0, f[e].width, f[e].height, A, S, f[e].data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, w, f[e].width, f[e].height, 0, A, S, f[e].data);
                            for (let i = 0; i < E.length; i++) {
                                const s = E[i].image[e].image;
                                _ ? T && n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i + 1, 0, 0, s.width, s.height, A, S, s.data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i + 1, w, s.width, s.height, 0, A, S, s.data)
                            }
                        } else {
                            _ ? T && n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, 0, 0, A, S, f[e]) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, w, A, S, f[e]);
                            for (let i = 0; i < E.length; i++) {
                                const s = E[i];
                                _ ? T && n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i + 1, 0, 0, A, S, s.image[e]) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i + 1, w, A, S, s.image[e])
                            }
                        }
                }
                g(o) && v(t.TEXTURE_CUBE_MAP), h.__version = c.version, o.onUpdate && o.onUpdate(o)
            }
            e.__version = o.version
        }(a, e, o) : n.bindTexture(t.TEXTURE_CUBE_MAP, a.__webglTexture, t.TEXTURE0 + o)
    }, this.rebindTextures = function(e, n, s) {
        const r = i.get(e);
        void 0 !== n && D(r.__webglFramebuffer, e, e.texture, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, 0), void 0 !== s && L(e)
    }, this.setupRenderTarget = function(e) {
        const s = e.texture,
            a = i.get(e),
            l = i.get(s);
        e.addEventListener("dispose", A);
        const c = e.textures,
            h = !0 === e.isWebGLCubeRenderTarget,
            u = c.length > 1;
        if (u || (void 0 === l.__webglTexture && (l.__webglTexture = t.createTexture()), l.__version = s.version, o.memory.textures++), h) {
            a.__webglFramebuffer = [];
            for (let e = 0; e < 6; e++)
                if (s.mipmaps && s.mipmaps.length > 0) {
                    a.__webglFramebuffer[e] = [];
                    for (let n = 0; n < s.mipmaps.length; n++) a.__webglFramebuffer[e][n] = t.createFramebuffer()
                } else a.__webglFramebuffer[e] = t.createFramebuffer()
        } else {
            if (s.mipmaps && s.mipmaps.length > 0) {
                a.__webglFramebuffer = [];
                for (let e = 0; e < s.mipmaps.length; e++) a.__webglFramebuffer[e] = t.createFramebuffer()
            } else a.__webglFramebuffer = t.createFramebuffer();
            if (u)
                for (let e = 0, n = c.length; e < n; e++) {
                    const n = i.get(c[e]);
                    void 0 === n.__webglTexture && (n.__webglTexture = t.createTexture(), o.memory.textures++)
                }
            if (e.samples > 0 && !1 === N(e)) {
                a.__webglMultisampledFramebuffer = t.createFramebuffer(), a.__webglColorRenderbuffer = [], n.bindFramebuffer(t.FRAMEBUFFER, a.__webglMultisampledFramebuffer);
                for (let n = 0; n < c.length; n++) {
                    const i = c[n];
                    a.__webglColorRenderbuffer[n] = t.createRenderbuffer(), t.bindRenderbuffer(t.RENDERBUFFER, a.__webglColorRenderbuffer[n]);
                    const s = r.convert(i.format, i.colorSpace),
                        o = r.convert(i.type),
                        l = y(i.internalFormat, s, o, i.colorSpace, !0 === e.isXRRenderTarget),
                        h = B(e);
                    t.renderbufferStorageMultisample(t.RENDERBUFFER, h, l, e.width, e.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + n, t.RENDERBUFFER, a.__webglColorRenderbuffer[n])
                }
                t.bindRenderbuffer(t.RENDERBUFFER, null), e.depthBuffer && (a.__webglDepthRenderbuffer = t.createRenderbuffer(), I(a.__webglDepthRenderbuffer, e, !0)), n.bindFramebuffer(t.FRAMEBUFFER, null)
            }
        }
        if (h) {
            n.bindTexture(t.TEXTURE_CUBE_MAP, l.__webglTexture), C(t.TEXTURE_CUBE_MAP, s);
            for (let n = 0; n < 6; n++)
                if (s.mipmaps && s.mipmaps.length > 0)
                    for (let i = 0; i < s.mipmaps.length; i++) D(a.__webglFramebuffer[n][i], e, s, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + n, i);
                else D(a.__webglFramebuffer[n], e, s, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + n, 0);
            g(s) && v(t.TEXTURE_CUBE_MAP), n.unbindTexture()
        } else if (u) {
            for (let s = 0, r = c.length; s < r; s++) {
                const r = c[s],
                    o = i.get(r);
                n.bindTexture(t.TEXTURE_2D, o.__webglTexture), C(t.TEXTURE_2D, r), D(a.__webglFramebuffer, e, r, t.COLOR_ATTACHMENT0 + s, t.TEXTURE_2D, 0), g(r) && v(t.TEXTURE_2D)
            }
            n.unbindTexture()
        } else {
            let i = t.TEXTURE_2D;
            if ((e.isWebGL3DRenderTarget || e.isWebGLArrayRenderTarget) && (i = e.isWebGL3DRenderTarget ? t.TEXTURE_3D : t.TEXTURE_2D_ARRAY), n.bindTexture(i, l.__webglTexture), C(i, s), s.mipmaps && s.mipmaps.length > 0)
                for (let n = 0; n < s.mipmaps.length; n++) D(a.__webglFramebuffer[n], e, s, t.COLOR_ATTACHMENT0, i, n);
            else D(a.__webglFramebuffer, e, s, t.COLOR_ATTACHMENT0, i, 0);
            g(s) && v(i), n.unbindTexture()
        }
        e.depthBuffer && L(e)
    }, this.updateRenderTargetMipmap = function(e) {
        const s = e.textures;
        for (let r = 0, o = s.length; r < o; r++) {
            const o = s[r];
            if (g(o)) {
                const s = e.isWebGLCubeRenderTarget ? t.TEXTURE_CUBE_MAP : t.TEXTURE_2D,
                    r = i.get(o).__webglTexture;
                n.bindTexture(s, r), v(s), n.unbindTexture()
            }
        }
    }, this.updateMultisampleRenderTarget = function(e) {
        if (e.samples > 0)
            if (!1 === N(e)) {
                const s = e.textures,
                    r = e.width,
                    o = e.height;
                let a = t.COLOR_BUFFER_BIT;
                const c = e.stencilBuffer ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT,
                    h = i.get(e),
                    u = s.length > 1;
                if (u)
                    for (let e = 0; e < s.length; e++) n.bindFramebuffer(t.FRAMEBUFFER, h.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + e, t.RENDERBUFFER, null), n.bindFramebuffer(t.FRAMEBUFFER, h.__webglFramebuffer), t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0 + e, t.TEXTURE_2D, null, 0);
                n.bindFramebuffer(t.READ_FRAMEBUFFER, h.__webglMultisampledFramebuffer), n.bindFramebuffer(t.DRAW_FRAMEBUFFER, h.__webglFramebuffer);
                for (let n = 0; n < s.length; n++) {
                    if (e.resolveDepthBuffer && (e.depthBuffer && (a |= t.DEPTH_BUFFER_BIT), e.stencilBuffer && e.resolveStencilBuffer && (a |= t.STENCIL_BUFFER_BIT)), u) {
                        t.framebufferRenderbuffer(t.READ_FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.RENDERBUFFER, h.__webglColorRenderbuffer[n]);
                        const e = i.get(s[n]).__webglTexture;
                        t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, e, 0)
                    }
                    t.blitFramebuffer(0, 0, r, o, 0, 0, r, o, a, t.NEAREST), !0 === l && (U.length = 0, O.length = 0, U.push(t.COLOR_ATTACHMENT0 + n), e.depthBuffer && !1 === e.resolveDepthBuffer && (U.push(c), O.push(c), t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER, O)), t.invalidateFramebuffer(t.READ_FRAMEBUFFER, U))
                }
                if (n.bindFramebuffer(t.READ_FRAMEBUFFER, null), n.bindFramebuffer(t.DRAW_FRAMEBUFFER, null), u)
                    for (let e = 0; e < s.length; e++) {
                        n.bindFramebuffer(t.FRAMEBUFFER, h.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + e, t.RENDERBUFFER, h.__webglColorRenderbuffer[e]);
                        const r = i.get(s[e]).__webglTexture;
                        n.bindFramebuffer(t.FRAMEBUFFER, h.__webglFramebuffer), t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0 + e, t.TEXTURE_2D, r, 0)
                    }
                n.bindFramebuffer(t.DRAW_FRAMEBUFFER, h.__webglMultisampledFramebuffer)
            } else if (e.depthBuffer && !1 === e.resolveDepthBuffer && l) {
            const n = e.stencilBuffer ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT;
            t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER, [n])
        }
    }, this.setupDepthRenderbuffer = L, this.setupFrameBufferTexture = D, this.useMultisampledRTT = N
}

function ZA(t, e) {
    return {
        convert: function(n, i = "") {
            let s;
            const r = vt.getTransfer(i);
            if (n === Qt) return t.UNSIGNED_BYTE;
            if (n === sp) return t.UNSIGNED_SHORT_4_4_4_4;
            if (n === rp) return t.UNSIGNED_SHORT_5_5_5_1;
            if (n === Mv) return t.UNSIGNED_INT_5_9_9_9_REV;
            if (n === _v) return t.BYTE;
            if (n === wv) return t.SHORT;
            if (n === np) return t.UNSIGNED_SHORT;
            if (n === ip) return t.INT;
            if (n === Cs) return t.UNSIGNED_INT;
            if (n === oi) return t.FLOAT;
            if (n === Ha) return t.HALF_FLOAT;
            if (n === op) return t.ALPHA;
            if (n === Ev) return t.RGB;
            if (n === Nn) return t.RGBA;
            if (n === ap) return t.LUMINANCE;
            if (n === lp) return t.LUMINANCE_ALPHA;
            if (n === Ms) return t.DEPTH_COMPONENT;
            if (n === Ps) return t.DEPTH_STENCIL;
            if (n === sh) return t.RED;
            if (n === rh) return t.RED_INTEGER;
            if (n === cp) return t.RG;
            if (n === oh) return t.RG_INTEGER;
            if (n === ah) return t.RGBA_INTEGER;
            if (n === Al || n === Sl || n === _l || n === wl)
                if (r === St) {
                    if (s = e.get("WEBGL_compressed_texture_s3tc_srgb"), null === s) return null;
                    if (n === Al) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    if (n === Sl) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    if (n === _l) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                    if (n === wl) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                } else {
                    if (s = e.get("WEBGL_compressed_texture_s3tc"), null === s) return null;
                    if (n === Al) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (n === Sl) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (n === _l) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (n === wl) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT
                }
            if (n === mu || n === gu || n === vu || n === yu) {
                if (s = e.get("WEBGL_compressed_texture_pvrtc"), null === s) return null;
                if (n === mu) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (n === gu) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (n === vu) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (n === yu) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            }
            if (n === xu || n === bu || n === Au) {
                if (s = e.get("WEBGL_compressed_texture_etc"), null === s) return null;
                if (n === xu || n === bu) return r === St ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
                if (n === Au) return r === St ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : s.COMPRESSED_RGBA8_ETC2_EAC
            }
            if (n === Su || n === _u || n === wu || n === Mu || n === Eu || n === Tu || n === Cu || n === Pu || n === Ru || n === Du || n === Iu || n === Lu || n === Ou || n === Bu) {
                if (s = e.get("WEBGL_compressed_texture_astc"), null === s) return null;
                if (n === Su) return r === St ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (n === _u) return r === St ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (n === wu) return r === St ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (n === Mu) return r === St ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (n === Eu) return r === St ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (n === Tu) return r === St ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (n === Cu) return r === St ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (n === Pu) return r === St ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (n === Ru) return r === St ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (n === Du) return r === St ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (n === Iu) return r === St ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (n === Lu) return r === St ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (n === Ou) return r === St ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (n === Bu) return r === St ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : s.COMPRESSED_RGBA_ASTC_12x12_KHR
            }
            if (n === Ml || n === Uu || n === Nu) {
                if (s = e.get("EXT_texture_compression_bptc"), null === s) return null;
                if (n === Ml) return r === St ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : s.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                if (n === Uu) return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                if (n === Nu) return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
            }
            if (n === Tv || n === Fu || n === ku || n === zu) {
                if (s = e.get("EXT_texture_compression_rgtc"), null === s) return null;
                if (n === Ml) return s.COMPRESSED_RED_RGTC1_EXT;
                if (n === Fu) return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                if (n === ku) return s.COMPRESSED_RED_GREEN_RGTC2_EXT;
                if (n === zu) return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
            }
            return n === Dr ? t.UNSIGNED_INT_24_8 : void 0 !== t[n] ? t[n] : null
        }
    }
}
class JA extends Pt {
    constructor(t = []) {
        super(), this.isArrayCamera = !0, this.cameras = t
    }
}
let Fn = class extends ct {
    constructor() {
        super(), this.isGroup = !0, this.type = "Group"
    }
};
const $A = {
    type: "move"
};
class Zl {
    constructor() {
        this._targetRay = null, this._grip = null, this._hand = null
    }
    getHandSpace() {
        return null === this._hand && (this._hand = new Fn, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
            pinching: !1
        }), this._hand
    }
    getTargetRaySpace() {
        return null === this._targetRay && (this._targetRay = new Fn, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new U, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new U), this._targetRay
    }
    getGripSpace() {
        return null === this._grip && (this._grip = new Fn, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new U, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new U), this._grip
    }
    dispatchEvent(t) {
        return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this
    }
    connect(t) {
        if (t && t.hand) {
            const e = this._hand;
            if (e)
                for (const n of t.hand.values()) this._getHandJoint(e, n)
        }
        return this.dispatchEvent({
            type: "connected",
            data: t
        }), this
    }
    disconnect(t) {
        return this.dispatchEvent({
            type: "disconnected",
            data: t
        }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
    }
    update(t, e, n) {
        let i = null,
            s = null,
            r = null;
        const o = this._targetRay,
            a = this._grip,
            l = this._hand;
        if (t && "visible-blurred" !== e.session.visibilityState) {
            if (l && t.hand) {
                r = !0;
                for (const i of t.hand.values()) {
                    const t = e.getJointPose(i, n),
                        s = this._getHandJoint(l, i);
                    null !== t && (s.matrix.fromArray(t.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale), s.matrixWorldNeedsUpdate = !0, s.jointRadius = t.radius), s.visible = null !== t
                }
                const i = l.joints["index-finger-tip"],
                    s = l.joints["thumb-tip"],
                    o = i.position.distanceTo(s.position),
                    a = .02,
                    c = .005;
                l.inputState.pinching && o > a + c ? (l.inputState.pinching = !1, this.dispatchEvent({
                    type: "pinchend",
                    handedness: t.handedness,
                    target: this
                })) : !l.inputState.pinching && o <= a - c && (l.inputState.pinching = !0, this.dispatchEvent({
                    type: "pinchstart",
                    handedness: t.handedness,
                    target: this
                }))
            } else null !== a && t.gripSpace && (s = e.getPose(t.gripSpace, n), null !== s && (a.matrix.fromArray(s.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), a.matrixWorldNeedsUpdate = !0, s.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(s.linearVelocity)) : a.hasLinearVelocity = !1, s.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(s.angularVelocity)) : a.hasAngularVelocity = !1));
            null !== o && (i = e.getPose(t.targetRaySpace, n), null === i && null !== s && (i = s), null !== i && (o.matrix.fromArray(i.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), o.matrixWorldNeedsUpdate = !0, i.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(i.linearVelocity)) : o.hasLinearVelocity = !1, i.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(i.angularVelocity)) : o.hasAngularVelocity = !1, this.dispatchEvent($A)))
        }
        return null !== o && (o.visible = null !== i), null !== a && (a.visible = null !== s), null !== l && (l.visible = null !== r), this
    }
    _getHandJoint(t, e) {
        if (void 0 === t.joints[e.jointName]) {
            const n = new Fn;
            n.matrixAutoUpdate = !1, n.visible = !1, t.joints[e.jointName] = n, t.add(n)
        }
        return t.joints[e.jointName]
    }
}
const eS = "\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}",
    tS = "\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n\tvec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n\tif ( coord.x >= 1.0 ) {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n\t} else {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n\t}\n\n}";
class nS {
    constructor() {
        this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0
    }
    init(t, e, n) {
        if (null === this.texture) {
            const i = new wt;
            t.properties.get(i).__webglTexture = e.texture, (e.depthNear != n.depthNear || e.depthFar != n.depthFar) && (this.depthNear = e.depthNear, this.depthFar = e.depthFar), this.texture = i
        }
    }
    render(t, e) {
        if (null !== this.texture) {
            if (null === this.mesh) {
                const t = e.cameras[0].viewport,
                    n = new It({
                        vertexShader: eS,
                        fragmentShader: tS,
                        uniforms: {
                            depthColor: {
                                value: this.texture
                            },
                            depthWidth: {
                                value: t.z
                            },
                            depthHeight: {
                                value: t.w
                            }
                        }
                    });
                this.mesh = new be(new Ot(20, 20), n)
            }
            t.render(this.mesh, e)
        }
    }
    reset() {
        this.texture = null, this.mesh = null
    }
}
class iS extends hi {
    constructor(t, e) {
        super();
        const n = this;
        let i = null,
            s = 1,
            r = null,
            o = "local-floor",
            a = 1,
            l = null,
            c = null,
            h = null,
            u = null,
            d = null,
            p = null;
        const f = new nS,
            m = e.getContextAttributes();
        let g = null,
            v = null;
        const y = [],
            x = [],
            b = new Q;
        let A = null;
        const S = new Pt;
        S.layers.enable(1), S.viewport = new ot;
        const w = new Pt;
        w.layers.enable(2), w.viewport = new ot;
        const _ = [S, w],
            M = new JA;
        M.layers.enable(1), M.layers.enable(2);
        let T = null,
            E = null;

        function C(t) {
            const e = x.indexOf(t.inputSource);
            if (-1 === e) return;
            const n = y[e];
            void 0 !== n && (n.update(t.inputSource, t.frame, l || r), n.dispatchEvent({
                type: t.type,
                data: t.inputSource
            }))
        }

        function R() {
            i.removeEventListener("select", C), i.removeEventListener("selectstart", C), i.removeEventListener("selectend", C), i.removeEventListener("squeeze", C), i.removeEventListener("squeezestart", C), i.removeEventListener("squeezeend", C), i.removeEventListener("end", R), i.removeEventListener("inputsourceschange", P);
            for (let t = 0; t < y.length; t++) {
                const e = x[t];
                null !== e && (x[t] = null, y[t].disconnect(e))
            }
            T = null, E = null, f.reset(), t.setRenderTarget(g), d = null, u = null, h = null, i = null, v = null, B.stop(), n.isPresenting = !1, t.setPixelRatio(A), t.setSize(b.width, b.height, !1), n.dispatchEvent({
                type: "sessionend"
            })
        }

        function P(t) {
            for (let e = 0; e < t.removed.length; e++) {
                const n = t.removed[e],
                    i = x.indexOf(n);
                i >= 0 && (x[i] = null, y[i].disconnect(n))
            }
            for (let e = 0; e < t.added.length; e++) {
                const n = t.added[e];
                let i = x.indexOf(n);
                if (-1 === i) {
                    for (let t = 0; t < y.length; t++) {
                        if (t >= x.length) {
                            x.push(n), i = t;
                            break
                        }
                        if (null === x[t]) {
                            x[t] = n, i = t;
                            break
                        }
                    }
                    if (-1 === i) break
                }
                const s = y[i];
                s && s.connect(n)
            }
        }
        this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(t) {
            let e = y[t];
            return void 0 === e && (e = new Zl, y[t] = e), e.getTargetRaySpace()
        }, this.getControllerGrip = function(t) {
            let e = y[t];
            return void 0 === e && (e = new Zl, y[t] = e), e.getGripSpace()
        }, this.getHand = function(t) {
            let e = y[t];
            return void 0 === e && (e = new Zl, y[t] = e), e.getHandSpace()
        }, this.setFramebufferScaleFactor = function(t) {
            s = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
        }, this.setReferenceSpaceType = function(t) {
            o = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
        }, this.getReferenceSpace = function() {
            return l || r
        }, this.setReferenceSpace = function(t) {
            l = t
        }, this.getBaseLayer = function() {
            return null !== u ? u : d
        }, this.getBinding = function() {
            return h
        }, this.getFrame = function() {
            return p
        }, this.getSession = function() {
            return i
        }, this.setSession = async function(c) {
            if (i = c, null !== i) {
                if (g = t.getRenderTarget(), i.addEventListener("select", C), i.addEventListener("selectstart", C), i.addEventListener("selectend", C), i.addEventListener("squeeze", C), i.addEventListener("squeezestart", C), i.addEventListener("squeezeend", C), i.addEventListener("end", R), i.addEventListener("inputsourceschange", P), !0 !== m.xrCompatible && await e.makeXRCompatible(), A = t.getPixelRatio(), t.getSize(b), void 0 === i.renderState.layers) {
                    const n = {
                        antialias: m.antialias,
                        alpha: !0,
                        depth: m.depth,
                        stencil: m.stencil,
                        framebufferScaleFactor: s
                    };
                    d = new XRWebGLLayer(i, e, n), i.updateRenderState({
                        baseLayer: d
                    }), t.setPixelRatio(1), t.setSize(d.framebufferWidth, d.framebufferHeight, !1), v = new nn(d.framebufferWidth, d.framebufferHeight, {
                        format: Nn,
                        type: Qt,
                        colorSpace: t.outputColorSpace,
                        stencilBuffer: m.stencil
                    })
                } else {
                    let n = null,
                        r = null,
                        o = null;
                    m.depth && (o = m.stencil ? e.DEPTH24_STENCIL8 : e.DEPTH_COMPONENT24, n = m.stencil ? Ps : Ms, r = m.stencil ? Dr : Cs);
                    const a = {
                        colorFormat: e.RGBA8,
                        depthFormat: o,
                        scaleFactor: s
                    };
                    h = new XRWebGLBinding(i, e), u = h.createProjectionLayer(a), i.updateRenderState({
                        layers: [u]
                    }), t.setPixelRatio(1), t.setSize(u.textureWidth, u.textureHeight, !1), v = new nn(u.textureWidth, u.textureHeight, {
                        format: Nn,
                        type: Qt,
                        depthTexture: new ph(u.textureWidth, u.textureHeight, r, void 0, void 0, void 0, void 0, void 0, void 0, n),
                        stencilBuffer: m.stencil,
                        colorSpace: t.outputColorSpace,
                        samples: m.antialias ? 4 : 0,
                        resolveDepthBuffer: !1 === u.ignoreDepthValues
                    })
                }
                v.isXRRenderTarget = !0, this.setFoveation(a), l = null, r = await i.requestReferenceSpace(o), B.setContext(i), B.start(), n.isPresenting = !0, n.dispatchEvent({
                    type: "sessionstart"
                })
            }
        }, this.getEnvironmentBlendMode = function() {
            if (null !== i) return i.environmentBlendMode
        };
        const D = new U,
            I = new U;

        function L(t, e) {
            null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.copy(t.matrixWorld).invert()
        }
        this.updateCamera = function(t) {
            if (null === i) return;
            null !== f.texture && (t.near = f.depthNear, t.far = f.depthFar), M.near = w.near = S.near = t.near, M.far = w.far = S.far = t.far, (T !== M.near || E !== M.far) && (i.updateRenderState({
                depthNear: M.near,
                depthFar: M.far
            }), T = M.near, E = M.far, S.near = T, S.far = E, w.near = T, w.far = E, S.updateProjectionMatrix(), w.updateProjectionMatrix(), t.updateProjectionMatrix());
            const e = t.parent,
                n = M.cameras;
            L(M, e);
            for (let t = 0; t < n.length; t++) L(n[t], e);
            2 === n.length ? function(t, e, n) {
                    D.setFromMatrixPosition(e.matrixWorld), I.setFromMatrixPosition(n.matrixWorld);
                    const i = D.distanceTo(I),
                        s = e.projectionMatrix.elements,
                        r = n.projectionMatrix.elements,
                        o = s[14] / (s[10] - 1),
                        a = s[14] / (s[10] + 1),
                        l = (s[9] + 1) / s[5],
                        c = (s[9] - 1) / s[5],
                        h = (s[8] - 1) / s[0],
                        u = (r[8] + 1) / r[0],
                        d = o * h,
                        p = o * u,
                        f = i / (-h + u),
                        m = f * -h;
                    e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(m), t.translateZ(f), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.copy(t.matrixWorld).invert();
                    const g = o + f,
                        v = a + f,
                        y = d - m,
                        x = p + (i - m),
                        b = l * a / v * g,
                        A = c * a / v * g;
                    t.projectionMatrix.makePerspective(y, x, b, A, g, v), t.projectionMatrixInverse.copy(t.projectionMatrix).invert()
                }(M, S, w) : M.projectionMatrix.copy(S.projectionMatrix),
                function(t, e, n) {
                    null === n ? t.matrix.copy(e.matrixWorld) : (t.matrix.copy(n.matrixWorld), t.matrix.invert(), t.matrix.multiply(e.matrixWorld)), t.matrix.decompose(t.position, t.quaternion, t.scale), t.updateMatrixWorld(!0), t.projectionMatrix.copy(e.projectionMatrix), t.projectionMatrixInverse.copy(e.projectionMatrixInverse), t.isPerspectiveCamera && (t.fov = 2 * wr * Math.atan(1 / t.projectionMatrix.elements[5]), t.zoom = 1)
                }(t, M, e)
        }, this.getCamera = function() {
            return M
        }, this.getFoveation = function() {
            if (null !== u || null !== d) return a
        }, this.setFoveation = function(t) {
            a = t, null !== u && (u.fixedFoveation = t), null !== d && void 0 !== d.fixedFoveation && (d.fixedFoveation = t)
        }, this.hasDepthSensing = function() {
            return null !== f.texture
        };
        let O = null;
        const B = new Ap;
        B.setAnimationLoop((function(e, s) {
            if (c = s.getViewerPose(l || r), p = s, null !== c) {
                const e = c.views;
                null !== d && (t.setRenderTargetFramebuffer(v, d.framebuffer), t.setRenderTarget(v));
                let n = !1;
                e.length !== M.cameras.length && (M.cameras.length = 0, n = !0);
                for (let i = 0; i < e.length; i++) {
                    const s = e[i];
                    let r = null;
                    if (null !== d) r = d.getViewport(s);
                    else {
                        const e = h.getViewSubImage(u, s);
                        r = e.viewport, 0 === i && (t.setRenderTargetTextures(v, e.colorTexture, u.ignoreDepthValues ? void 0 : e.depthStencilTexture), t.setRenderTarget(v))
                    }
                    let o = _[i];
                    void 0 === o && (o = new Pt, o.layers.enable(i), o.viewport = new ot, _[i] = o), o.matrix.fromArray(s.transform.matrix), o.matrix.decompose(o.position, o.quaternion, o.scale), o.projectionMatrix.fromArray(s.projectionMatrix), o.projectionMatrixInverse.copy(o.projectionMatrix).invert(), o.viewport.set(r.x, r.y, r.width, r.height), 0 === i && (M.matrix.copy(o.matrix), M.matrix.decompose(M.position, M.quaternion, M.scale)), !0 === n && M.cameras.push(o)
                }
                const s = i.enabledFeatures;
                if (s && s.includes("depth-sensing")) {
                    const n = h.getDepthInformation(e[0]);
                    n && n.isValid && n.texture && f.init(t, n, i.renderState)
                }
            }
            for (let t = 0; t < y.length; t++) {
                const e = x[t],
                    n = y[t];
                null !== e && void 0 !== n && n.update(e, s, l || r)
            }
            f.render(t, M), O && O(e, s), s.detectedPlanes && n.dispatchEvent({
                type: "planesdetected",
                data: s
            }), p = null
        })), this.setAnimationLoop = function(t) {
            O = t
        }, this.dispose = function() {}
    }
}
const us = new Gn,
    sS = new Xe;

function rS(t, e) {
    function n(t, e) {
        !0 === t.matrixAutoUpdate && t.updateMatrix(), e.value.copy(t.matrix)
    }

    function i(i, s) {
        i.opacity.value = s.opacity, s.color && i.diffuse.value.copy(s.color), s.emissive && i.emissive.value.copy(s.emissive).multiplyScalar(s.emissiveIntensity), s.map && (i.map.value = s.map, n(s.map, i.mapTransform)), s.alphaMap && (i.alphaMap.value = s.alphaMap, n(s.alphaMap, i.alphaMapTransform)), s.bumpMap && (i.bumpMap.value = s.bumpMap, n(s.bumpMap, i.bumpMapTransform), i.bumpScale.value = s.bumpScale, s.side === Bt && (i.bumpScale.value *= -1)), s.normalMap && (i.normalMap.value = s.normalMap, n(s.normalMap, i.normalMapTransform), i.normalScale.value.copy(s.normalScale), s.side === Bt && i.normalScale.value.negate()), s.displacementMap && (i.displacementMap.value = s.displacementMap, n(s.displacementMap, i.displacementMapTransform), i.displacementScale.value = s.displacementScale, i.displacementBias.value = s.displacementBias), s.emissiveMap && (i.emissiveMap.value = s.emissiveMap, n(s.emissiveMap, i.emissiveMapTransform)), s.specularMap && (i.specularMap.value = s.specularMap, n(s.specularMap, i.specularMapTransform)), s.alphaTest > 0 && (i.alphaTest.value = s.alphaTest);
        const r = e.get(s),
            o = r.envMap,
            a = r.envMapRotation;
        if (o && (i.envMap.value = o, us.copy(a), us.x *= -1, us.y *= -1, us.z *= -1, o.isCubeTexture && !1 === o.isRenderTargetTexture && (us.y *= -1, us.z *= -1), i.envMapRotation.value.setFromMatrix4(sS.makeRotationFromEuler(us)), i.flipEnvMap.value = o.isCubeTexture && !1 === o.isRenderTargetTexture ? -1 : 1, i.reflectivity.value = s.reflectivity, i.ior.value = s.ior, i.refractionRatio.value = s.refractionRatio), s.lightMap) {
            i.lightMap.value = s.lightMap;
            const e = !0 === t._useLegacyLights ? Math.PI : 1;
            i.lightMapIntensity.value = s.lightMapIntensity * e, n(s.lightMap, i.lightMapTransform)
        }
        s.aoMap && (i.aoMap.value = s.aoMap, i.aoMapIntensity.value = s.aoMapIntensity, n(s.aoMap, i.aoMapTransform))
    }
    return {
        refreshFogUniforms: function(e, n) {
            n.color.getRGB(e.fogColor.value, xp(t)), n.isFog ? (e.fogNear.value = n.near, e.fogFar.value = n.far) : n.isFogExp2 && (e.fogDensity.value = n.density)
        },
        refreshMaterialUniforms: function(t, s, r, o, a) {
            s.isMeshBasicMaterial || s.isMeshLambertMaterial ? i(t, s) : s.isMeshToonMaterial ? (i(t, s), function(t, e) {
                e.gradientMap && (t.gradientMap.value = e.gradientMap)
            }(t, s)) : s.isMeshPhongMaterial ? (i(t, s), function(t, e) {
                t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4)
            }(t, s)) : s.isMeshStandardMaterial ? (i(t, s), function(t, e) {
                t.metalness.value = e.metalness, e.metalnessMap && (t.metalnessMap.value = e.metalnessMap, n(e.metalnessMap, t.metalnessMapTransform)), t.roughness.value = e.roughness, e.roughnessMap && (t.roughnessMap.value = e.roughnessMap, n(e.roughnessMap, t.roughnessMapTransform)), e.envMap && (t.envMapIntensity.value = e.envMapIntensity)
            }(t, s), s.isMeshPhysicalMaterial && function(t, e, i) {
                t.ior.value = e.ior, e.sheen > 0 && (t.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen), t.sheenRoughness.value = e.sheenRoughness, e.sheenColorMap && (t.sheenColorMap.value = e.sheenColorMap, n(e.sheenColorMap, t.sheenColorMapTransform)), e.sheenRoughnessMap && (t.sheenRoughnessMap.value = e.sheenRoughnessMap, n(e.sheenRoughnessMap, t.sheenRoughnessMapTransform))), e.clearcoat > 0 && (t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap, n(e.clearcoatMap, t.clearcoatMapTransform)), e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap, n(e.clearcoatRoughnessMap, t.clearcoatRoughnessMapTransform)), e.clearcoatNormalMap && (t.clearcoatNormalMap.value = e.clearcoatNormalMap, n(e.clearcoatNormalMap, t.clearcoatNormalMapTransform), t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), e.side === Bt && t.clearcoatNormalScale.value.negate())), e.dispersion > 0 && (t.dispersion.value = e.dispersion), e.iridescence > 0 && (t.iridescence.value = e.iridescence, t.iridescenceIOR.value = e.iridescenceIOR, t.iridescenceThicknessMinimum.value = e.iridescenceThicknessRange[0], t.iridescenceThicknessMaximum.value = e.iridescenceThicknessRange[1], e.iridescenceMap && (t.iridescenceMap.value = e.iridescenceMap, n(e.iridescenceMap, t.iridescenceMapTransform)), e.iridescenceThicknessMap && (t.iridescenceThicknessMap.value = e.iridescenceThicknessMap, n(e.iridescenceThicknessMap, t.iridescenceThicknessMapTransform))), e.transmission > 0 && (t.transmission.value = e.transmission, t.transmissionSamplerMap.value = i.texture, t.transmissionSamplerSize.value.set(i.width, i.height), e.transmissionMap && (t.transmissionMap.value = e.transmissionMap, n(e.transmissionMap, t.transmissionMapTransform)), t.thickness.value = e.thickness, e.thicknessMap && (t.thicknessMap.value = e.thicknessMap, n(e.thicknessMap, t.thicknessMapTransform)), t.attenuationDistance.value = e.attenuationDistance, t.attenuationColor.value.copy(e.attenuationColor)), e.anisotropy > 0 && (t.anisotropyVector.value.set(e.anisotropy * Math.cos(e.anisotropyRotation), e.anisotropy * Math.sin(e.anisotropyRotation)), e.anisotropyMap && (t.anisotropyMap.value = e.anisotropyMap, n(e.anisotropyMap, t.anisotropyMapTransform))), t.specularIntensity.value = e.specularIntensity, t.specularColor.value.copy(e.specularColor), e.specularColorMap && (t.specularColorMap.value = e.specularColorMap, n(e.specularColorMap, t.specularColorMapTransform)), e.specularIntensityMap && (t.specularIntensityMap.value = e.specularIntensityMap, n(e.specularIntensityMap, t.specularIntensityMapTransform))
            }(t, s, a)) : s.isMeshMatcapMaterial ? (i(t, s), function(t, e) {
                e.matcap && (t.matcap.value = e.matcap)
            }(t, s)) : s.isMeshDepthMaterial ? i(t, s) : s.isMeshDistanceMaterial ? (i(t, s), function(t, n) {
                const i = e.get(n).light;
                t.referencePosition.value.setFromMatrixPosition(i.matrixWorld), t.nearDistance.value = i.shadow.camera.near, t.farDistance.value = i.shadow.camera.far
            }(t, s)) : s.isMeshNormalMaterial ? i(t, s) : s.isLineBasicMaterial ? (function(t, e) {
                t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, e.map && (t.map.value = e.map, n(e.map, t.mapTransform))
            }(t, s), s.isLineDashedMaterial && function(t, e) {
                t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale
            }(t, s)) : s.isPointsMaterial ? function(t, e, i, s) {
                t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * i, t.scale.value = .5 * s, e.map && (t.map.value = e.map, n(e.map, t.uvTransform)), e.alphaMap && (t.alphaMap.value = e.alphaMap, n(e.alphaMap, t.alphaMapTransform)), e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest)
            }(t, s, r, o) : s.isSpriteMaterial ? function(t, e) {
                t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map, n(e.map, t.mapTransform)), e.alphaMap && (t.alphaMap.value = e.alphaMap, n(e.alphaMap, t.alphaMapTransform)), e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest)
            }(t, s) : s.isShadowMaterial ? (t.color.value.copy(s.color), t.opacity.value = s.opacity) : s.isShaderMaterial && (s.uniformsNeedUpdate = !1)
        }
    }
}

function oS(t, e, n, i) {
    let s = {},
        r = {},
        o = [];
    const a = t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS);

    function l(t, e, n, i) {
        const s = t.value,
            r = e + "_" + n;
        if (void 0 === i[r]) return i[r] = "number" == typeof s || "boolean" == typeof s ? s : s.clone(), !0; {
            const t = i[r];
            if ("number" == typeof s || "boolean" == typeof s) {
                if (t !== s) return i[r] = s, !0
            } else if (!1 === t.equals(s)) return t.copy(s), !0
        }
        return !1
    }

    function c(t) {
        const e = {
            boundary: 0,
            storage: 0
        };
        return "number" == typeof t || "boolean" == typeof t ? (e.boundary = 4, e.storage = 4) : t.isVector2 ? (e.boundary = 8, e.storage = 8) : t.isVector3 || t.isColor ? (e.boundary = 16, e.storage = 12) : t.isVector4 ? (e.boundary = 16, e.storage = 16) : t.isMatrix3 ? (e.boundary = 48, e.storage = 48) : t.isMatrix4 ? (e.boundary = 64, e.storage = 64) : t.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", t), e
    }

    function h(e) {
        const n = e.target;
        n.removeEventListener("dispose", h);
        const i = o.indexOf(n.__bindingPointIndex);
        o.splice(i, 1), t.deleteBuffer(s[n.id]), delete s[n.id], delete r[n.id]
    }
    return {
        bind: function(t, e) {
            const n = e.program;
            i.uniformBlockBinding(t, n)
        },
        update: function(n, u) {
            let d = s[n.id];
            void 0 === d && (function(t) {
                const e = t.uniforms;
                let n = 0;
                const i = 16;
                for (let t = 0, s = e.length; t < s; t++) {
                    const s = Array.isArray(e[t]) ? e[t] : [e[t]];
                    for (let t = 0, e = s.length; t < e; t++) {
                        const e = s[t],
                            r = Array.isArray(e.value) ? e.value : [e.value];
                        for (let t = 0, s = r.length; t < s; t++) {
                            const s = c(r[t]),
                                o = n % i;
                            0 !== o && i - o < s.boundary && (n += i - o), e.__data = new Float32Array(s.storage / Float32Array.BYTES_PER_ELEMENT), e.__offset = n, n += s.storage
                        }
                    }
                }
                const s = n % i;
                s > 0 && (n += i - s), t.__size = n, t.__cache = {}
            }(n), d = function(e) {
                const n = function() {
                    for (let t = 0; t < a; t++)
                        if (-1 === o.indexOf(t)) return o.push(t), t;
                    return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0
                }();
                e.__bindingPointIndex = n;
                const i = t.createBuffer(),
                    s = e.__size,
                    r = e.usage;
                return t.bindBuffer(t.UNIFORM_BUFFER, i), t.bufferData(t.UNIFORM_BUFFER, s, r), t.bindBuffer(t.UNIFORM_BUFFER, null), t.bindBufferBase(t.UNIFORM_BUFFER, n, i), i
            }(n), s[n.id] = d, n.addEventListener("dispose", h));
            const p = u.program;
            i.updateUBOMapping(n, p);
            const f = e.render.frame;
            r[n.id] !== f && (function(e) {
                const n = s[e.id],
                    i = e.uniforms,
                    r = e.__cache;
                t.bindBuffer(t.UNIFORM_BUFFER, n);
                for (let e = 0, n = i.length; e < n; e++) {
                    const n = Array.isArray(i[e]) ? i[e] : [i[e]];
                    for (let i = 0, s = n.length; i < s; i++) {
                        const s = n[i];
                        if (!0 === l(s, e, i, r)) {
                            const e = s.__offset,
                                n = Array.isArray(s.value) ? s.value : [s.value];
                            let i = 0;
                            for (let r = 0; r < n.length; r++) {
                                const o = n[r],
                                    a = c(o);
                                "number" == typeof o || "boolean" == typeof o ? (s.__data[0] = o, t.bufferSubData(t.UNIFORM_BUFFER, e + i, s.__data)) : o.isMatrix3 ? (s.__data[0] = o.elements[0], s.__data[1] = o.elements[1], s.__data[2] = o.elements[2], s.__data[3] = 0, s.__data[4] = o.elements[3], s.__data[5] = o.elements[4], s.__data[6] = o.elements[5], s.__data[7] = 0, s.__data[8] = o.elements[6], s.__data[9] = o.elements[7], s.__data[10] = o.elements[8], s.__data[11] = 0) : (o.toArray(s.__data, i), i += a.storage / Float32Array.BYTES_PER_ELEMENT)
                            }
                            t.bufferSubData(t.UNIFORM_BUFFER, e, s.__data)
                        }
                    }
                }
                t.bindBuffer(t.UNIFORM_BUFFER, null)
            }(n), r[n.id] = f)
        },
        dispose: function() {
            for (const e in s) t.deleteBuffer(s[e]);
            o = [], s = {}, r = {}
        }
    }
}
class aS {
    constructor(t = {}) {
        const {
            canvas: e = t0(),
            context: n = null,
            depth: i = !0,
            stencil: s = !1,
            alpha: r = !1,
            antialias: o = !1,
            premultipliedAlpha: a = !0,
            preserveDrawingBuffer: l = !1,
            powerPreference: c = "default",
            failIfMajorPerformanceCaveat: h = !1
        } = t;
        let u;
        if (this.isWebGLRenderer = !0, null !== n) {
            if (typeof WebGLRenderingContext < "u" && n instanceof WebGLRenderingContext) throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
            u = n.getContextAttributes().alpha
        } else u = r;
        const d = new Uint32Array(4),
            p = new Int32Array(4);
        let f = null,
            m = null;
        const g = [],
            v = [];
        this.domElement = e, this.debug = {
            checkShaderErrors: !0,
            onShaderError: null
        }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = rt, this._useLegacyLights = !1, this.toneMapping = qi, this.toneMappingExposure = 1;
        const y = this;
        let x = !1,
            b = 0,
            A = 0,
            S = null,
            w = -1,
            _ = null;
        const M = new ot,
            T = new ot;
        let E = null;
        const C = new Le(0);
        let R = 0,
            P = e.width,
            D = e.height,
            I = 1,
            L = null,
            O = null;
        const B = new ot(0, 0, P, D),
            N = new ot(0, 0, P, D);
        let F = !1;
        const k = new dh;
        let z = !1,
            G = !1;
        const H = new Xe,
            V = new U,
            W = {
                background: null,
                fog: null,
                environment: null,
                overrideMaterial: null,
                isScene: !0
            };

        function j() {
            return null === S ? I : 1
        }
        let X, Q, K, Y, q, Z, J, $, tt, et, nt, it, st, at, lt, ct, ht, ut, dt, pt, ft, mt, gt, vt, yt = n;

        function xt(t, n) {
            return e.getContext(t, n)
        }
        try {
            const t = {
                alpha: !0,
                depth: i,
                stencil: s,
                antialias: o,
                premultipliedAlpha: a,
                preserveDrawingBuffer: l,
                powerPreference: c,
                failIfMajorPerformanceCaveat: h
            };
            if ("setAttribute" in e && e.setAttribute("data-engine", `three.js r${ns}`), e.addEventListener("webglcontextlost", St, !1), e.addEventListener("webglcontextrestored", wt, !1), e.addEventListener("webglcontextcreationerror", _t, !1), null === yt) {
                const e = "webgl2";
                if (yt = xt(e, t), null === yt) throw xt(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
            }
        } catch (t) {
            throw console.error("THREE.WebGLRenderer: " + t.message), t
        }

        function bt() {
            X = new mb(yt), X.init(), mt = new ZA(yt, X), Q = new cb(yt, X, t, mt), K = new QA(yt), Y = new yb(yt), q = new BA, Z = new qA(yt, X, K, q, Q, mt, Y), J = new ub(y), $ = new pb(y), tt = new M0(yt), gt = new ab(yt, tt), et = new gb(yt, tt, Y, gt), nt = new bb(yt, et, tt, Y), dt = new xb(yt, Q, Z), ct = new hb(q), it = new OA(y, J, $, X, Q, gt, ct), st = new rS(y, q), at = new NA, lt = new VA(X), ut = new ob(y, J, $, K, nt, u, a), ht = new YA(y, nt, Q), vt = new oS(yt, Y, Q, K), pt = new lb(yt, X, Y), ft = new vb(yt, X, Y), Y.programs = it.programs, y.capabilities = Q, y.extensions = X, y.properties = q, y.renderLists = at, y.shadowMap = ht, y.state = K, y.info = Y
        }
        bt();
        const At = new iS(y, yt);

        function St(t) {
            t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), x = !0
        }

        function wt() {
            console.log("THREE.WebGLRenderer: Context Restored."), x = !1;
            const t = Y.autoReset,
                e = ht.enabled,
                n = ht.autoUpdate,
                i = ht.needsUpdate,
                s = ht.type;
            bt(), Y.autoReset = t, ht.enabled = e, ht.autoUpdate = n, ht.needsUpdate = i, ht.type = s
        }

        function _t(t) {
            console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", t.statusMessage)
        }

        function Mt(t) {
            const e = t.target;
            e.removeEventListener("dispose", Mt),
                function(t) {
                    (function(t) {
                        const e = q.get(t).programs;
                        void 0 !== e && (e.forEach((function(t) {
                            it.releaseProgram(t)
                        })), t.isShaderMaterial && it.releaseShaderCache(t))
                    })(t), q.remove(t)
                }(e)
        }

        function Tt(t, e, n) {
            !0 === t.transparent && 2 === t.side && !1 === t.forceSinglePass ? (t.side = Bt, t.needsUpdate = !0, Nt(t, e, n), t.side = li, t.needsUpdate = !0, Nt(t, e, n), t.side = 2) : Nt(t, e, n)
        }
        this.xr = At, this.getContext = function() {
            return yt
        }, this.getContextAttributes = function() {
            return yt.getContextAttributes()
        }, this.forceContextLoss = function() {
            const t = X.get("WEBGL_lose_context");
            t && t.loseContext()
        }, this.forceContextRestore = function() {
            const t = X.get("WEBGL_lose_context");
            t && t.restoreContext()
        }, this.getPixelRatio = function() {
            return I
        }, this.setPixelRatio = function(t) {
            void 0 !== t && (I = t, this.setSize(P, D, !1))
        }, this.getSize = function(t) {
            return t.set(P, D)
        }, this.setSize = function(t, n, i = !0) {
            At.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (P = t, D = n, e.width = Math.floor(t * I), e.height = Math.floor(n * I), !0 === i && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n))
        }, this.getDrawingBufferSize = function(t) {
            return t.set(P * I, D * I).floor()
        }, this.setDrawingBufferSize = function(t, n, i) {
            P = t, D = n, I = i, e.width = Math.floor(t * i), e.height = Math.floor(n * i), this.setViewport(0, 0, t, n)
        }, this.getCurrentViewport = function(t) {
            return t.copy(M)
        }, this.getViewport = function(t) {
            return t.copy(B)
        }, this.setViewport = function(t, e, n, i) {
            t.isVector4 ? B.set(t.x, t.y, t.z, t.w) : B.set(t, e, n, i), K.viewport(M.copy(B).multiplyScalar(I).round())
        }, this.getScissor = function(t) {
            return t.copy(N)
        }, this.setScissor = function(t, e, n, i) {
            t.isVector4 ? N.set(t.x, t.y, t.z, t.w) : N.set(t, e, n, i), K.scissor(T.copy(N).multiplyScalar(I).round())
        }, this.getScissorTest = function() {
            return F
        }, this.setScissorTest = function(t) {
            K.setScissorTest(F = t)
        }, this.setOpaqueSort = function(t) {
            L = t
        }, this.setTransparentSort = function(t) {
            O = t
        }, this.getClearColor = function(t) {
            return t.copy(ut.getClearColor())
        }, this.setClearColor = function() {
            ut.setClearColor.apply(ut, arguments)
        }, this.getClearAlpha = function() {
            return ut.getClearAlpha()
        }, this.setClearAlpha = function() {
            ut.setClearAlpha.apply(ut, arguments)
        }, this.clear = function(t = !0, e = !0, n = !0) {
            let i = 0;
            if (t) {
                let t = !1;
                if (null !== S) {
                    const e = S.texture.format;
                    t = e === ah || e === oh || e === rh
                }
                if (t) {
                    const t = S.texture.type,
                        e = t === Qt || t === Cs || t === np || t === Dr || t === sp || t === rp,
                        n = ut.getClearColor(),
                        i = ut.getClearAlpha(),
                        s = n.r,
                        r = n.g,
                        o = n.b;
                    e ? (d[0] = s, d[1] = r, d[2] = o, d[3] = i, yt.clearBufferuiv(yt.COLOR, 0, d)) : (p[0] = s, p[1] = r, p[2] = o, p[3] = i, yt.clearBufferiv(yt.COLOR, 0, p))
                } else i |= yt.COLOR_BUFFER_BIT
            }
            e && (i |= yt.DEPTH_BUFFER_BIT), n && (i |= yt.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), yt.clear(i)
        }, this.clearColor = function() {
            this.clear(!0, !1, !1)
        }, this.clearDepth = function() {
            this.clear(!1, !0, !1)
        }, this.clearStencil = function() {
            this.clear(!1, !1, !0)
        }, this.dispose = function() {
            e.removeEventListener("webglcontextlost", St, !1), e.removeEventListener("webglcontextrestored", wt, !1), e.removeEventListener("webglcontextcreationerror", _t, !1), at.dispose(), lt.dispose(), q.dispose(), J.dispose(), $.dispose(), nt.dispose(), gt.dispose(), vt.dispose(), it.dispose(), At.dispose(), At.removeEventListener("sessionstart", Ct), At.removeEventListener("sessionend", Rt), Pt.stop()
        }, this.renderBufferDirect = function(t, e, n, i, s, r) {
            null === e && (e = W);
            const o = s.isMesh && s.matrixWorld.determinant() < 0,
                a = function(t, e, n, i, s) {
                    !0 !== e.isScene && (e = W), Z.resetTextureUnits();
                    const r = e.fog,
                        o = i.isMeshStandardMaterial ? e.environment : null,
                        a = null === S ? y.outputColorSpace : !0 === S.isXRRenderTarget ? S.texture.colorSpace : Zn,
                        l = (i.isMeshStandardMaterial ? $ : J).get(i.envMap || o),
                        c = !0 === i.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize,
                        h = !!n.attributes.tangent && (!!i.normalMap || i.anisotropy > 0),
                        u = !!n.morphAttributes.position,
                        d = !!n.morphAttributes.normal,
                        p = !!n.morphAttributes.color;
                    let f = qi;
                    i.toneMapped && (null === S || !0 === S.isXRRenderTarget) && (f = y.toneMapping);
                    const g = n.morphAttributes.position || n.morphAttributes.normal || n.morphAttributes.color,
                        v = void 0 !== g ? g.length : 0,
                        x = q.get(i),
                        b = m.state.lights;
                    if (!0 === z && (!0 === G || t !== _)) {
                        const e = t === _ && i.id === w;
                        ct.setState(i, t, e)
                    }
                    let A = !1;
                    i.version === x.__version ? (x.needsLights && x.lightsStateVersion !== b.state.version || x.outputColorSpace !== a || s.isBatchedMesh && !1 === x.batching || !s.isBatchedMesh && !0 === x.batching || s.isInstancedMesh && !1 === x.instancing || !s.isInstancedMesh && !0 === x.instancing || s.isSkinnedMesh && !1 === x.skinning || !s.isSkinnedMesh && !0 === x.skinning || s.isInstancedMesh && !0 === x.instancingColor && null === s.instanceColor || s.isInstancedMesh && !1 === x.instancingColor && null !== s.instanceColor || s.isInstancedMesh && !0 === x.instancingMorph && null === s.morphTexture || s.isInstancedMesh && !1 === x.instancingMorph && null !== s.morphTexture || x.envMap !== l || !0 === i.fog && x.fog !== r || void 0 !== x.numClippingPlanes && (x.numClippingPlanes !== ct.numPlanes || x.numIntersection !== ct.numIntersection) || x.vertexAlphas !== c || x.vertexTangents !== h || x.morphTargets !== u || x.morphNormals !== d || x.morphColors !== p || x.toneMapping !== f || x.morphTargetsCount !== v) && (A = !0) : (A = !0, x.__version = i.version);
                    let M = x.currentProgram;
                    !0 === A && (M = Nt(i, e, s));
                    let T = !1,
                        E = !1,
                        C = !1;
                    const R = M.getUniforms(),
                        P = x.uniforms;
                    if (K.useProgram(M.program) && (T = !0, E = !0, C = !0), i.id !== w && (w = i.id, E = !0), T || _ !== t) {
                        R.setValue(yt, "projectionMatrix", t.projectionMatrix), R.setValue(yt, "viewMatrix", t.matrixWorldInverse);
                        const e = R.map.cameraPosition;
                        void 0 !== e && e.setValue(yt, V.setFromMatrixPosition(t.matrixWorld)), Q.logarithmicDepthBuffer && R.setValue(yt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && R.setValue(yt, "isOrthographic", !0 === t.isOrthographicCamera), _ !== t && (_ = t, E = !0, C = !0)
                    }
                    if (s.isSkinnedMesh) {
                        R.setOptional(yt, s, "bindMatrix"), R.setOptional(yt, s, "bindMatrixInverse");
                        const t = s.skeleton;
                        t && (null === t.boneTexture && t.computeBoneTexture(), R.setValue(yt, "boneTexture", t.boneTexture, Z))
                    }
                    s.isBatchedMesh && (R.setOptional(yt, s, "batchingTexture"), R.setValue(yt, "batchingTexture", s._matricesTexture, Z));
                    const L = n.morphAttributes;
                    if ((void 0 !== L.position || void 0 !== L.normal || void 0 !== L.color) && dt.update(s, n, M), (E || x.receiveShadow !== s.receiveShadow) && (x.receiveShadow = s.receiveShadow, R.setValue(yt, "receiveShadow", s.receiveShadow)), i.isMeshGouraudMaterial && null !== i.envMap && (P.envMap.value = l, P.flipEnvMap.value = l.isCubeTexture && !1 === l.isRenderTargetTexture ? -1 : 1), i.isMeshStandardMaterial && null === i.envMap && null !== e.environment && (P.envMapIntensity.value = e.environmentIntensity), E && (R.setValue(yt, "toneMappingExposure", y.toneMappingExposure), x.needsLights && function(t, e) {
                            t.ambientLightColor.needsUpdate = e, t.lightProbe.needsUpdate = e, t.directionalLights.needsUpdate = e, t.directionalLightShadows.needsUpdate = e, t.pointLights.needsUpdate = e, t.pointLightShadows.needsUpdate = e, t.spotLights.needsUpdate = e, t.spotLightShadows.needsUpdate = e, t.rectAreaLights.needsUpdate = e, t.hemisphereLights.needsUpdate = e
                        }(P, C), r && !0 === i.fog && st.refreshFogUniforms(P, r), st.refreshMaterialUniforms(P, i, I, D, m.state.transmissionRenderTarget[t.id]), Ma.upload(yt, Ft(x), P, Z)), i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (Ma.upload(yt, Ft(x), P, Z), i.uniformsNeedUpdate = !1), i.isSpriteMaterial && R.setValue(yt, "center", s.center), R.setValue(yt, "modelViewMatrix", s.modelViewMatrix), R.setValue(yt, "normalMatrix", s.normalMatrix), R.setValue(yt, "modelMatrix", s.matrixWorld), i.isShaderMaterial || i.isRawShaderMaterial) {
                        const t = i.uniformsGroups;
                        for (let e = 0, n = t.length; e < n; e++) {
                            const n = t[e];
                            vt.update(n, M), vt.bind(n, M)
                        }
                    }
                    return M
                }(t, e, n, i, s);
            K.setMaterial(i, o);
            let l = n.index,
                c = 1;
            if (!0 === i.wireframe) {
                if (l = et.getWireframeAttribute(n), void 0 === l) return;
                c = 2
            }
            const h = n.drawRange,
                u = n.attributes.position;
            let d = h.start * c,
                p = (h.start + h.count) * c;
            null !== r && (d = Math.max(d, r.start * c), p = Math.min(p, (r.start + r.count) * c)), null !== l ? (d = Math.max(d, 0), p = Math.min(p, l.count)) : null != u && (d = Math.max(d, 0), p = Math.min(p, u.count));
            const f = p - d;
            if (f < 0 || f === 1 / 0) return;
            gt.setup(s, i, a, n, l);
            let g, v = pt;
            if (null !== l && (g = tt.get(l), v = ft, v.setIndex(g)), s.isMesh) !0 === i.wireframe ? (K.setLineWidth(i.wireframeLinewidth * j()), v.setMode(yt.LINES)) : v.setMode(yt.TRIANGLES);
            else if (s.isLine) {
                let t = i.linewidth;
                void 0 === t && (t = 1), K.setLineWidth(t * j()), s.isLineSegments ? v.setMode(yt.LINES) : s.isLineLoop ? v.setMode(yt.LINE_LOOP) : v.setMode(yt.LINE_STRIP)
            } else s.isPoints ? v.setMode(yt.POINTS) : s.isSprite && v.setMode(yt.TRIANGLES);
            if (s.isBatchedMesh) null !== s._multiDrawInstances ? v.renderMultiDrawInstances(s._multiDrawStarts, s._multiDrawCounts, s._multiDrawCount, s._multiDrawInstances) : v.renderMultiDraw(s._multiDrawStarts, s._multiDrawCounts, s._multiDrawCount);
            else if (s.isInstancedMesh) v.renderInstances(d, f, s.count);
            else if (n.isInstancedBufferGeometry) {
                const t = void 0 !== n._maxInstanceCount ? n._maxInstanceCount : 1 / 0,
                    e = Math.min(n.instanceCount, t);
                v.renderInstances(d, f, e)
            } else v.render(d, f)
        }, this.compile = function(t, e, n = null) {
            null === n && (n = t), m = lt.get(n), m.init(e), v.push(m), n.traverseVisible((function(t) {
                t.isLight && t.layers.test(e.layers) && (m.pushLight(t), t.castShadow && m.pushShadow(t))
            })), t !== n && t.traverseVisible((function(t) {
                t.isLight && t.layers.test(e.layers) && (m.pushLight(t), t.castShadow && m.pushShadow(t))
            })), m.setupLights(y._useLegacyLights);
            const i = new Set;
            return t.traverse((function(t) {
                const e = t.material;
                if (e)
                    if (Array.isArray(e))
                        for (let s = 0; s < e.length; s++) {
                            const r = e[s];
                            Tt(r, n, t), i.add(r)
                        } else Tt(e, n, t), i.add(e)
            })), v.pop(), m = null, i
        }, this.compileAsync = function(t, e, n = null) {
            const i = this.compile(t, e, n);
            return new Promise((e => {
                function n() {
                    i.forEach((function(t) {
                        q.get(t).currentProgram.isReady() && i.delete(t)
                    })), 0 !== i.size ? setTimeout(n, 10) : e(t)
                }
                null !== X.get("KHR_parallel_shader_compile") ? n() : setTimeout(n, 10)
            }))
        };
        let Et = null;

        function Ct() {
            Pt.stop()
        }

        function Rt() {
            Pt.start()
        }
        const Pt = new Ap;

        function Dt(t, e, n, i) {
            if (!1 === t.visible) return;
            if (t.layers.test(e.layers))
                if (t.isGroup) n = t.renderOrder;
                else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
            else if (t.isLight) m.pushLight(t), t.castShadow && m.pushShadow(t);
            else if (t.isSprite) {
                if (!t.frustumCulled || k.intersectsSprite(t)) {
                    i && V.setFromMatrixPosition(t.matrixWorld).applyMatrix4(H);
                    const e = nt.update(t),
                        s = t.material;
                    s.visible && f.push(t, e, s, n, V.z, null)
                }
            } else if ((t.isMesh || t.isLine || t.isPoints) && (!t.frustumCulled || k.intersectsObject(t))) {
                const e = nt.update(t),
                    s = t.material;
                if (i && (void 0 !== t.boundingSphere ? (null === t.boundingSphere && t.computeBoundingSphere(), V.copy(t.boundingSphere.center)) : (null === e.boundingSphere && e.computeBoundingSphere(), V.copy(e.boundingSphere.center)), V.applyMatrix4(t.matrixWorld).applyMatrix4(H)), Array.isArray(s)) {
                    const i = e.groups;
                    for (let r = 0, o = i.length; r < o; r++) {
                        const o = i[r],
                            a = s[o.materialIndex];
                        a && a.visible && f.push(t, e, a, n, V.z, o)
                    }
                } else s.visible && f.push(t, e, s, n, V.z, null)
            }
            const s = t.children;
            for (let t = 0, r = s.length; t < r; t++) Dt(s[t], e, n, i)
        }

        function It(t, e, n, i) {
            const s = t.opaque,
                r = t.transmissive,
                o = t.transparent;
            m.setupLightsView(n), !0 === z && ct.setGlobalState(y.clippingPlanes, n), i && K.viewport(M.copy(i)), s.length > 0 && Ut(s, e, n), r.length > 0 && Ut(r, e, n), o.length > 0 && Ut(o, e, n), K.buffers.depth.setTest(!0), K.buffers.depth.setMask(!0), K.buffers.color.setMask(!0), K.setPolygonOffset(!1)
        }

        function Lt(t, e, n, i) {
            if (null !== (!0 === n.isScene ? n.overrideMaterial : null)) return;
            void 0 === m.state.transmissionRenderTarget[i.id] && (m.state.transmissionRenderTarget[i.id] = new nn(1, 1, {
                generateMipmaps: !0,
                type: X.has("EXT_color_buffer_half_float") || X.has("EXT_color_buffer_float") ? Ha : Qt,
                minFilter: Ei,
                samples: 4,
                stencilBuffer: s,
                resolveDepthBuffer: !1,
                resolveStencilBuffer: !1
            }));
            const r = m.state.transmissionRenderTarget[i.id],
                o = i.viewport || M;
            r.setSize(o.z, o.w);
            const a = y.getRenderTarget();
            y.setRenderTarget(r), y.getClearColor(C), R = y.getClearAlpha(), R < 1 && y.setClearColor(16777215, .5), y.clear();
            const l = y.toneMapping;
            y.toneMapping = qi;
            const c = i.viewport;
            if (void 0 !== i.viewport && (i.viewport = void 0), m.setupLightsView(i), !0 === z && ct.setGlobalState(y.clippingPlanes, i), Ut(t, n, i), Z.updateMultisampleRenderTarget(r), Z.updateRenderTargetMipmap(r), !1 === X.has("WEBGL_multisampled_render_to_texture")) {
                let t = !1;
                for (let s = 0, r = e.length; s < r; s++) {
                    const r = e[s],
                        o = r.object,
                        a = r.geometry,
                        l = r.material,
                        c = r.group;
                    if (2 === l.side && o.layers.test(i.layers)) {
                        const e = l.side;
                        l.side = Bt, l.needsUpdate = !0, Ot(o, n, i, a, l, c), l.side = e, l.needsUpdate = !0, t = !0
                    }
                }!0 === t && (Z.updateMultisampleRenderTarget(r), Z.updateRenderTargetMipmap(r))
            }
            y.setRenderTarget(a), y.setClearColor(C, R), void 0 !== c && (i.viewport = c), y.toneMapping = l
        }

        function Ut(t, e, n) {
            const i = !0 === e.isScene ? e.overrideMaterial : null;
            for (let s = 0, r = t.length; s < r; s++) {
                const r = t[s],
                    o = r.object,
                    a = r.geometry,
                    l = null === i ? r.material : i,
                    c = r.group;
                o.layers.test(n.layers) && Ot(o, e, n, a, l, c)
            }
        }

        function Ot(t, e, n, i, s, r) {
            t.onBeforeRender(y, e, n, i, s, r), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), s.onBeforeRender(y, e, n, i, t, r), !0 === s.transparent && 2 === s.side && !1 === s.forceSinglePass ? (s.side = Bt, s.needsUpdate = !0, y.renderBufferDirect(n, e, i, s, t, r), s.side = li, s.needsUpdate = !0, y.renderBufferDirect(n, e, i, s, t, r), s.side = 2) : y.renderBufferDirect(n, e, i, s, t, r), t.onAfterRender(y, e, n, i, s, r)
        }

        function Nt(t, e, n) {
            !0 !== e.isScene && (e = W);
            const i = q.get(t),
                s = m.state.lights,
                r = m.state.shadowsArray,
                o = s.state.version,
                a = it.getParameters(t, s.state, r, e, n),
                l = it.getProgramCacheKey(a);
            let c = i.programs;
            i.environment = t.isMeshStandardMaterial ? e.environment : null, i.fog = e.fog, i.envMap = (t.isMeshStandardMaterial ? $ : J).get(t.envMap || i.environment), i.envMapRotation = null !== i.environment && null === t.envMap ? e.environmentRotation : t.envMapRotation, void 0 === c && (t.addEventListener("dispose", Mt), c = new Map, i.programs = c);
            let h = c.get(l);
            if (void 0 !== h) {
                if (i.currentProgram === h && i.lightsStateVersion === o) return kt(t, a), h
            } else a.uniforms = it.getUniforms(t), t.onBuild(n, a, y), t.onBeforeCompile(a, y), h = it.acquireProgram(a, l), c.set(l, h), i.uniforms = a.uniforms;
            const u = i.uniforms;
            return (!t.isShaderMaterial && !t.isRawShaderMaterial || !0 === t.clipping) && (u.clippingPlanes = ct.uniform), kt(t, a), i.needsLights = function(t) {
                return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights
            }(t), i.lightsStateVersion = o, i.needsLights && (u.ambientLightColor.value = s.state.ambient, u.lightProbe.value = s.state.probe, u.directionalLights.value = s.state.directional, u.directionalLightShadows.value = s.state.directionalShadow, u.spotLights.value = s.state.spot, u.spotLightShadows.value = s.state.spotShadow, u.rectAreaLights.value = s.state.rectArea, u.ltc_1.value = s.state.rectAreaLTC1, u.ltc_2.value = s.state.rectAreaLTC2, u.pointLights.value = s.state.point, u.pointLightShadows.value = s.state.pointShadow, u.hemisphereLights.value = s.state.hemi, u.directionalShadowMap.value = s.state.directionalShadowMap, u.directionalShadowMatrix.value = s.state.directionalShadowMatrix, u.spotShadowMap.value = s.state.spotShadowMap, u.spotLightMatrix.value = s.state.spotLightMatrix, u.spotLightMap.value = s.state.spotLightMap, u.pointShadowMap.value = s.state.pointShadowMap, u.pointShadowMatrix.value = s.state.pointShadowMatrix), i.currentProgram = h, i.uniformsList = null, h
        }

        function Ft(t) {
            if (null === t.uniformsList) {
                const e = t.currentProgram.getUniforms();
                t.uniformsList = Ma.seqWithValue(e.seq, t.uniforms)
            }
            return t.uniformsList
        }

        function kt(t, e) {
            const n = q.get(t);
            n.outputColorSpace = e.outputColorSpace, n.batching = e.batching, n.instancing = e.instancing, n.instancingColor = e.instancingColor, n.instancingMorph = e.instancingMorph, n.skinning = e.skinning, n.morphTargets = e.morphTargets, n.morphNormals = e.morphNormals, n.morphColors = e.morphColors, n.morphTargetsCount = e.morphTargetsCount, n.numClippingPlanes = e.numClippingPlanes, n.numIntersection = e.numClipIntersection, n.vertexAlphas = e.vertexAlphas, n.vertexTangents = e.vertexTangents, n.toneMapping = e.toneMapping
        }
        Pt.setAnimationLoop((function(t) {
            Et && Et(t)
        })), typeof self < "u" && Pt.setContext(self), this.setAnimationLoop = function(t) {
            Et = t, At.setAnimationLoop(t), null === t ? Pt.stop() : Pt.start()
        }, At.addEventListener("sessionstart", Ct), At.addEventListener("sessionend", Rt), this.render = function(t, e) {
            if (void 0 !== e && !0 !== e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
            if (!0 === x) return;
            !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(), null === e.parent && !0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(), !0 === At.enabled && !0 === At.isPresenting && (!0 === At.cameraAutoUpdate && At.updateCamera(e), e = At.getCamera()), !0 === t.isScene && t.onBeforeRender(y, t, e, S), m = lt.get(t, v.length), m.init(e), v.push(m), H.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), k.setFromProjectionMatrix(H), G = this.localClippingEnabled, z = ct.init(this.clippingPlanes, G), f = at.get(t, g.length), f.init(), g.push(f), Dt(t, e, 0, y.sortObjects), f.finish(), !0 === y.sortObjects && f.sort(L, O);
            const n = !1 === At.enabled || !1 === At.isPresenting || !1 === At.hasDepthSensing();
            n && ut.addToRenderList(f, t), this.info.render.frame++, !0 === z && ct.beginShadows();
            const i = m.state.shadowsArray;
            ht.render(i, t, e), !0 === z && ct.endShadows(), !0 === this.info.autoReset && this.info.reset();
            const s = f.opaque,
                r = f.transmissive;
            if (m.setupLights(y._useLegacyLights), e.isArrayCamera) {
                const i = e.cameras;
                if (r.length > 0)
                    for (let e = 0, n = i.length; e < n; e++) {
                        Lt(s, r, t, i[e])
                    }
                n && ut.render(t);
                for (let e = 0, n = i.length; e < n; e++) {
                    const n = i[e];
                    It(f, t, n, n.viewport)
                }
            } else r.length > 0 && Lt(s, r, t, e), n && ut.render(t), It(f, t, e);
            null !== S && (Z.updateMultisampleRenderTarget(S), Z.updateRenderTargetMipmap(S)), !0 === t.isScene && t.onAfterRender(y, t, e), gt.resetDefaultState(), w = -1, _ = null, v.pop(), v.length > 0 ? (m = v[v.length - 1], !0 === z && ct.setGlobalState(y.clippingPlanes, m.state.camera)) : m = null, g.pop(), f = g.length > 0 ? g[g.length - 1] : null
        }, this.getActiveCubeFace = function() {
            return b
        }, this.getActiveMipmapLevel = function() {
            return A
        }, this.getRenderTarget = function() {
            return S
        }, this.setRenderTargetTextures = function(t, e, n) {
            q.get(t.texture).__webglTexture = e, q.get(t.depthTexture).__webglTexture = n;
            const i = q.get(t);
            i.__hasExternalTextures = !0, i.__autoAllocateDepthBuffer = void 0 === n, i.__autoAllocateDepthBuffer || !0 === X.has("WEBGL_multisampled_render_to_texture") && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), i.__useRenderToTexture = !1)
        }, this.setRenderTargetFramebuffer = function(t, e) {
            const n = q.get(t);
            n.__webglFramebuffer = e, n.__useDefaultFramebuffer = void 0 === e
        }, this.setRenderTarget = function(t, e = 0, n = 0) {
            S = t, b = e, A = n;
            let i = !0,
                s = null,
                r = !1,
                o = !1;
            if (t) {
                const a = q.get(t);
                void 0 !== a.__useDefaultFramebuffer ? (K.bindFramebuffer(yt.FRAMEBUFFER, null), i = !1) : void 0 === a.__webglFramebuffer ? Z.setupRenderTarget(t) : a.__hasExternalTextures && Z.rebindTextures(t, q.get(t.texture).__webglTexture, q.get(t.depthTexture).__webglTexture);
                const l = t.texture;
                (l.isData3DTexture || l.isDataArrayTexture || l.isCompressedArrayTexture) && (o = !0);
                const c = q.get(t).__webglFramebuffer;
                t.isWebGLCubeRenderTarget ? (s = Array.isArray(c[e]) ? c[e][n] : c[e], r = !0) : s = t.samples > 0 && !1 === Z.useMultisampledRTT(t) ? q.get(t).__webglMultisampledFramebuffer : Array.isArray(c) ? c[n] : c, M.copy(t.viewport), T.copy(t.scissor), E = t.scissorTest
            } else M.copy(B).multiplyScalar(I).floor(), T.copy(N).multiplyScalar(I).floor(), E = F;
            if (K.bindFramebuffer(yt.FRAMEBUFFER, s) && i && K.drawBuffers(t, s), K.viewport(M), K.scissor(T), K.setScissorTest(E), r) {
                const i = q.get(t.texture);
                yt.framebufferTexture2D(yt.FRAMEBUFFER, yt.COLOR_ATTACHMENT0, yt.TEXTURE_CUBE_MAP_POSITIVE_X + e, i.__webglTexture, n)
            } else if (o) {
                const i = q.get(t.texture),
                    s = e || 0;
                yt.framebufferTextureLayer(yt.FRAMEBUFFER, yt.COLOR_ATTACHMENT0, i.__webglTexture, n || 0, s)
            }
            w = -1
        }, this.readRenderTargetPixels = function(t, e, n, i, s, r, o) {
            if (!t || !t.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            let a = q.get(t).__webglFramebuffer;
            if (t.isWebGLCubeRenderTarget && void 0 !== o && (a = a[o]), a) {
                K.bindFramebuffer(yt.FRAMEBUFFER, a);
                try {
                    const o = t.texture,
                        a = o.format,
                        l = o.type;
                    if (!Q.textureFormatReadable(a)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                    if (!Q.textureTypeReadable(l)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                    e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - s && yt.readPixels(e, n, i, s, mt.convert(a), mt.convert(l), r)
                } finally {
                    const t = null !== S ? q.get(S).__webglFramebuffer : null;
                    K.bindFramebuffer(yt.FRAMEBUFFER, t)
                }
            }
        }, this.copyFramebufferToTexture = function(t, e, n = 0) {
            const i = Math.pow(2, -n),
                s = Math.floor(e.image.width * i),
                r = Math.floor(e.image.height * i);
            Z.setTexture2D(e, 0), yt.copyTexSubImage2D(yt.TEXTURE_2D, n, 0, 0, t.x, t.y, s, r), K.unbindTexture()
        }, this.copyTextureToTexture = function(t, e, n, i = 0) {
            const s = e.image.width,
                r = e.image.height,
                o = mt.convert(n.format),
                a = mt.convert(n.type);
            Z.setTexture2D(n, 0), yt.pixelStorei(yt.UNPACK_FLIP_Y_WEBGL, n.flipY), yt.pixelStorei(yt.UNPACK_PREMULTIPLY_ALPHA_WEBGL, n.premultiplyAlpha), yt.pixelStorei(yt.UNPACK_ALIGNMENT, n.unpackAlignment), e.isDataTexture ? yt.texSubImage2D(yt.TEXTURE_2D, i, t.x, t.y, s, r, o, a, e.image.data) : e.isCompressedTexture ? yt.compressedTexSubImage2D(yt.TEXTURE_2D, i, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, o, e.mipmaps[0].data) : yt.texSubImage2D(yt.TEXTURE_2D, i, t.x, t.y, o, a, e.image), 0 === i && n.generateMipmaps && yt.generateMipmap(yt.TEXTURE_2D), K.unbindTexture()
        }, this.copyTextureToTexture3D = function(t, e, n, i, s = 0) {
            const r = t.max.x - t.min.x,
                o = t.max.y - t.min.y,
                a = t.max.z - t.min.z,
                l = mt.convert(i.format),
                c = mt.convert(i.type);
            let h;
            if (i.isData3DTexture) Z.setTexture3D(i, 0), h = yt.TEXTURE_3D;
            else {
                if (!i.isDataArrayTexture && !i.isCompressedArrayTexture) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                Z.setTexture2DArray(i, 0), h = yt.TEXTURE_2D_ARRAY
            }
            yt.pixelStorei(yt.UNPACK_FLIP_Y_WEBGL, i.flipY), yt.pixelStorei(yt.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha), yt.pixelStorei(yt.UNPACK_ALIGNMENT, i.unpackAlignment);
            const u = yt.getParameter(yt.UNPACK_ROW_LENGTH),
                d = yt.getParameter(yt.UNPACK_IMAGE_HEIGHT),
                p = yt.getParameter(yt.UNPACK_SKIP_PIXELS),
                f = yt.getParameter(yt.UNPACK_SKIP_ROWS),
                m = yt.getParameter(yt.UNPACK_SKIP_IMAGES),
                g = n.isCompressedTexture ? n.mipmaps[s] : n.image;
            yt.pixelStorei(yt.UNPACK_ROW_LENGTH, g.width), yt.pixelStorei(yt.UNPACK_IMAGE_HEIGHT, g.height), yt.pixelStorei(yt.UNPACK_SKIP_PIXELS, t.min.x), yt.pixelStorei(yt.UNPACK_SKIP_ROWS, t.min.y), yt.pixelStorei(yt.UNPACK_SKIP_IMAGES, t.min.z), n.isDataTexture || n.isData3DTexture ? yt.texSubImage3D(h, s, e.x, e.y, e.z, r, o, a, l, c, g.data) : i.isCompressedArrayTexture ? yt.compressedTexSubImage3D(h, s, e.x, e.y, e.z, r, o, a, l, g.data) : yt.texSubImage3D(h, s, e.x, e.y, e.z, r, o, a, l, c, g), yt.pixelStorei(yt.UNPACK_ROW_LENGTH, u), yt.pixelStorei(yt.UNPACK_IMAGE_HEIGHT, d), yt.pixelStorei(yt.UNPACK_SKIP_PIXELS, p), yt.pixelStorei(yt.UNPACK_SKIP_ROWS, f), yt.pixelStorei(yt.UNPACK_SKIP_IMAGES, m), 0 === s && i.generateMipmaps && yt.generateMipmap(h), K.unbindTexture()
        }, this.initTexture = function(t) {
            t.isCubeTexture ? Z.setTextureCube(t, 0) : t.isData3DTexture ? Z.setTexture3D(t, 0) : t.isDataArrayTexture || t.isCompressedArrayTexture ? Z.setTexture2DArray(t, 0) : Z.setTexture2D(t, 0), K.unbindTexture()
        }, this.resetState = function() {
            b = 0, A = 0, S = null, K.reset(), gt.reset()
        }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
        }))
    }
    get coordinateSystem() {
        return Ti
    }
    get outputColorSpace() {
        return this._outputColorSpace
    }
    set outputColorSpace(t) {
        this._outputColorSpace = t;
        const e = this.getContext();
        e.drawingBufferColorSpace = t === lh ? "display-p3" : "srgb", e.unpackColorSpace = vt.workingColorSpace === Wa ? "display-p3" : "srgb"
    }
    get useLegacyLights() {
        return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights
    }
    set useLegacyLights(t) {
        console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights = t
    }
}
class mh {
    constructor(t, e = 1, n = 1e3) {
        this.isFog = !0, this.name = "", this.color = new Le(t), this.near = e, this.far = n
    }
    clone() {
        return new mh(this.color, this.near, this.far)
    }
    toJSON() {
        return {
            type: "Fog",
            name: this.name,
            color: this.color.getHex(),
            near: this.near,
            far: this.far
        }
    }
}
class Bc extends ct {
    constructor() {
        super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new Gn, this.environmentIntensity = 1, this.environmentRotation = new Gn, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
        }))
    }
    copy(t, e) {
        return super.copy(t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), this.backgroundBlurriness = t.backgroundBlurriness, this.backgroundIntensity = t.backgroundIntensity, this.backgroundRotation.copy(t.backgroundRotation), this.environmentIntensity = t.environmentIntensity, this.environmentRotation.copy(t.environmentRotation), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.matrixAutoUpdate = t.matrixAutoUpdate, this
    }
    toJSON(t) {
        const e = super.toJSON(t);
        return null !== this.fog && (e.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (e.object.backgroundBlurriness = this.backgroundBlurriness), 1 !== this.backgroundIntensity && (e.object.backgroundIntensity = this.backgroundIntensity), e.object.backgroundRotation = this.backgroundRotation.toArray(), 1 !== this.environmentIntensity && (e.object.environmentIntensity = this.environmentIntensity), e.object.environmentRotation = this.environmentRotation.toArray(), e
    }
}
class gh {
    constructor(t, e) {
        this.isInterleavedBuffer = !0, this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = Ic, this._updateRange = {
            offset: 0,
            count: -1
        }, this.updateRanges = [], this.version = 0, this.uuid = zn()
    }
    onUploadCallback() {}
    set needsUpdate(t) {
        !0 === t && this.version++
    }
    get updateRange() {
        return fp("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange
    }
    setUsage(t) {
        return this.usage = t, this
    }
    addUpdateRange(t, e) {
        this.updateRanges.push({
            start: t,
            count: e
        })
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0
    }
    copy(t) {
        return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this
    }
    copyAt(t, e, n) {
        t *= this.stride, n *= e.stride;
        for (let i = 0, s = this.stride; i < s; i++) this.array[t + i] = e.array[n + i];
        return this
    }
    set(t, e = 0) {
        return this.array.set(t, e), this
    }
    clone(t) {
        void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = zn()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
        const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),
            n = new this.constructor(e, this.stride);
        return n.setUsage(this.usage), n
    }
    onUpload(t) {
        return this.onUploadCallback = t, this
    }
    toJSON(t) {
        return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = zn()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
        }
    }
}
const un = new U;
class Qn {
    constructor(t, e, n, i = !1) {
        this.isInterleavedBufferAttribute = !0, this.name = "", this.data = t, this.itemSize = e, this.offset = n, this.normalized = i
    }
    get count() {
        return this.data.count
    }
    get array() {
        return this.data.array
    }
    set needsUpdate(t) {
        this.data.needsUpdate = t
    }
    applyMatrix4(t) {
        for (let e = 0, n = this.data.count; e < n; e++) un.fromBufferAttribute(this, e), un.applyMatrix4(t), this.setXYZ(e, un.x, un.y, un.z);
        return this
    }
    applyNormalMatrix(t) {
        for (let e = 0, n = this.count; e < n; e++) un.fromBufferAttribute(this, e), un.applyNormalMatrix(t), this.setXYZ(e, un.x, un.y, un.z);
        return this
    }
    transformDirection(t) {
        for (let e = 0, n = this.count; e < n; e++) un.fromBufferAttribute(this, e), un.transformDirection(t), this.setXYZ(e, un.x, un.y, un.z);
        return this
    }
    getComponent(t, e) {
        let n = this.array[t * this.data.stride + this.offset + e];
        return this.normalized && (n = Yn(n, this.array)), n
    }
    setComponent(t, e, n) {
        return this.normalized && (n = mt(n, this.array)), this.data.array[t * this.data.stride + this.offset + e] = n, this
    }
    setX(t, e) {
        return this.normalized && (e = mt(e, this.array)), this.data.array[t * this.data.stride + this.offset] = e, this
    }
    setY(t, e) {
        return this.normalized && (e = mt(e, this.array)), this.data.array[t * this.data.stride + this.offset + 1] = e, this
    }
    setZ(t, e) {
        return this.normalized && (e = mt(e, this.array)), this.data.array[t * this.data.stride + this.offset + 2] = e, this
    }
    setW(t, e) {
        return this.normalized && (e = mt(e, this.array)), this.data.array[t * this.data.stride + this.offset + 3] = e, this
    }
    getX(t) {
        let e = this.data.array[t * this.data.stride + this.offset];
        return this.normalized && (e = Yn(e, this.array)), e
    }
    getY(t) {
        let e = this.data.array[t * this.data.stride + this.offset + 1];
        return this.normalized && (e = Yn(e, this.array)), e
    }
    getZ(t) {
        let e = this.data.array[t * this.data.stride + this.offset + 2];
        return this.normalized && (e = Yn(e, this.array)), e
    }
    getW(t) {
        let e = this.data.array[t * this.data.stride + this.offset + 3];
        return this.normalized && (e = Yn(e, this.array)), e
    }
    setXY(t, e, n) {
        return t = t * this.data.stride + this.offset, this.normalized && (e = mt(e, this.array), n = mt(n, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = n, this
    }
    setXYZ(t, e, n, i) {
        return t = t * this.data.stride + this.offset, this.normalized && (e = mt(e, this.array), n = mt(n, this.array), i = mt(i, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this
    }
    setXYZW(t, e, n, i, s) {
        return t = t * this.data.stride + this.offset, this.normalized && (e = mt(e, this.array), n = mt(n, this.array), i = mt(i, this.array), s = mt(s, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this.data.array[t + 3] = s, this
    }
    clone(t) {
        if (void 0 === t) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
            const t = [];
            for (let e = 0; e < this.count; e++) {
                const n = e * this.data.stride + this.offset;
                for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e])
            }
            return new Xt(new this.array.constructor(t), this.itemSize, this.normalized)
        }
        return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new Qn(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
    }
    toJSON(t) {
        if (void 0 === t) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
            const t = [];
            for (let e = 0; e < this.count; e++) {
                const n = e * this.data.stride + this.offset;
                for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e])
            }
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: t,
                normalized: this.normalized
            }
        }
        return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), {
            isInterleavedBufferAttribute: !0,
            itemSize: this.itemSize,
            data: this.data.uuid,
            offset: this.offset,
            normalized: this.normalized
        }
    }
}
class Tp extends en {
    constructor(t) {
        super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new Le(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(t)
    }
    copy(t) {
        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this.fog = t.fog, this
    }
}
let $s;
const jr = new U,
    er = new U,
    tr = new U,
    nr = new Q,
    Kr = new Q,
    Cp = new Xe,
    Zo = new U,
    Yr = new U,
    Jo = new U,
    Od = new Q,
    Jl = new Q,
    Bd = new Q;
class lS extends ct {
    constructor(t = new Tp) {
        if (super(), this.isSprite = !0, this.type = "Sprite", void 0 === $s) {
            $s = new ht;
            const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
                e = new gh(t, 5);
            $s.setIndex([0, 1, 2, 0, 2, 3]), $s.setAttribute("position", new Qn(e, 3, 0, !1)), $s.setAttribute("uv", new Qn(e, 2, 3, !1))
        }
        this.geometry = $s, this.material = t, this.center = new Q(.5, .5)
    }
    raycast(t, e) {
        null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), er.setFromMatrixScale(this.matrixWorld), Cp.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), tr.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && er.multiplyScalar(-tr.z);
        const n = this.material.rotation;
        let i, s;
        0 !== n && (s = Math.cos(n), i = Math.sin(n));
        const r = this.center;
        $o(Zo.set(-.5, -.5, 0), tr, r, er, i, s), $o(Yr.set(.5, -.5, 0), tr, r, er, i, s), $o(Jo.set(.5, .5, 0), tr, r, er, i, s), Od.set(0, 0), Jl.set(1, 0), Bd.set(1, 1);
        let o = t.ray.intersectTriangle(Zo, Yr, Jo, !1, jr);
        if (null === o && ($o(Yr.set(-.5, .5, 0), tr, r, er, i, s), Jl.set(0, 1), o = t.ray.intersectTriangle(Zo, Jo, Yr, !1, jr), null === o)) return;
        const a = t.ray.origin.distanceTo(jr);
        a < t.near || a > t.far || e.push({
            distance: a,
            point: jr.clone(),
            uv: Bn.getInterpolation(jr, Zo, Yr, Jo, Od, Jl, Bd, new Q),
            face: null,
            object: this
        })
    }
    copy(t, e) {
        return super.copy(t, e), void 0 !== t.center && this.center.copy(t.center), this.material = t.material, this
    }
}

function $o(t, e, n, i, s, r) {
    nr.subVectors(t, n).addScalar(.5).multiply(i), void 0 !== s ? (Kr.x = r * nr.x - s * nr.y, Kr.y = s * nr.x + r * nr.y) : Kr.copy(nr), t.copy(e), t.x += Kr.x, t.y += Kr.y, t.applyMatrix4(Cp)
}
const Ud = new U,
    Nd = new ot,
    Fd = new ot,
    cS = new U,
    kd = new Xe,
    ea = new U,
    $l = new Hn,
    zd = new Xe,
    ec = new Ir;
class hS extends be {
    constructor(t, e) {
        super(t, e), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = pu, this.bindMatrix = new Xe, this.bindMatrixInverse = new Xe, this.boundingBox = null, this.boundingSphere = null
    }
    computeBoundingBox() {
        const t = this.geometry;
        null === this.boundingBox && (this.boundingBox = new Tn), this.boundingBox.makeEmpty();
        const e = t.getAttribute("position");
        for (let t = 0; t < e.count; t++) this.getVertexPosition(t, ea), this.boundingBox.expandByPoint(ea)
    }
    computeBoundingSphere() {
        const t = this.geometry;
        null === this.boundingSphere && (this.boundingSphere = new Hn), this.boundingSphere.makeEmpty();
        const e = t.getAttribute("position");
        for (let t = 0; t < e.count; t++) this.getVertexPosition(t, ea), this.boundingSphere.expandByPoint(ea)
    }
    copy(t, e) {
        return super.copy(t, e), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this
    }
    raycast(t, e) {
        const n = this.material,
            i = this.matrixWorld;
        void 0 !== n && (null === this.boundingSphere && this.computeBoundingSphere(), $l.copy(this.boundingSphere), $l.applyMatrix4(i), !1 !== t.ray.intersectsSphere($l) && (zd.copy(i).invert(), ec.copy(t.ray).applyMatrix4(zd), (null === this.boundingBox || !1 !== ec.intersectsBox(this.boundingBox)) && this._computeIntersections(t, e, ec)))
    }
    getVertexPosition(t, e) {
        return super.getVertexPosition(t, e), this.applyBoneTransform(t, e), e
    }
    bind(t, e) {
        this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert()
    }
    pose() {
        this.skeleton.pose()
    }
    normalizeSkinWeights() {
        const t = new ot,
            e = this.geometry.attributes.skinWeight;
        for (let n = 0, i = e.count; n < i; n++) {
            t.fromBufferAttribute(e, n);
            const i = 1 / t.manhattanLength();
            i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w)
        }
    }
    updateMatrixWorld(t) {
        super.updateMatrixWorld(t), this.bindMode === pu ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === Sv ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
    }
    applyBoneTransform(t, e) {
        const n = this.skeleton,
            i = this.geometry;
        Nd.fromBufferAttribute(i.attributes.skinIndex, t), Fd.fromBufferAttribute(i.attributes.skinWeight, t), Ud.copy(e).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
        for (let t = 0; t < 4; t++) {
            const i = Fd.getComponent(t);
            if (0 !== i) {
                const s = Nd.getComponent(t);
                kd.multiplyMatrices(n.bones[s].matrixWorld, n.boneInverses[s]), e.addScaledVector(cS.copy(Ud).applyMatrix4(kd), i)
            }
        }
        return e.applyMatrix4(this.bindMatrixInverse)
    }
}
class Pp extends ct {
    constructor() {
        super(), this.isBone = !0, this.type = "Bone"
    }
}
class vh extends wt {
    constructor(t = null, e = 1, n = 1, i, s, r, o, a, l = Vt, c = Vt, h, u) {
        super(null, r, o, a, l, c, i, s, h, u), this.isDataTexture = !0, this.image = {
            data: t,
            width: e,
            height: n
        }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
    }
}
const Gd = new Xe,
    uS = new Xe;
class yh {
    constructor(t = [], e = []) {
        this.uuid = zn(), this.bones = t.slice(0), this.boneInverses = e, this.boneMatrices = null, this.boneTexture = null, this.init()
    }
    init() {
        const t = this.bones,
            e = this.boneInverses;
        if (this.boneMatrices = new Float32Array(16 * t.length), 0 === e.length) this.calculateInverses();
        else if (t.length !== e.length) {
            console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
            for (let t = 0, e = this.bones.length; t < e; t++) this.boneInverses.push(new Xe)
        }
    }
    calculateInverses() {
        this.boneInverses.length = 0;
        for (let t = 0, e = this.bones.length; t < e; t++) {
            const e = new Xe;
            this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(), this.boneInverses.push(e)
        }
    }
    pose() {
        for (let t = 0, e = this.bones.length; t < e; t++) {
            const e = this.bones[t];
            e && e.matrixWorld.copy(this.boneInverses[t]).invert()
        }
        for (let t = 0, e = this.bones.length; t < e; t++) {
            const e = this.bones[t];
            e && (e.parent && e.parent.isBone ? (e.matrix.copy(e.parent.matrixWorld).invert(), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale))
        }
    }
    update() {
        const t = this.bones,
            e = this.boneInverses,
            n = this.boneMatrices,
            i = this.boneTexture;
        for (let i = 0, s = t.length; i < s; i++) {
            const s = t[i] ? t[i].matrixWorld : uS;
            Gd.multiplyMatrices(s, e[i]), Gd.toArray(n, 16 * i)
        }
        null !== i && (i.needsUpdate = !0)
    }
    clone() {
        return new yh(this.bones, this.boneInverses)
    }
    computeBoneTexture() {
        let t = Math.sqrt(4 * this.bones.length);
        t = 4 * Math.ceil(t / 4), t = Math.max(t, 4);
        const e = new Float32Array(t * t * 4);
        e.set(this.boneMatrices);
        const n = new vh(e, t, t, Nn, oi);
        return n.needsUpdate = !0, this.boneMatrices = e, this.boneTexture = n, this
    }
    getBoneByName(t) {
        for (let e = 0, n = this.bones.length; e < n; e++) {
            const n = this.bones[e];
            if (n.name === t) return n
        }
    }
    dispose() {
        null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null)
    }
    fromJSON(t, e) {
        this.uuid = t.uuid;
        for (let n = 0, i = t.bones.length; n < i; n++) {
            const i = t.bones[n];
            let s = e[i];
            void 0 === s && (console.warn("THREE.Skeleton: No bone found with UUID:", i), s = new Pp), this.bones.push(s), this.boneInverses.push((new Xe).fromArray(t.boneInverses[n]))
        }
        return this.init(), this
    }
    toJSON() {
        const t = {
            metadata: {
                version: 4.6,
                type: "Skeleton",
                generator: "Skeleton.toJSON"
            },
            bones: [],
            boneInverses: []
        };
        t.uuid = this.uuid;
        const e = this.bones,
            n = this.boneInverses;
        for (let i = 0, s = e.length; i < s; i++) {
            const s = e[i];
            t.bones.push(s.uuid);
            const r = n[i];
            t.boneInverses.push(r.toArray())
        }
        return t
    }
}
class Uc extends Xt {
    constructor(t, e, n, i = 1) {
        super(t, e, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = i
    }
    copy(t) {
        return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this
    }
    toJSON() {
        const t = super.toJSON();
        return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t
    }
}
const ir = new Xe,
    Hd = new Xe,
    ta = [],
    Vd = new Tn,
    dS = new Xe,
    Qr = new be,
    qr = new Hn;
class Rp extends be {
    constructor(t, e, n) {
        super(t, e), this.isInstancedMesh = !0, this.instanceMatrix = new Uc(new Float32Array(16 * n), 16), this.instanceColor = null, this.morphTexture = null, this.count = n, this.boundingBox = null, this.boundingSphere = null;
        for (let t = 0; t < n; t++) this.setMatrixAt(t, dS)
    }
    computeBoundingBox() {
        const t = this.geometry,
            e = this.count;
        null === this.boundingBox && (this.boundingBox = new Tn), null === t.boundingBox && t.computeBoundingBox(), this.boundingBox.makeEmpty();
        for (let n = 0; n < e; n++) this.getMatrixAt(n, ir), Vd.copy(t.boundingBox).applyMatrix4(ir), this.boundingBox.union(Vd)
    }
    computeBoundingSphere() {
        const t = this.geometry,
            e = this.count;
        null === this.boundingSphere && (this.boundingSphere = new Hn), null === t.boundingSphere && t.computeBoundingSphere(), this.boundingSphere.makeEmpty();
        for (let n = 0; n < e; n++) this.getMatrixAt(n, ir), qr.copy(t.boundingSphere).applyMatrix4(ir), this.boundingSphere.union(qr)
    }
    copy(t, e) {
        return super.copy(t, e), this.instanceMatrix.copy(t.instanceMatrix), null !== t.morphTexture && (this.morphTexture = t.morphTexture.clone()), null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()), this.count = t.count, null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this
    }
    getColorAt(t, e) {
        e.fromArray(this.instanceColor.array, 3 * t)
    }
    getMatrixAt(t, e) {
        e.fromArray(this.instanceMatrix.array, 16 * t)
    }
    getMorphAt(t, e) {
        const n = e.morphTargetInfluences,
            i = this.morphTexture.source.data.data,
            s = t * (n.length + 1) + 1;
        for (let t = 0; t < n.length; t++) n[t] = i[s + t]
    }
    raycast(t, e) {
        const n = this.matrixWorld,
            i = this.count;
        if (Qr.geometry = this.geometry, Qr.material = this.material, void 0 !== Qr.material && (null === this.boundingSphere && this.computeBoundingSphere(), qr.copy(this.boundingSphere), qr.applyMatrix4(n), !1 !== t.ray.intersectsSphere(qr)))
            for (let s = 0; s < i; s++) {
                this.getMatrixAt(s, ir), Hd.multiplyMatrices(n, ir), Qr.matrixWorld = Hd, Qr.raycast(t, ta);
                for (let t = 0, n = ta.length; t < n; t++) {
                    const n = ta[t];
                    n.instanceId = s, n.object = this, e.push(n)
                }
                ta.length = 0
            }
    }
    setColorAt(t, e) {
        null === this.instanceColor && (this.instanceColor = new Uc(new Float32Array(3 * this.instanceMatrix.count), 3)), e.toArray(this.instanceColor.array, 3 * t)
    }
    setMatrixAt(t, e) {
        e.toArray(this.instanceMatrix.array, 16 * t)
    }
    setMorphAt(t, e) {
        const n = e.morphTargetInfluences,
            i = n.length + 1;
        null === this.morphTexture && (this.morphTexture = new vh(new Float32Array(i * this.count), i, this.count, sh, oi));
        const s = this.morphTexture.source.data.data;
        let r = 0;
        for (let t = 0; t < n.length; t++) r += n[t];
        const o = this.geometry.morphTargetsRelative ? 1 : 1 - r,
            a = i * t;
        s[a] = o, s.set(n, a + 1)
    }
    updateMorphTargets() {}
    dispose() {
        return this.dispatchEvent({
            type: "dispose"
        }), null !== this.morphTexture && (this.morphTexture.dispose(), this.morphTexture = null), this
    }
}
class Zi extends en {
    constructor(t) {
        super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new Le(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(t)
    }
    copy(t) {
        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.fog = t.fog, this
    }
}
const La = new U,
    Oa = new U,
    Wd = new Xe,
    Zr = new Ir,
    na = new Hn,
    tc = new U,
    Xd = new U;
class at extends ct {
    constructor(t = new ht, e = new Zi) {
        super(), this.isLine = !0, this.type = "Line", this.geometry = t, this.material = e, this.updateMorphTargets()
    }
    copy(t, e) {
        return super.copy(t, e), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this
    }
    computeLineDistances() {
        const t = this.geometry;
        if (null === t.index) {
            const e = t.attributes.position,
                n = [0];
            for (let t = 1, i = e.count; t < i; t++) La.fromBufferAttribute(e, t - 1), Oa.fromBufferAttribute(e, t), n[t] = n[t - 1], n[t] += La.distanceTo(Oa);
            t.setAttribute("lineDistance", new Fe(n, 1))
        } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
    raycast(t, e) {
        const n = this.geometry,
            i = this.matrixWorld,
            s = t.params.Line.threshold,
            r = n.drawRange;
        if (null === n.boundingSphere && n.computeBoundingSphere(), na.copy(n.boundingSphere), na.applyMatrix4(i), na.radius += s, !1 === t.ray.intersectsSphere(na)) return;
        Wd.copy(i).invert(), Zr.copy(t.ray).applyMatrix4(Wd);
        const o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            a = o * o,
            l = this.isLineSegments ? 2 : 1,
            c = n.index,
            h = n.attributes.position;
        if (null !== c) {
            const n = Math.max(0, r.start),
                i = Math.min(c.count, r.start + r.count);
            for (let s = n, r = i - 1; s < r; s += l) {
                const n = c.getX(s),
                    i = c.getX(s + 1),
                    r = ia(this, t, Zr, a, n, i);
                r && e.push(r)
            }
            if (this.isLineLoop) {
                const s = c.getX(i - 1),
                    r = c.getX(n),
                    o = ia(this, t, Zr, a, s, r);
                o && e.push(o)
            }
        } else {
            const n = Math.max(0, r.start),
                i = Math.min(h.count, r.start + r.count);
            for (let s = n, r = i - 1; s < r; s += l) {
                const n = ia(this, t, Zr, a, s, s + 1);
                n && e.push(n)
            }
            if (this.isLineLoop) {
                const s = ia(this, t, Zr, a, i - 1, n);
                s && e.push(s)
            }
        }
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes,
            e = Object.keys(t);
        if (e.length > 0) {
            const n = t[e[0]];
            if (void 0 !== n) {
                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                for (let t = 0, e = n.length; t < e; t++) {
                    const e = n[t].name || String(t);
                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[e] = t
                }
            }
        }
    }
}

function ia(t, e, n, i, s, r) {
    const o = t.geometry.attributes.position;
    if (La.fromBufferAttribute(o, s), Oa.fromBufferAttribute(o, r), n.distanceSqToSegment(La, Oa, tc, Xd) > i) return;
    tc.applyMatrix4(t.matrixWorld);
    const a = e.ray.origin.distanceTo(tc);
    return a < e.near || a > e.far ? void 0 : {
        distance: a,
        point: Xd.clone().applyMatrix4(t.matrixWorld),
        index: s,
        face: null,
        faceIndex: null,
        object: t
    }
}
const jd = new U,
    Kd = new U;
class mo extends at {
    constructor(t, e) {
        super(t, e), this.isLineSegments = !0, this.type = "LineSegments"
    }
    computeLineDistances() {
        const t = this.geometry;
        if (null === t.index) {
            const e = t.attributes.position,
                n = [];
            for (let t = 0, i = e.count; t < i; t += 2) jd.fromBufferAttribute(e, t), Kd.fromBufferAttribute(e, t + 1), n[t] = 0 === t ? 0 : n[t - 1], n[t + 1] = n[t] + jd.distanceTo(Kd);
            t.setAttribute("lineDistance", new Fe(n, 1))
        } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
}
class fS extends at {
    constructor(t, e) {
        super(t, e), this.isLineLoop = !0, this.type = "LineLoop"
    }
}
class xs extends en {
    constructor(t) {
        super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new Le(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(t)
    }
    copy(t) {
        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.fog = t.fog, this
    }
}
const Yd = new Xe,
    Nc = new Ir,
    sa = new Hn,
    ra = new U;
class so extends ct {
    constructor(t = new ht, e = new xs) {
        super(), this.isPoints = !0, this.type = "Points", this.geometry = t, this.material = e, this.updateMorphTargets()
    }
    copy(t, e) {
        return super.copy(t, e), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this
    }
    raycast(t, e) {
        const n = this.geometry,
            i = this.matrixWorld,
            s = t.params.Points.threshold,
            r = n.drawRange;
        if (null === n.boundingSphere && n.computeBoundingSphere(), sa.copy(n.boundingSphere), sa.applyMatrix4(i), sa.radius += s, !1 === t.ray.intersectsSphere(sa)) return;
        Yd.copy(i).invert(), Nc.copy(t.ray).applyMatrix4(Yd);
        const o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            a = o * o,
            l = n.index,
            c = n.attributes.position;
        if (null !== l) {
            for (let n = Math.max(0, r.start), s = Math.min(l.count, r.start + r.count); n < s; n++) {
                const s = l.getX(n);
                ra.fromBufferAttribute(c, s), Qd(ra, s, a, i, t, e, this)
            }
        } else {
            for (let n = Math.max(0, r.start), s = Math.min(c.count, r.start + r.count); n < s; n++) ra.fromBufferAttribute(c, n), Qd(ra, n, a, i, t, e, this)
        }
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes,
            e = Object.keys(t);
        if (e.length > 0) {
            const n = t[e[0]];
            if (void 0 !== n) {
                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                for (let t = 0, e = n.length; t < e; t++) {
                    const e = n[t].name || String(t);
                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[e] = t
                }
            }
        }
    }
}

function Qd(t, e, n, i, s, r, o) {
    const a = Nc.distanceSqToPoint(t);
    if (a < n) {
        const n = new U;
        Nc.closestPointToPoint(t, n), n.applyMatrix4(i);
        const l = s.ray.origin.distanceTo(n);
        if (l < s.near || l > s.far) return;
        r.push({
            distance: l,
            distanceToRay: Math.sqrt(a),
            point: n,
            index: e,
            face: null,
            object: o
        })
    }
}
class Er extends wt {
    constructor(t, e, n, i, s, r, o, a, l) {
        super(t, e, n, i, s, r, o, a, l), this.isCanvasTexture = !0, this.needsUpdate = !0
    }
}
class ui {
    constructor() {
        this.type = "Curve", this.arcLengthDivisions = 200
    }
    getPoint() {
        return console.warn("THREE.Curve: .getPoint() not implemented."), null
    }
    getPointAt(t, e) {
        const n = this.getUtoTmapping(t);
        return this.getPoint(n, e)
    }
    getPoints(t = 5) {
        const e = [];
        for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
        return e
    }
    getSpacedPoints(t = 5) {
        const e = [];
        for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
        return e
    }
    getLength() {
        const t = this.getLengths();
        return t[t.length - 1]
    }
    getLengths(t = this.arcLengthDivisions) {
        if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
        this.needsUpdate = !1;
        const e = [];
        let n, i = this.getPoint(0),
            s = 0;
        e.push(0);
        for (let r = 1; r <= t; r++) n = this.getPoint(r / t), s += n.distanceTo(i), e.push(s), i = n;
        return this.cacheArcLengths = e, e
    }
    updateArcLengths() {
        this.needsUpdate = !0, this.getLengths()
    }
    getUtoTmapping(t, e) {
        const n = this.getLengths();
        let i = 0;
        const s = n.length;
        let r;
        r = e || t * n[s - 1];
        let o, a = 0,
            l = s - 1;
        for (; a <= l;)
            if (i = Math.floor(a + (l - a) / 2), o = n[i] - r, o < 0) a = i + 1;
            else {
                if (!(o > 0)) {
                    l = i;
                    break
                }
                l = i - 1
            }
        if (i = l, n[i] === r) return i / (s - 1);
        const c = n[i];
        return (i + (r - c) / (n[i + 1] - c)) / (s - 1)
    }
    getTangent(t, e) {
        let n = t - 1e-4,
            i = t + 1e-4;
        n < 0 && (n = 0), i > 1 && (i = 1);
        const s = this.getPoint(n),
            r = this.getPoint(i),
            o = e || (s.isVector2 ? new Q : new U);
        return o.copy(r).sub(s).normalize(), o
    }
    getTangentAt(t, e) {
        const n = this.getUtoTmapping(t);
        return this.getTangent(n, e)
    }
    computeFrenetFrames(t, e) {
        const n = new U,
            i = [],
            s = [],
            r = [],
            o = new U,
            a = new Xe;
        for (let e = 0; e <= t; e++) {
            const n = e / t;
            i[e] = this.getTangentAt(n, new U)
        }
        s[0] = new U, r[0] = new U;
        let l = Number.MAX_VALUE;
        const c = Math.abs(i[0].x),
            h = Math.abs(i[0].y),
            u = Math.abs(i[0].z);
        c <= l && (l = c, n.set(1, 0, 0)), h <= l && (l = h, n.set(0, 1, 0)), u <= l && n.set(0, 0, 1), o.crossVectors(i[0], n).normalize(), s[0].crossVectors(i[0], o), r[0].crossVectors(i[0], s[0]);
        for (let e = 1; e <= t; e++) {
            if (s[e] = s[e - 1].clone(), r[e] = r[e - 1].clone(), o.crossVectors(i[e - 1], i[e]), o.length() > Number.EPSILON) {
                o.normalize();
                const t = Math.acos(Ut(i[e - 1].dot(i[e]), -1, 1));
                s[e].applyMatrix4(a.makeRotationAxis(o, t))
            }
            r[e].crossVectors(i[e], s[e])
        }
        if (!0 === e) {
            let e = Math.acos(Ut(s[0].dot(s[t]), -1, 1));
            e /= t, i[0].dot(o.crossVectors(s[0], s[t])) > 0 && (e = -e);
            for (let n = 1; n <= t; n++) s[n].applyMatrix4(a.makeRotationAxis(i[n], e * n)), r[n].crossVectors(i[n], s[n])
        }
        return {
            tangents: i,
            normals: s,
            binormals: r
        }
    }
    clone() {
        return (new this.constructor).copy(this)
    }
    copy(t) {
        return this.arcLengthDivisions = t.arcLengthDivisions, this
    }
    toJSON() {
        const t = {
            metadata: {
                version: 4.6,
                type: "Curve",
                generator: "Curve.toJSON"
            }
        };
        return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
    }
    fromJSON(t) {
        return this.arcLengthDivisions = t.arcLengthDivisions, this
    }
}
class xh extends ui {
    constructor(t = 0, e = 0, n = 1, i = 1, s = 0, r = 2 * Math.PI, o = !1, a = 0) {
        super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = t, this.aY = e, this.xRadius = n, this.yRadius = i, this.aStartAngle = s, this.aEndAngle = r, this.aClockwise = o, this.aRotation = a
    }
    getPoint(t, e = new Q) {
        const n = e,
            i = 2 * Math.PI;
        let s = this.aEndAngle - this.aStartAngle;
        const r = Math.abs(s) < Number.EPSILON;
        for (; s < 0;) s += i;
        for (; s > i;) s -= i;
        s < Number.EPSILON && (s = r ? 0 : i), !0 === this.aClockwise && !r && (s === i ? s = -i : s -= i);
        const o = this.aStartAngle + t * s;
        let a = this.aX + this.xRadius * Math.cos(o),
            l = this.aY + this.yRadius * Math.sin(o);
        if (0 !== this.aRotation) {
            const t = Math.cos(this.aRotation),
                e = Math.sin(this.aRotation),
                n = a - this.aX,
                i = l - this.aY;
            a = n * t - i * e + this.aX, l = n * e + i * t + this.aY
        }
        return n.set(a, l)
    }
    copy(t) {
        return super.copy(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
    }
    toJSON() {
        const t = super.toJSON();
        return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t
    }
    fromJSON(t) {
        return super.fromJSON(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
    }
}
class pS extends xh {
    constructor(t, e, n, i, s, r) {
        super(t, e, n, n, i, s, r), this.isArcCurve = !0, this.type = "ArcCurve"
    }
}

function bh() {
    let t = 0,
        e = 0,
        n = 0,
        i = 0;

    function s(s, r, o, a) {
        t = s, e = o, n = -3 * s + 3 * r - 2 * o - a, i = 2 * s - 2 * r + o + a
    }
    return {
        initCatmullRom: function(t, e, n, i, r) {
            s(e, n, r * (n - t), r * (i - e))
        },
        initNonuniformCatmullRom: function(t, e, n, i, r, o, a) {
            let l = (e - t) / r - (n - t) / (r + o) + (n - e) / o,
                c = (n - e) / o - (i - e) / (o + a) + (i - n) / a;
            l *= o, c *= o, s(e, n, l, c)
        },
        calc: function(s) {
            const r = s * s;
            return t + e * s + n * r + i * (r * s)
        }
    }
}
const oa = new U,
    nc = new bh,
    ic = new bh,
    sc = new bh;
class mS extends ui {
    constructor(t = [], e = !1, n = "centripetal", i = .5) {
        super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = t, this.closed = e, this.curveType = n, this.tension = i
    }
    getPoint(t, e = new U) {
        const n = e,
            i = this.points,
            s = i.length,
            r = (s - (this.closed ? 0 : 1)) * t;
        let o, a, l = Math.floor(r),
            c = r - l;
        this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / s) + 1) * s : 0 === c && l === s - 1 && (l = s - 2, c = 1), this.closed || l > 0 ? o = i[(l - 1) % s] : (oa.subVectors(i[0], i[1]).add(i[0]), o = oa);
        const h = i[l % s],
            u = i[(l + 1) % s];
        if (this.closed || l + 2 < s ? a = i[(l + 2) % s] : (oa.subVectors(i[s - 1], i[s - 2]).add(i[s - 1]), a = oa), "centripetal" === this.curveType || "chordal" === this.curveType) {
            const t = "chordal" === this.curveType ? .5 : .25;
            let e = Math.pow(o.distanceToSquared(h), t),
                n = Math.pow(h.distanceToSquared(u), t),
                i = Math.pow(u.distanceToSquared(a), t);
            n < 1e-4 && (n = 1), e < 1e-4 && (e = n), i < 1e-4 && (i = n), nc.initNonuniformCatmullRom(o.x, h.x, u.x, a.x, e, n, i), ic.initNonuniformCatmullRom(o.y, h.y, u.y, a.y, e, n, i), sc.initNonuniformCatmullRom(o.z, h.z, u.z, a.z, e, n, i)
        } else "catmullrom" === this.curveType && (nc.initCatmullRom(o.x, h.x, u.x, a.x, this.tension), ic.initCatmullRom(o.y, h.y, u.y, a.y, this.tension), sc.initCatmullRom(o.z, h.z, u.z, a.z, this.tension));
        return n.set(nc.calc(c), ic.calc(c), sc.calc(c)), n
    }
    copy(t) {
        super.copy(t), this.points = [];
        for (let e = 0, n = t.points.length; e < n; e++) {
            const n = t.points[e];
            this.points.push(n.clone())
        }
        return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
    }
    toJSON() {
        const t = super.toJSON();
        t.points = [];
        for (let e = 0, n = this.points.length; e < n; e++) {
            const n = this.points[e];
            t.points.push(n.toArray())
        }
        return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
    }
    fromJSON(t) {
        super.fromJSON(t), this.points = [];
        for (let e = 0, n = t.points.length; e < n; e++) {
            const n = t.points[e];
            this.points.push((new U).fromArray(n))
        }
        return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
    }
}

function qd(t, e, n, i, s) {
    const r = .5 * (i - e),
        o = .5 * (s - n),
        a = t * t;
    return (2 * n - 2 * i + r + o) * (t * a) + (-3 * n + 3 * i - 2 * r - o) * a + r * t + n
}

function gS(t, e) {
    const n = 1 - t;
    return n * n * e
}

function vS(t, e) {
    return 2 * (1 - t) * t * e
}

function yS(t, e) {
    return t * t * e
}

function ro(t, e, n, i) {
    return gS(t, e) + vS(t, n) + yS(t, i)
}

function xS(t, e) {
    const n = 1 - t;
    return n * n * n * e
}

function bS(t, e) {
    const n = 1 - t;
    return 3 * n * n * t * e
}

function AS(t, e) {
    return 3 * (1 - t) * t * t * e
}

function SS(t, e) {
    return t * t * t * e
}

function oo(t, e, n, i, s) {
    return xS(t, e) + bS(t, n) + AS(t, i) + SS(t, s)
}
class Dp extends ui {
    constructor(t = new Q, e = new Q, n = new Q, i = new Q) {
        super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = i
    }
    getPoint(t, e = new Q) {
        const n = e,
            i = this.v0,
            s = this.v1,
            r = this.v2,
            o = this.v3;
        return n.set(oo(t, i.x, s.x, r.x, o.x), oo(t, i.y, s.y, r.y, o.y)), n
    }
    copy(t) {
        return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
    }
    toJSON() {
        const t = super.toJSON();
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
    }
    fromJSON(t) {
        return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
    }
}
class _S extends ui {
    constructor(t = new U, e = new U, n = new U, i = new U) {
        super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = i
    }
    getPoint(t, e = new U) {
        const n = e,
            i = this.v0,
            s = this.v1,
            r = this.v2,
            o = this.v3;
        return n.set(oo(t, i.x, s.x, r.x, o.x), oo(t, i.y, s.y, r.y, o.y), oo(t, i.z, s.z, r.z, o.z)), n
    }
    copy(t) {
        return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
    }
    toJSON() {
        const t = super.toJSON();
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
    }
    fromJSON(t) {
        return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
    }
}
class Ip extends ui {
    constructor(t = new Q, e = new Q) {
        super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = t, this.v2 = e
    }
    getPoint(t, e = new Q) {
        const n = e;
        return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
    }
    getPointAt(t, e) {
        return this.getPoint(t, e)
    }
    getTangent(t, e = new Q) {
        return e.subVectors(this.v2, this.v1).normalize()
    }
    getTangentAt(t, e) {
        return this.getTangent(t, e)
    }
    copy(t) {
        return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
    }
    toJSON() {
        const t = super.toJSON();
        return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
    }
    fromJSON(t) {
        return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
    }
}
class wS extends ui {
    constructor(t = new U, e = new U) {
        super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = t, this.v2 = e
    }
    getPoint(t, e = new U) {
        const n = e;
        return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
    }
    getPointAt(t, e) {
        return this.getPoint(t, e)
    }
    getTangent(t, e = new U) {
        return e.subVectors(this.v2, this.v1).normalize()
    }
    getTangentAt(t, e) {
        return this.getTangent(t, e)
    }
    copy(t) {
        return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
    }
    toJSON() {
        const t = super.toJSON();
        return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
    }
    fromJSON(t) {
        return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
    }
}
class Lp extends ui {
    constructor(t = new Q, e = new Q, n = new Q) {
        super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n
    }
    getPoint(t, e = new Q) {
        const n = e,
            i = this.v0,
            s = this.v1,
            r = this.v2;
        return n.set(ro(t, i.x, s.x, r.x), ro(t, i.y, s.y, r.y)), n
    }
    copy(t) {
        return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
    }
    toJSON() {
        const t = super.toJSON();
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
    }
    fromJSON(t) {
        return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
    }
}
class MS extends ui {
    constructor(t = new U, e = new U, n = new U) {
        super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n
    }
    getPoint(t, e = new U) {
        const n = e,
            i = this.v0,
            s = this.v1,
            r = this.v2;
        return n.set(ro(t, i.x, s.x, r.x), ro(t, i.y, s.y, r.y), ro(t, i.z, s.z, r.z)), n
    }
    copy(t) {
        return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
    }
    toJSON() {
        const t = super.toJSON();
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
    }
    fromJSON(t) {
        return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
    }
}
class Op extends ui {
    constructor(t = []) {
        super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = t
    }
    getPoint(t, e = new Q) {
        const n = e,
            i = this.points,
            s = (i.length - 1) * t,
            r = Math.floor(s),
            o = s - r,
            a = i[0 === r ? r : r - 1],
            l = i[r],
            c = i[r > i.length - 2 ? i.length - 1 : r + 1],
            h = i[r > i.length - 3 ? i.length - 1 : r + 2];
        return n.set(qd(o, a.x, l.x, c.x, h.x), qd(o, a.y, l.y, c.y, h.y)), n
    }
    copy(t) {
        super.copy(t), this.points = [];
        for (let e = 0, n = t.points.length; e < n; e++) {
            const n = t.points[e];
            this.points.push(n.clone())
        }
        return this
    }
    toJSON() {
        const t = super.toJSON();
        t.points = [];
        for (let e = 0, n = this.points.length; e < n; e++) {
            const n = this.points[e];
            t.points.push(n.toArray())
        }
        return t
    }
    fromJSON(t) {
        super.fromJSON(t), this.points = [];
        for (let e = 0, n = t.points.length; e < n; e++) {
            const n = t.points[e];
            this.points.push((new Q).fromArray(n))
        }
        return this
    }
}
var Zd = Object.freeze({
    __proto__: null,
    ArcCurve: pS,
    CatmullRomCurve3: mS,
    CubicBezierCurve: Dp,
    CubicBezierCurve3: _S,
    EllipseCurve: xh,
    LineCurve: Ip,
    LineCurve3: wS,
    QuadraticBezierCurve: Lp,
    QuadraticBezierCurve3: MS,
    SplineCurve: Op
});
class ES extends ui {
    constructor() {
        super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1
    }
    add(t) {
        this.curves.push(t)
    }
    closePath() {
        const t = this.curves[0].getPoint(0),
            e = this.curves[this.curves.length - 1].getPoint(1);
        if (!t.equals(e)) {
            const n = !0 === t.isVector2 ? "LineCurve" : "LineCurve3";
            this.curves.push(new Zd[n](e, t))
        }
        return this
    }
    getPoint(t, e) {
        const n = t * this.getLength(),
            i = this.getCurveLengths();
        let s = 0;
        for (; s < i.length;) {
            if (i[s] >= n) {
                const t = i[s] - n,
                    r = this.curves[s],
                    o = r.getLength(),
                    a = 0 === o ? 0 : 1 - t / o;
                return r.getPointAt(a, e)
            }
            s++
        }
        return null
    }
    getLength() {
        const t = this.getCurveLengths();
        return t[t.length - 1]
    }
    updateArcLengths() {
        this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
    }
    getCurveLengths() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
        const t = [];
        let e = 0;
        for (let n = 0, i = this.curves.length; n < i; n++) e += this.curves[n].getLength(), t.push(e);
        return this.cacheLengths = t, t
    }
    getSpacedPoints(t = 40) {
        const e = [];
        for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
        return this.autoClose && e.push(e[0]), e
    }
    getPoints(t = 12) {
        const e = [];
        let n;
        for (let i = 0, s = this.curves; i < s.length; i++) {
            const r = s[i],
                o = r.isEllipseCurve ? 2 * t : r.isLineCurve || r.isLineCurve3 ? 1 : r.isSplineCurve ? t * r.points.length : t,
                a = r.getPoints(o);
            for (let t = 0; t < a.length; t++) {
                const i = a[t];
                n && n.equals(i) || (e.push(i), n = i)
            }
        }
        return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e
    }
    copy(t) {
        super.copy(t), this.curves = [];
        for (let e = 0, n = t.curves.length; e < n; e++) {
            const n = t.curves[e];
            this.curves.push(n.clone())
        }
        return this.autoClose = t.autoClose, this
    }
    toJSON() {
        const t = super.toJSON();
        t.autoClose = this.autoClose, t.curves = [];
        for (let e = 0, n = this.curves.length; e < n; e++) {
            const n = this.curves[e];
            t.curves.push(n.toJSON())
        }
        return t
    }
    fromJSON(t) {
        super.fromJSON(t), this.autoClose = t.autoClose, this.curves = [];
        for (let e = 0, n = t.curves.length; e < n; e++) {
            const n = t.curves[e];
            this.curves.push((new Zd[n.type]).fromJSON(n))
        }
        return this
    }
}
class fr extends ES {
    constructor(t) {
        super(), this.type = "Path", this.currentPoint = new Q, t && this.setFromPoints(t)
    }
    setFromPoints(t) {
        this.moveTo(t[0].x, t[0].y);
        for (let e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y);
        return this
    }
    moveTo(t, e) {
        return this.currentPoint.set(t, e), this
    }
    lineTo(t, e) {
        const n = new Ip(this.currentPoint.clone(), new Q(t, e));
        return this.curves.push(n), this.currentPoint.set(t, e), this
    }
    quadraticCurveTo(t, e, n, i) {
        const s = new Lp(this.currentPoint.clone(), new Q(t, e), new Q(n, i));
        return this.curves.push(s), this.currentPoint.set(n, i), this
    }
    bezierCurveTo(t, e, n, i, s, r) {
        const o = new Dp(this.currentPoint.clone(), new Q(t, e), new Q(n, i), new Q(s, r));
        return this.curves.push(o), this.currentPoint.set(s, r), this
    }
    splineThru(t) {
        const e = [this.currentPoint.clone()].concat(t),
            n = new Op(e);
        return this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this
    }
    arc(t, e, n, i, s, r) {
        const o = this.currentPoint.x,
            a = this.currentPoint.y;
        return this.absarc(t + o, e + a, n, i, s, r), this
    }
    absarc(t, e, n, i, s, r) {
        return this.absellipse(t, e, n, n, i, s, r), this
    }
    ellipse(t, e, n, i, s, r, o, a) {
        const l = this.currentPoint.x,
            c = this.currentPoint.y;
        return this.absellipse(t + l, e + c, n, i, s, r, o, a), this
    }
    absellipse(t, e, n, i, s, r, o, a) {
        const l = new xh(t, e, n, i, s, r, o, a);
        if (this.curves.length > 0) {
            const t = l.getPoint(0);
            t.equals(this.currentPoint) || this.lineTo(t.x, t.y)
        }
        this.curves.push(l);
        const c = l.getPoint(1);
        return this.currentPoint.copy(c), this
    }
    copy(t) {
        return super.copy(t), this.currentPoint.copy(t.currentPoint), this
    }
    toJSON() {
        const t = super.toJSON();
        return t.currentPoint = this.currentPoint.toArray(), t
    }
    fromJSON(t) {
        return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this
    }
}
class Ah extends ht {
    constructor(t = [new Q(0, -.5), new Q(.5, 0), new Q(0, .5)], e = 12, n = 0, i = 2 * Math.PI) {
        super(), this.type = "LatheGeometry", this.parameters = {
            points: t,
            segments: e,
            phiStart: n,
            phiLength: i
        }, e = Math.floor(e), i = Ut(i, 0, 2 * Math.PI);
        const s = [],
            r = [],
            o = [],
            a = [],
            l = [],
            c = 1 / e,
            h = new U,
            u = new Q,
            d = new U,
            p = new U,
            f = new U;
        let m = 0,
            g = 0;
        for (let e = 0; e <= t.length - 1; e++) switch (e) {
            case 0:
                m = t[e + 1].x - t[e].x, g = t[e + 1].y - t[e].y, d.x = 1 * g, d.y = -m, d.z = 0 * g, f.copy(d), d.normalize(), a.push(d.x, d.y, d.z);
                break;
            case t.length - 1:
                a.push(f.x, f.y, f.z);
                break;
            default:
                m = t[e + 1].x - t[e].x, g = t[e + 1].y - t[e].y, d.x = 1 * g, d.y = -m, d.z = 0 * g, p.copy(d), d.x += f.x, d.y += f.y, d.z += f.z, d.normalize(), a.push(d.x, d.y, d.z), f.copy(p)
        }
        for (let s = 0; s <= e; s++) {
            const d = n + s * c * i,
                p = Math.sin(d),
                f = Math.cos(d);
            for (let n = 0; n <= t.length - 1; n++) {
                h.x = t[n].x * p, h.y = t[n].y, h.z = t[n].x * f, r.push(h.x, h.y, h.z), u.x = s / e, u.y = n / (t.length - 1), o.push(u.x, u.y);
                const i = a[3 * n + 0] * p,
                    c = a[3 * n + 1],
                    d = a[3 * n + 0] * f;
                l.push(i, c, d)
            }
        }
        for (let n = 0; n < e; n++)
            for (let e = 0; e < t.length - 1; e++) {
                const i = e + n * t.length,
                    r = i,
                    o = i + t.length,
                    a = i + t.length + 1,
                    l = i + 1;
                s.push(r, o, l), s.push(a, l, o)
            }
        this.setIndex(s), this.setAttribute("position", new Fe(r, 3)), this.setAttribute("uv", new Fe(o, 2)), this.setAttribute("normal", new Fe(l, 3))
    }
    copy(t) {
        return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
    }
    static fromJSON(t) {
        return new Ah(t.points, t.segments, t.phiStart, t.phiLength)
    }
}
class Sh extends ht {
    constructor(t = 1, e = 32, n = 0, i = 2 * Math.PI) {
        super(), this.type = "CircleGeometry", this.parameters = {
            radius: t,
            segments: e,
            thetaStart: n,
            thetaLength: i
        }, e = Math.max(3, e);
        const s = [],
            r = [],
            o = [],
            a = [],
            l = new U,
            c = new Q;
        r.push(0, 0, 0), o.push(0, 0, 1), a.push(.5, .5);
        for (let s = 0, h = 3; s <= e; s++, h += 3) {
            const u = n + s / e * i;
            l.x = t * Math.cos(u), l.y = t * Math.sin(u), r.push(l.x, l.y, l.z), o.push(0, 0, 1), c.x = (r[h] / t + 1) / 2, c.y = (r[h + 1] / t + 1) / 2, a.push(c.x, c.y)
        }
        for (let t = 1; t <= e; t++) s.push(t, t + 1, 0);
        this.setIndex(s), this.setAttribute("position", new Fe(r, 3)), this.setAttribute("normal", new Fe(o, 3)), this.setAttribute("uv", new Fe(a, 2))
    }
    copy(t) {
        return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
    }
    static fromJSON(t) {
        return new Sh(t.radius, t.segments, t.thetaStart, t.thetaLength)
    }
}
class pn extends ht {
    constructor(t = 1, e = 1, n = 1, i = 32, s = 1, r = !1, o = 0, a = 2 * Math.PI) {
        super(), this.type = "CylinderGeometry", this.parameters = {
            radiusTop: t,
            radiusBottom: e,
            height: n,
            radialSegments: i,
            heightSegments: s,
            openEnded: r,
            thetaStart: o,
            thetaLength: a
        };
        const l = this;
        i = Math.floor(i), s = Math.floor(s);
        const c = [],
            h = [],
            u = [],
            d = [];
        let p = 0;
        const f = [],
            m = n / 2;
        let g = 0;

        function v(n) {
            const s = p,
                r = new Q,
                f = new U;
            let v = 0;
            const y = !0 === n ? t : e,
                x = !0 === n ? 1 : -1;
            for (let t = 1; t <= i; t++) h.push(0, m * x, 0), u.push(0, x, 0), d.push(.5, .5), p++;
            const b = p;
            for (let t = 0; t <= i; t++) {
                const e = t / i * a + o,
                    n = Math.cos(e),
                    s = Math.sin(e);
                f.x = y * s, f.y = m * x, f.z = y * n, h.push(f.x, f.y, f.z), u.push(0, x, 0), r.x = .5 * n + .5, r.y = .5 * s * x + .5, d.push(r.x, r.y), p++
            }
            for (let t = 0; t < i; t++) {
                const e = s + t,
                    i = b + t;
                !0 === n ? c.push(i, i + 1, e) : c.push(i + 1, i, e), v += 3
            }
            l.addGroup(g, v, !0 === n ? 1 : 2), g += v
        }(function() {
            const r = new U,
                v = new U;
            let y = 0;
            const x = (e - t) / n;
            for (let l = 0; l <= s; l++) {
                const c = [],
                    g = l / s,
                    y = g * (e - t) + t;
                for (let t = 0; t <= i; t++) {
                    const e = t / i,
                        s = e * a + o,
                        l = Math.sin(s),
                        f = Math.cos(s);
                    v.x = y * l, v.y = -g * n + m, v.z = y * f, h.push(v.x, v.y, v.z), r.set(l, x, f).normalize(), u.push(r.x, r.y, r.z), d.push(e, 1 - g), c.push(p++)
                }
                f.push(c)
            }
            for (let t = 0; t < i; t++)
                for (let e = 0; e < s; e++) {
                    const n = f[e][t],
                        i = f[e + 1][t],
                        s = f[e + 1][t + 1],
                        r = f[e][t + 1];
                    c.push(n, i, r), c.push(i, s, r), y += 6
                }
            l.addGroup(g, y, 0), g += y
        })(), !1 === r && (t > 0 && v(!0), e > 0 && v(!1)), this.setIndex(c), this.setAttribute("position", new Fe(h, 3)), this.setAttribute("normal", new Fe(u, 3)), this.setAttribute("uv", new Fe(d, 2))
    }
    copy(t) {
        return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
    }
    static fromJSON(t) {
        return new pn(t.radiusTop, t.radiusBottom, t.height, t.radialSegments, t.heightSegments, t.openEnded, t.thetaStart, t.thetaLength)
    }
}
class ja extends pn {
    constructor(t = 1, e = 1, n = 32, i = 1, s = !1, r = 0, o = 2 * Math.PI) {
        super(0, t, e, n, i, s, r, o), this.type = "ConeGeometry", this.parameters = {
            radius: t,
            height: e,
            radialSegments: n,
            heightSegments: i,
            openEnded: s,
            thetaStart: r,
            thetaLength: o
        }
    }
    static fromJSON(t) {
        return new ja(t.radius, t.height, t.radialSegments, t.heightSegments, t.openEnded, t.thetaStart, t.thetaLength)
    }
}
class Ka extends ht {
    constructor(t = [], e = [], n = 1, i = 0) {
        super(), this.type = "PolyhedronGeometry", this.parameters = {
            vertices: t,
            indices: e,
            radius: n,
            detail: i
        };
        const s = [],
            r = [];

        function o(t, e, n, i) {
            const s = i + 1,
                r = [];
            for (let i = 0; i <= s; i++) {
                r[i] = [];
                const o = t.clone().lerp(n, i / s),
                    a = e.clone().lerp(n, i / s),
                    l = s - i;
                for (let t = 0; t <= l; t++) r[i][t] = 0 === t && i === s ? o : o.clone().lerp(a, t / l)
            }
            for (let t = 0; t < s; t++)
                for (let e = 0; e < 2 * (s - t) - 1; e++) {
                    const n = Math.floor(e / 2);
                    e % 2 == 0 ? (a(r[t][n + 1]), a(r[t + 1][n]), a(r[t][n])) : (a(r[t][n + 1]), a(r[t + 1][n + 1]), a(r[t + 1][n]))
                }
        }

        function a(t) {
            s.push(t.x, t.y, t.z)
        }

        function l(e, n) {
            const i = 3 * e;
            n.x = t[i + 0], n.y = t[i + 1], n.z = t[i + 2]
        }

        function c(t, e, n, i) {
            i < 0 && 1 === t.x && (r[e] = t.x - 1), 0 === n.x && 0 === n.z && (r[e] = i / 2 / Math.PI + .5)
        }

        function h(t) {
            return Math.atan2(t.z, -t.x)
        }

        function u(t) {
            return Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z))
        }(function(t) {
            const n = new U,
                i = new U,
                s = new U;
            for (let r = 0; r < e.length; r += 3) l(e[r + 0], n), l(e[r + 1], i), l(e[r + 2], s), o(n, i, s, t)
        })(i),
        function(t) {
            const e = new U;
            for (let n = 0; n < s.length; n += 3) e.x = s[n + 0], e.y = s[n + 1], e.z = s[n + 2], e.normalize().multiplyScalar(t), s[n + 0] = e.x, s[n + 1] = e.y, s[n + 2] = e.z
        }(n),
        function() {
            const t = new U;
            for (let e = 0; e < s.length; e += 3) {
                t.x = s[e + 0], t.y = s[e + 1], t.z = s[e + 2];
                const n = h(t) / 2 / Math.PI + .5,
                    i = u(t) / Math.PI + .5;
                r.push(n, 1 - i)
            }(function() {
                const t = new U,
                    e = new U,
                    n = new U,
                    i = new U,
                    o = new Q,
                    a = new Q,
                    l = new Q;
                for (let u = 0, d = 0; u < s.length; u += 9, d += 6) {
                    t.set(s[u + 0], s[u + 1], s[u + 2]), e.set(s[u + 3], s[u + 4], s[u + 5]), n.set(s[u + 6], s[u + 7], s[u + 8]), o.set(r[d + 0], r[d + 1]), a.set(r[d + 2], r[d + 3]), l.set(r[d + 4], r[d + 5]), i.copy(t).add(e).add(n).divideScalar(3);
                    const p = h(i);
                    c(o, d + 0, t, p), c(a, d + 2, e, p), c(l, d + 4, n, p)
                }
            })(),
            function() {
                for (let t = 0; t < r.length; t += 6) {
                    const e = r[t + 0],
                        n = r[t + 2],
                        i = r[t + 4],
                        s = Math.max(e, n, i),
                        o = Math.min(e, n, i);
                    s > .9 && o < .1 && (e < .2 && (r[t + 0] += 1), n < .2 && (r[t + 2] += 1), i < .2 && (r[t + 4] += 1))
                }
            }()
        }(), this.setAttribute("position", new Fe(s, 3)), this.setAttribute("normal", new Fe(s.slice(), 3)), this.setAttribute("uv", new Fe(r, 2)), 0 === i ? this.computeVertexNormals() : this.normalizeNormals()
    }
    copy(t) {
        return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
    }
    static fromJSON(t) {
        return new Ka(t.vertices, t.indices, t.radius, t.details)
    }
}
const aa = new U,
    la = new U,
    rc = new U,
    ca = new Bn;
class Bp extends ht {
    constructor(t = null, e = 1) {
        if (super(), this.type = "EdgesGeometry", this.parameters = {
                geometry: t,
                thresholdAngle: e
            }, null !== t) {
            const n = Math.pow(10, 4),
                i = Math.cos(ur * e),
                s = t.getIndex(),
                r = t.getAttribute("position"),
                o = s ? s.count : r.count,
                a = [0, 0, 0],
                l = ["a", "b", "c"],
                c = new Array(3),
                h = {},
                u = [];
            for (let t = 0; t < o; t += 3) {
                s ? (a[0] = s.getX(t), a[1] = s.getX(t + 1), a[2] = s.getX(t + 2)) : (a[0] = t, a[1] = t + 1, a[2] = t + 2);
                const {
                    a: e,
                    b: o,
                    c: d
                } = ca;
                if (e.fromBufferAttribute(r, a[0]), o.fromBufferAttribute(r, a[1]), d.fromBufferAttribute(r, a[2]), ca.getNormal(rc), c[0] = `${Math.round(e.x*n)},${Math.round(e.y*n)},${Math.round(e.z*n)}`, c[1] = `${Math.round(o.x*n)},${Math.round(o.y*n)},${Math.round(o.z*n)}`, c[2] = `${Math.round(d.x*n)},${Math.round(d.y*n)},${Math.round(d.z*n)}`, c[0] !== c[1] && c[1] !== c[2] && c[2] !== c[0])
                    for (let t = 0; t < 3; t++) {
                        const e = (t + 1) % 3,
                            n = c[t],
                            s = c[e],
                            r = ca[l[t]],
                            o = ca[l[e]],
                            d = `${n}_${s}`,
                            p = `${s}_${n}`;
                        p in h && h[p] ? (rc.dot(h[p].normal) <= i && (u.push(r.x, r.y, r.z), u.push(o.x, o.y, o.z)), h[p] = null) : d in h || (h[d] = {
                            index0: a[t],
                            index1: a[e],
                            normal: rc.clone()
                        })
                    }
            }
            for (const t in h)
                if (h[t]) {
                    const {
                        index0: e,
                        index1: n
                    } = h[t];
                    aa.fromBufferAttribute(r, e), la.fromBufferAttribute(r, n), u.push(aa.x, aa.y, aa.z), u.push(la.x, la.y, la.z)
                }
            this.setAttribute("position", new Fe(u, 3))
        }
    }
    copy(t) {
        return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
    }
}
class Ji extends fr {
    constructor(t) {
        super(t), this.uuid = zn(), this.type = "Shape", this.holes = []
    }
    getPointsHoles(t) {
        const e = [];
        for (let n = 0, i = this.holes.length; n < i; n++) e[n] = this.holes[n].getPoints(t);
        return e
    }
    extractPoints(t) {
        return {
            shape: this.getPoints(t),
            holes: this.getPointsHoles(t)
        }
    }
    copy(t) {
        super.copy(t), this.holes = [];
        for (let e = 0, n = t.holes.length; e < n; e++) {
            const n = t.holes[e];
            this.holes.push(n.clone())
        }
        return this
    }
    toJSON() {
        const t = super.toJSON();
        t.uuid = this.uuid, t.holes = [];
        for (let e = 0, n = this.holes.length; e < n; e++) {
            const n = this.holes[e];
            t.holes.push(n.toJSON())
        }
        return t
    }
    fromJSON(t) {
        super.fromJSON(t), this.uuid = t.uuid, this.holes = [];
        for (let e = 0, n = t.holes.length; e < n; e++) {
            const n = t.holes[e];
            this.holes.push((new fr).fromJSON(n))
        }
        return this
    }
}
const TS = {
    triangulate: function(t, e, n = 2) {
        const i = e && e.length,
            s = i ? e[0] * n : t.length;
        let r = Up(t, 0, s, n, !0);
        const o = [];
        if (!r || r.next === r.prev) return o;
        let a, l, c, h, u, d, p;
        if (i && (r = IS(t, e, r, n)), t.length > 80 * n) {
            a = c = t[0], l = h = t[1];
            for (let e = n; e < s; e += n) u = t[e], d = t[e + 1], u < a && (a = u), d < l && (l = d), u > c && (c = u), d > h && (h = d);
            p = Math.max(c - a, h - l), p = 0 !== p ? 32767 / p : 0
        }
        return go(r, o, n, a, l, p, 0), o
    }
};

function Up(t, e, n, i, s) {
    let r, o;
    if (s === VS(t, e, n, i) > 0)
        for (r = e; r < n; r += i) o = Jd(r, t[r], t[r + 1], o);
    else
        for (r = n - i; r >= e; r -= i) o = Jd(r, t[r], t[r + 1], o);
    return o && Ya(o, o.next) && (yo(o), o = o.next), o
}

function Rs(t, e) {
    if (!t) return t;
    e || (e = t);
    let n, i = t;
    do {
        if (n = !1, i.steiner || !Ya(i, i.next) && 0 !== Dt(i.prev, i, i.next)) i = i.next;
        else {
            if (yo(i), i = e = i.prev, i === i.next) break;
            n = !0
        }
    } while (n || i !== e);
    return e
}

function go(t, e, n, i, s, r, o) {
    if (!t) return;
    !o && r && NS(t, i, s, r);
    let a, l, c = t;
    for (; t.prev !== t.next;)
        if (a = t.prev, l = t.next, r ? PS(t, i, s, r) : CS(t)) e.push(a.i / n | 0), e.push(t.i / n | 0), e.push(l.i / n | 0), yo(t), t = l.next, c = l.next;
        else if ((t = l) === c) {
        o ? 1 === o ? go(t = RS(Rs(t), e, n), e, n, i, s, r, 2) : 2 === o && DS(t, e, n, i, s, r) : go(Rs(t), e, n, i, s, r, 1);
        break
    }
}

function CS(t) {
    const e = t.prev,
        n = t,
        i = t.next;
    if (Dt(e, n, i) >= 0) return !1;
    const s = e.x,
        r = n.x,
        o = i.x,
        a = e.y,
        l = n.y,
        c = i.y,
        h = s < r ? s < o ? s : o : r < o ? r : o,
        u = a < l ? a < c ? a : c : l < c ? l : c,
        d = s > r ? s > o ? s : o : r > o ? r : o,
        p = a > l ? a > c ? a : c : l > c ? l : c;
    let f = i.next;
    for (; f !== e;) {
        if (f.x >= h && f.x <= d && f.y >= u && f.y <= p && ar(s, a, r, l, o, c, f.x, f.y) && Dt(f.prev, f, f.next) >= 0) return !1;
        f = f.next
    }
    return !0
}

function PS(t, e, n, i) {
    const s = t.prev,
        r = t,
        o = t.next;
    if (Dt(s, r, o) >= 0) return !1;
    const a = s.x,
        l = r.x,
        c = o.x,
        h = s.y,
        u = r.y,
        d = o.y,
        p = a < l ? a < c ? a : c : l < c ? l : c,
        f = h < u ? h < d ? h : d : u < d ? u : d,
        m = a > l ? a > c ? a : c : l > c ? l : c,
        g = h > u ? h > d ? h : d : u > d ? u : d,
        v = Fc(p, f, e, n, i),
        y = Fc(m, g, e, n, i);
    let x = t.prevZ,
        b = t.nextZ;
    for (; x && x.z >= v && b && b.z <= y;) {
        if (x.x >= p && x.x <= m && x.y >= f && x.y <= g && x !== s && x !== o && ar(a, h, l, u, c, d, x.x, x.y) && Dt(x.prev, x, x.next) >= 0 || (x = x.prevZ, b.x >= p && b.x <= m && b.y >= f && b.y <= g && b !== s && b !== o && ar(a, h, l, u, c, d, b.x, b.y) && Dt(b.prev, b, b.next) >= 0)) return !1;
        b = b.nextZ
    }
    for (; x && x.z >= v;) {
        if (x.x >= p && x.x <= m && x.y >= f && x.y <= g && x !== s && x !== o && ar(a, h, l, u, c, d, x.x, x.y) && Dt(x.prev, x, x.next) >= 0) return !1;
        x = x.prevZ
    }
    for (; b && b.z <= y;) {
        if (b.x >= p && b.x <= m && b.y >= f && b.y <= g && b !== s && b !== o && ar(a, h, l, u, c, d, b.x, b.y) && Dt(b.prev, b, b.next) >= 0) return !1;
        b = b.nextZ
    }
    return !0
}

function RS(t, e, n) {
    let i = t;
    do {
        const s = i.prev,
            r = i.next.next;
        !Ya(s, r) && Np(s, i, i.next, r) && vo(s, r) && vo(r, s) && (e.push(s.i / n | 0), e.push(i.i / n | 0), e.push(r.i / n | 0), yo(i), yo(i.next), i = t = r), i = i.next
    } while (i !== t);
    return Rs(i)
}

function DS(t, e, n, i, s, r) {
    let o = t;
    do {
        let t = o.next.next;
        for (; t !== o.prev;) {
            if (o.i !== t.i && zS(o, t)) {
                let a = Fp(o, t);
                return o = Rs(o, o.next), a = Rs(a, a.next), go(o, e, n, i, s, r, 0), void go(a, e, n, i, s, r, 0)
            }
            t = t.next
        }
        o = o.next
    } while (o !== t)
}

function IS(t, e, n, i) {
    const s = [];
    let r, o, a, l, c;
    for (r = 0, o = e.length; r < o; r++) a = e[r] * i, l = r < o - 1 ? e[r + 1] * i : t.length, c = Up(t, a, l, i, !1), c === c.next && (c.steiner = !0), s.push(kS(c));
    for (s.sort(LS), r = 0; r < s.length; r++) n = OS(s[r], n);
    return n
}

function LS(t, e) {
    return t.x - e.x
}

function OS(t, e) {
    const n = BS(t, e);
    if (!n) return e;
    const i = Fp(n, t);
    return Rs(i, i.next), Rs(n, n.next)
}

function BS(t, e) {
    let n, i = e,
        s = -1 / 0;
    const r = t.x,
        o = t.y;
    do {
        if (o <= i.y && o >= i.next.y && i.next.y !== i.y) {
            const t = i.x + (o - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
            if (t <= r && t > s && (s = t, n = i.x < i.next.x ? i : i.next, t === r)) return n
        }
        i = i.next
    } while (i !== e);
    if (!n) return null;
    const a = n,
        l = n.x,
        c = n.y;
    let h, u = 1 / 0;
    i = n;
    do {
        r >= i.x && i.x >= l && r !== i.x && ar(o < c ? r : s, o, l, c, o < c ? s : r, o, i.x, i.y) && (h = Math.abs(o - i.y) / (r - i.x), vo(i, t) && (h < u || h === u && (i.x > n.x || i.x === n.x && US(n, i))) && (n = i, u = h)), i = i.next
    } while (i !== a);
    return n
}

function US(t, e) {
    return Dt(t.prev, t, e.prev) < 0 && Dt(e.next, t, t.next) < 0
}

function NS(t, e, n, i) {
    let s = t;
    do {
        0 === s.z && (s.z = Fc(s.x, s.y, e, n, i)), s.prevZ = s.prev, s.nextZ = s.next, s = s.next
    } while (s !== t);
    s.prevZ.nextZ = null, s.prevZ = null, FS(s)
}

function FS(t) {
    let e, n, i, s, r, o, a, l, c = 1;
    do {
        for (n = t, t = null, r = null, o = 0; n;) {
            for (o++, i = n, a = 0, e = 0; e < c && (a++, i = i.nextZ, i); e++);
            for (l = c; a > 0 || l > 0 && i;) 0 !== a && (0 === l || !i || n.z <= i.z) ? (s = n, n = n.nextZ, a--) : (s = i, i = i.nextZ, l--), r ? r.nextZ = s : t = s, s.prevZ = r, r = s;
            n = i
        }
        r.nextZ = null, c *= 2
    } while (o > 1);
    return t
}

function Fc(t, e, n, i, s) {
    return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - n) * s | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - i) * s | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
}

function kS(t) {
    let e = t,
        n = t;
    do {
        (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next
    } while (e !== t);
    return n
}

function ar(t, e, n, i, s, r, o, a) {
    return (s - o) * (e - a) >= (t - o) * (r - a) && (t - o) * (i - a) >= (n - o) * (e - a) && (n - o) * (r - a) >= (s - o) * (i - a)
}

function zS(t, e) {
    return t.next.i !== e.i && t.prev.i !== e.i && !GS(t, e) && (vo(t, e) && vo(e, t) && HS(t, e) && (Dt(t.prev, t, e.prev) || Dt(t, e.prev, e)) || Ya(t, e) && Dt(t.prev, t, t.next) > 0 && Dt(e.prev, e, e.next) > 0)
}

function Dt(t, e, n) {
    return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
}

function Ya(t, e) {
    return t.x === e.x && t.y === e.y
}

function Np(t, e, n, i) {
    const s = ua(Dt(t, e, n)),
        r = ua(Dt(t, e, i)),
        o = ua(Dt(n, i, t)),
        a = ua(Dt(n, i, e));
    return !!(s !== r && o !== a || 0 === s && ha(t, n, e) || 0 === r && ha(t, i, e) || 0 === o && ha(n, t, i) || 0 === a && ha(n, e, i))
}

function ha(t, e, n) {
    return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y)
}

function ua(t) {
    return t > 0 ? 1 : t < 0 ? -1 : 0
}

function GS(t, e) {
    let n = t;
    do {
        if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && Np(n, n.next, t, e)) return !0;
        n = n.next
    } while (n !== t);
    return !1
}

function vo(t, e) {
    return Dt(t.prev, t, t.next) < 0 ? Dt(t, e, t.next) >= 0 && Dt(t, t.prev, e) >= 0 : Dt(t, e, t.prev) < 0 || Dt(t, t.next, e) < 0
}

function HS(t, e) {
    let n = t,
        i = !1;
    const s = (t.x + e.x) / 2,
        r = (t.y + e.y) / 2;
    do {
        n.y > r != n.next.y > r && n.next.y !== n.y && s < (n.next.x - n.x) * (r - n.y) / (n.next.y - n.y) + n.x && (i = !i), n = n.next
    } while (n !== t);
    return i
}

function Fp(t, e) {
    const n = new kc(t.i, t.x, t.y),
        i = new kc(e.i, e.x, e.y),
        s = t.next,
        r = e.prev;
    return t.next = e, e.prev = t, n.next = s, s.prev = n, i.next = n, n.prev = i, r.next = i, i.prev = r, i
}

function Jd(t, e, n, i) {
    const s = new kc(t, e, n);
    return i ? (s.next = i.next, s.prev = i, i.next.prev = s, i.next = s) : (s.prev = s, s.next = s), s
}

function yo(t) {
    t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
}

function kc(t, e, n) {
    this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1
}

function VS(t, e, n, i) {
    let s = 0;
    for (let r = e, o = n - i; r < n; r += i) s += (t[o] - t[r]) * (t[r + 1] + t[o + 1]), o = r;
    return s
}
class Es {
    static area(t) {
        const e = t.length;
        let n = 0;
        for (let i = e - 1, s = 0; s < e; i = s++) n += t[i].x * t[s].y - t[s].x * t[i].y;
        return .5 * n
    }
    static isClockWise(t) {
        return Es.area(t) < 0
    }
    static triangulateShape(t, e) {
        const n = [],
            i = [],
            s = [];
        $d(t), ef(n, t);
        let r = t.length;
        e.forEach($d);
        for (let t = 0; t < e.length; t++) i.push(r), r += e[t].length, ef(n, e[t]);
        const o = TS.triangulate(n, i);
        for (let t = 0; t < o.length; t += 3) s.push(o.slice(t, t + 3));
        return s
    }
}

function $d(t) {
    const e = t.length;
    e > 2 && t[e - 1].equals(t[0]) && t.pop()
}

function ef(t, e) {
    for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y)
}
class Qa extends Ka {
    constructor(t = 1, e = 0) {
        const n = (1 + Math.sqrt(5)) / 2;
        super([-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e), this.type = "IcosahedronGeometry", this.parameters = {
            radius: t,
            detail: e
        }
    }
    static fromJSON(t) {
        return new Qa(t.radius, t.detail)
    }
}
class wi extends Ka {
    constructor(t = 1, e = 0) {
        super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e), this.type = "OctahedronGeometry", this.parameters = {
            radius: t,
            detail: e
        }
    }
    static fromJSON(t) {
        return new wi(t.radius, t.detail)
    }
}
class _h extends ht {
    constructor(t = .5, e = 1, n = 32, i = 1, s = 0, r = 2 * Math.PI) {
        super(), this.type = "RingGeometry", this.parameters = {
            innerRadius: t,
            outerRadius: e,
            thetaSegments: n,
            phiSegments: i,
            thetaStart: s,
            thetaLength: r
        }, n = Math.max(3, n);
        const o = [],
            a = [],
            l = [],
            c = [];
        let h = t;
        const u = (e - t) / (i = Math.max(1, i)),
            d = new U,
            p = new Q;
        for (let t = 0; t <= i; t++) {
            for (let t = 0; t <= n; t++) {
                const i = s + t / n * r;
                d.x = h * Math.cos(i), d.y = h * Math.sin(i), a.push(d.x, d.y, d.z), l.push(0, 0, 1), p.x = (d.x / e + 1) / 2, p.y = (d.y / e + 1) / 2, c.push(p.x, p.y)
            }
            h += u
        }
        for (let t = 0; t < i; t++) {
            const e = t * (n + 1);
            for (let t = 0; t < n; t++) {
                const i = t + e,
                    s = i,
                    r = i + n + 1,
                    a = i + n + 2,
                    l = i + 1;
                o.push(s, r, l), o.push(r, a, l)
            }
        }
        this.setIndex(o), this.setAttribute("position", new Fe(a, 3)), this.setAttribute("normal", new Fe(l, 3)), this.setAttribute("uv", new Fe(c, 2))
    }
    copy(t) {
        return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
    }
    static fromJSON(t) {
        return new _h(t.innerRadius, t.outerRadius, t.thetaSegments, t.phiSegments, t.thetaStart, t.thetaLength)
    }
}
class Ba extends ht {
    constructor(t = new Ji([new Q(0, .5), new Q(-.5, -.5), new Q(.5, -.5)]), e = 12) {
        super(), this.type = "ShapeGeometry", this.parameters = {
            shapes: t,
            curveSegments: e
        };
        const n = [],
            i = [],
            s = [],
            r = [];
        let o = 0,
            a = 0;
        if (!1 === Array.isArray(t)) l(t);
        else
            for (let e = 0; e < t.length; e++) l(t[e]), this.addGroup(o, a, e), o += a, a = 0;

        function l(t) {
            const o = i.length / 3,
                l = t.extractPoints(e);
            let c = l.shape;
            const h = l.holes;
            !1 === Es.isClockWise(c) && (c = c.reverse());
            for (let t = 0, e = h.length; t < e; t++) {
                const e = h[t];
                !0 === Es.isClockWise(e) && (h[t] = e.reverse())
            }
            const u = Es.triangulateShape(c, h);
            for (let t = 0, e = h.length; t < e; t++) {
                const e = h[t];
                c = c.concat(e)
            }
            for (let t = 0, e = c.length; t < e; t++) {
                const e = c[t];
                i.push(e.x, e.y, 0), s.push(0, 0, 1), r.push(e.x, e.y)
            }
            for (let t = 0, e = u.length; t < e; t++) {
                const e = u[t],
                    i = e[0] + o,
                    s = e[1] + o,
                    r = e[2] + o;
                n.push(i, s, r), a += 3
            }
        }
        this.setIndex(n), this.setAttribute("position", new Fe(i, 3)), this.setAttribute("normal", new Fe(s, 3)), this.setAttribute("uv", new Fe(r, 2))
    }
    copy(t) {
        return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
    }
    toJSON() {
        const t = super.toJSON();
        return WS(this.parameters.shapes, t)
    }
    static fromJSON(t, e) {
        const n = [];
        for (let i = 0, s = t.shapes.length; i < s; i++) {
            const s = e[t.shapes[i]];
            n.push(s)
        }
        return new Ba(n, t.curveSegments)
    }
}

function WS(t, e) {
    if (e.shapes = [], Array.isArray(t))
        for (let n = 0, i = t.length; n < i; n++) {
            const i = t[n];
            e.shapes.push(i.uuid)
        } else e.shapes.push(t.uuid);
    return e
}
class Or extends ht {
    constructor(t = 1, e = 32, n = 16, i = 0, s = 2 * Math.PI, r = 0, o = Math.PI) {
        super(), this.type = "SphereGeometry", this.parameters = {
            radius: t,
            widthSegments: e,
            heightSegments: n,
            phiStart: i,
            phiLength: s,
            thetaStart: r,
            thetaLength: o
        }, e = Math.max(3, Math.floor(e)), n = Math.max(2, Math.floor(n));
        const a = Math.min(r + o, Math.PI);
        let l = 0;
        const c = [],
            h = new U,
            u = new U,
            d = [],
            p = [],
            f = [],
            m = [];
        for (let d = 0; d <= n; d++) {
            const g = [],
                v = d / n;
            let y = 0;
            0 === d && 0 === r ? y = .5 / e : d === n && a === Math.PI && (y = -.5 / e);
            for (let n = 0; n <= e; n++) {
                const a = n / e;
                h.x = -t * Math.cos(i + a * s) * Math.sin(r + v * o), h.y = t * Math.cos(r + v * o), h.z = t * Math.sin(i + a * s) * Math.sin(r + v * o), p.push(h.x, h.y, h.z), u.copy(h).normalize(), f.push(u.x, u.y, u.z), m.push(a + y, 1 - v), g.push(l++)
            }
            c.push(g)
        }
        for (let t = 0; t < n; t++)
            for (let i = 0; i < e; i++) {
                const e = c[t][i + 1],
                    s = c[t][i],
                    o = c[t + 1][i],
                    l = c[t + 1][i + 1];
                (0 !== t || r > 0) && d.push(e, s, l), (t !== n - 1 || a < Math.PI) && d.push(s, o, l)
            }
        this.setIndex(d), this.setAttribute("position", new Fe(p, 3)), this.setAttribute("normal", new Fe(f, 3)), this.setAttribute("uv", new Fe(m, 2))
    }
    copy(t) {
        return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
    }
    static fromJSON(t) {
        return new Or(t.radius, t.widthSegments, t.heightSegments, t.phiStart, t.phiLength, t.thetaStart, t.thetaLength)
    }
}
class lr extends ht {
    constructor(t = 1, e = .4, n = 12, i = 48, s = 2 * Math.PI) {
        super(), this.type = "TorusGeometry", this.parameters = {
            radius: t,
            tube: e,
            radialSegments: n,
            tubularSegments: i,
            arc: s
        }, n = Math.floor(n), i = Math.floor(i);
        const r = [],
            o = [],
            a = [],
            l = [],
            c = new U,
            h = new U,
            u = new U;
        for (let r = 0; r <= n; r++)
            for (let d = 0; d <= i; d++) {
                const p = d / i * s,
                    f = r / n * Math.PI * 2;
                h.x = (t + e * Math.cos(f)) * Math.cos(p), h.y = (t + e * Math.cos(f)) * Math.sin(p), h.z = e * Math.sin(f), o.push(h.x, h.y, h.z), c.x = t * Math.cos(p), c.y = t * Math.sin(p), u.subVectors(h, c).normalize(), a.push(u.x, u.y, u.z), l.push(d / i), l.push(r / n)
            }
        for (let t = 1; t <= n; t++)
            for (let e = 1; e <= i; e++) {
                const n = (i + 1) * t + e - 1,
                    s = (i + 1) * (t - 1) + e - 1,
                    o = (i + 1) * (t - 1) + e,
                    a = (i + 1) * t + e;
                r.push(n, s, a), r.push(s, o, a)
            }
        this.setIndex(r), this.setAttribute("position", new Fe(o, 3)), this.setAttribute("normal", new Fe(a, 3)), this.setAttribute("uv", new Fe(l, 2))
    }
    copy(t) {
        return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
    }
    static fromJSON(t) {
        return new lr(t.radius, t.tube, t.radialSegments, t.tubularSegments, t.arc)
    }
}
class XS extends ht {
    constructor(t = null) {
        if (super(), this.type = "WireframeGeometry", this.parameters = {
                geometry: t
            }, null !== t) {
            const e = [],
                n = new Set,
                i = new U,
                s = new U;
            if (null !== t.index) {
                const r = t.attributes.position,
                    o = t.index;
                let a = t.groups;
                0 === a.length && (a = [{
                    start: 0,
                    count: o.count,
                    materialIndex: 0
                }]);
                for (let t = 0, l = a.length; t < l; ++t) {
                    const l = a[t],
                        c = l.start;
                    for (let t = c, a = c + l.count; t < a; t += 3)
                        for (let a = 0; a < 3; a++) {
                            const l = o.getX(t + a),
                                c = o.getX(t + (a + 1) % 3);
                            i.fromBufferAttribute(r, l), s.fromBufferAttribute(r, c), !0 === tf(i, s, n) && (e.push(i.x, i.y, i.z), e.push(s.x, s.y, s.z))
                        }
                }
            } else {
                const r = t.attributes.position;
                for (let t = 0, o = r.count / 3; t < o; t++)
                    for (let o = 0; o < 3; o++) {
                        const a = 3 * t + o,
                            l = 3 * t + (o + 1) % 3;
                        i.fromBufferAttribute(r, a), s.fromBufferAttribute(r, l), !0 === tf(i, s, n) && (e.push(i.x, i.y, i.z), e.push(s.x, s.y, s.z))
                    }
            }
            this.setAttribute("position", new Fe(e, 3))
        }
    }
    copy(t) {
        return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
    }
}

function tf(t, e, n) {
    const i = `${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`,
        s = `${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`;
    return !0 !== n.has(i) && !0 !== n.has(s) && (n.add(i), n.add(s), !0)
}
class wh extends en {
    constructor(t) {
        super(), this.isMeshStandardMaterial = !0, this.defines = {
            STANDARD: ""
        }, this.type = "MeshStandardMaterial", this.color = new Le(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Le(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Q(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Gn, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(t)
    }
    copy(t) {
        return super.copy(t), this.defines = {
            STANDARD: ""
        }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapRotation.copy(t.envMapRotation), this.envMapIntensity = t.envMapIntensity, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this.fog = t.fog, this
    }
}
class di extends wh {
    constructor(t) {
        super(), this.isMeshPhysicalMaterial = !0, this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Q(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
            get: function() {
                return Ut(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
            },
            set: function(t) {
                this.ior = (1 + .4 * t) / (1 - .4 * t)
            }
        }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new Le(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Le(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Le(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(t)
    }
    get anisotropy() {
        return this._anisotropy
    }
    set anisotropy(t) {
        this._anisotropy > 0 != t > 0 && this.version++, this._anisotropy = t
    }
    get clearcoat() {
        return this._clearcoat
    }
    set clearcoat(t) {
        this._clearcoat > 0 != t > 0 && this.version++, this._clearcoat = t
    }
    get iridescence() {
        return this._iridescence
    }
    set iridescence(t) {
        this._iridescence > 0 != t > 0 && this.version++, this._iridescence = t
    }
    get dispersion() {
        return this._dispersion
    }
    set dispersion(t) {
        this._dispersion > 0 != t > 0 && this.version++, this._dispersion = t
    }
    get sheen() {
        return this._sheen
    }
    set sheen(t) {
        this._sheen > 0 != t > 0 && this.version++, this._sheen = t
    }
    get transmission() {
        return this._transmission
    }
    set transmission(t) {
        this._transmission > 0 != t > 0 && this.version++, this._transmission = t
    }
    copy(t) {
        return super.copy(t), this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        }, this.anisotropy = t.anisotropy, this.anisotropyRotation = t.anisotropyRotation, this.anisotropyMap = t.anisotropyMap, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.dispersion = t.dispersion, this.ior = t.ior, this.iridescence = t.iridescence, this.iridescenceMap = t.iridescenceMap, this.iridescenceIOR = t.iridescenceIOR, this.iridescenceThicknessRange = [...t.iridescenceThicknessRange], this.iridescenceThicknessMap = t.iridescenceThicknessMap, this.sheen = t.sheen, this.sheenColor.copy(t.sheenColor), this.sheenColorMap = t.sheenColorMap, this.sheenRoughness = t.sheenRoughness, this.sheenRoughnessMap = t.sheenRoughnessMap, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this.thickness = t.thickness, this.thicknessMap = t.thicknessMap, this.attenuationDistance = t.attenuationDistance, this.attenuationColor.copy(t.attenuationColor), this.specularIntensity = t.specularIntensity, this.specularIntensityMap = t.specularIntensityMap, this.specularColor.copy(t.specularColor), this.specularColorMap = t.specularColorMap, this
    }
}
class kp extends en {
    constructor(t) {
        super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new Le(16777215), this.specular = new Le(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Le(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Q(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Gn, this.combine = ih, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(t)
    }
    copy(t) {
        return super.copy(t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapRotation.copy(t.envMapRotation), this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this.fog = t.fog, this
    }
}
class zc extends en {
    constructor(t) {
        super(), this.isMeshMatcapMaterial = !0, this.defines = {
            MATCAP: ""
        }, this.type = "MeshMatcapMaterial", this.color = new Le(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Q(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(t)
    }
    copy(t) {
        return super.copy(t), this.defines = {
            MATCAP: ""
        }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.flatShading = t.flatShading, this.fog = t.fog, this
    }
}

function da(t, e, n) {
    return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
}

function jS(t) {
    return ArrayBuffer.isView(t) && !(t instanceof DataView)
}

function KS(t) {
    const e = t.length,
        n = new Array(e);
    for (let t = 0; t !== e; ++t) n[t] = t;
    return n.sort((function(e, n) {
        return t[e] - t[n]
    })), n
}

function nf(t, e, n) {
    const i = t.length,
        s = new t.constructor(i);
    for (let r = 0, o = 0; o !== i; ++r) {
        const i = n[r] * e;
        for (let n = 0; n !== e; ++n) s[o++] = t[i + n]
    }
    return s
}

function zp(t, e, n, i) {
    let s = 1,
        r = t[0];
    for (; void 0 !== r && void 0 === r[i];) r = t[s++];
    if (void 0 === r) return;
    let o = r[i];
    if (void 0 !== o)
        if (Array.isArray(o))
            do {
                o = r[i], void 0 !== o && (e.push(r.time), n.push.apply(n, o)), r = t[s++]
            } while (void 0 !== r);
        else if (void 0 !== o.toArray)
        do {
            o = r[i], void 0 !== o && (e.push(r.time), o.toArray(n, n.length)), r = t[s++]
        } while (void 0 !== r);
    else
        do {
            o = r[i], void 0 !== o && (e.push(r.time), n.push(o)), r = t[s++]
        } while (void 0 !== r)
}
class _o {
    constructor(t, e, n, i) {
        this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new e.constructor(n), this.sampleValues = e, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {}
    }
    evaluate(t) {
        const e = this.parameterPositions;
        let n = this._cachedIndex,
            i = e[n],
            s = e[n - 1];
        t: {
            e: {
                let r;n: {
                    i: if (!(t < i)) {
                        for (let r = n + 2;;) {
                            if (void 0 === i) {
                                if (t < s) break i;
                                return n = e.length, this._cachedIndex = n, this.copySampleValue_(n - 1)
                            }
                            if (n === r) break;
                            if (s = i, i = e[++n], t < i) break e
                        }
                        r = e.length;
                        break n
                    }if (t >= s) break t; {
                        const o = e[1];
                        t < o && (n = 2, s = o);
                        for (let r = n - 2;;) {
                            if (void 0 === s) return this._cachedIndex = 0, this.copySampleValue_(0);
                            if (n === r) break;
                            if (i = s, s = e[--n - 1], t >= s) break e
                        }
                        r = n, n = 0
                    }
                }
                for (; n < r;) {
                    const i = n + r >>> 1;
                    t < e[i] ? r = i : n = i + 1
                }
                if (i = e[n], s = e[n - 1], void 0 === s) return this._cachedIndex = 0, this.copySampleValue_(0);
                if (void 0 === i) return n = e.length, this._cachedIndex = n, this.copySampleValue_(n - 1)
            }
            this._cachedIndex = n,
            this.intervalChanged_(n, s, i)
        }
        return this.interpolate_(n, s, t, i)
    }
    getSettings_() {
        return this.settings || this.DefaultSettings_
    }
    copySampleValue_(t) {
        const e = this.resultBuffer,
            n = this.sampleValues,
            i = this.valueSize,
            s = t * i;
        for (let t = 0; t !== i; ++t) e[t] = n[s + t];
        return e
    }
    interpolate_() {
        throw new Error("call to abstract method")
    }
    intervalChanged_() {}
}
class YS extends _o {
    constructor(t, e, n, i) {
        super(t, e, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
            endingStart: Gu,
            endingEnd: Gu
        }
    }
    intervalChanged_(t, e, n) {
        const i = this.parameterPositions;
        let s = t - 2,
            r = t + 1,
            o = i[s],
            a = i[r];
        if (void 0 === o) switch (this.getSettings_().endingStart) {
            case Hu:
                s = t, o = 2 * e - n;
                break;
            case Vu:
                s = i.length - 2, o = e + i[s] - i[s + 1];
                break;
            default:
                s = t, o = n
        }
        if (void 0 === a) switch (this.getSettings_().endingEnd) {
            case Hu:
                r = t, a = 2 * n - e;
                break;
            case Vu:
                r = 1, a = n + i[1] - i[0];
                break;
            default:
                r = t - 1, a = e
        }
        const l = .5 * (n - e),
            c = this.valueSize;
        this._weightPrev = l / (e - o), this._weightNext = l / (a - n), this._offsetPrev = s * c, this._offsetNext = r * c
    }
    interpolate_(t, e, n, i) {
        const s = this.resultBuffer,
            r = this.sampleValues,
            o = this.valueSize,
            a = t * o,
            l = a - o,
            c = this._offsetPrev,
            h = this._offsetNext,
            u = this._weightPrev,
            d = this._weightNext,
            p = (n - e) / (i - e),
            f = p * p,
            m = f * p,
            g = -u * m + 2 * u * f - u * p,
            v = (1 + u) * m + (-1.5 - 2 * u) * f + (-.5 + u) * p + 1,
            y = (-1 - d) * m + (1.5 + d) * f + .5 * p,
            x = d * m - d * f;
        for (let t = 0; t !== o; ++t) s[t] = g * r[c + t] + v * r[l + t] + y * r[a + t] + x * r[h + t];
        return s
    }
}
class QS extends _o {
    constructor(t, e, n, i) {
        super(t, e, n, i)
    }
    interpolate_(t, e, n, i) {
        const s = this.resultBuffer,
            r = this.sampleValues,
            o = this.valueSize,
            a = t * o,
            l = a - o,
            c = (n - e) / (i - e),
            h = 1 - c;
        for (let t = 0; t !== o; ++t) s[t] = r[l + t] * h + r[a + t] * c;
        return s
    }
}
class qS extends _o {
    constructor(t, e, n, i) {
        super(t, e, n, i)
    }
    interpolate_(t) {
        return this.copySampleValue_(t - 1)
    }
}
class fi {
    constructor(t, e, n, i) {
        if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
        this.name = t, this.times = da(e, this.TimeBufferType), this.values = da(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation)
    }
    static toJSON(t) {
        const e = t.constructor;
        let n;
        if (e.toJSON !== this.toJSON) n = e.toJSON(t);
        else {
            n = {
                name: t.name,
                times: da(t.times, Array),
                values: da(t.values, Array)
            };
            const e = t.getInterpolation();
            e !== t.DefaultInterpolation && (n.interpolation = e)
        }
        return n.type = t.ValueTypeName, n
    }
    InterpolantFactoryMethodDiscrete(t) {
        return new qS(this.times, this.values, this.getValueSize(), t)
    }
    InterpolantFactoryMethodLinear(t) {
        return new QS(this.times, this.values, this.getValueSize(), t)
    }
    InterpolantFactoryMethodSmooth(t) {
        return new YS(this.times, this.values, this.getValueSize(), t)
    }
    setInterpolation(t) {
        let e;
        switch (t) {
            case fo:
                e = this.InterpolantFactoryMethodDiscrete;
                break;
            case _r:
                e = this.InterpolantFactoryMethodLinear;
                break;
            case El:
                e = this.InterpolantFactoryMethodSmooth
        }
        if (void 0 === e) {
            const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (void 0 === this.createInterpolant) {
                if (t === this.DefaultInterpolation) throw new Error(e);
                this.setInterpolation(this.DefaultInterpolation)
            }
            return console.warn("THREE.KeyframeTrack:", e), this
        }
        return this.createInterpolant = e, this
    }
    getInterpolation() {
        switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
                return fo;
            case this.InterpolantFactoryMethodLinear:
                return _r;
            case this.InterpolantFactoryMethodSmooth:
                return El
        }
    }
    getValueSize() {
        return this.values.length / this.times.length
    }
    shift(t) {
        if (0 !== t) {
            const e = this.times;
            for (let n = 0, i = e.length; n !== i; ++n) e[n] += t
        }
        return this
    }
    scale(t) {
        if (1 !== t) {
            const e = this.times;
            for (let n = 0, i = e.length; n !== i; ++n) e[n] *= t
        }
        return this
    }
    trim(t, e) {
        const n = this.times,
            i = n.length;
        let s = 0,
            r = i - 1;
        for (; s !== i && n[s] < t;) ++s;
        for (; - 1 !== r && n[r] > e;) --r;
        if (++r, 0 !== s || r !== i) {
            s >= r && (r = Math.max(r, 1), s = r - 1);
            const t = this.getValueSize();
            this.times = n.slice(s, r), this.values = this.values.slice(s * t, r * t)
        }
        return this
    }
    validate() {
        let t = !0;
        const e = this.getValueSize();
        e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
        const n = this.times,
            i = this.values,
            s = n.length;
        0 === s && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
        let r = null;
        for (let e = 0; e !== s; e++) {
            const i = n[e];
            if ("number" == typeof i && isNaN(i)) {
                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e, i), t = !1;
                break
            }
            if (null !== r && r > i) {
                console.error("THREE.KeyframeTrack: Out of order keys.", this, e, i, r), t = !1;
                break
            }
            r = i
        }
        if (void 0 !== i && jS(i))
            for (let e = 0, n = i.length; e !== n; ++e) {
                const n = i[e];
                if (isNaN(n)) {
                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e, n), t = !1;
                    break
                }
            }
        return t
    }
    optimize() {
        const t = this.times.slice(),
            e = this.values.slice(),
            n = this.getValueSize(),
            i = this.getInterpolation() === El,
            s = t.length - 1;
        let r = 1;
        for (let o = 1; o < s; ++o) {
            let s = !1;
            const a = t[o];
            if (a !== t[o + 1] && (1 !== o || a !== t[0]))
                if (i) s = !0;
                else {
                    const t = o * n,
                        i = t - n,
                        r = t + n;
                    for (let o = 0; o !== n; ++o) {
                        const n = e[t + o];
                        if (n !== e[i + o] || n !== e[r + o]) {
                            s = !0;
                            break
                        }
                    }
                }
            if (s) {
                if (o !== r) {
                    t[r] = t[o];
                    const i = o * n,
                        s = r * n;
                    for (let t = 0; t !== n; ++t) e[s + t] = e[i + t]
                }++r
            }
        }
        if (s > 0) {
            t[r] = t[s];
            for (let t = s * n, i = r * n, o = 0; o !== n; ++o) e[i + o] = e[t + o];
            ++r
        }
        return r !== t.length ? (this.times = t.slice(0, r), this.values = e.slice(0, r * n)) : (this.times = t, this.values = e), this
    }
    clone() {
        const t = this.times.slice(),
            e = this.values.slice(),
            n = new(0, this.constructor)(this.name, t, e);
        return n.createInterpolant = this.createInterpolant, n
    }
}
fi.prototype.TimeBufferType = Float32Array, fi.prototype.ValueBufferType = Float32Array, fi.prototype.DefaultInterpolation = _r;
class Br extends fi {}
Br.prototype.ValueTypeName = "bool", Br.prototype.ValueBufferType = Array, Br.prototype.DefaultInterpolation = fo, Br.prototype.InterpolantFactoryMethodLinear = void 0, Br.prototype.InterpolantFactoryMethodSmooth = void 0;
class Gp extends fi {}
Gp.prototype.ValueTypeName = "color";
class Tr extends fi {}
Tr.prototype.ValueTypeName = "number";
class ZS extends _o {
    constructor(t, e, n, i) {
        super(t, e, n, i)
    }
    interpolate_(t, e, n, i) {
        const s = this.resultBuffer,
            r = this.sampleValues,
            o = this.valueSize,
            a = (n - e) / (i - e);
        let l = t * o;
        for (let t = l + o; l !== t; l += 4) bt.slerpFlat(s, 0, r, l - o, r, l, a);
        return s
    }
}
class Ds extends fi {
    InterpolantFactoryMethodLinear(t) {
        return new ZS(this.times, this.values, this.getValueSize(), t)
    }
}
Ds.prototype.ValueTypeName = "quaternion", Ds.prototype.DefaultInterpolation = _r, Ds.prototype.InterpolantFactoryMethodSmooth = void 0;
class Ur extends fi {}
Ur.prototype.ValueTypeName = "string", Ur.prototype.ValueBufferType = Array, Ur.prototype.DefaultInterpolation = fo, Ur.prototype.InterpolantFactoryMethodLinear = void 0, Ur.prototype.InterpolantFactoryMethodSmooth = void 0;
class Cr extends fi {}
Cr.prototype.ValueTypeName = "vector";
class JS {
    constructor(t = "", e = -1, n = [], i = Cv) {
        this.name = t, this.tracks = n, this.duration = e, this.blendMode = i, this.uuid = zn(), this.duration < 0 && this.resetDuration()
    }
    static parse(t) {
        const e = [],
            n = t.tracks,
            i = 1 / (t.fps || 1);
        for (let t = 0, s = n.length; t !== s; ++t) e.push(e_(n[t]).scale(i));
        const s = new this(t.name, t.duration, e, t.blendMode);
        return s.uuid = t.uuid, s
    }
    static toJSON(t) {
        const e = [],
            n = t.tracks,
            i = {
                name: t.name,
                duration: t.duration,
                tracks: e,
                uuid: t.uuid,
                blendMode: t.blendMode
            };
        for (let t = 0, i = n.length; t !== i; ++t) e.push(fi.toJSON(n[t]));
        return i
    }
    static CreateFromMorphTargetSequence(t, e, n, i) {
        const s = e.length,
            r = [];
        for (let t = 0; t < s; t++) {
            let o = [],
                a = [];
            o.push((t + s - 1) % s, t, (t + 1) % s), a.push(0, 1, 0);
            const l = KS(o);
            o = nf(o, 1, l), a = nf(a, 1, l), !i && 0 === o[0] && (o.push(s), a.push(a[0])), r.push(new Tr(".morphTargetInfluences[" + e[t].name + "]", o, a).scale(1 / n))
        }
        return new this(t, -1, r)
    }
    static findByName(t, e) {
        let n = t;
        if (!Array.isArray(t)) {
            const e = t;
            n = e.geometry && e.geometry.animations || e.animations
        }
        for (let t = 0; t < n.length; t++)
            if (n[t].name === e) return n[t];
        return null
    }
    static CreateClipsFromMorphTargetSequences(t, e, n) {
        const i = {},
            s = /^([\w-]*?)([\d]+)$/;
        for (let e = 0, n = t.length; e < n; e++) {
            const n = t[e],
                r = n.name.match(s);
            if (r && r.length > 1) {
                const t = r[1];
                let e = i[t];
                e || (i[t] = e = []), e.push(n)
            }
        }
        const r = [];
        for (const t in i) r.push(this.CreateFromMorphTargetSequence(t, i[t], e, n));
        return r
    }
    static parseAnimation(t, e) {
        if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
        const n = function(t, e, n, i, s) {
                if (0 !== n.length) {
                    const r = [],
                        o = [];
                    zp(n, r, o, i), 0 !== r.length && s.push(new t(e, r, o))
                }
            },
            i = [],
            s = t.name || "default",
            r = t.fps || 30,
            o = t.blendMode;
        let a = t.length || -1;
        const l = t.hierarchy || [];
        for (let t = 0; t < l.length; t++) {
            const s = l[t].keys;
            if (s && 0 !== s.length)
                if (s[0].morphTargets) {
                    const t = {};
                    let e;
                    for (e = 0; e < s.length; e++)
                        if (s[e].morphTargets)
                            for (let n = 0; n < s[e].morphTargets.length; n++) t[s[e].morphTargets[n]] = -1;
                    for (const n in t) {
                        const t = [],
                            r = [];
                        for (let i = 0; i !== s[e].morphTargets.length; ++i) {
                            const i = s[e];
                            t.push(i.time), r.push(i.morphTarget === n ? 1 : 0)
                        }
                        i.push(new Tr(".morphTargetInfluence[" + n + "]", t, r))
                    }
                    a = t.length * r
                } else {
                    const r = ".bones[" + e[t].name + "]";
                    n(Cr, r + ".position", s, "pos", i), n(Ds, r + ".quaternion", s, "rot", i), n(Cr, r + ".scale", s, "scl", i)
                }
        }
        return 0 === i.length ? null : new this(s, a, i, o)
    }
    resetDuration() {
        let t = 0;
        for (let e = 0, n = this.tracks.length; e !== n; ++e) {
            const n = this.tracks[e];
            t = Math.max(t, n.times[n.times.length - 1])
        }
        return this.duration = t, this
    }
    trim() {
        for (let t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
        return this
    }
    validate() {
        let t = !0;
        for (let e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
        return t
    }
    optimize() {
        for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
        return this
    }
    clone() {
        const t = [];
        for (let e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
        return new this.constructor(this.name, this.duration, t, this.blendMode)
    }
    toJSON() {
        return this.constructor.toJSON(this)
    }
}

function $S(t) {
    switch (t.toLowerCase()) {
        case "scalar":
        case "double":
        case "float":
        case "number":
        case "integer":
            return Tr;
        case "vector":
        case "vector2":
        case "vector3":
        case "vector4":
            return Cr;
        case "color":
            return Gp;
        case "quaternion":
            return Ds;
        case "bool":
        case "boolean":
            return Br;
        case "string":
            return Ur
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
}

function e_(t) {
    if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    const e = $S(t.type);
    if (void 0 === t.times) {
        const e = [],
            n = [];
        zp(t.keys, e, n, "value"), t.times = e, t.values = n
    }
    return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
}
const Qi = {
    enabled: !1,
    files: {},
    add: function(t, e) {
        !1 !== this.enabled && (this.files[t] = e)
    },
    get: function(t) {
        if (!1 !== this.enabled) return this.files[t]
    },
    remove: function(t) {
        delete this.files[t]
    },
    clear: function() {
        this.files = {}
    }
};
class Hp {
    constructor(t, e, n) {
        const i = this;
        let s, r = !1,
            o = 0,
            a = 0;
        const l = [];
        this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function(t) {
            a++, !1 === r && void 0 !== i.onStart && i.onStart(t, o, a), r = !0
        }, this.itemEnd = function(t) {
            o++, void 0 !== i.onProgress && i.onProgress(t, o, a), o === a && (r = !1, void 0 !== i.onLoad && i.onLoad())
        }, this.itemError = function(t) {
            void 0 !== i.onError && i.onError(t)
        }, this.resolveURL = function(t) {
            return s ? s(t) : t
        }, this.setURLModifier = function(t) {
            return s = t, this
        }, this.addHandler = function(t, e) {
            return l.push(t, e), this
        }, this.removeHandler = function(t) {
            const e = l.indexOf(t);
            return -1 !== e && l.splice(e, 2), this
        }, this.getHandler = function(t) {
            for (let e = 0, n = l.length; e < n; e += 2) {
                const n = l[e],
                    i = l[e + 1];
                if (n.global && (n.lastIndex = 0), n.test(t)) return i
            }
            return null
        }
    }
}
const t_ = new Hp;
class is {
    constructor(t) {
        this.manager = void 0 !== t ? t : t_, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
    }
    load() {}
    loadAsync(t, e) {
        const n = this;
        return new Promise((function(i, s) {
            n.load(t, i, e, s)
        }))
    }
    parse() {}
    setCrossOrigin(t) {
        return this.crossOrigin = t, this
    }
    setWithCredentials(t) {
        return this.withCredentials = t, this
    }
    setPath(t) {
        return this.path = t, this
    }
    setResourcePath(t) {
        return this.resourcePath = t, this
    }
    setRequestHeader(t) {
        return this.requestHeader = t, this
    }
}
is.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const Ai = {};
class n_ extends Error {
    constructor(t, e) {
        super(t), this.response = e
    }
}
class qa extends is {
    constructor(t) {
        super(t)
    }
    load(t, e, n, i) {
        void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
        const s = Qi.get(t);
        if (void 0 !== s) return this.manager.itemStart(t), setTimeout((() => {
            e && e(s), this.manager.itemEnd(t)
        }), 0), s;
        if (void 0 !== Ai[t]) return void Ai[t].push({
            onLoad: e,
            onProgress: n,
            onError: i
        });
        Ai[t] = [], Ai[t].push({
            onLoad: e,
            onProgress: n,
            onError: i
        });
        const r = new Request(t, {
                headers: new Headers(this.requestHeader),
                credentials: this.withCredentials ? "include" : "same-origin"
            }),
            o = this.mimeType,
            a = this.responseType;
        fetch(r).then((e => {
            if (200 === e.status || 0 === e.status) {
                if (0 === e.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || void 0 === e.body || void 0 === e.body.getReader) return e;
                const n = Ai[t],
                    i = e.body.getReader(),
                    s = e.headers.get("X-File-Size") || e.headers.get("Content-Length"),
                    r = s ? parseInt(s) : 0,
                    o = 0 !== r;
                let a = 0;
                const l = new ReadableStream({
                    start(t) {
                        ! function e() {
                            i.read().then((({
                                done: i,
                                value: s
                            }) => {
                                if (i) t.close();
                                else {
                                    a += s.byteLength;
                                    const i = new ProgressEvent("progress", {
                                        lengthComputable: o,
                                        loaded: a,
                                        total: r
                                    });
                                    for (let t = 0, e = n.length; t < e; t++) {
                                        const e = n[t];
                                        e.onProgress && e.onProgress(i)
                                    }
                                    t.enqueue(s), e()
                                }
                            }))
                        }()
                    }
                });
                return new Response(l)
            }
            throw new n_(`fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`, e)
        })).then((t => {
            switch (a) {
                case "arraybuffer":
                    return t.arrayBuffer();
                case "blob":
                    return t.blob();
                case "document":
                    return t.text().then((t => (new DOMParser).parseFromString(t, o)));
                case "json":
                    return t.json();
                default:
                    if (void 0 === o) return t.text(); {
                        const e = /charset="?([^;"\s]*)"?/i.exec(o),
                            n = e && e[1] ? e[1].toLowerCase() : void 0,
                            i = new TextDecoder(n);
                        return t.arrayBuffer().then((t => i.decode(t)))
                    }
            }
        })).then((e => {
            Qi.add(t, e);
            const n = Ai[t];
            delete Ai[t];
            for (let t = 0, i = n.length; t < i; t++) {
                const i = n[t];
                i.onLoad && i.onLoad(e)
            }
        })).catch((e => {
            const n = Ai[t];
            if (void 0 === n) throw this.manager.itemError(t), e;
            delete Ai[t];
            for (let t = 0, i = n.length; t < i; t++) {
                const i = n[t];
                i.onError && i.onError(e)
            }
            this.manager.itemError(t)
        })).finally((() => {
            this.manager.itemEnd(t)
        })), this.manager.itemStart(t)
    }
    setResponseType(t) {
        return this.responseType = t, this
    }
    setMimeType(t) {
        return this.mimeType = t, this
    }
}
class i_ extends is {
    constructor(t) {
        super(t)
    }
    load(t, e, n, i) {
        void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
        const s = this,
            r = Qi.get(t);
        if (void 0 !== r) return s.manager.itemStart(t), setTimeout((function() {
            e && e(r), s.manager.itemEnd(t)
        }), 0), r;
        const o = po("img");

        function a() {
            c(), Qi.add(t, this), e && e(this), s.manager.itemEnd(t)
        }

        function l(e) {
            c(), i && i(e), s.manager.itemError(t), s.manager.itemEnd(t)
        }

        function c() {
            o.removeEventListener("load", a, !1), o.removeEventListener("error", l, !1)
        }
        return o.addEventListener("load", a, !1), o.addEventListener("error", l, !1), "data:" !== t.slice(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin), s.manager.itemStart(t), o.src = t, o
    }
}
class Vp extends is {
    constructor(t) {
        super(t)
    }
    load(t, e, n, i) {
        const s = new wt,
            r = new i_(this.manager);
        return r.setCrossOrigin(this.crossOrigin), r.setPath(this.path), r.load(t, (function(t) {
            s.image = t, s.needsUpdate = !0, void 0 !== e && e(s)
        }), n, i), s
    }
}
class wo extends ct {
    constructor(t, e = 1) {
        super(), this.isLight = !0, this.type = "Light", this.color = new Le(t), this.intensity = e
    }
    dispose() {}
    copy(t, e) {
        return super.copy(t, e), this.color.copy(t.color), this.intensity = t.intensity, this
    }
    toJSON(t) {
        const e = super.toJSON(t);
        return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
    }
}
class s_ extends wo {
    constructor(t, e, n) {
        super(t, n), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(ct.DEFAULT_UP), this.updateMatrix(), this.groundColor = new Le(e)
    }
    copy(t, e) {
        return super.copy(t, e), this.groundColor.copy(t.groundColor), this
    }
}
const oc = new Xe,
    sf = new U,
    rf = new U;
class Mh {
    constructor(t) {
        this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Q(512, 512), this.map = null, this.mapPass = null, this.matrix = new Xe, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new dh, this._frameExtents = new Q(1, 1), this._viewportCount = 1, this._viewports = [new ot(0, 0, 1, 1)]
    }
    getViewportCount() {
        return this._viewportCount
    }
    getFrustum() {
        return this._frustum
    }
    updateMatrices(t) {
        const e = this.camera,
            n = this.matrix;
        sf.setFromMatrixPosition(t.matrixWorld), e.position.copy(sf), rf.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(rf), e.updateMatrixWorld(), oc.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(oc), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(oc)
    }
    getViewport(t) {
        return this._viewports[t]
    }
    getFrameExtents() {
        return this._frameExtents
    }
    dispose() {
        this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
    }
    copy(t) {
        return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this
    }
    clone() {
        return (new this.constructor).copy(this)
    }
    toJSON() {
        const t = {};
        return 0 !== this.bias && (t.bias = this.bias), 0 !== this.normalBias && (t.normalBias = this.normalBias), 1 !== this.radius && (t.radius = this.radius), (512 !== this.mapSize.x || 512 !== this.mapSize.y) && (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
    }
}
class r_ extends Mh {
    constructor() {
        super(new Pt(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1
    }
    updateMatrices(t) {
        const e = this.camera,
            n = 2 * wr * t.angle * this.focus,
            i = this.mapSize.width / this.mapSize.height,
            s = t.distance || e.far;
        (n !== e.fov || i !== e.aspect || s !== e.far) && (e.fov = n, e.aspect = i, e.far = s, e.updateProjectionMatrix()), super.updateMatrices(t)
    }
    copy(t) {
        return super.copy(t), this.focus = t.focus, this
    }
}
class Wp extends wo {
    constructor(t, e, n = 0, i = Math.PI / 3, s = 0, r = 2) {
        super(t, e), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(ct.DEFAULT_UP), this.updateMatrix(), this.target = new ct, this.distance = n, this.angle = i, this.penumbra = s, this.decay = r, this.map = null, this.shadow = new r_
    }
    get power() {
        return this.intensity * Math.PI
    }
    set power(t) {
        this.intensity = t / Math.PI
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(t, e) {
        return super.copy(t, e), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
    }
}
const of = new Xe, Jr = new U, ac = new U;
class o_ extends Mh {
    constructor() {
        super(new Pt(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new Q(4, 2), this._viewportCount = 6, this._viewports = [new ot(2, 1, 1, 1), new ot(0, 1, 1, 1), new ot(3, 1, 1, 1), new ot(1, 1, 1, 1), new ot(3, 0, 1, 1), new ot(1, 0, 1, 1)], this._cubeDirections = [new U(1, 0, 0), new U(-1, 0, 0), new U(0, 0, 1), new U(0, 0, -1), new U(0, 1, 0), new U(0, -1, 0)], this._cubeUps = [new U(0, 1, 0), new U(0, 1, 0), new U(0, 1, 0), new U(0, 1, 0), new U(0, 0, 1), new U(0, 0, -1)]
    }
    updateMatrices(t, e = 0) {
        const n = this.camera,
            i = this.matrix,
            s = t.distance || n.far;
        s !== n.far && (n.far = s, n.updateProjectionMatrix()), Jr.setFromMatrixPosition(t.matrixWorld), n.position.copy(Jr), ac.copy(n.position), ac.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(ac), n.updateMatrixWorld(), i.makeTranslation(-Jr.x, -Jr.y, -Jr.z), of .multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix( of )
    }
}
class Xp extends wo {
    constructor(t, e, n = 0, i = 2) {
        super(t, e), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new o_
    }
    get power() {
        return 4 * this.intensity * Math.PI
    }
    set power(t) {
        this.intensity = t / (4 * Math.PI)
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(t, e) {
        return super.copy(t, e), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
    }
}
class a_ extends Mh {
    constructor() {
        super(new Ci(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0
    }
}
class l_ extends wo {
    constructor(t, e) {
        super(t, e), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(ct.DEFAULT_UP), this.updateMatrix(), this.target = new ct, this.shadow = new a_
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(t) {
        return super.copy(t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
    }
}
class c_ extends wo {
    constructor(t, e) {
        super(t, e), this.isAmbientLight = !0, this.type = "AmbientLight"
    }
}
class ao {
    static decodeText(t) {
        if (typeof TextDecoder < "u") return (new TextDecoder).decode(t);
        let e = "";
        for (let n = 0, i = t.length; n < i; n++) e += String.fromCharCode(t[n]);
        try {
            return decodeURIComponent(escape(e))
        } catch {
            return e
        }
    }
    static extractUrlBase(t) {
        const e = t.lastIndexOf("/");
        return -1 === e ? "./" : t.slice(0, e + 1)
    }
    static resolveURL(t, e) {
        return "string" != typeof t || "" === t ? "" : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e + t)
    }
}
class h_ extends ht {
    constructor() {
        super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
    }
    copy(t) {
        return super.copy(t), this.instanceCount = t.instanceCount, this
    }
    toJSON() {
        const t = super.toJSON();
        return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = !0, t
    }
}
class jp extends is {
    constructor(t) {
        super(t), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
            premultiplyAlpha: "none"
        }
    }
    setOptions(t) {
        return this.options = t, this
    }
    load(t, e, n, i) {
        void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
        const s = this,
            r = Qi.get(t);
        if (void 0 !== r) return s.manager.itemStart(t), r.then ? void r.then((n => {
            e && e(n), s.manager.itemEnd(t)
        })).catch((t => {
            i && i(t)
        })) : (setTimeout((function() {
            e && e(r), s.manager.itemEnd(t)
        }), 0), r);
        const o = {};
        o.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", o.headers = this.requestHeader;
        const a = fetch(t, o).then((function(t) {
            return t.blob()
        })).then((function(t) {
            return createImageBitmap(t, Object.assign(s.options, {
                colorSpaceConversion: "none"
            }))
        })).then((function(n) {
            return Qi.add(t, n), e && e(n), s.manager.itemEnd(t), n
        })).catch((function(e) {
            i && i(e), Qi.remove(t), s.manager.itemError(t), s.manager.itemEnd(t)
        }));
        Qi.add(t, a), s.manager.itemStart(t)
    }
}
class u_ {
    constructor(t = !0) {
        this.autoStart = t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
    }
    start() {
        this.startTime = af(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
    }
    stop() {
        this.getElapsedTime(), this.running = !1, this.autoStart = !1
    }
    getElapsedTime() {
        return this.getDelta(), this.elapsedTime
    }
    getDelta() {
        let t = 0;
        if (this.autoStart && !this.running) return this.start(), 0;
        if (this.running) {
            const e = af();
            t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t
        }
        return t
    }
}

function af() {
    return (typeof performance > "u" ? Date : performance).now()
}
const Eh = "\\[\\]\\.:\\/",
    d_ = new RegExp("[" + Eh + "]", "g"),
    Th = "[^" + Eh + "]",
    f_ = "[^" + Eh.replace("\\.", "") + "]",
    p_ = /((?:WC+[\/:])*)/.source.replace("WC", Th),
    m_ = /(WCOD+)?/.source.replace("WCOD", f_),
    g_ = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Th),
    v_ = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Th),
    y_ = new RegExp("^" + p_ + m_ + g_ + v_ + "$"),
    x_ = ["material", "materials", "bones", "map"];
class b_ {
    constructor(t, e, n) {
        const i = n || gt.parseTrackName(e);
        this._targetGroup = t, this._bindings = t.subscribe_(e, i)
    }
    getValue(t, e) {
        this.bind();
        const n = this._targetGroup.nCachedObjects_,
            i = this._bindings[n];
        void 0 !== i && i.getValue(t, e)
    }
    setValue(t, e) {
        const n = this._bindings;
        for (let i = this._targetGroup.nCachedObjects_, s = n.length; i !== s; ++i) n[i].setValue(t, e)
    }
    bind() {
        const t = this._bindings;
        for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].bind()
    }
    unbind() {
        const t = this._bindings;
        for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].unbind()
    }
}
class gt {
    constructor(t, e, n) {
        this.path = e, this.parsedPath = n || gt.parseTrackName(e), this.node = gt.findNode(t, this.parsedPath.nodeName), this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
    }
    static create(t, e, n) {
        return t && t.isAnimationObjectGroup ? new gt.Composite(t, e, n) : new gt(t, e, n)
    }
    static sanitizeNodeName(t) {
        return t.replace(/\s/g, "_").replace(d_, "")
    }
    static parseTrackName(t) {
        const e = y_.exec(t);
        if (null === e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
        const n = {
                nodeName: e[2],
                objectName: e[3],
                objectIndex: e[4],
                propertyName: e[5],
                propertyIndex: e[6]
            },
            i = n.nodeName && n.nodeName.lastIndexOf(".");
        if (void 0 !== i && -1 !== i) {
            const t = n.nodeName.substring(i + 1); - 1 !== x_.indexOf(t) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = t)
        }
        if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
        return n
    }
    static findNode(t, e) {
        if (void 0 === e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
        if (t.skeleton) {
            const n = t.skeleton.getBoneByName(e);
            if (void 0 !== n) return n
        }
        if (t.children) {
            const n = function(t) {
                    for (let i = 0; i < t.length; i++) {
                        const s = t[i];
                        if (s.name === e || s.uuid === e) return s;
                        const r = n(s.children);
                        if (r) return r
                    }
                    return null
                },
                i = n(t.children);
            if (i) return i
        }
        return null
    }
    _getValue_unavailable() {}
    _setValue_unavailable() {}
    _getValue_direct(t, e) {
        t[e] = this.targetObject[this.propertyName]
    }
    _getValue_array(t, e) {
        const n = this.resolvedProperty;
        for (let i = 0, s = n.length; i !== s; ++i) t[e++] = n[i]
    }
    _getValue_arrayElement(t, e) {
        t[e] = this.resolvedProperty[this.propertyIndex]
    }
    _getValue_toArray(t, e) {
        this.resolvedProperty.toArray(t, e)
    }
    _setValue_direct(t, e) {
        this.targetObject[this.propertyName] = t[e]
    }
    _setValue_direct_setNeedsUpdate(t, e) {
        this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
        this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_array(t, e) {
        const n = this.resolvedProperty;
        for (let i = 0, s = n.length; i !== s; ++i) n[i] = t[e++]
    }
    _setValue_array_setNeedsUpdate(t, e) {
        const n = this.resolvedProperty;
        for (let i = 0, s = n.length; i !== s; ++i) n[i] = t[e++];
        this.targetObject.needsUpdate = !0
    }
    _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
        const n = this.resolvedProperty;
        for (let i = 0, s = n.length; i !== s; ++i) n[i] = t[e++];
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_arrayElement(t, e) {
        this.resolvedProperty[this.propertyIndex] = t[e]
    }
    _setValue_arrayElement_setNeedsUpdate(t, e) {
        this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
        this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_fromArray(t, e) {
        this.resolvedProperty.fromArray(t, e)
    }
    _setValue_fromArray_setNeedsUpdate(t, e) {
        this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
        this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _getValue_unbound(t, e) {
        this.bind(), this.getValue(t, e)
    }
    _setValue_unbound(t, e) {
        this.bind(), this.setValue(t, e)
    }
    bind() {
        let t = this.node;
        const e = this.parsedPath,
            n = e.objectName,
            i = e.propertyName;
        let s = e.propertyIndex;
        if (t || (t = gt.findNode(this.rootNode, e.nodeName), this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
        if (n) {
            let i = e.objectIndex;
            switch (n) {
                case "materials":
                    if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                    if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                    t = t.material.materials;
                    break;
                case "bones":
                    if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                    t = t.skeleton.bones;
                    for (let e = 0; e < t.length; e++)
                        if (t[e].name === i) {
                            i = e;
                            break
                        }
                    break;
                case "map":
                    if ("map" in t) {
                        t = t.map;
                        break
                    }
                    if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                    if (!t.material.map) return void console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                    t = t.material.map;
                    break;
                default:
                    if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                    t = t[n]
            }
            if (void 0 !== i) {
                if (void 0 === t[i]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                t = t[i]
            }
        }
        const r = t[i];
        if (void 0 === r) {
            const n = e.nodeName;
            return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + i + " but it wasn't found.", t)
        }
        let o = this.Versioning.None;
        this.targetObject = t, void 0 !== t.needsUpdate ? o = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (o = this.Versioning.MatrixWorldNeedsUpdate);
        let a = this.BindingType.Direct;
        if (void 0 !== s) {
            if ("morphTargetInfluences" === i) {
                if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                void 0 !== t.morphTargetDictionary[s] && (s = t.morphTargetDictionary[s])
            }
            a = this.BindingType.ArrayElement, this.resolvedProperty = r, this.propertyIndex = s
        } else void 0 !== r.fromArray && void 0 !== r.toArray ? (a = this.BindingType.HasFromToArray, this.resolvedProperty = r) : Array.isArray(r) ? (a = this.BindingType.EntireArray, this.resolvedProperty = r) : this.propertyName = i;
        this.getValue = this.GetterByBindingType[a], this.setValue = this.SetterByBindingTypeAndVersioning[a][o]
    }
    unbind() {
        this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
    }
}
gt.Composite = b_, gt.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
}, gt.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
}, gt.prototype.GetterByBindingType = [gt.prototype._getValue_direct, gt.prototype._getValue_array, gt.prototype._getValue_arrayElement, gt.prototype._getValue_toArray], gt.prototype.SetterByBindingTypeAndVersioning = [
    [gt.prototype._setValue_direct, gt.prototype._setValue_direct_setNeedsUpdate, gt.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
    [gt.prototype._setValue_array, gt.prototype._setValue_array_setNeedsUpdate, gt.prototype._setValue_array_setMatrixWorldNeedsUpdate],
    [gt.prototype._setValue_arrayElement, gt.prototype._setValue_arrayElement_setNeedsUpdate, gt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
    [gt.prototype._setValue_fromArray, gt.prototype._setValue_fromArray_setNeedsUpdate, gt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
];
class Ce {
    constructor(t) {
        this.value = t
    }
    clone() {
        return new Ce(void 0 === this.value.clone ? this.value : this.value.clone())
    }
}
class Gc extends gh {
    constructor(t, e, n = 1) {
        super(t, e), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = n
    }
    copy(t) {
        return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this
    }
    clone(t) {
        const e = super.clone(t);
        return e.meshPerAttribute = this.meshPerAttribute, e
    }
    toJSON(t) {
        const e = super.toJSON(t);
        return e.isInstancedInterleavedBuffer = !0, e.meshPerAttribute = this.meshPerAttribute, e
    }
}
const lf = new Xe;
class Kp {
    constructor(t, e, n = 0, i = 1 / 0) {
        this.ray = new Ir(t, e), this.near = n, this.far = i, this.camera = null, this.layers = new hh, this.params = {
            Mesh: {},
            Line: {
                threshold: 1
            },
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        }
    }
    set(t, e) {
        this.ray.set(t, e)
    }
    setFromCamera(t, e) {
        e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type: " + e.type)
    }
    setFromXRController(t) {
        return lf.identity().extractRotation(t.matrixWorld), this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(lf), this
    }
    intersectObject(t, e = !0, n = []) {
        return Hc(t, this, n, e), n.sort(cf), n
    }
    intersectObjects(t, e = !0, n = []) {
        for (let i = 0, s = t.length; i < s; i++) Hc(t[i], this, n, e);
        return n.sort(cf), n
    }
}

function cf(t, e) {
    return t.distance - e.distance
}

function Hc(t, e, n, i) {
    if (t.layers.test(e.layers) && t.raycast(e, n), !0 === i) {
        const i = t.children;
        for (let t = 0, s = i.length; t < s; t++) Hc(i[t], e, n, !0)
    }
}
class hf {
    constructor(t = 1, e = 0, n = 0) {
        return this.radius = t, this.phi = e, this.theta = n, this
    }
    set(t, e, n) {
        return this.radius = t, this.phi = e, this.theta = n, this
    }
    copy(t) {
        return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this
    }
    makeSafe() {
        return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
    }
    setFromVector3(t) {
        return this.setFromCartesianCoords(t.x, t.y, t.z)
    }
    setFromCartesianCoords(t, e, n) {
        return this.radius = Math.sqrt(t * t + e * e + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n), this.phi = Math.acos(Ut(e / this.radius, -1, 1))), this
    }
    clone() {
        return (new this.constructor).copy(this)
    }
}
const uf = new Q;
class A_ {
    constructor(t = new Q(1 / 0, 1 / 0), e = new Q(-1 / 0, -1 / 0)) {
        this.isBox2 = !0, this.min = t, this.max = e
    }
    set(t, e) {
        return this.min.copy(t), this.max.copy(e), this
    }
    setFromPoints(t) {
        this.makeEmpty();
        for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
        return this
    }
    setFromCenterAndSize(t, e) {
        const n = uf.copy(e).multiplyScalar(.5);
        return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
    }
    clone() {
        return (new this.constructor).copy(this)
    }
    copy(t) {
        return this.min.copy(t.min), this.max.copy(t.max), this
    }
    makeEmpty() {
        return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y
    }
    getCenter(t) {
        return this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(t) {
        return this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
    }
    expandByPoint(t) {
        return this.min.min(t), this.max.max(t), this
    }
    expandByVector(t) {
        return this.min.sub(t), this.max.add(t), this
    }
    expandByScalar(t) {
        return this.min.addScalar(-t), this.max.addScalar(t), this
    }
    containsPoint(t) {
        return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
    }
    containsBox(t) {
        return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
    }
    getParameter(t, e) {
        return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
    }
    intersectsBox(t) {
        return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
    }
    clampPoint(t, e) {
        return e.copy(t).clamp(this.min, this.max)
    }
    distanceToPoint(t) {
        return this.clampPoint(t, uf).distanceTo(t)
    }
    intersect(t) {
        return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
    }
    union(t) {
        return this.min.min(t.min), this.max.max(t.max), this
    }
    translate(t) {
        return this.min.add(t), this.max.add(t), this
    }
    equals(t) {
        return t.min.equals(this.min) && t.max.equals(this.max)
    }
}
const df = new U,
    fa = new U;
class S_ {
    constructor(t = new U, e = new U) {
        this.start = t, this.end = e
    }
    set(t, e) {
        return this.start.copy(t), this.end.copy(e), this
    }
    copy(t) {
        return this.start.copy(t.start), this.end.copy(t.end), this
    }
    getCenter(t) {
        return t.addVectors(this.start, this.end).multiplyScalar(.5)
    }
    delta(t) {
        return t.subVectors(this.end, this.start)
    }
    distanceSq() {
        return this.start.distanceToSquared(this.end)
    }
    distance() {
        return this.start.distanceTo(this.end)
    }
    at(t, e) {
        return this.delta(e).multiplyScalar(t).add(this.start)
    }
    closestPointToPointParameter(t, e) {
        df.subVectors(t, this.start), fa.subVectors(this.end, this.start);
        const n = fa.dot(fa);
        let i = fa.dot(df) / n;
        return e && (i = Ut(i, 0, 1)), i
    }
    closestPointToPoint(t, e, n) {
        const i = this.closestPointToPointParameter(t, e);
        return this.delta(n).multiplyScalar(i).add(this.start)
    }
    applyMatrix4(t) {
        return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
    }
    equals(t) {
        return t.start.equals(this.start) && t.end.equals(this.end)
    }
    clone() {
        return (new this.constructor).copy(this)
    }
}
const ff = new U;
class __ extends ct {
    constructor(t, e) {
        super(), this.light = t, this.matrixAutoUpdate = !1, this.color = e, this.type = "SpotLightHelper";
        const n = new ht,
            i = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
        for (let t = 0, e = 1, n = 32; t < n; t++, e++) {
            const s = t / n * Math.PI * 2,
                r = e / n * Math.PI * 2;
            i.push(Math.cos(s), Math.sin(s), 1, Math.cos(r), Math.sin(r), 1)
        }
        n.setAttribute("position", new Fe(i, 3));
        const s = new Zi({
            fog: !1,
            toneMapped: !1
        });
        this.cone = new mo(n, s), this.add(this.cone), this.update()
    }
    dispose() {
        this.cone.geometry.dispose(), this.cone.material.dispose()
    }
    update() {
        this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), this.parent ? (this.parent.updateWorldMatrix(!0), this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)) : this.matrix.copy(this.light.matrixWorld), this.matrixWorld.copy(this.light.matrixWorld);
        const t = this.light.distance ? this.light.distance : 1e3,
            e = t * Math.tan(this.light.angle);
        this.cone.scale.set(e, e, t), ff.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(ff), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
    }
}
class w_ extends be {
    constructor(t, e, n) {
        super(new Or(e, 4, 2), new At({
            wireframe: !0,
            fog: !1,
            toneMapped: !1
        })), this.light = t, this.color = n, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose()
    }
    update() {
        this.light.updateWorldMatrix(!0, !1), void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
    }
}
class M_ extends mo {
    constructor(t = 10, e = 16, n = 8, i = 64, s = 4473924, r = 8947848) {
        s = new Le(s), r = new Le(r);
        const o = [],
            a = [];
        if (e > 1)
            for (let n = 0; n < e; n++) {
                const i = n / e * (2 * Math.PI),
                    l = Math.sin(i) * t,
                    c = Math.cos(i) * t;
                o.push(0, 0, 0), o.push(l, 0, c);
                const h = 1 & n ? s : r;
                a.push(h.r, h.g, h.b), a.push(h.r, h.g, h.b)
            }
        for (let e = 0; e < n; e++) {
            const l = 1 & e ? s : r,
                c = t - t / n * e;
            for (let t = 0; t < i; t++) {
                let e = t / i * (2 * Math.PI),
                    n = Math.sin(e) * c,
                    s = Math.cos(e) * c;
                o.push(n, 0, s), a.push(l.r, l.g, l.b), e = (t + 1) / i * (2 * Math.PI), n = Math.sin(e) * c, s = Math.cos(e) * c, o.push(n, 0, s), a.push(l.r, l.g, l.b)
            }
        }
        const l = new ht;
        l.setAttribute("position", new Fe(o, 3)), l.setAttribute("color", new Fe(a, 3));
        super(l, new Zi({
            vertexColors: !0,
            toneMapped: !1
        })), this.type = "PolarGridHelper"
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose()
    }
}
class ds {
    constructor() {
        this.type = "ShapePath", this.color = new Le, this.subPaths = [], this.currentPath = null
    }
    moveTo(t, e) {
        return this.currentPath = new fr, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e), this
    }
    lineTo(t, e) {
        return this.currentPath.lineTo(t, e), this
    }
    quadraticCurveTo(t, e, n, i) {
        return this.currentPath.quadraticCurveTo(t, e, n, i), this
    }
    bezierCurveTo(t, e, n, i, s, r) {
        return this.currentPath.bezierCurveTo(t, e, n, i, s, r), this
    }
    splineThru(t) {
        return this.currentPath.splineThru(t), this
    }
    toShapes(t) {
        function e(t, e) {
            const n = e.length;
            let i = !1;
            for (let s = n - 1, r = 0; r < n; s = r++) {
                let n = e[s],
                    o = e[r],
                    a = o.x - n.x,
                    l = o.y - n.y;
                if (Math.abs(l) > Number.EPSILON) {
                    if (l < 0 && (n = e[r], a = -a, o = e[s], l = -l), t.y < n.y || t.y > o.y) continue;
                    if (t.y === n.y) {
                        if (t.x === n.x) return !0
                    } else {
                        const e = l * (t.x - n.x) - a * (t.y - n.y);
                        if (0 === e) return !0;
                        if (e < 0) continue;
                        i = !i
                    }
                } else {
                    if (t.y !== n.y) continue;
                    if (o.x <= t.x && t.x <= n.x || n.x <= t.x && t.x <= o.x) return !0
                }
            }
            return i
        }
        const n = Es.isClockWise,
            i = this.subPaths;
        if (0 === i.length) return [];
        let s, r, o;
        const a = [];
        if (1 === i.length) return r = i[0], o = new Ji, o.curves = r.curves, a.push(o), a;
        let l = !n(i[0].getPoints());
        l = t ? !l : l;
        const c = [],
            h = [];
        let u, d, p = [],
            f = 0;
        h[f] = void 0, p[f] = [];
        for (let e = 0, o = i.length; e < o; e++) r = i[e], u = r.getPoints(), s = n(u), s = t ? !s : s, s ? (!l && h[f] && f++, h[f] = {
            s: new Ji,
            p: u
        }, h[f].s.curves = r.curves, l && f++, p[f] = []) : p[f].push({
            h: r,
            p: u[0]
        });
        if (!h[0]) return function(t) {
            const e = [];
            for (let n = 0, i = t.length; n < i; n++) {
                const i = t[n],
                    s = new Ji;
                s.curves = i.curves, e.push(s)
            }
            return e
        }(i);
        if (h.length > 1) {
            let t = !1,
                n = 0;
            for (let t = 0, e = h.length; t < e; t++) c[t] = [];
            for (let i = 0, s = h.length; i < s; i++) {
                const s = p[i];
                for (let r = 0; r < s.length; r++) {
                    const o = s[r];
                    let a = !0;
                    for (let s = 0; s < h.length; s++) e(o.p, h[s].p) && (i !== s && n++, a ? (a = !1, c[s].push(o)) : t = !0);
                    a && c[i].push(o)
                }
            }
            n > 0 && !1 === t && (p = c)
        }
        for (let t = 0, e = h.length; t < e; t++) {
            o = h[t].s, a.push(o), d = p[t];
            for (let t = 0, e = d.length; t < e; t++) o.holes.push(d[t].h)
        }
        return a
    }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
    detail: {
        revision: ns
    }
})), typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = ns);
/**
 * postprocessing v6.36.1 build Mon Sep 02 2024
 * https://github.com/pmndrs/postprocessing
 * Copyright 2015-2024 Raoul van Rüschen
 * @license Zlib
 */
var lc = .001,
    E_ = 1e3,
    T_ = class {
        constructor() {
            this.startTime = performance.now(), this.previousTime = 0, this.currentTime = 0, this._delta = 0, this._elapsed = 0, this._fixedDelta = 1e3 / 60, this.timescale = 1, this.useFixedDelta = !1, this._autoReset = !1
        }
        get autoReset() {
            return this._autoReset
        }
        set autoReset(t) {
            typeof document < "u" && void 0 !== document.hidden && (t ? document.addEventListener("visibilitychange", this) : document.removeEventListener("visibilitychange", this), this._autoReset = t)
        }
        get delta() {
            return this._delta * lc
        }
        get fixedDelta() {
            return this._fixedDelta * lc
        }
        set fixedDelta(t) {
            this._fixedDelta = t * E_
        }
        get elapsed() {
            return this._elapsed * lc
        }
        update(t) {
            this.useFixedDelta ? this._delta = this.fixedDelta : (this.previousTime = this.currentTime, this.currentTime = (void 0 !== t ? t : performance.now()) - this.startTime, this._delta = this.currentTime - this.previousTime), this._delta *= this.timescale, this._elapsed += this._delta
        }
        reset() {
            this._delta = 0, this._elapsed = 0, this.currentTime = performance.now() - this.startTime
        }
        getDelta() {
            return this.delta
        }
        getElapsed() {
            return this.elapsed
        }
        handleEvent(t) {
            document.hidden || (this.currentTime = performance.now() - this.startTime)
        }
        dispose() {
            this.autoReset = !1
        }
    },
    C_ = (() => {
        const t = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]),
            e = new Float32Array([0, 0, 2, 0, 0, 2]),
            n = new ht;
        return n.setAttribute("position", new Xt(t, 3)), n.setAttribute("uv", new Xt(e, 2)), n
    })(),
    Vn = class t {
        static get fullscreenGeometry() {
            return C_
        }
        constructor(t = "Pass", e = new Bc, n = new uh) {
            this.name = t, this.renderer = null, this.scene = e, this.camera = n, this.screen = null, this.rtt = !0, this.needsSwap = !0, this.needsDepthTexture = !1, this.enabled = !0
        }
        get renderToScreen() {
            return !this.rtt
        }
        set renderToScreen(t) {
            if (this.rtt === t) {
                const e = this.fullscreenMaterial;
                null !== e && (e.needsUpdate = !0), this.rtt = !t
            }
        }
        set mainScene(t) {}
        set mainCamera(t) {}
        setRenderer(t) {
            this.renderer = t
        }
        isEnabled() {
            return this.enabled
        }
        setEnabled(t) {
            this.enabled = t
        }
        get fullscreenMaterial() {
            return null !== this.screen ? this.screen.material : null
        }
        set fullscreenMaterial(e) {
            let n = this.screen;
            null !== n ? n.material = e : (n = new be(t.fullscreenGeometry, e), n.frustumCulled = !1, null === this.scene && (this.scene = new Bc), this.scene.add(n), this.screen = n)
        }
        getFullscreenMaterial() {
            return this.fullscreenMaterial
        }
        setFullscreenMaterial(t) {
            this.fullscreenMaterial = t
        }
        getDepthTexture() {
            return null
        }
        setDepthTexture(t, e = Oi) {}
        render(t, e, n, i, s) {
            throw new Error("Render method not implemented!")
        }
        setSize(t, e) {}
        initialize(t, e, n) {}
        dispose() {
            for (const e of Object.keys(this)) {
                const n = this[e];
                (n instanceof nn || n instanceof en || n instanceof wt || n instanceof t) && this[e].dispose()
            }
            null !== this.fullscreenMaterial && this.fullscreenMaterial.dispose()
        }
    },
    P_ = class extends Vn {
        constructor() {
            super("ClearMaskPass", null, null), this.needsSwap = !1
        }
        render(t, e, n, i, s) {
            const r = t.state.buffers.stencil;
            r.setLocked(!1), r.setTest(!1)
        }
    },
    R_ = "#include <common>\n#include <dithering_pars_fragment>\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;\n#include <colorspace_fragment>\n#include <dithering_fragment>\n}",
    Mo = "varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}",
    Yp = class extends It {
        constructor() {
            super({
                name: "CopyMaterial",
                uniforms: {
                    inputBuffer: new Ce(null),
                    opacity: new Ce(1)
                },
                blending: 0,
                toneMapped: !1,
                depthWrite: !1,
                depthTest: !1,
                fragmentShader: R_,
                vertexShader: Mo
            })
        }
        set inputBuffer(t) {
            this.uniforms.inputBuffer.value = t
        }
        setInputBuffer(t) {
            this.uniforms.inputBuffer.value = t
        }
        getOpacity(t) {
            return this.uniforms.opacity.value
        }
        setOpacity(t) {
            this.uniforms.opacity.value = t
        }
    },
    D_ = class extends Vn {
        constructor(t, e = !0) {
            super("CopyPass"), this.fullscreenMaterial = new Yp, this.needsSwap = !1, this.renderTarget = t, void 0 === t && (this.renderTarget = new nn(1, 1, {
                minFilter: Ht,
                magFilter: Ht,
                stencilBuffer: !1,
                depthBuffer: !1
            }), this.renderTarget.texture.name = "CopyPass.Target"), this.autoResize = e
        }
        get resize() {
            return this.autoResize
        }
        set resize(t) {
            this.autoResize = t
        }
        get texture() {
            return this.renderTarget.texture
        }
        getTexture() {
            return this.renderTarget.texture
        }
        setAutoResizeEnabled(t) {
            this.autoResize = t
        }
        render(t, e, n, i, s) {
            this.fullscreenMaterial.inputBuffer = e.texture, t.setRenderTarget(this.renderToScreen ? null : this.renderTarget), t.render(this.scene, this.camera)
        }
        setSize(t, e) {
            this.autoResize && this.renderTarget.setSize(t, e)
        }
        initialize(t, e, n) {
            void 0 !== n && (this.renderTarget.texture.type = n, n !== Qt ? this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1" : null !== t && t.outputColorSpace === rt && (this.renderTarget.texture.colorSpace = rt))
        }
    },
    pf = new Le,
    Ch = class extends Vn {
        constructor(t = !0, e = !0, n = !1) {
            super("ClearPass", null, null), this.needsSwap = !1, this.color = t, this.depth = e, this.stencil = n, this.overrideClearColor = null, this.overrideClearAlpha = -1
        }
        setClearFlags(t, e, n) {
            this.color = t, this.depth = e, this.stencil = n
        }
        getOverrideClearColor() {
            return this.overrideClearColor
        }
        setOverrideClearColor(t) {
            this.overrideClearColor = t
        }
        getOverrideClearAlpha() {
            return this.overrideClearAlpha
        }
        setOverrideClearAlpha(t) {
            this.overrideClearAlpha = t
        }
        render(t, e, n, i, s) {
            const r = this.overrideClearColor,
                o = this.overrideClearAlpha,
                a = t.getClearAlpha(),
                l = null !== r,
                c = o >= 0;
            l ? (t.getClearColor(pf), t.setClearColor(r, c ? o : a)) : c && t.setClearAlpha(o), t.setRenderTarget(this.renderToScreen ? null : e), t.clear(this.color, this.depth, this.stencil), l ? t.setClearColor(pf, a) : c && t.setClearAlpha(a)
        }
    },
    I_ = class extends Vn {
        constructor(t, e) {
            super("MaskPass", t, e), this.needsSwap = !1, this.clearPass = new Ch(!1, !1, !0), this.inverse = !1
        }
        set mainScene(t) {
            this.scene = t
        }
        set mainCamera(t) {
            this.camera = t
        }
        get inverted() {
            return this.inverse
        }
        set inverted(t) {
            this.inverse = t
        }
        get clear() {
            return this.clearPass.enabled
        }
        set clear(t) {
            this.clearPass.enabled = t
        }
        getClearPass() {
            return this.clearPass
        }
        isInverted() {
            return this.inverted
        }
        setInverted(t) {
            this.inverted = t
        }
        render(t, e, n, i, s) {
            const r = t.getContext(),
                o = t.state.buffers,
                a = this.scene,
                l = this.camera,
                c = this.clearPass,
                h = this.inverted ? 0 : 1,
                u = 1 - h;
            o.color.setMask(!1), o.depth.setMask(!1), o.color.setLocked(!0), o.depth.setLocked(!0), o.stencil.setTest(!0), o.stencil.setOp(r.REPLACE, r.REPLACE, r.REPLACE), o.stencil.setFunc(r.ALWAYS, h, 4294967295), o.stencil.setClear(u), o.stencil.setLocked(!0), this.clearPass.enabled && (this.renderToScreen ? c.render(t, null) : (c.render(t, e), c.render(t, n))), this.renderToScreen ? (t.setRenderTarget(null), t.render(a, l)) : (t.setRenderTarget(e), t.render(a, l), t.setRenderTarget(n), t.render(a, l)), o.color.setLocked(!1), o.depth.setLocked(!1), o.stencil.setLocked(!1), o.stencil.setFunc(r.EQUAL, 1, 4294967295), o.stencil.setOp(r.KEEP, r.KEEP, r.KEEP), o.stencil.setLocked(!0)
        }
    },
    L_ = class {
        constructor(t = null, {
            depthBuffer: e = !0,
            stencilBuffer: n = !1,
            multisampling: i = 0,
            frameBufferType: s
        } = {}) {
            this.renderer = null, this.inputBuffer = this.createBuffer(e, n, s, i), this.outputBuffer = this.inputBuffer.clone(), this.copyPass = new D_, this.depthTexture = null, this.passes = [], this.timer = new T_, this.autoRenderToScreen = !0, this.setRenderer(t)
        }
        get multisampling() {
            return this.inputBuffer.samples || 0
        }
        set multisampling(t) {
            const e = this.inputBuffer,
                n = this.multisampling;
            n > 0 && t > 0 ? (this.inputBuffer.samples = t, this.outputBuffer.samples = t, this.inputBuffer.dispose(), this.outputBuffer.dispose()) : n !== t && (this.inputBuffer.dispose(), this.outputBuffer.dispose(), this.inputBuffer = this.createBuffer(e.depthBuffer, e.stencilBuffer, e.texture.type, t), this.inputBuffer.depthTexture = this.depthTexture, this.outputBuffer = this.inputBuffer.clone())
        }
        getTimer() {
            return this.timer
        }
        getRenderer() {
            return this.renderer
        }
        setRenderer(t) {
            if (this.renderer = t, null !== t) {
                const e = t.getSize(new Q),
                    n = t.getContext().getContextAttributes().alpha,
                    i = this.inputBuffer.texture.type;
                i === Qt && t.outputColorSpace === rt && (this.inputBuffer.texture.colorSpace = rt, this.outputBuffer.texture.colorSpace = rt, this.inputBuffer.dispose(), this.outputBuffer.dispose()), t.autoClear = !1, this.setSize(e.width, e.height);
                for (const e of this.passes) e.initialize(t, n, i)
            }
        }
        replaceRenderer(t, e = !0) {
            const n = this.renderer,
                i = n.domElement.parentNode;
            return this.setRenderer(t), e && null !== i && (i.removeChild(n.domElement), i.appendChild(t.domElement)), n
        }
        createDepthTexture() {
            const t = this.depthTexture = new ph;
            return this.inputBuffer.depthTexture = t, this.inputBuffer.dispose(), this.inputBuffer.stencilBuffer ? (t.format = Ps, t.type = Dr) : t.type = Cs, t
        }
        deleteDepthTexture() {
            if (null !== this.depthTexture) {
                this.depthTexture.dispose(), this.depthTexture = null, this.inputBuffer.depthTexture = null, this.inputBuffer.dispose();
                for (const t of this.passes) t.setDepthTexture(null)
            }
        }
        createBuffer(t, e, n, i) {
            const s = this.renderer,
                r = null === s ? new Q : s.getDrawingBufferSize(new Q),
                o = {
                    minFilter: Ht,
                    magFilter: Ht,
                    stencilBuffer: e,
                    depthBuffer: t,
                    type: n
                },
                a = new nn(r.width, r.height, o);
            return i > 0 && (a.ignoreDepthForMultisampleCopy = !1, a.samples = i), n === Qt && null !== s && s.outputColorSpace === rt && (a.texture.colorSpace = rt), a.texture.name = "EffectComposer.Buffer", a.texture.generateMipmaps = !1, a
        }
        setMainScene(t) {
            for (const e of this.passes) e.mainScene = t
        }
        setMainCamera(t) {
            for (const e of this.passes) e.mainCamera = t
        }
        addPass(t, e) {
            const n = this.passes,
                i = this.renderer,
                s = i.getDrawingBufferSize(new Q),
                r = i.getContext().getContextAttributes().alpha,
                o = this.inputBuffer.texture.type;
            if (t.setRenderer(i), t.setSize(s.width, s.height), t.initialize(i, r, o), this.autoRenderToScreen && (n.length > 0 && (n[n.length - 1].renderToScreen = !1), t.renderToScreen && (this.autoRenderToScreen = !1)), void 0 !== e ? n.splice(e, 0, t) : n.push(t), this.autoRenderToScreen && (n[n.length - 1].renderToScreen = !0), t.needsDepthTexture || null !== this.depthTexture)
                if (null === this.depthTexture) {
                    const e = this.createDepthTexture();
                    for (t of n) t.setDepthTexture(e)
                } else t.setDepthTexture(this.depthTexture)
        }
        removePass(t) {
            const e = this.passes,
                n = e.indexOf(t);
            if (-1 !== n && e.splice(n, 1).length > 0) {
                if (null !== this.depthTexture) {
                    const n = (t, e) => t || e.needsDepthTexture;
                    e.reduce(n, !1) || (t.getDepthTexture() === this.depthTexture && t.setDepthTexture(null), this.deleteDepthTexture())
                }
                this.autoRenderToScreen && n === e.length && (t.renderToScreen = !1, e.length > 0 && (e[e.length - 1].renderToScreen = !0))
            }
        }
        removeAllPasses() {
            const t = this.passes;
            this.deleteDepthTexture(), t.length > 0 && (this.autoRenderToScreen && (t[t.length - 1].renderToScreen = !1), this.passes = [])
        }
        render(t) {
            const e = this.renderer,
                n = this.copyPass;
            let i, s, r, o = this.inputBuffer,
                a = this.outputBuffer,
                l = !1;
            void 0 === t && (this.timer.update(), t = this.timer.getDelta());
            for (const c of this.passes) c.enabled && (c.render(e, o, a, t, l), c.needsSwap && (l && (n.renderToScreen = c.renderToScreen, i = e.getContext(), s = e.state.buffers.stencil, s.setFunc(i.NOTEQUAL, 1, 4294967295), n.render(e, o, a, t, l), s.setFunc(i.EQUAL, 1, 4294967295)), r = o, o = a, a = r), c instanceof I_ ? l = !0 : c instanceof P_ && (l = !1))
        }
        setSize(t, e, n) {
            const i = this.renderer,
                s = i.getSize(new Q);
            (void 0 === t || void 0 === e) && (t = s.width, e = s.height), (s.width !== t || s.height !== e) && i.setSize(t, e, n);
            const r = i.getDrawingBufferSize(new Q);
            this.inputBuffer.setSize(r.width, r.height), this.outputBuffer.setSize(r.width, r.height);
            for (const t of this.passes) t.setSize(r.width, r.height)
        }
        reset() {
            this.dispose(), this.autoRenderToScreen = !0
        }
        dispose() {
            for (const t of this.passes) t.dispose();
            this.passes = [], null !== this.inputBuffer && this.inputBuffer.dispose(), null !== this.outputBuffer && this.outputBuffer.dispose(), this.deleteDepthTexture(), this.copyPass.dispose(), this.timer.dispose(), Vn.fullscreenGeometry.dispose()
        }
    },
    qn = {
        NONE: 0,
        DEPTH: 1,
        CONVOLUTION: 2
    },
    dt = {
        FRAGMENT_HEAD: "FRAGMENT_HEAD",
        FRAGMENT_MAIN_UV: "FRAGMENT_MAIN_UV",
        FRAGMENT_MAIN_IMAGE: "FRAGMENT_MAIN_IMAGE",
        VERTEX_HEAD: "VERTEX_HEAD",
        VERTEX_MAIN_SUPPORT: "VERTEX_MAIN_SUPPORT"
    },
    O_ = class {
        constructor() {
            this.shaderParts = new Map([
                [dt.FRAGMENT_HEAD, null],
                [dt.FRAGMENT_MAIN_UV, null],
                [dt.FRAGMENT_MAIN_IMAGE, null],
                [dt.VERTEX_HEAD, null],
                [dt.VERTEX_MAIN_SUPPORT, null]
            ]), this.defines = new Map, this.uniforms = new Map, this.blendModes = new Map, this.extensions = new Set, this.attributes = qn.NONE, this.varyings = new Set, this.uvTransformation = !1, this.readDepth = !1, this.colorSpace = Zn
        }
    },
    cc = !1,
    mf = class {
        constructor(t = null) {
            this.originalMaterials = new Map, this.material = null, this.materials = null, this.materialsBackSide = null, this.materialsDoubleSide = null, this.materialsFlatShaded = null, this.materialsFlatShadedBackSide = null, this.materialsFlatShadedDoubleSide = null, this.setMaterial(t), this.meshCount = 0, this.replaceMaterial = t => {
                if (t.isMesh) {
                    let e;
                    if (t.material.flatShading) switch (t.material.side) {
                        case 2:
                            e = this.materialsFlatShadedDoubleSide;
                            break;
                        case Bt:
                            e = this.materialsFlatShadedBackSide;
                            break;
                        default:
                            e = this.materialsFlatShaded
                    } else switch (t.material.side) {
                        case 2:
                            e = this.materialsDoubleSide;
                            break;
                        case Bt:
                            e = this.materialsBackSide;
                            break;
                        default:
                            e = this.materials
                    }
                    this.originalMaterials.set(t, t.material), t.isSkinnedMesh ? t.material = e[2] : t.isInstancedMesh ? t.material = e[1] : t.material = e[0], ++this.meshCount
                }
            }
        }
        cloneMaterial(t) {
            if (!(t instanceof It)) return t.clone();
            const e = t.uniforms,
                n = new Map;
            for (const t in e) {
                const i = e[t].value;
                i.isRenderTargetTexture && (e[t].value = null, n.set(t, i))
            }
            const i = t.clone();
            for (const t of n) e[t[0]].value = t[1], i.uniforms[t[0]].value = t[1];
            return i
        }
        setMaterial(t) {
            if (this.disposeMaterials(), this.material = t, null !== t) {
                const e = this.materials = [this.cloneMaterial(t), this.cloneMaterial(t), this.cloneMaterial(t)];
                for (const n of e) n.uniforms = Object.assign({}, t.uniforms), n.side = li;
                e[2].skinning = !0, this.materialsBackSide = e.map((e => {
                    const n = this.cloneMaterial(e);
                    return n.uniforms = Object.assign({}, t.uniforms), n.side = Bt, n
                })), this.materialsDoubleSide = e.map((e => {
                    const n = this.cloneMaterial(e);
                    return n.uniforms = Object.assign({}, t.uniforms), n.side = 2, n
                })), this.materialsFlatShaded = e.map((e => {
                    const n = this.cloneMaterial(e);
                    return n.uniforms = Object.assign({}, t.uniforms), n.flatShading = !0, n
                })), this.materialsFlatShadedBackSide = e.map((e => {
                    const n = this.cloneMaterial(e);
                    return n.uniforms = Object.assign({}, t.uniforms), n.flatShading = !0, n.side = Bt, n
                })), this.materialsFlatShadedDoubleSide = e.map((e => {
                    const n = this.cloneMaterial(e);
                    return n.uniforms = Object.assign({}, t.uniforms), n.flatShading = !0, n.side = 2, n
                }))
            }
        }
        render(t, e, n) {
            const i = t.shadowMap.enabled;
            if (t.shadowMap.enabled = !1, cc) {
                const i = this.originalMaterials;
                this.meshCount = 0, e.traverse(this.replaceMaterial), t.render(e, n);
                for (const t of i) t[0].material = t[1];
                this.meshCount !== i.size && i.clear()
            } else {
                const i = e.overrideMaterial;
                e.overrideMaterial = this.material, t.render(e, n), e.overrideMaterial = i
            }
            t.shadowMap.enabled = i
        }
        disposeMaterials() {
            if (null !== this.material) {
                const t = this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide);
                for (const e of t) e.dispose()
            }
        }
        dispose() {
            this.originalMaterials.clear(), this.disposeMaterials()
        }
        static get workaroundEnabled() {
            return cc
        }
        static set workaroundEnabled(t) {
            cc = t
        }
    },
    Wi = -1,
    _n = class extends hi {
        constructor(t, e = Wi, n = Wi, i = 1) {
            super(), this.resizable = t, this.baseSize = new Q(1, 1), this.preferredSize = new Q(e, n), this.target = this.preferredSize, this.s = i, this.effectiveSize = new Q, this.addEventListener("change", (() => this.updateEffectiveSize())), this.updateEffectiveSize()
        }
        updateEffectiveSize() {
            const t = this.baseSize,
                e = this.preferredSize,
                n = this.effectiveSize,
                i = this.scale;
            e.width !== Wi ? n.width = e.width : e.height !== Wi ? n.width = Math.round(e.height * (t.width / Math.max(t.height, 1))) : n.width = Math.round(t.width * i), e.height !== Wi ? n.height = e.height : e.width !== Wi ? n.height = Math.round(e.width / Math.max(t.width / Math.max(t.height, 1), 1)) : n.height = Math.round(t.height * i)
        }
        get width() {
            return this.effectiveSize.width
        }
        set width(t) {
            this.preferredWidth = t
        }
        get height() {
            return this.effectiveSize.height
        }
        set height(t) {
            this.preferredHeight = t
        }
        getWidth() {
            return this.width
        }
        getHeight() {
            return this.height
        }
        get scale() {
            return this.s
        }
        set scale(t) {
            this.s !== t && (this.s = t, this.preferredSize.setScalar(Wi), this.dispatchEvent({
                type: "change"
            }), this.resizable.setSize(this.baseSize.width, this.baseSize.height))
        }
        getScale() {
            return this.scale
        }
        setScale(t) {
            this.scale = t
        }
        get baseWidth() {
            return this.baseSize.width
        }
        set baseWidth(t) {
            this.baseSize.width !== t && (this.baseSize.width = t, this.dispatchEvent({
                type: "change"
            }), this.resizable.setSize(this.baseSize.width, this.baseSize.height))
        }
        getBaseWidth() {
            return this.baseWidth
        }
        setBaseWidth(t) {
            this.baseWidth = t
        }
        get baseHeight() {
            return this.baseSize.height
        }
        set baseHeight(t) {
            this.baseSize.height !== t && (this.baseSize.height = t, this.dispatchEvent({
                type: "change"
            }), this.resizable.setSize(this.baseSize.width, this.baseSize.height))
        }
        getBaseHeight() {
            return this.baseHeight
        }
        setBaseHeight(t) {
            this.baseHeight = t
        }
        setBaseSize(t, e) {
            (this.baseSize.width !== t || this.baseSize.height !== e) && (this.baseSize.set(t, e), this.dispatchEvent({
                type: "change"
            }), this.resizable.setSize(this.baseSize.width, this.baseSize.height))
        }
        get preferredWidth() {
            return this.preferredSize.width
        }
        set preferredWidth(t) {
            this.preferredSize.width !== t && (this.preferredSize.width = t, this.dispatchEvent({
                type: "change"
            }), this.resizable.setSize(this.baseSize.width, this.baseSize.height))
        }
        getPreferredWidth() {
            return this.preferredWidth
        }
        setPreferredWidth(t) {
            this.preferredWidth = t
        }
        get preferredHeight() {
            return this.preferredSize.height
        }
        set preferredHeight(t) {
            this.preferredSize.height !== t && (this.preferredSize.height = t, this.dispatchEvent({
                type: "change"
            }), this.resizable.setSize(this.baseSize.width, this.baseSize.height))
        }
        getPreferredHeight() {
            return this.preferredHeight
        }
        setPreferredHeight(t) {
            this.preferredHeight = t
        }
        setPreferredSize(t, e) {
            (this.preferredSize.width !== t || this.preferredSize.height !== e) && (this.preferredSize.set(t, e), this.dispatchEvent({
                type: "change"
            }), this.resizable.setSize(this.baseSize.width, this.baseSize.height))
        }
        copy(t) {
            this.s = t.scale, this.baseSize.set(t.baseWidth, t.baseHeight), this.preferredSize.set(t.preferredWidth, t.preferredHeight), this.dispatchEvent({
                type: "change"
            }), this.resizable.setSize(this.baseSize.width, this.baseSize.height)
        }
        static get AUTO_SIZE() {
            return Wi
        }
    },
    Ae = {
        SKIP: 9,
        SET: 30,
        ADD: 0,
        ALPHA: 1,
        AVERAGE: 2,
        COLOR: 3,
        COLOR_BURN: 4,
        COLOR_DODGE: 5,
        DARKEN: 6,
        DIFFERENCE: 7,
        DIVIDE: 8,
        DST: 9,
        EXCLUSION: 10,
        HARD_LIGHT: 11,
        HARD_MIX: 12,
        HUE: 13,
        INVERT: 14,
        INVERT_RGB: 15,
        LIGHTEN: 16,
        LINEAR_BURN: 17,
        LINEAR_DODGE: 18,
        LINEAR_LIGHT: 19,
        LUMINOSITY: 20,
        MULTIPLY: 21,
        NEGATION: 22,
        NORMAL: 23,
        OVERLAY: 24,
        PIN_LIGHT: 25,
        REFLECT: 26,
        SATURATION: 27,
        SCREEN: 28,
        SOFT_LIGHT: 29,
        SRC: 30,
        SUBTRACT: 31,
        VIVID_LIGHT: 32
    },
    B_ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y,opacity);}",
    U_ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,min(y.a,opacity));}",
    N_ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y)*0.5,opacity);}",
    F_ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.rg,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}",
    k_ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(step(0.0,y)*(1.0-min(vec4(1.0),(1.0-x)/y)),vec4(1.0),step(1.0,x));return mix(x,z,opacity);}",
    z_ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=step(0.0,x)*mix(min(vec4(1.0),x/max(1.0-y,1e-9)),vec4(1.0),step(1.0,y));return mix(x,z,opacity);}",
    G_ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x,y),opacity);}",
    H_ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,abs(x-y),opacity);}",
    V_ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x/max(y,1e-12),opacity);}",
    W_ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y-2.0*x*y),opacity);}",
    X_ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 a=min(x,1.0),b=min(y,1.0);vec4 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,y));return mix(x,z,opacity);}",
    j_ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,step(1.0,x+y),opacity);}",
    K_ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.r,xHSL.gb));return vec4(mix(x.rgb,z,opacity),y.a);}",
    Y_ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-y,opacity);}",
    Q_ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y*(1.0-x),opacity);}",
    q_ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x,y),opacity);}",
    Z_ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(y+x-1.0,0.0,1.0),opacity);}",
    J_ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x+y,1.0),opacity);}",
    $_ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(2.0*y+x-1.0,0.0,1.0),opacity);}",
    ew = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.rg,yHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}",
    tw = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x*y,opacity);}",
    nw = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-abs(1.0-x-y),opacity);}",
    iw = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}",
    sw = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(2.0*y*x,1.0-2.0*(1.0-y)*(1.0-x),step(0.5,x));return mix(x,z,opacity);}",
    rw = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 z=mix(mix(y2,x,step(0.5*x,y)),max(vec4(0.0),y2-1.0),step(x,(y2-1.0)));return mix(x,z,opacity);}",
    ow = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(min(x*x/max(1.0-y,1e-12),1.0),y,step(1.0,y));return mix(x,z,opacity);}",
    aw = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.r,yHSL.g,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}",
    lw = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y-min(x*y,1.0),opacity);}",
    cw = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 w=step(0.5,y);vec4 z=mix(x-(1.0-y2)*x*(1.0-x),mix(x+(y2-1.0)*(sqrt(x)-x),x+(y2-1.0)*x*((16.0*x-12.0)*x+3.0),w*(1.0-step(0.25,x))),w);return mix(x,z,opacity);}",
    hw = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}",
    uw = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x+y-1.0,0.0),opacity);}",
    dw = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(max(1.0-min((1.0-x)/(2.0*y),1.0),0.0),min(x/(2.0*(1.0-y)),1.0),step(0.5,y));return mix(x,z,opacity);}",
    fw = new Map([
        [Ae.ADD, B_],
        [Ae.ALPHA, U_],
        [Ae.AVERAGE, N_],
        [Ae.COLOR, F_],
        [Ae.COLOR_BURN, k_],
        [Ae.COLOR_DODGE, z_],
        [Ae.DARKEN, G_],
        [Ae.DIFFERENCE, H_],
        [Ae.DIVIDE, V_],
        [Ae.DST, null],
        [Ae.EXCLUSION, W_],
        [Ae.HARD_LIGHT, X_],
        [Ae.HARD_MIX, j_],
        [Ae.HUE, K_],
        [Ae.INVERT, Y_],
        [Ae.INVERT_RGB, Q_],
        [Ae.LIGHTEN, q_],
        [Ae.LINEAR_BURN, Z_],
        [Ae.LINEAR_DODGE, J_],
        [Ae.LINEAR_LIGHT, $_],
        [Ae.LUMINOSITY, ew],
        [Ae.MULTIPLY, tw],
        [Ae.NEGATION, nw],
        [Ae.NORMAL, iw],
        [Ae.OVERLAY, sw],
        [Ae.PIN_LIGHT, rw],
        [Ae.REFLECT, ow],
        [Ae.SATURATION, aw],
        [Ae.SCREEN, lw],
        [Ae.SOFT_LIGHT, cw],
        [Ae.SRC, hw],
        [Ae.SUBTRACT, uw],
        [Ae.VIVID_LIGHT, dw]
    ]),
    pw = class extends hi {
        constructor(t, e = 1) {
            super(), this._blendFunction = t, this.opacity = new Ce(e)
        }
        getOpacity() {
            return this.opacity.value
        }
        setOpacity(t) {
            this.opacity.value = t
        }
        get blendFunction() {
            return this._blendFunction
        }
        set blendFunction(t) {
            this._blendFunction = t, this.dispatchEvent({
                type: "change"
            })
        }
        getBlendFunction() {
            return this.blendFunction
        }
        setBlendFunction(t) {
            this.blendFunction = t
        }
        getShaderCode() {
            return fw.get(this.blendFunction)
        }
    },
    hn = {
        VERY_SMALL: 0,
        SMALL: 1,
        MEDIUM: 2,
        LARGE: 3,
        VERY_LARGE: 4,
        HUGE: 5
    },
    mw = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nvarying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;\n#include <colorspace_fragment>\n}",
    gw = "uniform vec4 texelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}",
    vw = [new Float32Array([0, 0]), new Float32Array([0, 1, 1]), new Float32Array([0, 1, 1, 2]), new Float32Array([0, 1, 2, 2, 3]), new Float32Array([0, 1, 2, 3, 4, 4, 5]), new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10])],
    yw = class extends It {
        constructor(t = new ot) {
            super({
                name: "KawaseBlurMaterial",
                uniforms: {
                    inputBuffer: new Ce(null),
                    texelSize: new Ce(new ot),
                    scale: new Ce(1),
                    kernel: new Ce(0)
                },
                blending: 0,
                toneMapped: !1,
                depthWrite: !1,
                depthTest: !1,
                fragmentShader: mw,
                vertexShader: gw
            }), this.setTexelSize(t.x, t.y), this.kernelSize = hn.MEDIUM
        }
        set inputBuffer(t) {
            this.uniforms.inputBuffer.value = t
        }
        setInputBuffer(t) {
            this.inputBuffer = t
        }
        get kernelSequence() {
            return vw[this.kernelSize]
        }
        get scale() {
            return this.uniforms.scale.value
        }
        set scale(t) {
            this.uniforms.scale.value = t
        }
        getScale() {
            return this.uniforms.scale.value
        }
        setScale(t) {
            this.uniforms.scale.value = t
        }
        getKernel() {
            return null
        }
        get kernel() {
            return this.uniforms.kernel.value
        }
        set kernel(t) {
            this.uniforms.kernel.value = t
        }
        setKernel(t) {
            this.kernel = t
        }
        setTexelSize(t, e) {
            this.uniforms.texelSize.value.set(t, e, .5 * t, .5 * e)
        }
        setSize(t, e) {
            const n = 1 / t,
                i = 1 / e;
            this.uniforms.texelSize.value.set(n, i, .5 * n, .5 * i)
        }
    },
    Ph = class extends Vn {
        constructor({
            kernelSize: t = hn.MEDIUM,
            resolutionScale: e = .5,
            width: n = _n.AUTO_SIZE,
            height: i = _n.AUTO_SIZE,
            resolutionX: s = n,
            resolutionY: r = i
        } = {}) {
            super("KawaseBlurPass"), this.renderTargetA = new nn(1, 1, {
                depthBuffer: !1
            }), this.renderTargetA.texture.name = "Blur.Target.A", this.renderTargetB = this.renderTargetA.clone(), this.renderTargetB.texture.name = "Blur.Target.B";
            const o = this.resolution = new _n(this, s, r, e);
            o.addEventListener("change", (t => this.setSize(o.baseWidth, o.baseHeight))), this._blurMaterial = new yw, this._blurMaterial.kernelSize = t, this.copyMaterial = new Yp
        }
        getResolution() {
            return this.resolution
        }
        get blurMaterial() {
            return this._blurMaterial
        }
        set blurMaterial(t) {
            this._blurMaterial = t
        }
        get dithering() {
            return this.copyMaterial.dithering
        }
        set dithering(t) {
            this.copyMaterial.dithering = t
        }
        get kernelSize() {
            return this.blurMaterial.kernelSize
        }
        set kernelSize(t) {
            this.blurMaterial.kernelSize = t
        }
        get width() {
            return this.resolution.width
        }
        set width(t) {
            this.resolution.preferredWidth = t
        }
        get height() {
            return this.resolution.height
        }
        set height(t) {
            this.resolution.preferredHeight = t
        }
        get scale() {
            return this.blurMaterial.scale
        }
        set scale(t) {
            this.blurMaterial.scale = t
        }
        getScale() {
            return this.blurMaterial.scale
        }
        setScale(t) {
            this.blurMaterial.scale = t
        }
        getKernelSize() {
            return this.kernelSize
        }
        setKernelSize(t) {
            this.kernelSize = t
        }
        getResolutionScale() {
            return this.resolution.scale
        }
        setResolutionScale(t) {
            this.resolution.scale = t
        }
        render(t, e, n, i, s) {
            const r = this.scene,
                o = this.camera,
                a = this.renderTargetA,
                l = this.renderTargetB,
                c = this.blurMaterial,
                h = c.kernelSequence;
            let u = e;
            this.fullscreenMaterial = c;
            for (let e = 0, n = h.length; e < n; ++e) {
                const n = 1 & e ? l : a;
                c.kernel = h[e], c.inputBuffer = u.texture, t.setRenderTarget(n), t.render(r, o), u = n
            }
            this.fullscreenMaterial = this.copyMaterial, this.copyMaterial.inputBuffer = u.texture, t.setRenderTarget(this.renderToScreen ? null : n), t.render(r, o)
        }
        setSize(t, e) {
            const n = this.resolution;
            n.setBaseSize(t, e);
            const i = n.width,
                s = n.height;
            this.renderTargetA.setSize(i, s), this.renderTargetB.setSize(i, s), this.blurMaterial.setSize(t, e)
        }
        initialize(t, e, n) {
            void 0 !== n && (this.renderTargetA.texture.type = n, this.renderTargetB.texture.type = n, n !== Qt ? (this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1", this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1") : null !== t && t.outputColorSpace === rt && (this.renderTargetA.texture.colorSpace = rt, this.renderTargetB.texture.colorSpace = rt))
        }
        static get AUTO_SIZE() {
            return _n.AUTO_SIZE
        }
    },
    xw = "#include <common>\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#ifdef RANGE\nuniform vec2 range;\n#elif defined(THRESHOLD)\nuniform float threshold;uniform float smoothing;\n#endif\nvarying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=luminance(texel.rgb);\n#ifdef RANGE\nfloat low=step(range.x,l);float high=step(l,range.y);l*=low*high;\n#elif defined(THRESHOLD)\nl=smoothstep(threshold,threshold+smoothing,l)*l;\n#endif\n#ifdef COLOR\ngl_FragColor=vec4(texel.rgb*clamp(l,0.0,1.0),l);\n#else\ngl_FragColor=vec4(l);\n#endif\n}",
    bw = class extends It {
        constructor(t = !1, e = null) {
            super({
                name: "LuminanceMaterial",
                defines: {
                    THREE_REVISION: ns.replace(/\D+/g, "")
                },
                uniforms: {
                    inputBuffer: new Ce(null),
                    threshold: new Ce(0),
                    smoothing: new Ce(1),
                    range: new Ce(null)
                },
                blending: 0,
                toneMapped: !1,
                depthWrite: !1,
                depthTest: !1,
                fragmentShader: xw,
                vertexShader: Mo
            }), this.colorOutput = t, this.luminanceRange = e
        }
        set inputBuffer(t) {
            this.uniforms.inputBuffer.value = t
        }
        setInputBuffer(t) {
            this.uniforms.inputBuffer.value = t
        }
        get threshold() {
            return this.uniforms.threshold.value
        }
        set threshold(t) {
            this.smoothing > 0 || t > 0 ? this.defines.THRESHOLD = "1" : delete this.defines.THRESHOLD, this.uniforms.threshold.value = t
        }
        getThreshold() {
            return this.threshold
        }
        setThreshold(t) {
            this.threshold = t
        }
        get smoothing() {
            return this.uniforms.smoothing.value
        }
        set smoothing(t) {
            this.threshold > 0 || t > 0 ? this.defines.THRESHOLD = "1" : delete this.defines.THRESHOLD, this.uniforms.smoothing.value = t
        }
        getSmoothingFactor() {
            return this.smoothing
        }
        setSmoothingFactor(t) {
            this.smoothing = t
        }
        get useThreshold() {
            return this.threshold > 0 || this.smoothing > 0
        }
        set useThreshold(t) {}
        get colorOutput() {
            return void 0 !== this.defines.COLOR
        }
        set colorOutput(t) {
            t ? this.defines.COLOR = "1" : delete this.defines.COLOR, this.needsUpdate = !0
        }
        isColorOutputEnabled(t) {
            return this.colorOutput
        }
        setColorOutputEnabled(t) {
            this.colorOutput = t
        }
        get useRange() {
            return null !== this.luminanceRange
        }
        set useRange(t) {
            this.luminanceRange = null
        }
        get luminanceRange() {
            return this.uniforms.range.value
        }
        set luminanceRange(t) {
            null !== t ? this.defines.RANGE = "1" : delete this.defines.RANGE, this.uniforms.range.value = t, this.needsUpdate = !0
        }
        getLuminanceRange() {
            return this.luminanceRange
        }
        setLuminanceRange(t) {
            this.luminanceRange = t
        }
    },
    Aw = class extends Vn {
        constructor({
            renderTarget: t,
            luminanceRange: e,
            colorOutput: n,
            resolutionScale: i = 1,
            width: s = _n.AUTO_SIZE,
            height: r = _n.AUTO_SIZE,
            resolutionX: o = s,
            resolutionY: a = r
        } = {}) {
            super("LuminancePass"), this.fullscreenMaterial = new bw(n, e), this.needsSwap = !1, this.renderTarget = t, void 0 === this.renderTarget && (this.renderTarget = new nn(1, 1, {
                depthBuffer: !1
            }), this.renderTarget.texture.name = "LuminancePass.Target");
            const l = this.resolution = new _n(this, o, a, i);
            l.addEventListener("change", (t => this.setSize(l.baseWidth, l.baseHeight)))
        }
        get texture() {
            return this.renderTarget.texture
        }
        getTexture() {
            return this.renderTarget.texture
        }
        getResolution() {
            return this.resolution
        }
        render(t, e, n, i, s) {
            this.fullscreenMaterial.inputBuffer = e.texture, t.setRenderTarget(this.renderToScreen ? null : this.renderTarget), t.render(this.scene, this.camera)
        }
        setSize(t, e) {
            const n = this.resolution;
            n.setBaseSize(t, e), this.renderTarget.setSize(n.width, n.height)
        }
        initialize(t, e, n) {
            void 0 !== n && n !== Qt && (this.renderTarget.texture.type = n, this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1")
        }
    },
    Sw = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#define WEIGHT_INNER 0.125\n#define WEIGHT_OUTER 0.0555555\nvarying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;float clampToBorder(const in vec2 uv){return float(uv.s>=0.0&&uv.s<=1.0&&uv.t>=0.0&&uv.t<=1.0);}void main(){vec4 c=vec4(0.0);vec4 w=WEIGHT_INNER*vec4(clampToBorder(vUv00),clampToBorder(vUv01),clampToBorder(vUv02),clampToBorder(vUv03));c+=w.x*texture2D(inputBuffer,vUv00);c+=w.y*texture2D(inputBuffer,vUv01);c+=w.z*texture2D(inputBuffer,vUv02);c+=w.w*texture2D(inputBuffer,vUv03);w=WEIGHT_OUTER*vec4(clampToBorder(vUv04),clampToBorder(vUv05),clampToBorder(vUv06),clampToBorder(vUv07));c+=w.x*texture2D(inputBuffer,vUv04);c+=w.y*texture2D(inputBuffer,vUv05);c+=w.z*texture2D(inputBuffer,vUv06);c+=w.w*texture2D(inputBuffer,vUv07);w=WEIGHT_OUTER*vec4(clampToBorder(vUv08),clampToBorder(vUv09),clampToBorder(vUv10),clampToBorder(vUv11));c+=w.x*texture2D(inputBuffer,vUv08);c+=w.y*texture2D(inputBuffer,vUv09);c+=w.z*texture2D(inputBuffer,vUv10);c+=w.w*texture2D(inputBuffer,vUv11);c+=WEIGHT_OUTER*texture2D(inputBuffer,vUv);gl_FragColor=c;\n#include <colorspace_fragment>\n}",
    _w = "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;void main(){vUv=position.xy*0.5+0.5;vUv00=vUv+texelSize*vec2(-1.0,1.0);vUv01=vUv+texelSize*vec2(1.0,1.0);vUv02=vUv+texelSize*vec2(-1.0,-1.0);vUv03=vUv+texelSize*vec2(1.0,-1.0);vUv04=vUv+texelSize*vec2(-2.0,2.0);vUv05=vUv+texelSize*vec2(0.0,2.0);vUv06=vUv+texelSize*vec2(2.0,2.0);vUv07=vUv+texelSize*vec2(-2.0,0.0);vUv08=vUv+texelSize*vec2(2.0,0.0);vUv09=vUv+texelSize*vec2(-2.0,-2.0);vUv10=vUv+texelSize*vec2(0.0,-2.0);vUv11=vUv+texelSize*vec2(2.0,-2.0);gl_Position=vec4(position.xy,1.0,1.0);}",
    ww = class extends It {
        constructor() {
            super({
                name: "DownsamplingMaterial",
                uniforms: {
                    inputBuffer: new Ce(null),
                    texelSize: new Ce(new Q)
                },
                blending: 0,
                toneMapped: !1,
                depthWrite: !1,
                depthTest: !1,
                fragmentShader: Sw,
                vertexShader: _w
            })
        }
        set inputBuffer(t) {
            this.uniforms.inputBuffer.value = t
        }
        setSize(t, e) {
            this.uniforms.texelSize.value.set(1 / t, 1 / e)
        }
    },
    Mw = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;uniform mediump sampler2D supportBuffer;\n#else\nuniform lowp sampler2D inputBuffer;uniform lowp sampler2D supportBuffer;\n#endif\nuniform float radius;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vec4 c=vec4(0.0);c+=texture2D(inputBuffer,vUv0)*0.0625;c+=texture2D(inputBuffer,vUv1)*0.125;c+=texture2D(inputBuffer,vUv2)*0.0625;c+=texture2D(inputBuffer,vUv3)*0.125;c+=texture2D(inputBuffer,vUv)*0.25;c+=texture2D(inputBuffer,vUv4)*0.125;c+=texture2D(inputBuffer,vUv5)*0.0625;c+=texture2D(inputBuffer,vUv6)*0.125;c+=texture2D(inputBuffer,vUv7)*0.0625;vec4 baseColor=texture2D(supportBuffer,vUv);gl_FragColor=mix(baseColor,c,radius);\n#include <colorspace_fragment>\n}",
    Ew = "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,1.0);vUv1=vUv+texelSize*vec2(0.0,1.0);vUv2=vUv+texelSize*vec2(1.0,1.0);vUv3=vUv+texelSize*vec2(-1.0,0.0);vUv4=vUv+texelSize*vec2(1.0,0.0);vUv5=vUv+texelSize*vec2(-1.0,-1.0);vUv6=vUv+texelSize*vec2(0.0,-1.0);vUv7=vUv+texelSize*vec2(1.0,-1.0);gl_Position=vec4(position.xy,1.0,1.0);}",
    Tw = class extends It {
        constructor() {
            super({
                name: "UpsamplingMaterial",
                uniforms: {
                    inputBuffer: new Ce(null),
                    supportBuffer: new Ce(null),
                    texelSize: new Ce(new Q),
                    radius: new Ce(.85)
                },
                blending: 0,
                toneMapped: !1,
                depthWrite: !1,
                depthTest: !1,
                fragmentShader: Mw,
                vertexShader: Ew
            })
        }
        set inputBuffer(t) {
            this.uniforms.inputBuffer.value = t
        }
        set supportBuffer(t) {
            this.uniforms.supportBuffer.value = t
        }
        get radius() {
            return this.uniforms.radius.value
        }
        set radius(t) {
            this.uniforms.radius.value = t
        }
        setSize(t, e) {
            this.uniforms.texelSize.value.set(1 / t, 1 / e)
        }
    },
    Cw = class extends Vn {
        constructor() {
            super("MipmapBlurPass"), this.needsSwap = !1, this.renderTarget = new nn(1, 1, {
                depthBuffer: !1
            }), this.renderTarget.texture.name = "Upsampling.Mipmap0", this.downsamplingMipmaps = [], this.upsamplingMipmaps = [], this.downsamplingMaterial = new ww, this.upsamplingMaterial = new Tw, this.resolution = new Q
        }
        get texture() {
            return this.renderTarget.texture
        }
        get levels() {
            return this.downsamplingMipmaps.length
        }
        set levels(t) {
            if (this.levels !== t) {
                const e = this.renderTarget;
                this.dispose(), this.downsamplingMipmaps = [], this.upsamplingMipmaps = [];
                for (let n = 0; n < t; ++n) {
                    const t = e.clone();
                    t.texture.name = "Downsampling.Mipmap" + n, this.downsamplingMipmaps.push(t)
                }
                this.upsamplingMipmaps.push(e);
                for (let n = 1, i = t - 1; n < i; ++n) {
                    const t = e.clone();
                    t.texture.name = "Upsampling.Mipmap" + n, this.upsamplingMipmaps.push(t)
                }
                this.setSize(this.resolution.x, this.resolution.y)
            }
        }
        get radius() {
            return this.upsamplingMaterial.radius
        }
        set radius(t) {
            this.upsamplingMaterial.radius = t
        }
        render(t, e, n, i, s) {
            const {
                scene: r,
                camera: o
            } = this, {
                downsamplingMaterial: a,
                upsamplingMaterial: l
            } = this, {
                downsamplingMipmaps: c,
                upsamplingMipmaps: h
            } = this;
            let u = e;
            this.fullscreenMaterial = a;
            for (let e = 0, n = c.length; e < n; ++e) {
                const n = c[e];
                a.setSize(u.width, u.height), a.inputBuffer = u.texture, t.setRenderTarget(n), t.render(r, o), u = n
            }
            this.fullscreenMaterial = l;
            for (let e = h.length - 1; e >= 0; --e) {
                const n = h[e];
                l.setSize(u.width, u.height), l.inputBuffer = u.texture, l.supportBuffer = c[e].texture, t.setRenderTarget(n), t.render(r, o), u = n
            }
        }
        setSize(t, e) {
            const n = this.resolution;
            n.set(t, e);
            let i = n.width,
                s = n.height;
            for (let t = 0, e = this.downsamplingMipmaps.length; t < e; ++t) i = Math.round(.5 * i), s = Math.round(.5 * s), this.downsamplingMipmaps[t].setSize(i, s), t < this.upsamplingMipmaps.length && this.upsamplingMipmaps[t].setSize(i, s)
        }
        initialize(t, e, n) {
            if (void 0 !== n) {
                const e = this.downsamplingMipmaps.concat(this.upsamplingMipmaps);
                for (const t of e) t.texture.type = n;
                if (n !== Qt) this.downsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1", this.upsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
                else if (null !== t && t.outputColorSpace === rt)
                    for (const t of e) t.texture.colorSpace = rt
            }
        }
        dispose() {
            super.dispose();
            for (const t of this.downsamplingMipmaps.concat(this.upsamplingMipmaps)) t.dispose()
        }
    },
    Cn = class extends hi {
        constructor(t, e, {
            attributes: n = qn.NONE,
            blendFunction: i = Ae.NORMAL,
            defines: s = new Map,
            uniforms: r = new Map,
            extensions: o = null,
            vertexShader: a = null
        } = {}) {
            super(), this.name = t, this.renderer = null, this.attributes = n, this.fragmentShader = e, this.vertexShader = a, this.defines = s, this.uniforms = r, this.extensions = o, this.blendMode = new pw(i), this.blendMode.addEventListener("change", (t => this.setChanged())), this._inputColorSpace = Zn, this._outputColorSpace = ""
        }
        get inputColorSpace() {
            return this._inputColorSpace
        }
        set inputColorSpace(t) {
            this._inputColorSpace = t, this.setChanged()
        }
        get outputColorSpace() {
            return this._outputColorSpace
        }
        set outputColorSpace(t) {
            this._outputColorSpace = t, this.setChanged()
        }
        set mainScene(t) {}
        set mainCamera(t) {}
        getName() {
            return this.name
        }
        setRenderer(t) {
            this.renderer = t
        }
        getDefines() {
            return this.defines
        }
        getUniforms() {
            return this.uniforms
        }
        getExtensions() {
            return this.extensions
        }
        getBlendMode() {
            return this.blendMode
        }
        getAttributes() {
            return this.attributes
        }
        setAttributes(t) {
            this.attributes = t, this.setChanged()
        }
        getFragmentShader() {
            return this.fragmentShader
        }
        setFragmentShader(t) {
            this.fragmentShader = t, this.setChanged()
        }
        getVertexShader() {
            return this.vertexShader
        }
        setVertexShader(t) {
            this.vertexShader = t, this.setChanged()
        }
        setChanged() {
            this.dispatchEvent({
                type: "change"
            })
        }
        setDepthTexture(t, e = Oi) {}
        update(t, e, n) {}
        setSize(t, e) {}
        initialize(t, e, n) {}
        dispose() {
            for (const t of Object.keys(this)) {
                const e = this[t];
                (e instanceof nn || e instanceof en || e instanceof wt || e instanceof Vn) && this[t].dispose()
            }
        }
    },
    Pw = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D map;\n#else\nuniform lowp sampler2D map;\n#endif\nuniform float intensity;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 texel=texture2D(map,uv);outputColor=vec4(texel.rgb*intensity,texel.a);}",
    Rw = class extends Cn {
        constructor({
            blendFunction: t = Ae.SCREEN,
            luminanceThreshold: e = .9,
            luminanceSmoothing: n = .025,
            mipmapBlur: i = !1,
            intensity: s = 1,
            radius: r = .85,
            levels: o = 8,
            kernelSize: a = hn.LARGE,
            resolutionScale: l = .5,
            width: c = _n.AUTO_SIZE,
            height: h = _n.AUTO_SIZE,
            resolutionX: u = c,
            resolutionY: d = h
        } = {}) {
            super("BloomEffect", Pw, {
                blendFunction: t,
                uniforms: new Map([
                    ["map", new Ce(null)],
                    ["intensity", new Ce(s)]
                ])
            }), this.renderTarget = new nn(1, 1, {
                depthBuffer: !1
            }), this.renderTarget.texture.name = "Bloom.Target", this.blurPass = new Ph({
                kernelSize: a
            }), this.luminancePass = new Aw({
                colorOutput: !0
            }), this.luminanceMaterial.threshold = e, this.luminanceMaterial.smoothing = n, this.mipmapBlurPass = new Cw, this.mipmapBlurPass.enabled = i, this.mipmapBlurPass.radius = r, this.mipmapBlurPass.levels = o, this.uniforms.get("map").value = i ? this.mipmapBlurPass.texture : this.renderTarget.texture;
            const p = this.resolution = new _n(this, u, d, l);
            p.addEventListener("change", (t => this.setSize(p.baseWidth, p.baseHeight)))
        }
        get texture() {
            return this.mipmapBlurPass.enabled ? this.mipmapBlurPass.texture : this.renderTarget.texture
        }
        getTexture() {
            return this.texture
        }
        getResolution() {
            return this.resolution
        }
        getBlurPass() {
            return this.blurPass
        }
        getLuminancePass() {
            return this.luminancePass
        }
        get luminanceMaterial() {
            return this.luminancePass.fullscreenMaterial
        }
        getLuminanceMaterial() {
            return this.luminancePass.fullscreenMaterial
        }
        get width() {
            return this.resolution.width
        }
        set width(t) {
            this.resolution.preferredWidth = t
        }
        get height() {
            return this.resolution.height
        }
        set height(t) {
            this.resolution.preferredHeight = t
        }
        get dithering() {
            return this.blurPass.dithering
        }
        set dithering(t) {
            this.blurPass.dithering = t
        }
        get kernelSize() {
            return this.blurPass.kernelSize
        }
        set kernelSize(t) {
            this.blurPass.kernelSize = t
        }
        get distinction() {
            return console.warn(this.name, "distinction was removed"), 1
        }
        set distinction(t) {
            console.warn(this.name, "distinction was removed")
        }
        get intensity() {
            return this.uniforms.get("intensity").value
        }
        set intensity(t) {
            this.uniforms.get("intensity").value = t
        }
        getIntensity() {
            return this.intensity
        }
        setIntensity(t) {
            this.intensity = t
        }
        getResolutionScale() {
            return this.resolution.scale
        }
        setResolutionScale(t) {
            this.resolution.scale = t
        }
        update(t, e, n) {
            const i = this.renderTarget,
                s = this.luminancePass;
            s.enabled ? (s.render(t, e), this.mipmapBlurPass.enabled ? this.mipmapBlurPass.render(t, s.renderTarget) : this.blurPass.render(t, s.renderTarget, i)) : this.mipmapBlurPass.enabled ? this.mipmapBlurPass.render(t, e) : this.blurPass.render(t, e, i)
        }
        setSize(t, e) {
            const n = this.resolution;
            n.setBaseSize(t, e), this.renderTarget.setSize(n.width, n.height), this.blurPass.resolution.copy(n), this.luminancePass.setSize(t, e), this.mipmapBlurPass.setSize(t, e)
        }
        initialize(t, e, n) {
            this.blurPass.initialize(t, e, n), this.luminancePass.initialize(t, e, n), this.mipmapBlurPass.initialize(t, e, n), void 0 !== n && (this.renderTarget.texture.type = n, null !== t && t.outputColorSpace === rt && (this.renderTarget.texture.colorSpace = rt))
        }
    },
    Dw = "uniform float brightness;uniform float contrast;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=inputColor.rgb+vec3(brightness-0.5);if(contrast>0.0){color/=vec3(1.0-contrast);}else{color*=vec3(1.0+contrast);}outputColor=vec4(color+vec3(0.5),inputColor.a);}",
    Iw = class extends Cn {
        constructor({
            blendFunction: t = Ae.SRC,
            brightness: e = 0,
            contrast: n = 0
        } = {}) {
            super("BrightnessContrastEffect", Dw, {
                blendFunction: t,
                uniforms: new Map([
                    ["brightness", new Ce(e)],
                    ["contrast", new Ce(n)]
                ])
            }), this.inputColorSpace = rt
        }
        get brightness() {
            return this.uniforms.get("brightness").value
        }
        set brightness(t) {
            this.uniforms.get("brightness").value = t
        }
        getBrightness() {
            return this.brightness
        }
        setBrightness(t) {
            this.brightness = t
        }
        get contrast() {
            return this.uniforms.get("contrast").value
        }
        set contrast(t) {
            this.uniforms.get("contrast").value = t
        }
        getContrast() {
            return this.contrast
        }
        setContrast(t) {
            this.contrast = t
        }
    },
    Lw = "#ifdef RADIAL_MODULATION\nuniform float modulationOffset;\n#endif\nvarying float vActive;varying vec2 vUvR;varying vec2 vUvB;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec2 ra=inputColor.ra;vec2 ba=inputColor.ba;\n#ifdef RADIAL_MODULATION\nconst vec2 center=vec2(0.5);float d=distance(uv,center)*2.0;d=max(d-modulationOffset,0.0);if(vActive>0.0&&d>0.0){ra=texture2D(inputBuffer,mix(uv,vUvR,d)).ra;ba=texture2D(inputBuffer,mix(uv,vUvB,d)).ba;}\n#else\nif(vActive>0.0){ra=texture2D(inputBuffer,vUvR).ra;ba=texture2D(inputBuffer,vUvB).ba;}\n#endif\noutputColor=vec4(ra.x,inputColor.g,ba.x,max(max(ra.y,ba.y),inputColor.a));}",
    Ow = "uniform vec2 offset;varying float vActive;varying vec2 vUvR;varying vec2 vUvB;void mainSupport(const in vec2 uv){vec2 shift=offset*vec2(1.0,aspect);vActive=(shift.x!=0.0||shift.y!=0.0)?1.0:0.0;vUvR=uv+shift;vUvB=uv-shift;}",
    Bw = class extends Cn {
        constructor({
            offset: t = new Q(.001, 5e-4),
            radialModulation: e = !1,
            modulationOffset: n = .15
        } = {}) {
            super("ChromaticAberrationEffect", Lw, {
                vertexShader: Ow,
                attributes: qn.CONVOLUTION,
                uniforms: new Map([
                    ["offset", new Ce(t)],
                    ["modulationOffset", new Ce(n)]
                ])
            }), this.radialModulation = e
        }
        get offset() {
            return this.uniforms.get("offset").value
        }
        set offset(t) {
            this.uniforms.get("offset").value = t
        }
        get radialModulation() {
            return this.defines.has("RADIAL_MODULATION")
        }
        set radialModulation(t) {
            t ? this.defines.set("RADIAL_MODULATION", "1") : this.defines.delete("RADIAL_MODULATION"), this.setChanged()
        }
        get modulationOffset() {
            return this.uniforms.get("modulationOffset").value
        }
        set modulationOffset(t) {
            this.uniforms.get("modulationOffset").value = t
        }
        getOffset() {
            return this.offset
        }
        setOffset(t) {
            this.offset = t
        }
    },
    Qp = {
        RED: 0,
        GREEN: 1,
        BLUE: 2,
        ALPHA: 3
    },
    qp = {
        DISCARD: 0,
        MULTIPLY: 1,
        MULTIPLY_RGB_SET_ALPHA: 2,
        MULTIPLY_RGB: 3
    },
    Uw = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#if PASS == 1\nuniform vec4 kernel64[32];\n#else\nuniform vec4 kernel16[8];\n#endif\nuniform lowp sampler2D cocBuffer;uniform vec2 texelSize;uniform float scale;varying vec2 vUv;void main(){\n#ifdef FOREGROUND\nvec2 cocNearFar=texture2D(cocBuffer,vUv).rg*scale;float coc=cocNearFar.x;\n#else\nfloat coc=texture2D(cocBuffer,vUv).g*scale;\n#endif\nif(coc==0.0){gl_FragColor=texture2D(inputBuffer,vUv);}else{\n#ifdef FOREGROUND\nvec2 step=texelSize*max(cocNearFar.x,cocNearFar.y);\n#else\nvec2 step=texelSize*coc;\n#endif\n#if PASS == 1\nvec4 acc=vec4(0.0);for(int i=0;i<32;++i){vec4 kernel=kernel64[i];vec2 uv=step*kernel.xy+vUv;acc+=texture2D(inputBuffer,uv);uv=step*kernel.zw+vUv;acc+=texture2D(inputBuffer,uv);}gl_FragColor=acc/64.0;\n#else\nvec4 maxValue=texture2D(inputBuffer,vUv);for(int i=0;i<8;++i){vec4 kernel=kernel16[i];vec2 uv=step*kernel.xy+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);uv=step*kernel.zw+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);}gl_FragColor=maxValue;\n#endif\n}}",
    pa = class extends It {
        constructor(t = !1, e = !1) {
            super({
                name: "BokehMaterial",
                defines: {
                    PASS: t ? "2" : "1"
                },
                uniforms: {
                    inputBuffer: new Ce(null),
                    cocBuffer: new Ce(null),
                    texelSize: new Ce(new Q),
                    kernel64: new Ce(null),
                    kernel16: new Ce(null),
                    scale: new Ce(1)
                },
                blending: 0,
                toneMapped: !1,
                depthWrite: !1,
                depthTest: !1,
                fragmentShader: Uw,
                vertexShader: Mo
            }), e && (this.defines.FOREGROUND = "1"), this.generateKernel()
        }
        set inputBuffer(t) {
            this.uniforms.inputBuffer.value = t
        }
        setInputBuffer(t) {
            this.uniforms.inputBuffer.value = t
        }
        set cocBuffer(t) {
            this.uniforms.cocBuffer.value = t
        }
        setCoCBuffer(t) {
            this.uniforms.cocBuffer.value = t
        }
        get scale() {
            return this.uniforms.scale.value
        }
        set scale(t) {
            this.uniforms.scale.value = t
        }
        getScale(t) {
            return this.scale
        }
        setScale(t) {
            this.scale = t
        }
        generateKernel() {
            const t = new Float64Array(128),
                e = new Float64Array(32);
            let n = 0,
                i = 0;
            for (let s = 0, r = Math.sqrt(80); s < 80; ++s) {
                const o = 2.39996323 * s,
                    a = Math.sqrt(s) / r,
                    l = a * Math.cos(o),
                    c = a * Math.sin(o);
                s % 5 == 0 ? (e[i++] = l, e[i++] = c) : (t[n++] = l, t[n++] = c)
            }
            this.uniforms.kernel64.value = t, this.uniforms.kernel16.value = e
        }
        setTexelSize(t, e) {
            this.uniforms.texelSize.value.set(t, e)
        }
        setSize(t, e) {
            this.uniforms.texelSize.value.set(1 / t, 1 / e)
        }
    };

function gf(t, e, n) {
    return t * (e - n) - e
}

function Wc(t, e, n) {
    return Math.min(Math.max((t + e) / (e - n), 0), 1)
}
var Nw = "#include <common>\n#include <packing>\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nuniform float focusDistance;uniform float focusRange;uniform float cameraNear;uniform float cameraFar;varying vec2 vUv;float readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nfloat depth=unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nfloat depth=texture2D(depthBuffer,uv).r;\n#endif\n#ifdef LOG_DEPTH\nfloat d=pow(2.0,depth*log2(cameraFar+1.0))-1.0;float a=cameraFar/(cameraFar-cameraNear);float b=cameraFar*cameraNear/(cameraNear-cameraFar);depth=a+b/d;\n#endif\nreturn depth;}void main(){float depth=readDepth(vUv);\n#ifdef PERSPECTIVE_CAMERA\nfloat viewZ=perspectiveDepthToViewZ(depth,cameraNear,cameraFar);float linearDepth=viewZToOrthographicDepth(viewZ,cameraNear,cameraFar);\n#else\nfloat linearDepth=depth;\n#endif\nfloat signedDistance=linearDepth-focusDistance;float magnitude=smoothstep(0.0,focusRange,abs(signedDistance));gl_FragColor.rg=magnitude*vec2(step(signedDistance,0.0),step(0.0,signedDistance));}",
    Fw = class extends It {
        constructor(t) {
            super({
                name: "CircleOfConfusionMaterial",
                defines: {
                    DEPTH_PACKING: "0"
                },
                uniforms: {
                    depthBuffer: new Ce(null),
                    focusDistance: new Ce(0),
                    focusRange: new Ce(0),
                    cameraNear: new Ce(.3),
                    cameraFar: new Ce(1e3)
                },
                blending: 0,
                toneMapped: !1,
                depthWrite: !1,
                depthTest: !1,
                fragmentShader: Nw,
                vertexShader: Mo
            }), this.uniforms.focalLength = this.uniforms.focusRange, this.copyCameraSettings(t)
        }
        get near() {
            return this.uniforms.cameraNear.value
        }
        get far() {
            return this.uniforms.cameraFar.value
        }
        set depthBuffer(t) {
            this.uniforms.depthBuffer.value = t
        }
        set depthPacking(t) {
            this.defines.DEPTH_PACKING = t.toFixed(0), this.needsUpdate = !0
        }
        setDepthBuffer(t, e = Oi) {
            this.depthBuffer = t, this.depthPacking = e
        }
        get focusDistance() {
            return this.uniforms.focusDistance.value
        }
        set focusDistance(t) {
            this.uniforms.focusDistance.value = t
        }
        get worldFocusDistance() {
            return -gf(this.focusDistance, this.near, this.far)
        }
        set worldFocusDistance(t) {
            this.focusDistance = Wc(-t, this.near, this.far)
        }
        getFocusDistance(t) {
            this.uniforms.focusDistance.value = t
        }
        setFocusDistance(t) {
            this.uniforms.focusDistance.value = t
        }
        get focalLength() {
            return this.focusRange
        }
        set focalLength(t) {
            this.focusRange = t
        }
        get focusRange() {
            return this.uniforms.focusRange.value
        }
        set focusRange(t) {
            this.uniforms.focusRange.value = t
        }
        get worldFocusRange() {
            return -gf(this.focusRange, this.near, this.far)
        }
        set worldFocusRange(t) {
            this.focusRange = Wc(-t, this.near, this.far)
        }
        getFocalLength(t) {
            return this.focusRange
        }
        setFocalLength(t) {
            this.focusRange = t
        }
        adoptCameraSettings(t) {
            this.copyCameraSettings(t)
        }
        copyCameraSettings(t) {
            t && (this.uniforms.cameraNear.value = t.near, this.uniforms.cameraFar.value = t.far, t instanceof Pt ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = !0)
        }
    },
    kw = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#ifdef MASK_PRECISION_HIGH\nuniform mediump sampler2D maskTexture;\n#else\nuniform lowp sampler2D maskTexture;\n#endif\n#if MASK_FUNCTION != 0\nuniform float strength;\n#endif\nvarying vec2 vUv;void main(){\n#if COLOR_CHANNEL == 0\nfloat mask=texture2D(maskTexture,vUv).r;\n#elif COLOR_CHANNEL == 1\nfloat mask=texture2D(maskTexture,vUv).g;\n#elif COLOR_CHANNEL == 2\nfloat mask=texture2D(maskTexture,vUv).b;\n#else\nfloat mask=texture2D(maskTexture,vUv).a;\n#endif\n#if MASK_FUNCTION == 0\n#ifdef INVERTED\nmask=step(mask,0.0);\n#else\nmask=1.0-step(mask,0.0);\n#endif\n#else\nmask=clamp(mask*strength,0.0,1.0);\n#ifdef INVERTED\nmask=1.0-mask;\n#endif\n#endif\n#if MASK_FUNCTION == 3\nvec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=vec4(mask*texel.rgb,texel.a);\n#elif MASK_FUNCTION == 2\ngl_FragColor=vec4(mask*texture2D(inputBuffer,vUv).rgb,mask);\n#else\ngl_FragColor=mask*texture2D(inputBuffer,vUv);\n#endif\n}",
    zw = class extends It {
        constructor(t = null) {
            super({
                name: "MaskMaterial",
                uniforms: {
                    maskTexture: new Ce(t),
                    inputBuffer: new Ce(null),
                    strength: new Ce(1)
                },
                blending: 0,
                toneMapped: !1,
                depthWrite: !1,
                depthTest: !1,
                fragmentShader: kw,
                vertexShader: Mo
            }), this.colorChannel = Qp.RED, this.maskFunction = qp.DISCARD
        }
        set inputBuffer(t) {
            this.uniforms.inputBuffer.value = t
        }
        setInputBuffer(t) {
            this.uniforms.inputBuffer.value = t
        }
        set maskTexture(t) {
            this.uniforms.maskTexture.value = t, delete this.defines.MASK_PRECISION_HIGH, t.type !== Qt && (this.defines.MASK_PRECISION_HIGH = "1"), this.needsUpdate = !0
        }
        setMaskTexture(t) {
            this.maskTexture = t
        }
        set colorChannel(t) {
            this.defines.COLOR_CHANNEL = t.toFixed(0), this.needsUpdate = !0
        }
        setColorChannel(t) {
            this.colorChannel = t
        }
        set maskFunction(t) {
            this.defines.MASK_FUNCTION = t.toFixed(0), this.needsUpdate = !0
        }
        setMaskFunction(t) {
            this.maskFunction = t
        }
        get inverted() {
            return void 0 !== this.defines.INVERTED
        }
        set inverted(t) {
            this.inverted && !t ? delete this.defines.INVERTED : t && (this.defines.INVERTED = "1"), this.needsUpdate = !0
        }
        isInverted() {
            return this.inverted
        }
        setInverted(t) {
            this.inverted = t
        }
        get strength() {
            return this.uniforms.strength.value
        }
        set strength(t) {
            this.uniforms.strength.value = t
        }
        getStrength() {
            return this.strength
        }
        setStrength(t) {
            this.strength = t
        }
    },
    Ki = class extends Vn {
        constructor(t, e = "inputBuffer") {
            super("ShaderPass"), this.fullscreenMaterial = t, this.input = e
        }
        setInput(t) {
            this.input = t
        }
        render(t, e, n, i, s) {
            const r = this.fullscreenMaterial.uniforms;
            null !== e && void 0 !== r && void 0 !== r[this.input] && (r[this.input].value = e.texture), t.setRenderTarget(this.renderToScreen ? null : n), t.render(this.scene, this.camera)
        }
        initialize(t, e, n) {
            void 0 !== n && n !== Qt && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1")
        }
    },
    Gw = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D nearColorBuffer;uniform mediump sampler2D farColorBuffer;\n#else\nuniform lowp sampler2D nearColorBuffer;uniform lowp sampler2D farColorBuffer;\n#endif\nuniform lowp sampler2D nearCoCBuffer;uniform lowp sampler2D farCoCBuffer;uniform float scale;void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){vec4 colorNear=texture2D(nearColorBuffer,uv);vec4 colorFar=texture2D(farColorBuffer,uv);\n#if MASK_FUNCTION == 1\nvec2 cocNearFar=vec2(texture2D(nearCoCBuffer,uv).r,colorFar.a);cocNearFar.x=min(cocNearFar.x*scale,1.0);\n#else\nvec2 cocNearFar=vec2(texture2D(nearCoCBuffer,uv).r,texture2D(farCoCBuffer,uv).g);cocNearFar=min(cocNearFar*scale,1.0);\n#endif\nvec4 result=inputColor*(1.0-cocNearFar.y)+colorFar;result=mix(result,colorNear,cocNearFar.x);outputColor=result;}",
    Hw = class extends Cn {
        constructor(t, {
            blendFunction: e,
            worldFocusDistance: n,
            worldFocusRange: i,
            focusDistance: s = 0,
            focalLength: r = .1,
            focusRange: o = r,
            bokehScale: a = 1,
            resolutionScale: l = 1,
            width: c = _n.AUTO_SIZE,
            height: h = _n.AUTO_SIZE,
            resolutionX: u = c,
            resolutionY: d = h
        } = {}) {
            super("DepthOfFieldEffect", Gw, {
                blendFunction: e,
                attributes: qn.DEPTH,
                uniforms: new Map([
                    ["nearColorBuffer", new Ce(null)],
                    ["farColorBuffer", new Ce(null)],
                    ["nearCoCBuffer", new Ce(null)],
                    ["farCoCBuffer", new Ce(null)],
                    ["scale", new Ce(1)]
                ])
            }), this.camera = t, this.renderTarget = new nn(1, 1, {
                depthBuffer: !1
            }), this.renderTarget.texture.name = "DoF.Intermediate", this.renderTargetMasked = this.renderTarget.clone(), this.renderTargetMasked.texture.name = "DoF.Masked.Far", this.renderTargetNear = this.renderTarget.clone(), this.renderTargetNear.texture.name = "DoF.Bokeh.Near", this.uniforms.get("nearColorBuffer").value = this.renderTargetNear.texture, this.renderTargetFar = this.renderTarget.clone(), this.renderTargetFar.texture.name = "DoF.Bokeh.Far", this.uniforms.get("farColorBuffer").value = this.renderTargetFar.texture, this.renderTargetCoC = this.renderTarget.clone(), this.renderTargetCoC.texture.name = "DoF.CoC", this.uniforms.get("farCoCBuffer").value = this.renderTargetCoC.texture, this.renderTargetCoCBlurred = this.renderTargetCoC.clone(), this.renderTargetCoCBlurred.texture.name = "DoF.CoC.Blurred", this.uniforms.get("nearCoCBuffer").value = this.renderTargetCoCBlurred.texture, this.cocPass = new Ki(new Fw(t));
            const p = this.cocMaterial;
            p.focusDistance = s, p.focusRange = o, void 0 !== n && (p.worldFocusDistance = n), void 0 !== i && (p.worldFocusRange = i), this.blurPass = new Ph({
                resolutionScale: l,
                resolutionX: u,
                resolutionY: d,
                kernelSize: hn.MEDIUM
            }), this.maskPass = new Ki(new zw(this.renderTargetCoC.texture));
            this.maskPass.fullscreenMaterial.colorChannel = Qp.GREEN, this.maskFunction = qp.MULTIPLY_RGB, this.bokehNearBasePass = new Ki(new pa(!1, !0)), this.bokehNearBasePass.fullscreenMaterial.cocBuffer = this.renderTargetCoCBlurred.texture, this.bokehNearFillPass = new Ki(new pa(!0, !0)), this.bokehNearFillPass.fullscreenMaterial.cocBuffer = this.renderTargetCoCBlurred.texture, this.bokehFarBasePass = new Ki(new pa(!1, !1)), this.bokehFarBasePass.fullscreenMaterial.cocBuffer = this.renderTargetCoC.texture, this.bokehFarFillPass = new Ki(new pa(!0, !1)), this.bokehFarFillPass.fullscreenMaterial.cocBuffer = this.renderTargetCoC.texture, this.target = null;
            const f = this.resolution = new _n(this, u, d, l);
            f.addEventListener("change", (t => this.setSize(f.baseWidth, f.baseHeight))), this.bokehScale = a
        }
        set mainCamera(t) {
            this.camera = t, this.cocMaterial.copyCameraSettings(t)
        }
        get cocTexture() {
            return this.renderTargetCoC.texture
        }
        get maskFunction() {
            return this.maskPass.fullscreenMaterial.maskFunction
        }
        set maskFunction(t) {
            this.maskFunction !== t && (this.defines.set("MASK_FUNCTION", t.toFixed(0)), this.maskPass.fullscreenMaterial.maskFunction = t, this.setChanged())
        }
        get cocMaterial() {
            return this.cocPass.fullscreenMaterial
        }
        get circleOfConfusionMaterial() {
            return this.cocMaterial
        }
        getCircleOfConfusionMaterial() {
            return this.cocMaterial
        }
        getBlurPass() {
            return this.blurPass
        }
        getResolution() {
            return this.resolution
        }
        get bokehScale() {
            return this.uniforms.get("scale").value
        }
        set bokehScale(t) {
            this.bokehNearBasePass.fullscreenMaterial.scale = t, this.bokehNearFillPass.fullscreenMaterial.scale = t, this.bokehFarBasePass.fullscreenMaterial.scale = t, this.bokehFarFillPass.fullscreenMaterial.scale = t, this.maskPass.fullscreenMaterial.strength = t, this.uniforms.get("scale").value = t
        }
        getBokehScale() {
            return this.bokehScale
        }
        setBokehScale(t) {
            this.bokehScale = t
        }
        getTarget() {
            return this.target
        }
        setTarget(t) {
            this.target = t
        }
        calculateFocusDistance(t) {
            const e = this.camera;
            return Wc(-e.position.distanceTo(t), e.near, e.far)
        }
        setDepthTexture(t, e = Oi) {
            this.cocMaterial.depthBuffer = t, this.cocMaterial.depthPacking = e
        }
        update(t, e, n) {
            const i = this.renderTarget,
                s = this.renderTargetCoC,
                r = this.renderTargetCoCBlurred,
                o = this.renderTargetMasked;
            if (null !== this.target) {
                const t = this.calculateFocusDistance(this.target);
                this.cocMaterial.focusDistance = t
            }
            this.cocPass.render(t, null, s), this.blurPass.render(t, s, r), this.maskPass.render(t, e, o), this.bokehFarBasePass.render(t, o, i), this.bokehFarFillPass.render(t, i, this.renderTargetFar), this.bokehNearBasePass.render(t, e, i), this.bokehNearFillPass.render(t, i, this.renderTargetNear)
        }
        setSize(t, e) {
            const n = this.resolution;
            n.setBaseSize(t, e);
            const i = n.width,
                s = n.height;
            this.cocPass.setSize(t, e), this.blurPass.setSize(t, e), this.maskPass.setSize(t, e), this.renderTargetFar.setSize(t, e), this.renderTargetCoC.setSize(t, e), this.renderTargetMasked.setSize(t, e), this.renderTarget.setSize(i, s), this.renderTargetNear.setSize(i, s), this.renderTargetCoCBlurred.setSize(i, s), this.bokehNearBasePass.fullscreenMaterial.setSize(t, e), this.bokehNearFillPass.fullscreenMaterial.setSize(t, e), this.bokehFarBasePass.fullscreenMaterial.setSize(t, e), this.bokehFarFillPass.fullscreenMaterial.setSize(t, e)
        }
        initialize(t, e, n) {
            this.cocPass.initialize(t, e, n), this.maskPass.initialize(t, e, n), this.bokehNearBasePass.initialize(t, e, n), this.bokehNearFillPass.initialize(t, e, n), this.bokehFarBasePass.initialize(t, e, n), this.bokehFarFillPass.initialize(t, e, n), this.blurPass.initialize(t, e, Qt), t.capabilities.logarithmicDepthBuffer && (this.cocPass.fullscreenMaterial.defines.LOG_DEPTH = "1"), void 0 !== n && (this.renderTarget.texture.type = n, this.renderTargetNear.texture.type = n, this.renderTargetFar.texture.type = n, this.renderTargetMasked.texture.type = n, null !== t && t.outputColorSpace === rt && (this.renderTarget.texture.colorSpace = rt, this.renderTargetNear.texture.colorSpace = rt, this.renderTargetFar.texture.colorSpace = rt, this.renderTargetMasked.texture.colorSpace = rt))
        }
    },
    Vw = "#define QUALITY(q) ((q) < 5 ? 1.0 : ((q) > 5 ? ((q) < 10 ? 2.0 : ((q) < 11 ? 4.0 : 8.0)) : 1.5))\n#define ONE_OVER_TWELVE 0.08333333333333333\nvarying vec2 vUvDown;varying vec2 vUvUp;varying vec2 vUvLeft;varying vec2 vUvRight;varying vec2 vUvDownLeft;varying vec2 vUvUpRight;varying vec2 vUvUpLeft;varying vec2 vUvDownRight;vec4 fxaa(const in vec4 inputColor,const in vec2 uv){float lumaCenter=luminance(inputColor.rgb);float lumaDown=luminance(texture2D(inputBuffer,vUvDown).rgb);float lumaUp=luminance(texture2D(inputBuffer,vUvUp).rgb);float lumaLeft=luminance(texture2D(inputBuffer,vUvLeft).rgb);float lumaRight=luminance(texture2D(inputBuffer,vUvRight).rgb);float lumaMin=min(lumaCenter,min(min(lumaDown,lumaUp),min(lumaLeft,lumaRight)));float lumaMax=max(lumaCenter,max(max(lumaDown,lumaUp),max(lumaLeft,lumaRight)));float lumaRange=lumaMax-lumaMin;if(lumaRange<max(EDGE_THRESHOLD_MIN,lumaMax*EDGE_THRESHOLD_MAX)){return inputColor;}float lumaDownLeft=luminance(texture2D(inputBuffer,vUvDownLeft).rgb);float lumaUpRight=luminance(texture2D(inputBuffer,vUvUpRight).rgb);float lumaUpLeft=luminance(texture2D(inputBuffer,vUvUpLeft).rgb);float lumaDownRight=luminance(texture2D(inputBuffer,vUvDownRight).rgb);float lumaDownUp=lumaDown+lumaUp;float lumaLeftRight=lumaLeft+lumaRight;float lumaLeftCorners=lumaDownLeft+lumaUpLeft;float lumaDownCorners=lumaDownLeft+lumaDownRight;float lumaRightCorners=lumaDownRight+lumaUpRight;float lumaUpCorners=lumaUpRight+lumaUpLeft;float edgeHorizontal=(abs(-2.0*lumaLeft+lumaLeftCorners)+abs(-2.0*lumaCenter+lumaDownUp)*2.0+abs(-2.0*lumaRight+lumaRightCorners));float edgeVertical=(abs(-2.0*lumaUp+lumaUpCorners)+abs(-2.0*lumaCenter+lumaLeftRight)*2.0+abs(-2.0*lumaDown+lumaDownCorners));bool isHorizontal=(edgeHorizontal>=edgeVertical);float stepLength=isHorizontal?texelSize.y:texelSize.x;float luma1=isHorizontal?lumaDown:lumaLeft;float luma2=isHorizontal?lumaUp:lumaRight;float gradient1=abs(luma1-lumaCenter);float gradient2=abs(luma2-lumaCenter);bool is1Steepest=gradient1>=gradient2;float gradientScaled=0.25*max(gradient1,gradient2);float lumaLocalAverage=0.0;if(is1Steepest){stepLength=-stepLength;lumaLocalAverage=0.5*(luma1+lumaCenter);}else{lumaLocalAverage=0.5*(luma2+lumaCenter);}vec2 currentUv=uv;if(isHorizontal){currentUv.y+=stepLength*0.5;}else{currentUv.x+=stepLength*0.5;}vec2 offset=isHorizontal?vec2(texelSize.x,0.0):vec2(0.0,texelSize.y);vec2 uv1=currentUv-offset*QUALITY(0);vec2 uv2=currentUv+offset*QUALITY(0);float lumaEnd1=luminance(texture2D(inputBuffer,uv1).rgb);float lumaEnd2=luminance(texture2D(inputBuffer,uv2).rgb);lumaEnd1-=lumaLocalAverage;lumaEnd2-=lumaLocalAverage;bool reached1=abs(lumaEnd1)>=gradientScaled;bool reached2=abs(lumaEnd2)>=gradientScaled;bool reachedBoth=reached1&&reached2;if(!reached1){uv1-=offset*QUALITY(1);}if(!reached2){uv2+=offset*QUALITY(1);}if(!reachedBoth){for(int i=2;i<SAMPLES;++i){if(!reached1){lumaEnd1=luminance(texture2D(inputBuffer,uv1).rgb);lumaEnd1=lumaEnd1-lumaLocalAverage;}if(!reached2){lumaEnd2=luminance(texture2D(inputBuffer,uv2).rgb);lumaEnd2=lumaEnd2-lumaLocalAverage;}reached1=abs(lumaEnd1)>=gradientScaled;reached2=abs(lumaEnd2)>=gradientScaled;reachedBoth=reached1&&reached2;if(!reached1){uv1-=offset*QUALITY(i);}if(!reached2){uv2+=offset*QUALITY(i);}if(reachedBoth){break;}}}float distance1=isHorizontal?(uv.x-uv1.x):(uv.y-uv1.y);float distance2=isHorizontal?(uv2.x-uv.x):(uv2.y-uv.y);bool isDirection1=distance1<distance2;float distanceFinal=min(distance1,distance2);float edgeThickness=(distance1+distance2);bool isLumaCenterSmaller=lumaCenter<lumaLocalAverage;bool correctVariation1=(lumaEnd1<0.0)!=isLumaCenterSmaller;bool correctVariation2=(lumaEnd2<0.0)!=isLumaCenterSmaller;bool correctVariation=isDirection1?correctVariation1:correctVariation2;float pixelOffset=-distanceFinal/edgeThickness+0.5;float finalOffset=correctVariation?pixelOffset:0.0;float lumaAverage=ONE_OVER_TWELVE*(2.0*(lumaDownUp+lumaLeftRight)+lumaLeftCorners+lumaRightCorners);float subPixelOffset1=clamp(abs(lumaAverage-lumaCenter)/lumaRange,0.0,1.0);float subPixelOffset2=(-2.0*subPixelOffset1+3.0)*subPixelOffset1*subPixelOffset1;float subPixelOffsetFinal=subPixelOffset2*subPixelOffset2*SUBPIXEL_QUALITY;finalOffset=max(finalOffset,subPixelOffsetFinal);vec2 finalUv=uv;if(isHorizontal){finalUv.y+=finalOffset*stepLength;}else{finalUv.x+=finalOffset*stepLength;}return texture2D(inputBuffer,finalUv);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=fxaa(inputColor,uv);}",
    Ww = "varying vec2 vUvDown;varying vec2 vUvUp;varying vec2 vUvLeft;varying vec2 vUvRight;varying vec2 vUvDownLeft;varying vec2 vUvUpRight;varying vec2 vUvUpLeft;varying vec2 vUvDownRight;void mainSupport(const in vec2 uv){vUvDown=uv+vec2(0.0,-1.0)*texelSize;vUvUp=uv+vec2(0.0,1.0)*texelSize;vUvRight=uv+vec2(1.0,0.0)*texelSize;vUvLeft=uv+vec2(-1.0,0.0)*texelSize;vUvDownLeft=uv+vec2(-1.0,-1.0)*texelSize;vUvUpRight=uv+vec2(1.0,1.0)*texelSize;vUvUpLeft=uv+vec2(-1.0,1.0)*texelSize;vUvDownRight=uv+vec2(1.0,-1.0)*texelSize;}",
    Xw = class extends Cn {
        constructor({
            blendFunction: t = Ae.SRC
        } = {}) {
            super("FXAAEffect", Vw, {
                vertexShader: Ww,
                blendFunction: t,
                defines: new Map([
                    ["EDGE_THRESHOLD_MIN", "0.0312"],
                    ["EDGE_THRESHOLD_MAX", "0.125"],
                    ["SUBPIXEL_QUALITY", "0.75"],
                    ["SAMPLES", "12"]
                ])
            })
        }
        get minEdgeThreshold() {
            return Number(this.defines.get("EDGE_THRESHOLD_MIN"))
        }
        set minEdgeThreshold(t) {
            this.defines.set("EDGE_THRESHOLD_MIN", t.toFixed(12)), this.setChanged()
        }
        get maxEdgeThreshold() {
            return Number(this.defines.get("EDGE_THRESHOLD_MAX"))
        }
        set maxEdgeThreshold(t) {
            this.defines.set("EDGE_THRESHOLD_MAX", t.toFixed(12)), this.setChanged()
        }
        get subpixelQuality() {
            return Number(this.defines.get("SUBPIXEL_QUALITY"))
        }
        set subpixelQuality(t) {
            this.defines.set("SUBPIXEL_QUALITY", t.toFixed(12)), this.setChanged()
        }
        get samples() {
            return Number(this.defines.get("SAMPLES"))
        }
        set samples(t) {
            this.defines.set("SAMPLES", t.toFixed(0)), this.setChanged()
        }
    },
    jw = class extends Vn {
        constructor(t, e, n = null) {
            super("RenderPass", t, e), this.needsSwap = !1, this.clearPass = new Ch, this.overrideMaterialManager = null === n ? null : new mf(n), this.ignoreBackground = !1, this.skipShadowMapUpdate = !1, this.selection = null
        }
        set mainScene(t) {
            this.scene = t
        }
        set mainCamera(t) {
            this.camera = t
        }
        get renderToScreen() {
            return super.renderToScreen
        }
        set renderToScreen(t) {
            super.renderToScreen = t, this.clearPass.renderToScreen = t
        }
        get overrideMaterial() {
            const t = this.overrideMaterialManager;
            return null !== t ? t.material : null
        }
        set overrideMaterial(t) {
            const e = this.overrideMaterialManager;
            null !== t ? null !== e ? e.setMaterial(t) : this.overrideMaterialManager = new mf(t) : null !== e && (e.dispose(), this.overrideMaterialManager = null)
        }
        getOverrideMaterial() {
            return this.overrideMaterial
        }
        setOverrideMaterial(t) {
            this.overrideMaterial = t
        }
        get clear() {
            return this.clearPass.enabled
        }
        set clear(t) {
            this.clearPass.enabled = t
        }
        getSelection() {
            return this.selection
        }
        setSelection(t) {
            this.selection = t
        }
        isBackgroundDisabled() {
            return this.ignoreBackground
        }
        setBackgroundDisabled(t) {
            this.ignoreBackground = t
        }
        isShadowMapDisabled() {
            return this.skipShadowMapUpdate
        }
        setShadowMapDisabled(t) {
            this.skipShadowMapUpdate = t
        }
        getClearPass() {
            return this.clearPass
        }
        render(t, e, n, i, s) {
            const r = this.scene,
                o = this.camera,
                a = this.selection,
                l = o.layers.mask,
                c = r.background,
                h = t.shadowMap.autoUpdate,
                u = this.renderToScreen ? null : e;
            null !== a && o.layers.set(a.getLayer()), this.skipShadowMapUpdate && (t.shadowMap.autoUpdate = !1), (this.ignoreBackground || null !== this.clearPass.overrideClearColor) && (r.background = null), this.clearPass.enabled && this.clearPass.render(t, e), t.setRenderTarget(u), null !== this.overrideMaterialManager ? this.overrideMaterialManager.render(t, r, o) : t.render(r, o), o.layers.mask = l, r.background = c, t.shadowMap.autoUpdate = h
        }
    },
    Kw = "uniform vec2 scale;uniform float lineWidth;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){float grid=0.5-max(abs(mod(uv.x*scale.x,1.0)-0.5),abs(mod(uv.y*scale.y,1.0)-0.5));outputColor=vec4(vec3(smoothstep(0.0,lineWidth,grid)),inputColor.a);}",
    Yw = class extends Cn {
        constructor({
            blendFunction: t = Ae.OVERLAY,
            scale: e = 1,
            lineWidth: n = 0
        } = {}) {
            super("GridEffect", Kw, {
                blendFunction: t,
                uniforms: new Map([
                    ["scale", new Ce(new Q)],
                    ["lineWidth", new Ce(n)]
                ])
            }), this.resolution = new Q, this.s = 0, this.scale = e, this.l = 0, this.lineWidth = n
        }
        get scale() {
            return this.s
        }
        set scale(t) {
            this.s = Math.max(t, 1e-6), this.setSize(this.resolution.width, this.resolution.height)
        }
        getScale() {
            return this.scale
        }
        setScale(t) {
            this.scale = t
        }
        get lineWidth() {
            return this.l
        }
        set lineWidth(t) {
            this.l = t, this.setSize(this.resolution.width, this.resolution.height)
        }
        getLineWidth() {
            return this.lineWidth
        }
        setLineWidth(t) {
            this.lineWidth = t
        }
        setSize(t, e) {
            this.resolution.set(t, e);
            const n = t / e,
                i = this.scale * (.125 * e);
            this.uniforms.get("scale").value.set(n * i, i), this.uniforms.get("lineWidth").value = i / e + this.lineWidth
        }
    },
    Qw = "uniform vec3 hue;uniform float saturation;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(dot(inputColor.rgb,hue.xyz),dot(inputColor.rgb,hue.zxy),dot(inputColor.rgb,hue.yzx));float average=(color.r+color.g+color.b)/3.0;vec3 diff=average-color;if(saturation>0.0){color+=diff*(1.0-1.0/(1.001-saturation));}else{color+=diff*-saturation;}outputColor=vec4(min(color,1.0),inputColor.a);}",
    qw = class extends Cn {
        constructor({
            blendFunction: t = Ae.SRC,
            hue: e = 0,
            saturation: n = 0
        } = {}) {
            super("HueSaturationEffect", Qw, {
                blendFunction: t,
                uniforms: new Map([
                    ["hue", new Ce(new U)],
                    ["saturation", new Ce(n)]
                ])
            }), this.hue = e
        }
        get saturation() {
            return this.uniforms.get("saturation").value
        }
        set saturation(t) {
            this.uniforms.get("saturation").value = t
        }
        getSaturation() {
            return this.saturation
        }
        setSaturation(t) {
            this.saturation = t
        }
        get hue() {
            const t = this.uniforms.get("hue").value;
            return Math.acos((3 * t.x - 1) / 2)
        }
        set hue(t) {
            const e = Math.sin(t),
                n = Math.cos(t);
            this.uniforms.get("hue").value.set((2 * n + 1) / 3, (-Math.sqrt(3) * e - n + 1) / 3, (Math.sqrt(3) * e - n + 1) / 3)
        }
        getHue() {
            return this.hue
        }
        setHue(t) {
            this.hue = t
        }
    },
    Zw = "uniform vec2 distortion;uniform vec2 principalPoint;uniform vec2 focalLength;uniform float skew;float mask(const in vec2 uv){return float(uv.s>=0.0&&uv.s<=1.0&&uv.t>=0.0&&uv.t<=1.0);}void mainUv(inout vec2 uv){vec2 xn=2.0*(uv.st-0.5);vec3 xDistorted=vec3((1.0+distortion*dot(xn,xn))*xn,1.0);mat3 kk=mat3(vec3(focalLength.x,0.0,0.0),vec3(skew*focalLength.x,focalLength.y,0.0),vec3(principalPoint.x,principalPoint.y,1.0));uv=(kk*xDistorted).xy*0.5+0.5;}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=mask(uv)*inputColor;}",
    Jw = class extends Cn {
        constructor({
            distortion: t = new Q(0, 0),
            principalPoint: e = new Q(0, 0),
            focalLength: n = new Q(1, 1),
            skew: i = 0
        } = {}) {
            super("LensDistortionEffect", Zw, {
                uniforms: new Map([
                    ["distortion", new Ce(t)],
                    ["principalPoint", new Ce(e)],
                    ["focalLength", new Ce(n)],
                    ["skew", new Ce(i)]
                ])
            })
        }
        get distortion() {
            return this.uniforms.get("distortion").value
        }
        set distortion(t) {
            this.uniforms.get("distortion").value = t
        }
        get principalPoint() {
            return this.uniforms.get("principalPoint").value
        }
        set principalPoint(t) {
            this.uniforms.get("principalPoint").value = t
        }
        get focalLength() {
            return this.uniforms.get("focalLength").value
        }
        set focalLength(t) {
            this.uniforms.get("focalLength").value = t
        }
        get skew() {
            return this.uniforms.get("skew").value
        }
        set skew(t) {
            this.uniforms.get("skew").value = t
        }
    },
    Zp = {
        DEPTH: 0,
        LUMA: 1,
        COLOR: 2
    },
    $w = {
        DISABLED: 0,
        DEPTH: 1,
        CUSTOM: 2
    },
    Un = {
        LOW: 0,
        MEDIUM: 1,
        HIGH: 2,
        ULTRA: 3
    },
    vs = {
        DEFAULT: 0,
        ESKIL: 1
    },
    eM = "void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 noise=vec3(rand(uv*(1.0+time)));\n#ifdef PREMULTIPLY\noutputColor=vec4(min(inputColor.rgb*noise,vec3(1.0)),inputColor.a);\n#else\noutputColor=vec4(noise,inputColor.a);\n#endif\n}",
    tM = class extends Cn {
        constructor({
            blendFunction: t = Ae.SCREEN,
            premultiply: e = !1
        } = {}) {
            super("NoiseEffect", eM, {
                blendFunction: t
            }), this.premultiply = e
        }
        get premultiply() {
            return this.defines.has("PREMULTIPLY")
        }
        set premultiply(t) {
            this.premultiply !== t && (t ? this.defines.set("PREMULTIPLY", "1") : this.defines.delete("PREMULTIPLY"), this.setChanged())
        }
        isPremultiplied() {
            return this.premultiply
        }
        setPremultiplied(t) {
            this.premultiply = t
        }
    },
    nM = "uniform bool active;uniform vec4 d;void mainUv(inout vec2 uv){if(active){uv=d.xy*(floor(uv*d.zw)+0.5);}}",
    iM = class extends Cn {
        constructor(t = 30) {
            super("PixelationEffect", nM, {
                uniforms: new Map([
                    ["active", new Ce(!1)],
                    ["d", new Ce(new ot)]
                ])
            }), this.resolution = new Q, this._granularity = 0, this.granularity = t
        }
        get granularity() {
            return this._granularity
        }
        set granularity(t) {
            let e = Math.floor(t);
            e % 2 > 0 && (e += 1), this._granularity = e, this.uniforms.get("active").value = e > 0, this.setSize(this.resolution.width, this.resolution.height)
        }
        getGranularity() {
            return this.granularity
        }
        setGranularity(t) {
            this.granularity = t
        }
        setSize(t, e) {
            const n = this.resolution;
            n.set(t, e);
            const i = this.granularity,
                s = i / n.x,
                r = i / n.y;
            this.uniforms.get("d").value.set(s, r, 1 / s, 1 / r)
        }
    },
    sM = "uniform float count;\n#ifdef SCROLL\nuniform float scrollSpeed;\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){float y=uv.y;\n#ifdef SCROLL\ny+=time*scrollSpeed;\n#endif\nvec2 sl=vec2(sin(y*count),cos(y*count));outputColor=vec4(sl.xyx,inputColor.a);}",
    rM = class extends Cn {
        constructor({
            blendFunction: t = Ae.OVERLAY,
            density: e = 1.25,
            scrollSpeed: n = 0
        } = {}) {
            super("ScanlineEffect", sM, {
                blendFunction: t,
                uniforms: new Map([
                    ["count", new Ce(0)],
                    ["scrollSpeed", new Ce(0)]
                ])
            }), this.resolution = new Q, this.d = e, this.scrollSpeed = n
        }
        get density() {
            return this.d
        }
        set density(t) {
            this.d = t, this.setSize(this.resolution.width, this.resolution.height)
        }
        getDensity() {
            return this.density
        }
        setDensity(t) {
            this.density = t
        }
        get scrollSpeed() {
            return this.uniforms.get("scrollSpeed").value
        }
        set scrollSpeed(t) {
            this.uniforms.get("scrollSpeed").value = t, 0 === t ? this.defines.delete("SCROLL") && this.setChanged() : this.defines.has("SCROLL") || (this.defines.set("SCROLL", "1"), this.setChanged())
        }
        setSize(t, e) {
            this.resolution.set(t, e), this.uniforms.get("count").value = Math.round(e * this.density)
        }
    },
    oM = "varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;\n#if EDGE_DETECTION_MODE != 0\nvarying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;\n#endif\n#if EDGE_DETECTION_MODE == 1\n#include <common>\n#endif\n#if EDGE_DETECTION_MODE == 0 || PREDICATION_MODE == 1\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}vec3 gatherNeighbors(){float p=readDepth(vUv);float pLeft=readDepth(vUv0);float pTop=readDepth(vUv1);return vec3(p,pLeft,pTop);}\n#elif PREDICATION_MODE == 2\nuniform sampler2D predicationBuffer;vec3 gatherNeighbors(){float p=texture2D(predicationBuffer,vUv).r;float pLeft=texture2D(predicationBuffer,vUv0).r;float pTop=texture2D(predicationBuffer,vUv1).r;return vec3(p,pLeft,pTop);}\n#endif\n#if PREDICATION_MODE != 0\nvec2 calculatePredicatedThreshold(){vec3 neighbours=gatherNeighbors();vec2 delta=abs(neighbours.xx-neighbours.yz);vec2 edges=step(PREDICATION_THRESHOLD,delta);return PREDICATION_SCALE*EDGE_THRESHOLD*(1.0-PREDICATION_STRENGTH*edges);}\n#endif\n#if EDGE_DETECTION_MODE != 0\nuniform sampler2D inputBuffer;\n#endif\nvoid main(){\n#if EDGE_DETECTION_MODE == 0\nconst vec2 threshold=vec2(DEPTH_THRESHOLD);\n#elif PREDICATION_MODE != 0\nvec2 threshold=calculatePredicatedThreshold();\n#else\nconst vec2 threshold=vec2(EDGE_THRESHOLD);\n#endif\n#if EDGE_DETECTION_MODE == 0\nvec3 neighbors=gatherNeighbors();vec2 delta=abs(neighbors.xx-vec2(neighbors.y,neighbors.z));vec2 edges=step(threshold,delta);if(dot(edges,vec2(1.0))==0.0){discard;}gl_FragColor=vec4(edges,0.0,1.0);\n#elif EDGE_DETECTION_MODE == 1\nfloat l=luminance(texture2D(inputBuffer,vUv).rgb);float lLeft=luminance(texture2D(inputBuffer,vUv0).rgb);float lTop=luminance(texture2D(inputBuffer,vUv1).rgb);vec4 delta;delta.xy=abs(l-vec2(lLeft,lTop));vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}float lRight=luminance(texture2D(inputBuffer,vUv2).rgb);float lBottom=luminance(texture2D(inputBuffer,vUv3).rgb);delta.zw=abs(l-vec2(lRight,lBottom));vec2 maxDelta=max(delta.xy,delta.zw);float lLeftLeft=luminance(texture2D(inputBuffer,vUv4).rgb);float lTopTop=luminance(texture2D(inputBuffer,vUv5).rgb);delta.zw=abs(vec2(lLeft,lTop)-vec2(lLeftLeft,lTopTop));maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges.xy*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);\n#elif EDGE_DETECTION_MODE == 2\nvec4 delta;vec3 c=texture2D(inputBuffer,vUv).rgb;vec3 cLeft=texture2D(inputBuffer,vUv0).rgb;vec3 t=abs(c-cLeft);delta.x=max(max(t.r,t.g),t.b);vec3 cTop=texture2D(inputBuffer,vUv1).rgb;t=abs(c-cTop);delta.y=max(max(t.r,t.g),t.b);vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}vec3 cRight=texture2D(inputBuffer,vUv2).rgb;t=abs(c-cRight);delta.z=max(max(t.r,t.g),t.b);vec3 cBottom=texture2D(inputBuffer,vUv3).rgb;t=abs(c-cBottom);delta.w=max(max(t.r,t.g),t.b);vec2 maxDelta=max(delta.xy,delta.zw);vec3 cLeftLeft=texture2D(inputBuffer,vUv4).rgb;t=abs(c-cLeftLeft);delta.z=max(max(t.r,t.g),t.b);vec3 cTopTop=texture2D(inputBuffer,vUv5).rgb;t=abs(c-cTopTop);delta.w=max(max(t.r,t.g),t.b);maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);\n#endif\n}",
    aM = "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;\n#if EDGE_DETECTION_MODE != 0\nvarying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;\n#endif\nvoid main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,0.0);vUv1=vUv+texelSize*vec2(0.0,-1.0);\n#if EDGE_DETECTION_MODE != 0\nvUv2=vUv+texelSize*vec2(1.0,0.0);vUv3=vUv+texelSize*vec2(0.0,1.0);vUv4=vUv+texelSize*vec2(-2.0,0.0);vUv5=vUv+texelSize*vec2(0.0,-2.0);\n#endif\ngl_Position=vec4(position.xy,1.0,1.0);}",
    lM = class extends It {
        constructor(t = new Q, e = Zp.COLOR) {
            super({
                name: "EdgeDetectionMaterial",
                defines: {
                    THREE_REVISION: ns.replace(/\D+/g, ""),
                    LOCAL_CONTRAST_ADAPTATION_FACTOR: "2.0",
                    EDGE_THRESHOLD: "0.1",
                    DEPTH_THRESHOLD: "0.01",
                    PREDICATION_MODE: "0",
                    PREDICATION_THRESHOLD: "0.01",
                    PREDICATION_SCALE: "2.0",
                    PREDICATION_STRENGTH: "1.0",
                    DEPTH_PACKING: "0"
                },
                uniforms: {
                    inputBuffer: new Ce(null),
                    depthBuffer: new Ce(null),
                    predicationBuffer: new Ce(null),
                    texelSize: new Ce(t)
                },
                blending: 0,
                toneMapped: !1,
                depthWrite: !1,
                depthTest: !1,
                fragmentShader: oM,
                vertexShader: aM
            }), this.edgeDetectionMode = e
        }
        set depthBuffer(t) {
            this.uniforms.depthBuffer.value = t
        }
        set depthPacking(t) {
            this.defines.DEPTH_PACKING = t.toFixed(0), this.needsUpdate = !0
        }
        setDepthBuffer(t, e = Oi) {
            this.depthBuffer = t, this.depthPacking = e
        }
        get edgeDetectionMode() {
            return Number(this.defines.EDGE_DETECTION_MODE)
        }
        set edgeDetectionMode(t) {
            this.defines.EDGE_DETECTION_MODE = t.toFixed(0), this.needsUpdate = !0
        }
        getEdgeDetectionMode() {
            return this.edgeDetectionMode
        }
        setEdgeDetectionMode(t) {
            this.edgeDetectionMode = t
        }
        get localContrastAdaptationFactor() {
            return Number(this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR)
        }
        set localContrastAdaptationFactor(t) {
            this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR = t.toFixed("6"), this.needsUpdate = !0
        }
        getLocalContrastAdaptationFactor() {
            return this.localContrastAdaptationFactor
        }
        setLocalContrastAdaptationFactor(t) {
            this.localContrastAdaptationFactor = t
        }
        get edgeDetectionThreshold() {
            return Number(this.defines.EDGE_THRESHOLD)
        }
        set edgeDetectionThreshold(t) {
            this.defines.EDGE_THRESHOLD = t.toFixed("6"), this.defines.DEPTH_THRESHOLD = (.1 * t).toFixed("6"), this.needsUpdate = !0
        }
        getEdgeDetectionThreshold() {
            return this.edgeDetectionThreshold
        }
        setEdgeDetectionThreshold(t) {
            this.edgeDetectionThreshold = t
        }
        get predicationMode() {
            return Number(this.defines.PREDICATION_MODE)
        }
        set predicationMode(t) {
            this.defines.PREDICATION_MODE = t.toFixed(0), this.needsUpdate = !0
        }
        getPredicationMode() {
            return this.predicationMode
        }
        setPredicationMode(t) {
            this.predicationMode = t
        }
        set predicationBuffer(t) {
            this.uniforms.predicationBuffer.value = t
        }
        setPredicationBuffer(t) {
            this.uniforms.predicationBuffer.value = t
        }
        get predicationThreshold() {
            return Number(this.defines.PREDICATION_THRESHOLD)
        }
        set predicationThreshold(t) {
            this.defines.PREDICATION_THRESHOLD = t.toFixed("6"), this.needsUpdate = !0
        }
        getPredicationThreshold() {
            return this.predicationThreshold
        }
        setPredicationThreshold(t) {
            this.predicationThreshold = t
        }
        get predicationScale() {
            return Number(this.defines.PREDICATION_SCALE)
        }
        set predicationScale(t) {
            this.defines.PREDICATION_SCALE = t.toFixed("6"), this.needsUpdate = !0
        }
        getPredicationScale() {
            return this.predicationScale
        }
        setPredicationScale(t) {
            this.predicationScale = t
        }
        get predicationStrength() {
            return Number(this.defines.PREDICATION_STRENGTH)
        }
        set predicationStrength(t) {
            this.defines.PREDICATION_STRENGTH = t.toFixed("6"), this.needsUpdate = !0
        }
        getPredicationStrength() {
            return this.predicationStrength
        }
        setPredicationStrength(t) {
            this.predicationStrength = t
        }
        setSize(t, e) {
            this.uniforms.texelSize.value.set(1 / t, 1 / e)
        }
    },
    cM = "#define sampleLevelZeroOffset(t, coord, offset) texture2D(t, coord + offset * texelSize)\n#if __VERSION__ < 300\n#define round(v) floor(v + 0.5)\n#endif\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform lowp sampler2D areaTexture;uniform lowp sampler2D searchTexture;uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}vec2 decodeDiagBilinearAccess(in vec2 e){e.r=e.r*abs(5.0*e.r-5.0*0.75);return round(e);}vec4 decodeDiagBilinearAccess(in vec4 e){e.rb=e.rb*abs(5.0*e.rb-5.0*0.75);return round(e);}vec2 searchDiag1(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 searchDiag2(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);coord.x+=0.25*texelSize.x;vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;e=decodeDiagBilinearAccess(e);coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 areaDiag(const in vec2 dist,const in vec2 e,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE_DIAG,AREATEX_MAX_DISTANCE_DIAG)*e+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.x+=0.5;texCoord.y+=AREATEX_SUBTEX_SIZE*offset;return texture2D(areaTexture,texCoord).rg;}vec2 calculateDiagWeights(const in vec2 texCoord,const in vec2 e,const in vec4 subsampleIndices){vec2 weights=vec2(0.0);vec4 d;vec2 end;if(e.r>0.0){d.xz=searchDiag1(texCoord,vec2(-1.0,1.0),end);d.x+=float(end.y>0.9);}else{d.xz=vec2(0.0);}d.yw=searchDiag1(texCoord,vec2(1.0,-1.0),end);if(d.x+d.y>2.0){vec4 coords=vec4(-d.x+0.25,d.x,d.y,-d.y-0.25)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.xy=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).rg;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).rg;c.yxwz=decodeDiagBilinearAccess(c.xyzw);vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.z);}d.xz=searchDiag2(texCoord,vec2(-1.0,-1.0),end);if(sampleLevelZeroOffset(inputBuffer,texCoord,vec2(1,0)).r>0.0){d.yw=searchDiag2(texCoord,vec2(1.0),end);d.y+=float(end.y>0.9);}else{d.yw=vec2(0.0);}if(d.x+d.y>2.0){vec4 coords=vec4(-d.x,-d.x,d.y,d.y)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.x=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).g;c.y=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(0,-1)).r;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).gr;vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.w).gr;}return weights;}float searchLength(const in vec2 e,const in float offset){vec2 scale=SEARCHTEX_SIZE*vec2(0.5,-1.0);vec2 bias=SEARCHTEX_SIZE*vec2(offset,1.0);scale+=vec2(-1.0,1.0);bias+=vec2(0.5,-0.5);scale*=1.0/SEARCHTEX_PACKED_SIZE;bias*=1.0/SEARCHTEX_PACKED_SIZE;return texture2D(searchTexture,scale*e+bias).r;}float searchXLeft(in vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x>end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(-2.0,0.0)*texelSize+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.0)+3.25;return texelSize.x*offset+texCoord.x;}float searchXRight(vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x<end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(2.0,0.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.5)+3.25;return-texelSize.x*offset+texCoord.x;}float searchYUp(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.y>end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=-vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.0)+3.25;return texelSize.y*offset+texCoord.y;}float searchYDown(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;i++){if(!(texCoord.y<end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.5)+3.25;return-texelSize.y*offset+texCoord.y;}vec2 area(const in vec2 dist,const in float e1,const in float e2,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE)*round(4.0*vec2(e1,e2))+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.y=AREATEX_SUBTEX_SIZE*offset+texCoord.y;return texture2D(areaTexture,texCoord).rg;}void detectHorizontalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){\n#if !defined(DISABLE_CORNER_DETECTION)\nvec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,1)).r;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).r;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,-2)).r;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,-2)).r;weights*=clamp(factor,0.0,1.0);\n#endif\n}void detectVerticalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){\n#if !defined(DISABLE_CORNER_DETECTION)\nvec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(1,0)).g;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).g;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(-2,0)).g;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(-2,1)).g;weights*=clamp(factor,0.0,1.0);\n#endif\n}void main(){vec4 weights=vec4(0.0);vec4 subsampleIndices=vec4(0.0);vec2 e=texture2D(inputBuffer,vUv).rg;if(e.g>0.0){\n#if !defined(DISABLE_DIAG_DETECTION)\nweights.rg=calculateDiagWeights(vUv,e,subsampleIndices);if(weights.r==-weights.g){\n#endif\nvec2 d;vec3 coords;coords.x=searchXLeft(vOffset[0].xy,vOffset[2].x);coords.y=vOffset[1].y;d.x=coords.x;float e1=texture2D(inputBuffer,coords.xy).r;coords.z=searchXRight(vOffset[0].zw,vOffset[2].y);d.y=coords.z;d=round(resolution.xx*d+-vPixCoord.xx);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.zy,vec2(1,0)).r;weights.rg=area(sqrtD,e1,e2,subsampleIndices.y);coords.y=vUv.y;detectHorizontalCornerPattern(weights.rg,coords.xyzy,d);\n#if !defined(DISABLE_DIAG_DETECTION)\n}else{e.r=0.0;}\n#endif\n}if(e.r>0.0){vec2 d;vec3 coords;coords.y=searchYUp(vOffset[1].xy,vOffset[2].z);coords.x=vOffset[0].x;d.x=coords.y;float e1=texture2D(inputBuffer,coords.xy).g;coords.z=searchYDown(vOffset[1].zw,vOffset[2].w);d.y=coords.z;d=round(resolution.yy*d-vPixCoord.yy);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.xz,vec2(0,1)).g;weights.ba=area(sqrtD,e1,e2,subsampleIndices.x);coords.x=vUv.x;detectVerticalCornerPattern(weights.ba,coords.xyxz,d);}gl_FragColor=weights;}",
    hM = "uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void main(){vUv=position.xy*0.5+0.5;vPixCoord=vUv*resolution;vOffset[0]=vUv.xyxy+texelSize.xyxy*vec4(-0.25,-0.125,1.25,-0.125);vOffset[1]=vUv.xyxy+texelSize.xyxy*vec4(-0.125,-0.25,-0.125,1.25);vOffset[2]=vec4(vOffset[0].xz,vOffset[1].yw)+vec4(-2.0,2.0,-2.0,2.0)*texelSize.xxyy*MAX_SEARCH_STEPS_FLOAT;gl_Position=vec4(position.xy,1.0,1.0);}",
    uM = class extends It {
        constructor(t = new Q, e = new Q) {
            super({
                name: "SMAAWeightsMaterial",
                defines: {
                    MAX_SEARCH_STEPS_INT: "16",
                    MAX_SEARCH_STEPS_FLOAT: "16.0",
                    MAX_SEARCH_STEPS_DIAG_INT: "8",
                    MAX_SEARCH_STEPS_DIAG_FLOAT: "8.0",
                    CORNER_ROUNDING: "25",
                    CORNER_ROUNDING_NORM: "0.25",
                    AREATEX_MAX_DISTANCE: "16.0",
                    AREATEX_MAX_DISTANCE_DIAG: "20.0",
                    AREATEX_PIXEL_SIZE: "(1.0 / vec2(160.0, 560.0))",
                    AREATEX_SUBTEX_SIZE: "(1.0 / 7.0)",
                    SEARCHTEX_SIZE: "vec2(66.0, 33.0)",
                    SEARCHTEX_PACKED_SIZE: "vec2(64.0, 16.0)"
                },
                uniforms: {
                    inputBuffer: new Ce(null),
                    searchTexture: new Ce(null),
                    areaTexture: new Ce(null),
                    resolution: new Ce(e),
                    texelSize: new Ce(t)
                },
                blending: 0,
                toneMapped: !1,
                depthWrite: !1,
                depthTest: !1,
                fragmentShader: cM,
                vertexShader: hM
            })
        }
        set inputBuffer(t) {
            this.uniforms.inputBuffer.value = t
        }
        setInputBuffer(t) {
            this.uniforms.inputBuffer.value = t
        }
        get searchTexture() {
            return this.uniforms.searchTexture.value
        }
        set searchTexture(t) {
            this.uniforms.searchTexture.value = t
        }
        get areaTexture() {
            return this.uniforms.areaTexture.value
        }
        set areaTexture(t) {
            this.uniforms.areaTexture.value = t
        }
        setLookupTextures(t, e) {
            this.searchTexture = t, this.areaTexture = e
        }
        get orthogonalSearchSteps() {
            return Number(this.defines.MAX_SEARCH_STEPS_INT)
        }
        set orthogonalSearchSteps(t) {
            const e = Math.min(Math.max(t, 0), 112);
            this.defines.MAX_SEARCH_STEPS_INT = e.toFixed("0"), this.defines.MAX_SEARCH_STEPS_FLOAT = e.toFixed("1"), this.needsUpdate = !0
        }
        setOrthogonalSearchSteps(t) {
            this.orthogonalSearchSteps = t
        }
        get diagonalSearchSteps() {
            return Number(this.defines.MAX_SEARCH_STEPS_DIAG_INT)
        }
        set diagonalSearchSteps(t) {
            const e = Math.min(Math.max(t, 0), 20);
            this.defines.MAX_SEARCH_STEPS_DIAG_INT = e.toFixed("0"), this.defines.MAX_SEARCH_STEPS_DIAG_FLOAT = e.toFixed("1"), this.needsUpdate = !0
        }
        setDiagonalSearchSteps(t) {
            this.diagonalSearchSteps = t
        }
        get diagonalDetection() {
            return void 0 === this.defines.DISABLE_DIAG_DETECTION
        }
        set diagonalDetection(t) {
            t ? delete this.defines.DISABLE_DIAG_DETECTION : this.defines.DISABLE_DIAG_DETECTION = "1", this.needsUpdate = !0
        }
        isDiagonalDetectionEnabled() {
            return this.diagonalDetection
        }
        setDiagonalDetectionEnabled(t) {
            this.diagonalDetection = t
        }
        get cornerRounding() {
            return Number(this.defines.CORNER_ROUNDING)
        }
        set cornerRounding(t) {
            const e = Math.min(Math.max(t, 0), 100);
            this.defines.CORNER_ROUNDING = e.toFixed("4"), this.defines.CORNER_ROUNDING_NORM = (e / 100).toFixed("4"), this.needsUpdate = !0
        }
        setCornerRounding(t) {
            this.cornerRounding = t
        }
        get cornerDetection() {
            return void 0 === this.defines.DISABLE_CORNER_DETECTION
        }
        set cornerDetection(t) {
            t ? delete this.defines.DISABLE_CORNER_DETECTION : this.defines.DISABLE_CORNER_DETECTION = "1", this.needsUpdate = !0
        }
        isCornerRoundingEnabled() {
            return this.cornerDetection
        }
        setCornerRoundingEnabled(t) {
            this.cornerDetection = t
        }
        setSize(t, e) {
            const n = this.uniforms;
            n.texelSize.value.set(1 / t, 1 / e), n.resolution.value.set(t, e)
        }
    },
    vf = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAQCAYAAACm53kpAAAAeElEQVRYR+2XSwqAMAxEJ168ePEqwRSKhIIiuHjJqiU0gWE+1CQdApcVAMUAuARaMGCX1MIL/Ow13++9lW2s3mW9MWvsnWc/2fvGygwPAN4E8QzAA4CXAB6AHjG4JTHYI1ey3pcx6FHnEfhLDOIBKAmUBK6/ANUDTlROXAHd9EC1AAAAAElFTkSuQmCC",
    yf = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAIwCAYAAAABNmBHAAAgAElEQVR4Xuy9CbhlV1ktOvbpq09DkiIkUBI6kxASIH0DlAQiIK1wRfSJTx+i4JX7vKIigs8HXpXvqVcvrcC9agQ7IDTSSWgqCQQliDRBJKkkhDSkqVPNqVOnP+8b//rH3P+eZ+199tlznVTlvVrft7+1T7OaueZY42/m37QALKNk2wHg1pITlB17mC+Pp11W3X/LHyT32vhg48/5SOv+PnwpsHA70JoGlueB1iKApeqzvOzn44GatTB76Xzhd7suBR7+WWADgDEAwwCG/L54b/poDLrHuvvm70Z2Avhsc+PVcxscBU8F8C8ADg5+ipIjD/PlGwfgju8B924E5seARUfLsiNmqQW0IjL8+7L2NYD/7COBzfcCm+aB8SVgdAkYIRCXKyDax4EdAanL5PuNPllNvXDlAHwFgP8AcC2AhRIoDXbsYb48dl5WkVFTE3LGDcC9m4CZCWBuFFgeAZaGAYJQQCRqDHT+McJrVb8zwATUXH02MHYfMHEIGFsAxgjApQqACYQORjtd/B7Axt/z79sC0+cMPgjjlwPwVwHcA+DfAHzTxcVgWBroqMN8+cYBeM71wH0TwKExYHYUWCIAHYRLTlkCYgcIBcAgU/n3qy8GRu4HRgnAOWBkERhddPAJhGJDBxkvw7cqimr+zFM/ZLnZF64cgL8BYD+AWwB8x/dlWuWagHiYL984AJ/0RWBy1AE4AizyM1yxYAcTigW55xMbAkxEiwEdkJ/ZCQxPAiOHgBECcKEC4TBZcKkSv+mTieNcNPNC26mLNsj45QD8LQDTAO4GcJt/7iw2bfoG4WG+vAGwm9ExiEg69zpg/wgwPQLMjgALzn4E4aIzoJjQ9g4024uygkj+pyuAoX0VAIfngOH5NgCHMhAm8Sv2y3XDZeBhNIp8OzJE8OsBzAKYBHAXgDt8/4O+MVT0j4f58o0D8Pxrgf3DwMwIMEPQEYRkNwfgsuuDZLskip0No0gWMD/9HGDoADAkAC4Aw/wsAgZAgs2Z0ABI0GU6IVmKv+f28KDnHxkA/G0A8y6G73N9kOCjXnh/Ebb6OvgwX75xAF5wLTA1VIHPADgMLDj4yIA5AAm6aCUnv4oz46eeDwxNAUMzwJAz4BABSNDFTwSfg7DDKHE23MG5PqIY8A1u/dINs9dBdy8AgnGPM2NfUBrsnw7z5RsH4IXXAAcJviFgluAbygBINnSLWOAjGxJ4pgOKDV0v/OSLKp8iGXBovhLBBOCQM2ACoTOhnYrAdItYbCij5JFzRyIAqRccAnDAQUjg6UNQ7hsMXP0cRQAexss3DsCLCECCLwCQzMcPwUi2MwAScAKbfnY/YRLFQ8DHX+IAJAMSfDkAF13kLvleIjhjQQHxUVS3jjgGpKeeNzYVQEjgUS8k+PghONdhIwAP4+XXBYCHKIJbwJyDTgaIAdCBJx3Q2M8tYAHP9m4df/ylQOsQ0JqtRLCx30K1wtLBggScQOgsKBGcWHAJeOwRC0BSM1mQIKRbhh+Bj98JQP6t4U0APEyXXxcAEnxkQAFwoVUxID9kvQg+c1C7vidRbIDkc24B//hTQGumDcCWA5DgMxASdNIFBUI5pCML8v8API5zfEQx4BudgqiczviSnJhQwCP4BMCGl+wO8+U7AJi/W4O4YS6+pmK/2ciADsAOBhTIIiAJnPB7AvNjP+0AnANaYkAHX2JBAc+tYaJXOqBZv24Vc386XW5dtkHGW+4HFAJonpOe+YYQZAShgKjv3PNvPQaxVoI8zJdfFwASfPzMUwS3Kt1v0UFIlos6oDFdAGFcliMAP/ryAEAGNwQRnDOgLbdlIEwrIs6AZ/QgkMMHQF6ZAKQcJAsSYPwIeAIk9wJgoPK1gi7+PwF4GC/fOAAvIQPSs0URTPBJ/Pp3GSEGRHfBCIQ0xowBtUbcAj7ys5X4Jfu1HIAGQrIgQRXEsAFQIORDFhiDY/rMHmrU4QUgR08AkgUjCAW6CD6CkwBsAIQC4GG6fPMA3OXiNzCg2I9gNCMksmAAoemDzoimFwL48M85AKkiuQVMAAp8CYRRDAt8GQiJ67N6GJODAXAHlsGguscA2AJg1IPGYmxOpBxFWkRN9LsATgIwXnNs/v/5z/9XCf8BO3YAtxbc/46/KDt+5+ea1Yku2VUxHz/z0v24FwMGK1gWsK2OUUxHHdCBeRUB6OxHABr4ZICIBd0QWSF+XRdMTAjgCdTrG9cBNwE4F8CpDkICyYLGsuhFt6zs+gISwUen8zEAjgMw4cfx2H6O/90yAFo84Cbg4ID3/9TfLTt+5+ebnRABkODjx0SwPi5ec/FrYpmqSAxM8Dn60CsqAFI6GfhqAMiDE/gokmvEr0C4PgDkBQm40wE8zMFEUDKEVoxIMLl/KS73mE7H9d+vcKHQQcjwW0Yu9nP8m8sAmOIBuWY6wP2/4s0ezjjg8TuvaR6ABJ70vxUApGrm7EbGE+i472BAB+WHfqHS/eoAaEwY2E9+wLSXTqhI7CXgnB6LCoOJ4BiST+hTnG0HcCwAglCx3ARoZEVFXnBPp/O/A/hXACc7CPs9/i1lAOyIB+RDX+P9/+pbQjjjAMfv/PL6AFDs1wFAgs/9fgKfgdE/ZEpuiQlbwAde6QAMBgiRmsSwA9BY0JfjovGRDBMH4TlcXGhcBOc6HkF0gjPhZgchxTLZMAci/04W/B6Ab3t09EPXcPyflgFwRTwgJ2MN9/8bf5qFM67x+B/aW4XQz42FeL0YrRyikztUFw0704mf9kXgxhOAqc3AAsPyRxxQCs/PdXOFY0W1KHy3QIUGtx+6vdnx1vsB+dsTncm2AogglFgVEAlUWrOMB2RyEmMCGQ/Y7/HvKns6tfGAnJQ+r/9b76oJZ1zD8WdyQjYBh8aBhVEHjELouQ8ukQ7VRSCJAALwkr+sALhnGzDD3JAJYJHg9uhoi4bx8ytkWUtvHT/7+Zc4dw1uZ3612fH2dkQf7yxIEEockwkJQn4IQoq8unhAhmPRKKFx0uv4K8ueTs94wD7u//VX9ghn7OP4c+4G7h8HpseB+dF2AKlFLwuAIZ8jD6NPrOhAffmfA9/ZBuzZCkyRWSeqBCWyoYGQ5yQrBpDbum/ME1HoPo0XEkSD2zlfbna8q6+EUJcTCxKEtHL5EQjP6BEPyIgYAZBvYt3xHyx7OqvGA65y/7/9wVXCGVc5/sl7qxD66dEqiYgRzAqhN1A4CBNAAlDyAFI+iZ9/N3DLJuC+jcDUBmCWyUnOrmTYCMIOkNclLg0B8/RsNLg9+UvNjnd1APLmmQpFHyEBROuWACQT8nN+H/GAvY7/VNnT6SsesMf13/CpahGnZzhjj+PPmwX2MYdDIfQexWyBAwEUOQDrRDN/98p3A7dvAO6fAA5sqHJDBEAyoUVGkwEd6HR12XU4kwzfl6fCXTZzjy57vvnR513X7Hj7AyDvggAUi9EyFgiZqNxPQF6345nOWbD1HQ/Y5fpvuLa/2+82/vNHgAPDFQDnhoF5j2C2qBWCI8bw1eRw5CL5l94L3DEOTI4DB8Y9OWmsEu/zBJ3rgsaybqBob/7A4C7jtWcooRrczr+u2fH2D0AOQgAUCxKEP7aGgLy64+m6KdjWFA9Yc/03/Osa4glrjr+AupqHz1sEs0cxG0BC9HIePLoit9eNkVf9L+DuUWByDJgaq4ybGYLPAWgiXmLedUE7dwC7saL7CqfPKXi4NYdaykCD410bAHlDEsNiwZ9wAPYbkJcfz6T2gm3N8YDZ9d/wHxUA+739fPwXPrSKYGb+BuP3jAFDElFH9HIWwbzCIGkBr/or4J4RYO8oMOW6ZVcAuvi1Cgoha04BCwT5gfMKHm7NoRde2+x41w5A3hQZkADk5+cGiAeMx3+/7AENFA8Yrv/G71cAXFM4Yzj+otOAaQLQA0gZxaIIZtMDFTigKJV8H9Iq6aZ59ZXAvSPAvpEKgBTtBODcSCWCZeRYtpzrmLyeGNCAyFl1v+Hei8qeb370Rdc2O97BAMi7EgB/2QG41nhAHU9LuWAbOB7Qr//GPRUA13r7Gv9FZwIMoVcEswEwfDoimEP0shKKtIphaZQAXv1+YM+wA3DEdcvRKkGJADQQEsQuhi1Tjt95vBsh5nx2IO59SsHDrTmUOStNjndwAAqEry0IyCMICkOyiuIBNwBvPFQQT7gBuPjc9oRYAIHyOEL4vIFEYVNaOou5vCGE/tV/A0wOVcnpzI47NOri3QFIBpSeaSDUdYLOSWvYImSGgftpJDa4MWJbAGxivGUA5MAOc0Be6eVLj7/4Mk+hzCOYPYpZDBiNkLh+G/M3yFyv/ltgL3W3YQfgcFUhgRY2PwY+Z7/EhAR1SFyXCOb57r28QfQBsJQBMn5D4y0HYLPje9Cd7RIC0PM3EiMofF4gVCBp1P840ix/gyz56r+vAMjk9Gl375iB4+CzveuZdLkkEPJ8ZEfX/6R73vOjzT5Si9hucLxHAVg4PwJgRwh9CKOXK8YA4ZEqKZXSQWh5P+5AftXfA/uGKvYjCKn72cctbFrZNECka5L5CPwIPtMH3TVz17MLB5gdLgA2Nd6jACycHwLQxFEUSR5ASvARDB0h9AQb9bXIgCGk6lUfAPYTgEPAITKgg1BObk58srTJgG58WMkWMaAbQQT1nc8rHGANAJsc71EAFs4PAagQestgC1lsBJ4BMCSOK6dDUcwqqaFiQr/0QeAAAdjy+jBiQQeeMSBZT3nCPUDIa9z+/MIB1gCwyfEeBWDh/BCAeQSzgkjFfGLBBD5nxQ4DxN0wv3hVxX5TBGDwL5obxvVA5YqYL5BeMLd66YYxJpRB0gK+96LCAdYAsMnxHgVg4fwIgMrhUPKQ2C+Bz0PmBTqBMQehAbDlIjj4F80KJguSVZ0FuXpjoCOgXawLjALhbT9eOMAuAGxqvEcBWDg/l1IE05Ed0ygZnyHdz0VwCqEPIfNyx0QQvvLDFQCp+8nfZk5und8tXwIgWcHSNX0N2CJmnAl3v6RwgNnhl17T7HiPArBwfghAS7mV/hey2JS9FvM3BLpUUi1YwDRMXvkRYJoAlAh2l0dcZ04s6JUTDIjyBcrl4yDc/dLCAdYAsMnxHgVg4fxwKVwJgGEJNmWtxpQMpX9on2eRhVA+O56AjMfnP+e3Xvf3NwG4xIPTleiY55bpGh6UbafNU0l0z0p+5Jh5HqYJ6b51nP6XP8cx12XNHQVgIQB/bFPVg2OC7Q+WgVFWng/FvtWLI06uWh5oguKEcXVS/9sEAF//VGD7t4ETDgJbF4CNi8CGZWBs2fPL/H6Vwp2KEtVk4fJ+v/EIYPN9wKa5qu+IncfPwXHVZe/aOL3EbwS7xv8A1rQvnO0j8PArTgTGZ4BxFv9mIxhOCGsv+0OPYDRghcLfkWkEuq0+G00x4OtfDGz+d2DbHmDLjL8si8AYP/7CGIAiEEMTG92zXqSbH+d9R2aA0XnvO+JjthiIrOVDHHPOkBrzUQAWAPsZp3oPDpa/Xag6EVkLBK+5rAnJC3/nYk/APD704WiEAV8OTHwX2LQH2DgFbJgFNrBhjd8r79deGoEwsllgNBOzy8CdjweG9wBj08AIAci2D6HafmyAk4/Z7SJ72hGYRwFYAMDLTwOGp4FRFgD3HhzqRGQiyeurqOdG6r0Rm8IEZjzRlkiqCWoEgK8Axm4BJu4HJhyAbFhDxmbDGnZO4j0SgLGDkpibgEq66TJw/1nA0F5gdLpq+zDqFfd5LMeWqu5HNST0uJOIllg+qgMWgI+HPv0xwLA3gWHpW2sC441gCECbmKziaGrnUdMO4aHeh6MxAP4SMHI7ML4HGD8AjHvHJGNAgpDgY/ck3stipRemvVhc+uASMPUEYGh/9dIRgGx8Y+MNbR/00uVtH0wEx94j/v0oAxaA8Ed+GBieAYZZg5kADC0QWGOFzGJlcGPzl1BxNLXD8sk4xftwNAbA/wwM3wGMUmxOOQBnHXzetIYvibonmSiuYTNjriVg7glAiwBk0fNZH6+PmX9P6kfNmCXGpftJ7TgKwBIAnln14BAAYxMYm5C6RjCyCoOyr0qkD/c+HI0B8DXA8N3AyCQwesD1VQKH7EcASm1Q+y4CkN9pUKiVF5nLvy+fBbTUd8QBaH1HvNBROiZvfsNnrF4kcvPwpdsBLBeU18Nf7AB23Dp4ecHC8oBgUlJJecLS+7+WOpE3gbE+HKw+yoevCYkMGKqPJrdEKARutaFYRs1fiEZ0wP8CDN8LDO8FRqYq3W10pgKgfYLaYCzootgA6KXaTA90y374TKB1sBozy77xHFZ536utRgAmEaw6g5kUSFZwSXnA330qsOlfgHMPDlZesLA8IOjoLypPWHj/11EnCiVwkz7kAExtsGraYUWdSDX5TmsagL8KDBGA7Bd30JsW0oWivnEOQNP7yGTSBR101AlZSUtGyfgZDkCWY1HnJdcBVe6325hTvelg2CQjZNDygG/2An0j1wKnL6y9vGBheUC8prQ8YeH9X39OVQSc7Mc6fCaKvAeHdCIVf4yMYCynTpX+nb97NJmlSQb8r8DQHm9YOFUZTKOzoXGhs6AxF0HIexcLBvWBuiHN8s2ne98R3qc6L4Vyb2oBVjfm9MIFHbjDCh6kPOBbQoG+oW8CO5bWVl6wsDwgfr20PGHh/X/1iaEIuDcCTIW/1Q4rFv8OnYiW3c+W2iKwUjKbyjQNwL1uuR6sAEgDgq1brXOmV81PxhNB6DUDBSYzQJwFtz623XcktX1Q1VWKaTF/zZhVazBVYA1tX5MazsGvobwe/jQr0Ne6BTh5uf/ygoXlAfG60vKEhff/rSe1i4DnTWDUACY1guFTDqLYdCBvf6DJYSMYATBfOx1kLfj1v1axH10nQ3Sd0GUkBnTfpemtBJgseIKQAHLQcVxa2TnuMW0Aqui5es8xBIegVdVVE8VhzHnLh65WMB9An+X18K6aAn2tO4ETl6vqbKuVFywsDwhevqg8YeH93/Rk70JE90nowxZbIJjvS3WYNSGUwGHJTpPxwwcbBuBrgRYBeKACn7VtpdUu/c0NJxO9BIxcKu4TTODzbkonPLoaL0vyUQRb2y8HsL1ckfWzMeuFi40Qezqi+yiPhyt7FOjr6/gCFwgP7Xb5vssTFt7/nQRg6MGRWmDRoeyTlpgw68GRTwgZgo1gGmXAX6/8dtaylSKY/koyID9BhzML3q1gAos2AcOrZYSoq/pJp1VtODRm9Z3LS/7WjVkvXOzEtOpKyGrlAT+4SoG+VY8vBGCvy/dVnrDw/vee65NBJiAjBIVcAJQjOm+DkCZEeiGAMw6sAwDZsJrAdhFM9rPGhd4904Co5oVuCZPV6kD40Ec6+9W8dBTBsfdc3nkpvnB82fp2RPcs79dHgb51LA9ofsDV6vut5/3PnxcAmLVBiDqgevDaJLkYrpuQxzcNwN8AWgIgRbB8loEBzXDwl4cGiDGft58SCOWGedgjvOJ+bPvgRkiuA+ZjzhnQQOiFNVbloa7l/fos0LdO5QENgEXlCfs8Qbf7HyMA3QVjYihYhLENgjX9y/qwxQmRU/asfd0ZcLU2CHVGyusJQLKfVi98CS12T5f7iECkHpsMkAhCF8+nshWH2I/jXsOYO144GV/9ApAIrS3vt4YCfetQHtAA2G+/4PW4/2PPbzMgmUMi2NoeSCRxIt2/FvuxWURIWCXg357gfTjEDNIHnTRXRCpH5ugKwGl3HpMBXQc0v6WLYVm/5limj04rG762K2uYY9jBkr9+rI03NL5ZbczS/dJ+LQyoga4o77fGAn0NlwdMAOy3vl/T938KAcj121z8Bn+Y9eWQJRz8Y6kNagDh2ey5EvxjxQD8TWdAuneCCO4An1vw5vdzQMmdktwq7pLZQR+dM34+ZumAxvY1Y04uqOAJ6FsExzeto7zfAAX6GiwPaLWR1lrfr8n7f/Rl3QGzmsis+/uO71V9OFgP2gpPhgr7TGRqRUT6dyvr4aIs/pm/2zVUNbBSv6G8e5pEv0Cvec7Po7+bTtjlBRlkvAMBkDeQyvsNWKCvofKACYBrre/X1P0/oWEAnnFD1YdjhtXxR73mX10FfCHHE9pVWcGAI/S0gKsfA2y+twrFZw6Hxf/F0Pk8Ri/kpGSnMuDx5T0iACgQHioo0NdAecBUHW6QdsV2/cL7v/Cyqr5gnc42CCOcfX1VIZ/V8We9IDmTzVXwPDJiXuKXPxtDBma8+lzP4WAgKkPxCUAPE4v5GzEuMX0PYJPLhB6FJsc7MAMmkVxaYC/K9gG+F1++8AQ7Gwbgk78I7GFpXgIwFiRXOwaJZPUbiR0yCUDRk+cHf+YpwMj9HgfI8ClGPyvsSiH0WSKRuYlitLb/zHM/JOSs5C/YIC9cMQDZr/dwxgOW9gtGYUBi0wA8l304vDQvAchilFbpIBQhZ7Ejq6ZQ0/Yhil8y4j89Axie9DAsD6FX9HOK3QtROTFkviN83kG4felIY8DCeLrSeMDSfsEovAECUFsTjHD+tcB+tkFgcXKvBRir7qtFl9owmO4Xy/1G3bAFfPrZHorFNWBFwHjQAFctIghj2kBarw06If/+MM9ZqTN6DgsDojCerjQesLRfMApvoGkAWh8Ob/tgAPSKWCp8ngNQtadjmTdltvNvn3peFYhgQQgh+iUmEaUAUoXM1yRLmWuFLaE9Z+XIAWBhPF1pPGBpv2AU3kDTALzwmqo6qtVh9kJErAudABia38TC5wJgS2xIhAwBn3yhByL4EhzXfRXxYsDTJ4IvrNN2JFMxZcBzVo4cABbG05XGA5b2C0bhDTQNQLZBYH1AVsQSAAU+imI1obHyblnjG/kJk3U8BHz8xVUQAhnQIl5CyNgKAGp5LKSSCoAySh5Jj79vTagcxUaIBeRNe79g9gq+DXig4wGzy+PONfT7RWFA4noAkGXZVAhcBckJQgNgrLiaNb3paIDo1vHHX+oA9LQBi4DxJcOUPJUnTgU2NJUyROs8irGARxQAC+PpCtsFd40H/AEf0gMQkLgeACT41PiGoLOKqyrJq3K/Ya9mNyr5FusN/uPLPIeDa8Bc+w3rtyl4VFHaMZc3i9RWBM9jjzgAFsbTFbYLRmm/YBTeQNMAtD4cBKDXBTQGdAB2MGBo8SCLmEuS1AFVAJ3A/NhPt0PoCcA8bSDG76XI7aySg6JYuGfKwJHFgH0E5B3ueMCe/Y4L+xVHAOZ+9EHcEgQgwbeiEYx6jwTdz4qfu7EhEJqxGqruf/RnHIAEnxgwBM0aC8aUAYWNBRCmoIll4HTqO122QcZbrgMWxtMVtgvuOx6wa7/jwhtoGoDWh4MBJ16WN4lfr8AqI0TVV1O1fa9BbQzovkAy4Ed+NgCQUSxZCFWvCOaOFREXyUwZOPIA2GdA3uGOB6wPaOz+QPv5S+MA3OXiN9aclghW+d3IgupBF2pPqxcxGenDPxfSRh2ASiKKiVP2PaZScvAKoA0VDc6cOlIB2GdA3uGOB1zR77iwX/F6AFB9ONSOQW0frA50sILVcckWJyIDSgwPAVcJgFbYuZ3FJvAlEHbJ3IsgJLGedeBIA+AAAXmHOx6wo99xYb/i9QKg2iAIfDJEJHqj4SExbEty0gkdhB/6P9oZbBZIGiKYVb9GKaN50lRHBLOvhDxh/5EKwDUG5B3ueMB2QGM/grb7/6wHAPNGMAY+GSGUjC52VX2f2CD4+HO0gqkZfegXKgBaHkcWtS0AWii9xG1ImrLlN5XR8L8fmQD05BVrmEENmpYSP9QX+KHiqj2/82+HqqDWwnbBRfGATdzAegGwru2DpRq7Mzq2fpAf0Nq0Rl2wBXzglZ4yUAPAmDSVWDBPHQjLcgTqOZ6zUvdKHh4ruDCerox/Dnu7YqwXAC1NI/QcEQuK6WK/kdgCTGC0PYAP/KIDMBgglq+hIkrOfsaCviLSofcJgJ5AdM7kkSaCj/HqQKVIGvD4swF8bcBjmzjsaQ2H5D/6acBd9wALB4DFWWB5AVherMp4GKIYEOp7+26UF0aSfT/xYuDG7wDjrIpAERytXf2vajj7ueryQXSFl10K/ON3gIWDwCLvjfGB8Z54O+Ee4ve6513uB2R1yzsqC+twbC8HcNVhfAeaBuDP/TvwtS3A/ePAIfYFVlPq2HHTuyulZCTlhbjhETF5yxTQGgPGhoHhIWC4VSXGD3n0tLkMHXHxu+YyB+MlPwDuZs5K6FlsbCzdVO9DuKfkHM8AEkP7B8fOkwDcD+B7np42+JkGOvKdAL4E4K8P0zvQdET0b14D3DgB3D0B7B8HZka9WzrD88N6sFm+YcUjrn7E1ZDvMtF9DBgeAYaHgSGB0PNHCD4BLwLRsByAyX/ij0/dDUxuqlIG5hix7eFhvLcOVUAtyPSydAFmOQNe6EYGV/9ZESiKgIEgtbaD/gHALQC4ovY5r5KwtjOU/XfTAHzzLuCmIeDuMWDvKHBwpMoN0WQzNtAaYSs0K4ZlOSAjGG9kPjCBRwZ0ABKEBJexYAZEAU3A7Oi1BeDym4EDnjQ1TwCGWMW8MXcKks0YOyZNlQOQjcgYIUHllEzYQ0ktm+r6oz8G4F4AXwXwRd8/kO9A0wB8y65KmPxgGJgcqYJTKYpTv2CCzyddQJRDOjKivn+Deh8BF8BnwBtaCUA+YYEyAU8h+c6Az9gNHHRmrgOgmDA3jHQ+iWupCeUAvNSrA9HNwqx+muk9nJVNg/CTfrmbAPwbgK8D+PcHkIibjob5o13A3XypWsAkG1cPA9PDFQDZM1id0i1KxsWfOrKnAFXlifCFFMMRcASigOcs2MGAIfE9iWXplS6On7UbmPaUUTXQrgsVMzcRj5Folg2V5ayUA5BWYKwOxKUafnosWjcJwk+7W5F2EKvlE3xcXaNYfiCYsGkA/smuqug6hcleAnAImPbO6YwRpMgjCAVAm/yQmKTv5hNsAf/i7SyNBSl2a8Qv/4/M1yF+BZSYlNQCnnVrpbC+mToAACAASURBVJcaI7sOSEY2NpaDXLqpR+vE/OVksDgImgGgghHoYJbTWc7oJtFWc65/cg2AYvh2ALsB3AzgVv95nS/f4QdsIkT9T3cBrGtITWZfC5hqtQHInsEGQn3UDDvEDEY/ICf7SxMOrAg8T+c00JGkvHGd2DABUYZIAONzCUDppCFhSukCBsLQrFtZe/IixYQpSyEoJoqnuPWrVRAubQh83HNlZB23z7j1ywmj6CIIqUPxw2Xeu9bx2jx10wz4Z7sqTYZaDD8EIDuoE3hMVEphWg66JIp90k0sBxBcy+iPIIaT1RtEsHS/yIAqw+VSNPWQfe5tlVEk8auXgVa5BUsEJuT5uoliAbE5AGotmIAjCPnR9xDG3TQernYAUupTdBGEFMf83OkApHG+XlvTAPwfuyrgSZOhas3u6cwTsUBVn2gTwyFMi8wjHZAA1M9fYGHDULJD1m8Cpa8fRxDad+l+Ykf/3XNvd11U+qiL39SxXevSsshdDFvgbI1O2AwAtRZMZzTBRuDFjxe1Xg8QEIB8yyj5yYIUxfQIkfkIRnmHCM712JoG4FsdgHHp3ACoMH2G6jM4lWzoQarSvwQ6MSB/vporVaFkh+mCLlpVR8Z+dqDZLoDOpHSiQeAFDkBjPrlgCHgCUaFifg67H/9uYjn4Ai1vpTERTAASBaoQJBAKeNqHlL6mwPDZYAOROag/EYRkPX34MwHIvzW9rQcA+TLpI22G7EcQKlJGsYIJhC6ClUMiXfBTbFUQAej6nPS/OuAl9pOOqIc2BLzg++3VmWgIEUz82cRuCAtLIHQQm0gO52uOAb22sC3JEWgRfPpZf2sQBQIgLydPEIFGwPEj8MlF2bSbsulghLftqsCXq9HGgHysznrGgi5qzTUTFH8FLhAUn3hIJwCN0HLncw37qaF2zoYvuKNivmQIuUNc7GvWt6sHNs26twA6vhyq8NEMAHlyntFrDCcQehyaPTl+FwAbXDcmAKMRThakEk8Q8kPg8SPL0qzLBl+A9QCgR6uZGs3vfHz8TtBZvkgGQrEPBVAUg2Sij50QAOjiVKI3saADJRm7dSLYWfSFDkCem/dhZeMy9pPY5QvSDYQyUJoDIK8qMezh3wY6fSL49PcGgCAA8pScJLIgAUYQEmz8RPA17StvGoBv39W24eREiBoNQSgWNI1HBkdgxJSw1AI+dFIbgOYmkjimQ1r6XXC3rAbCHycAgytohf8vsB/r2KRaRq7zpZ+D37HMX0s3DDcCUGLYaw53MJ4YUODzusqlGCQAOQCejuxA8UULUkxIwAmMAp8Wa3qkN/R9W+sBwOhIEPjk5SLr8HeKFbTQfb77csPIMHGl/4MPbReslPhNe4+MiTpi9AFGV4nI7MfvagNQLh/pfrYnDAS8aJQ42A2w4em2cAyWQUuJVQTGWLs1uL7DG9J1RjhA+jvYk4t3KXeMqijpzrud4At9z3XtP16yGfjKZmCGooYh1tZzvv8xXPFl4PoJYC97k9FlwZWD+Azi/deMZWeP13eQCGEyoERudChIjbb3mJYwH7V0QIKuCwj/gfMj0asn2I0FXRSHXfL/iRkNgLyeVj8ccMY//J1fyxzTAXT2+xoQViKYD/1hDqLxPiYxTgSvQrphphG97tz4Slqafnj7uk1kIQDZrvWTw8B3jwEW+RLxPgSiCERdPwPR7+wCPg/gulFgfruDkOMQkFc5x84e708JAMmCuRNBXi4TIg5CGRzGiBGE/D4E/C2r2vcAYJoify62i0aJSMhB+2IHoNwu0fkcjQ85pu3ack5nIBREqneYFyWLkAXIJHESe00Cyx5QyeL6F/tyEcDcrOW2n7fX8df0mME+/vQ/PQjhoy3gzo3AISYf80MQaQx1peH9wb7v2mrtmCBkIMMejp3jIJD1MsaxaMZ8v5N/67INAsB3BAYU4JL4DSo1J15AFPAEwuQHZJzkKfUAtOHLJSOQRWndBYQvCQA01cfnNopfsaCJaD2baBn79QjSTiOEP1EcawIpkq2kegBTNgHWEpOKF8Uwq2NRFPM4AqCf46/rA2U9/uVDvurB01zvAJpiiwOl3fEeciCGF+Ij11f+QkbSfMPfIzqw57mEFZ9Dl3Ps5HXWAYByHJAJKV7N+s0cCQQhwSlfm4lGZ0KB8C/rABgZUS6ZHITBSEhCowUYAAksF7cStWREyxRwtuPpOlgw+5s9sq6OaIJIIlUgEhA1edoTgHxa9HVw5jibZNF+j/9yGQA/7pbujZ4bwv2+cWB6tFo0NzYnkxFA+cvEAo43VBoEo2e+48EMXEOmD9F6xhCE8RwZEJ80VblKvDlmzwicfqy93/o+8K8TwB2jVSgW138FrJQTXBNlnJgmrjZwanow9CBP/rL9wF0jwAGWDtFyoN9PHutnIHT05mPXz93dMGQAPniJsjiBXiTbxDZFMF9NLUPQxKR5qezz1Y6/YZDH0D6GkdAkYJIvRalAdHAMmPZoYhb6NhDWvEyf/ma737CXN7R1ZC7hUbPgcFgqt/ZZjADnM1xqEVhYBpb4CUk5UsL7jQvj///5buDrLeCOEeD+YQchYwG9VIfyg1NaZszFiCH6DkRGLze5/dgk8IMWcMCjdCiCzR8od1B8OTwvJM8JEShFut1fzMhi+eRJr6LI7hYP2M/xVLwKNoZjUTwRMAQQmYyhWGQxsSADOflZ4kukj7PhZ75bETjBpkAGahMkcrGgwhsXeCyBHBj1wmOBQwvAwqKzoFeRV8ZaerjKYAuirmPY/o9X7q5Cyr7fAvYMAftCPGAEoYlBiVtFwLjtp2U4irj7yOANbi+crHyrfCbTquJV44O0F1FrwQGIMZFqdQDyP/gGSZ8TC0ZRRsOlVzzgasd/u+zpMByLehAfCgMQCDyGZJHFCCgLZ2f8mgI5qauEcVx9e5vACTgCTwEMWr5TdIpWKJb5MvrnoocDswvAPAG4VLGg6UKeqmi4iuDz4er30oX0FP7u5moMvIf7W8B+jwlUNAzFnlZCIhvGFRCeWzrgXSSIBreXTFZSgVLHAp4UHOFuociEEsn2PJwl/XEk0dzfSojeerFg1IOo5BKAveIBex1P67lgUzgWQaJwLAKRH04i14ItgDKEtGsRnWx49b2Vkk9wUefTGrKCF7R0JxZMqxN8cmPAxWcAcxGABKEAKPA5u9lEaAbCmKMI+sDN1X3z+ro24wEZFc0VEE64ABgT180PF9ZdBcDb6JpqcPtPk+1ACbmKjJnllwyuILunEAWjZHkBsrsRUnfD0qEiC5IJfyisgMhzWhcP2O14Ro4WbASgAMQJ48SJwchmBCDFa8qpyBbSP7OvU4PQ0p2W7+LSnSJUFOrI4V7w5IoBTQQTfJ6oTSYk2mQcpGRyH2syGjIF6EM3V/fM++C1CfwUExhCsmzCaQT43lZC3e1hBpEHh36XEqrB7Scmq5dV0XZxmV8WuDFzAF9iwhow9seAGoBcGtKjqAc+1l9rLb/1igesO55ysmCrC8ei6IxRMAKTWNBi6Xw98xNTFUi0jEcmpYgRAPhddpVi9OIEPP5cYD4CcLkCooHPwaW9kV+iwWrQHT8uA1fd3F7DFvgUHUP2k8jTiogAqLoxFpDgbMj9jXSuN7i9dLIdaxzBp5XVBMIMgFEnFAPKT9qPd6A9BIGI7MfPmf4U+40HzI8nWgq2PBxL4FEkjKJixGRRFyQQPzzd1iAUzCAQas1YOmAEoFjwkecDC/PAwhKw6CxIkCXwOdVJLxTobMjBdyIgfvimNvNJ7Evf4jWtdnRYD1YNGVuG93VWuWs4Jf+mlZCCZxwP/cnJ6mXVKk2+tK8lQQVHRTGc64SDAZB3Ey3JcxyACkToJx4wHl+YwqloGDICmYmTFgMQFBET8yyYzyAG/AfWX8mCGQg0BTRoHwt9KVaPE/HQ890AIfgWK+CRAaMRYnVdxHbhdY8Wslw1V93UDsmPIj9GxgiAioRRMIJNvoti+SW/Ikd0gwAU8+XxJcbGITJPDvI6XdCFREFSknTB83xka40H1PGF9dnycCxFwygkK0bASJQSVAbAYeD98xUAe5U3jKIwBosSgNsuABYogl3/IwgFPrOIg1Xc4ZrpAsSrvruykl2ucykapkMMh4CExD5DwJfWAYAxwk4MKPAJgOIjGSEGwuCakRhemw6Yv0UUwRf7L00L9pnsNx6Qx4feY4O8pDEcixOjsoTKKpMYjSFYYjOC8Eq3Wnnr0YYS+0Tmi2HysrPGLqwASNYzBnT2Mz2QD91laxLB0gs12GAh81cf/o/OcHyJ+qj0S/zxnhUZbSyYWaL8+Rq2S29wowiWkJPan4MvgrDDGAlRe7KIywDIgR3meEDWg9HbJgApNTkXo8o0i7oVgxnEgFr8F7jEdnU5GvqfJQKQKyEOPlsNIQvyvupAGHS/Okv4qv9oh+PHxMLk8ggBCRxvAmEN+AiEzz2iQfQBeNmkh4K52hJBKOaNe/FSLobLRXCz43rQnu2yi9oMSMDxs2jo8303ERz1wsCGZECF4kd3DwEYYwJjhoNlQrgIjlYodbBPrwMAZfEmyzcIv27gs6XDzC/IR1DOgA9a6DRz4wZAsZ+LYXvQYsHoD4ziOFklna6YD3+nnU6dZ7bGDAcBUImIAmEUw/zbJ1i/scGNDJiLXmle3RhQ+l/aq57gUQCWzwwBKPeLsZ/LFrGg/ShRXAe64Ajkv30kALAjF8R11Dy3K7KRwJcsUTaqWScARou3w/INVnCH+A36n8RvM3nB5XP4oD6DATBYwGb5ajlOLOh6X8JaBKRG77+7ygGYp1bn+V25/01AzBnwQ1ypanD7KWfA1QDYC3zJIj7KgOUzc9nFbetX/r+O5biwNhyX5uSEDr5o0xsJwLp8/m4A7GaJUv/j3/5+HQFYJ3oFPPkho/hNeqBcMkcB2BAA6XrxmMBkfFAci/m0JpwzXw0TXvXtzrz+PKc/Ml/ugzM9MDqCAbz/keVjjGcQA/YLvjoguo1mRslRI6RwfsiA5nqhL5D6nscF8gfTdfxpS+/hLzvWfzMQCoB1Fq/8b3VWaPIDZqsRV64DALsZHVHs1gEvsqFAeBSApQC8pHK90Oql4UEAyvCwNeGcBXNLOPMLftgZsI75ouUr9ousp2TEyIJ/sU4AzC1e+WIFshyAHPZREVwItrrD3wGAhibTYBhxVpe/xePyrNBuWaoNp3DgFwC81O+RAepK/a5Lfe51jxr7JwA83nPXYgq1asl0yX5N48+f4VEGLATlK1vAo5YB1gBSRmsM+NFE57lcfPD5pPFWCJImtyvGgGfOAacBYO59zFglgHgPefZsXV6/gPXBYeC0RVgyJNOGYuJjPka9eHWgjL9bWzhWk0/n/wPn+k8bgFNmgYcsVflZnBRmIShtJM/m7JGibGBoOIIez9wKPP4AcNpylfbNlGfdI+9NjBjz8JVzppckZuJ+dBw4aQ44drk6j1LIY9JkPD7P4s2lwVEGLHwJnncscNIh4Nh5YMsSsHm5ndOu1BGFThJ8/K6JrZtoslST2+XHA6ftB05ZAE5crgAups5TfaL6EF+UyIif3gAcOwtsXep82eIYY9JkXpMgMp/AeZQBC2b8OduBYw8C2+aALQvARgJwGZhY7swEzbNa88IRvAVO1qkF91J36DNOBE7eD2yfB45fqphLnevzdGeBKBfL8UX5/CZgyyyweRHYsFwxYHzRNK6oetSBMDLjUQAWTPqPngpsnQK2zgKbCMAlYMMSME4ALrcnR6JYQIwsoUnjpDRstOLy7cBJB4CHUGwuAtuW2nUDVH1EFUhycSwWjGD64mZg0xywcaECoI0z5P3X5P6nWlHdgHgUgAUAfOYOYMtBYNMssHEe2LgITBCADkIzSJZXpCOnIg25uPrhgnupO/TyhwLHHwSOmwW2LVSik2pCrDsQskzNIBGIpBdGI+VfNgMb5oENCxX4yPRjPj4xaJ0+WGeEHRXBDUz2Mx4FbDoIbJypADixUAFwzAFI8KUJChMV2SUaAGc1cE/xFJef3FYRti64nkqWDrqqEhbrsm5zvZCdPCd8nHzJOLZuABRz9hTHZwPL7LnLnoNMIY2VyaKcjtZLHOAbNgNPngKe4BacfGF1pnydD+hphQ/8XV5UiEueLGnDN1tWXj/3/4cTwAUzwGPcRcFJiDpPt3FLmf5vjwE2HAQ2zPrEzDv7OQg5OSM+ScYQy5Xbo8465u/ZfLTJ7fKHAdumKxVh8wKwealSE6inEoSy2MWCdbUHIghv3AqMzwHji9VLZuDzD8cXxxWZs5c7apmW0fMBnIHKn5X7d6I5npvRz94O7LgXuGIReJSb+Xl1tzqflybwRwqf9i97BQRWomWJQ7oZVFtJoqDX/b/oGODsvcBTATB9gsfGqmzdjtVz+G+PAyamgYmZCoDjFE2anCVg1CeJwOMnTRB/DmUINVkkgia3y08BtkwDW+YqAFJFMD1VAAw6XG61R31O9/fdrcDYPDDmY0zjc1UjivBuAMx1QdMB+WAYXU8dhEU16dOSkppbcHFSrng8MHwnsGMPcN5ypURHp2xMIa7zDz2z8Gn/kVe0YomO0wEwBYKujL7v/zHA6C3AxfOVh58g5AsZxx4fZM7sf3h6BcDxWWeGBZ+cMEFiwGEHHRnDzun7ONHs/djkRgBunql0VDOSHIDU3cxSD4aEajhFXS4H4S1bgVGN0V8we7E0Fh9jVDG6Obr1LJMRwn+kOCaTEYT0dsfqZHXl/p7PrLi9wIY7gO0H2yAgCAWCWCowKrYE8nMLn/a7PQn9X7zIJPPkCcK+758y7x7guNsB6l98gZjLLYet3Ay5n0sv4R+fCYxPA2MOwLEAQLIDPyP8uBg2cRYmzFweAYilKkn+OC8/Fdh0CNhEA4nGA40kd6FES13WLO8v1qHKAfh9B+DoYjU2Ak/js/8NAIwg7OUb7LCC+WAfB4CpBJoIiTRNRmS1l13kqWh3Adv2A8cdqqp1MB+aIOSxWv6pq5D2kkIAvt8rF7BLJksN/jMqfa7v+7/Ak4B3A6ceqpasKMq5akAmlLWY37t8ZW97PDB2qALg2BxgAFwANEGcnI5JcrDZRPlkaXL4u1KJUAfAjbTQ59x6dSvdLPXAgGYshZWR6JIRaXB/NwFI8C1WwLMXzMeSwLfcXuKrA2G+wrLCDcN/IIg4ERRn0qvyySAQX6mG1XuA4fuAbTOVwktRRr2MLCoQyvEZ/UY/WwjAj3jtFJZkU79g1ghkgEBf98+0Umb/3A2M3lkBl/fOcdMok2EjkZyv8773LAfgHDDKjwNwxEUw9yailpwdxBAEYhBbAuGzG3aKkQEJwAkCkOCjlb7Y6SYyf2UwlAS+vKYnAXjfNmDEX7DEfA5CjUcsnzvbu1nDtUMmCDkRZEEyGdlAk6G6lQTSa6m0MP6HuY73AxNTlcJLZ6WOJYC5/CNxLpHMgdKIKNl69Qvu6/75AjHOiTU87gKOOViJb748BKCWrnK/maTA+58AjM0Ao7PA6Lx/xBAupoYDC9okBRAmPdBZ47lNA/DhwMRsxX7mPgl+SrmK5EaRNRslXFQ9CKB9DkADn79cZtkHFkysJ103eBbqlh97DpmTQTYgk9VNxu+xYbXKU3lhFoJPOgdFGY+lPkgQxokkgF9Xgj4AvfoFs84eX4Ke9x9fIC+tRfDxvvniif358sSir2LCj5wNjBKAc8CIi2AxxLCzIAGY9L7AhGIKgpATw4l8wToB0JjPrfTkp+SLQbHrOqm5jNyajS6VCMIpApDAWwQ4LrGgXqzIfnq5cv0vN0ZXHTInME5GBNLb1DGdOYQsI7AfGKFjlgqve8wJwG4T+fuFAFytXzCLb+VgWnH/fIGYfc46Hs7iHC8ZkPcdXx4VfVXJw8+cA4wIgM6AHSLKWZCTESfLfg7WsIyRF3ckiRQ+HACXkwHptyP4KHrpJvKVGnOhRF9eBF9wE0mUEogz2wC+WGI/vVxiQQIxAs9+rmHA6E1YFYB8DJwQMZl0OrLZ++i7sfT8zroYHLS9df4RACWKxSZvLXzG/fQLZqk2gqn2/vUCUQ9UZaM9wDaPeSPrC4A5C1KV+NITKwCS/SiCR/jRBDlLmP7nHynsxno1IPwJSyRpbiMADXzuPDYfZfBTEoAmcuVQdiaW0zwXwQsCYDYmMaDA1wG8TBSvaoR0G77EcGSET6hjOvVApfRPAUN0zjr45JzVcSqiTxD+VeGzXku/4Nr7JwDJOkxFIwt6j6+RqUrlkO4bXzp1gCAAv04AzgLDDsBhKugLFUvQUhTwCEKbnKCw14HwJ9cDgGQ9WegRgDI8XEcVEDvAl7lVlglAgi+I4CR+Zf1mLGgMmDFhBGFfDCicRJFERviSABjLS7FC0MFKMU+07wOPE0kGvaoQgGvtF9z1/iODkwn3VWoEXxres5ib9xx1wZufBAwLgAQexbAD0JiQwJOuJBA68/H3Zhk6+3CifqqwWNMKN8wjKgbk6gWJgC+FMaBb5vJVmsUbV2vCqo3cRWZcCIACoax53+ulkqNd7iqOcU1WcC9cxEm5kQBUdZ+sTnSL/jEtTWngi21jhJNJBivZBukXvOL+yYBkcOqxKjJ4AGgxzMrBVwdAMmHrZOAYF2l6y/mwV6xD17zmWo6MbRyeWtOHwxJ91IIhr6rqZS70DPPLXDVUrfBwzHKr1EUp6/h0T/6L/GcCqslt4IhoTcwdAqDSs7I60WQH6R329pHuFyuXDJmEjuOSbdB+wSvuP5bGUjmsA5XoUvcvBXKKAQnApUdXwah0b8jXR2YzJTsC0ZHB33FL+2yiX3h/1YeD1fFZGT81g/H6yqkVa9YEpqMhTADle8erHA6t7Mh6j4ZBXdBGjFyO4CSIm9wGBiBvgqxwIAJQlXIyEJLyI/i0SkAG/FbhaEr6BXfcv+5dLKhCg4z1C1HEBJ8+BODQGZXfk/quAZC6ketAZEQCTWAU8PIJt0fgwHzZvVWNaKqi7JLOmtDWFy42g1FxH/XfqGkII0C+a0tnDkfsGxQjn3VPsk7tXmuy+Xp0JhtoJosAaFcUAJUYKiYJxcqHqKAH9rPlG2cMrmCUbMX9guMLpGTcCMKDlZGhMK8IPnPIn1X5PA2AwegwEEYmDGBMjOI5whGQP3NPBT7VJlRNaKvF4t2IWHbDErtDlSk1p4lJ7/zd246tglGZryIfrFhQ7pU8WCAX0ZENG+57U14Z4YrCeLrSxXdev6TfLwrbxT7znMrfKQXfHLQCnyvmRIv0Q3430ezMmL98P393G3wqz6am1NYzzoGn+svqRmTAU2citctqAX/2EI8F9ACEmLHXLZGoFxtSl2xyK2bAYwrj6Xr12+1noL/jUTCD9vvFrn6u0v1/nvGkaoVBAQi0eummMAuXQHMWJAA7gCixG8U0gFfcXdlBKk4Z6zELgAJfZEKrxpC1xOIl/+Sk7jkcdYlSco90y9+gK6vJrRiADD0piad7RuFo3udNCgft94vCdrGXn+tujgV3QAcHLcFnroelivHkchEL8ue0uQ74S3eubAITS3IQhKkMRjBMokgWG3L//2z3VSnP4VDgQWxUEEUxAZFHL0eR3HDfm3IRbDHkBfF0zy4EIKNhSvr9goGEBdvTz/MIYQLQdVsTwRTFDj5jQmdArRDYJQNDSs961R3tPhx5NXoVgoxleHnarjohgLec3D2HI492yQNvIwvqO9fJm9zKGbAwnu6FhaP5pFuMg/b7tTbpBdvTz68cz/zI8azVj8iAHTqgmFHXDUB89R2dtaC7tUGw4kDOgFb0R2wYRDGZ8g9O8aU4XwPOczhiwGlMjqqLWiFYGu570wADFsbTvaxg8nkow7E8nM/atfKzln6/1mS4YHv6BQ4+Z0BbqHcd0NwwYbVD3+1yWhXJxPBrbq8AqE/XApSqAxiBV2MZ/54DMOZwKE00rnDUWcR5KiV/brjtSAMALIyn+/mCyeehjIYp6fdrvVELth8RAClyHXxmhPi6r1m8FM0ucgk8+y4RHC1kAK/5XgW+2hZYofafWcPq1B5AqDqEYsQ3nepR2gqhV2yiol1COkD0C+aOaoGx4aL7DQCwMJ7uVwomn4fm7VrX2u/XAlELth+5sHPtN+l/Ap6sX2dCsZ/phZkIJgv9l++1wbcq+2WFv2NXIjNKAPzuw7MUAV8DTuynFIEsQy83RgTAhiv+NgBABaQOGE/3mwWTLwAqHnaQfr9GnwUbARgDNBUlkpzQboyYCyYDYdILdf0l4NduW9kGoa4geNdazLElKoA3Prx7DofiETtC6XvE7hGEzJlpcis3Qgrj6d5UOJoYDcMglrX2+y0NPtl5UZUjkfx/Hqbecoe0OZzdF1gHQrln9Bhee4s3f3Zxm4MvAk9VSFdUIw0i+Q2PaBtISiBSSFgCYMjMW00MP7pwvvLDmwFgQTzdHxcOSGvBg/b7ZRZByWYAlOERluKM3Ra9CKWc0q73dTBhMFT4ZwIw9l5Lrpes+HjeBiGCUOKXeuBvPcKTiEIOR0f+RhDBMYi0Lhea4GTaa5NbOQAVDzhgPB1La5RssV3rIP1+7yy5OAADoAchEHBkFbKfGRpiweAPtMs5IFNokyOGk/7rAYC9OhBFwNXVY1at5tftCBHaWVS2AJdEcEinrDNC+Lumiyc1B8AB4+muLARAXTDCWvr93lR4/Z0Xt6ODFQkj8WtumEwHTKDLQejAfN3uds/dfjoQdatGLxb8jQBAYz6/boxiFgAVudzNIc2/s3xLk1szAORoB4yn+2DhaATAGJCtbpkCYq9+v4V+aBgAQ4i66XtaC85YkDog/zdZvzUgfN1N7a633Xqv6fe9msDIHfNaB6Ay2JRE1AHAEDIfI5nzZCLeN4Nbm9yaA+CA8XSsul6yqV0rJ2WQfr+splCyCYBR/HJyKX4phs0PKBZ0lqOYTpvniAiUAmAd+HKjo1cvDjHgr+3wPJQsVCymUZrPMuRsRBDG4AQCsunyJtFGHwAAIABJREFUcc0BUJlxQoH62q8ST8cggpKNAFRGwCD9fkuvbwAkyGgJE3C+Nz1P1q9/T3F1EZBxvZh50s6AEYC5yyUHXt5/Q8zI5/KrAmAIkkipkyGPYwXz1aRT8v5ZO6jJrRyAvKOvNXlLazsXs9bo/ztc29Pohgotp5J49Rcj/pzfIwGS//3OM4CNd1dpntQpFUmjEH4LYIgnyn/OLjL8FeDGhwJbNgFjI8DIEDA8BAy1PFK7FSKf43cNKrvHx+8C/vmxwMgmYHgEaA35J0StpvvzL/nP8RbLAfhyT207TChgDRiu/ZL9DsfWNABvYzbhCDBKoBAk/pEobGWTqp819hzQ1/0k0PoaMDEJbJjxVZFgDad0SaUO5LksWVj+XScDmw5UEUDJ6U4d0nVbC91S3ovfVHp5al64cgC+k7mZAP768KCA0WD3A/ieLz090CDceVmlAuhBljLgrfcAw6PAyDAwPFwBkCAbItM4a/FiNtERjBl76W9ffD2AbwJDdwFj+6syImRXrd5Y2FjIYcnzWPLEqnsfC0zsr6qBMQmfIDR/pyJ6xMhKyMrSDiKD2xja6TADTt0/AGAs1KcAUCFrOLF6tbtiRVFavT/wuMCa7MfVTlH098YBeBcwNAIMEYAUlS4uBULOmK3LCnwOPANlEIOSoF9+C4DvVoWXhvdWZVOYqWgi3vOXDUQhgieB0EElViMYJ08HxqeqnG8D4IIDkAzo51DKQQJvBKUmKACzbM4+5hUivwrgiwC4LzvjmgCh6nBcgiMTcv9Abo0D8E6g5eCjfpUA6AxoQIzgi8ALmWwC4z//DxcPPwBak8DQFDB8yJPpPZHeGCyC0KN5DFCByfh9/+OAsekKgEzCTwD047X0SCPM1IYQjCv2E/MJoGVwUUQoPboq0MdqkWVn7RtDDMahB4g+P6qhXFpjVtkDtRGA2nKjos7IyOyHFUbIrXe0FXsTuzIYfNb4O2M3ATGIYQOmPn6hG6gi3eUkQQAeAIYOAUOzALMVh2pAlESqGFBAXAYOMQVjxll03iO/yYKRAT0FQXkwZkjp1pz51LO2XAT3KtD3AIAwj4Wg05kfiuUHYlsXAJLVnP0INLM0OYFx78AzcRySeTsw2AJueI+Dj2Fne4EWKz5MA0MzDkCCkAByUWqsJzarEanzj2zXwjEGFHuGY+pYsMojzZL1G9EBexXou339IRBrC3lJGmNDuSHX+w7WC4Cm6wWxm8DngLTImgC8pBcGBuTXf/1fXnyTugnFwxTQOgi0CECyIFlsvvJfEnh0mhsYI/s5uxFYi1xZof7oOqSAawwYjRGBzYGXbtWXaCIrlvHUagX6SP/ruMVYCEbEqECXAMjfree2HgA0ESur1/0vtnNwGSsG0RsZME20/+/XWH6Mugk/yngPAGy5GDYALjiIHIgRUIrsZjM7Ax+BSx1S4pfffQVIep8dL7dMDsTGjJB+CvQxTHmdtrw4l0CovFruC2NOe975egDQsCXRK/eK634JhBK90q2C7I1i+Gt0jxF40k1cPJAB7UP2m3MGJAAFQrGei9iUTH9yBUDTHfU3B5+BOIKQ43BWtNtPcWIOzEZE8FoK9K0DCGNxLi3FqaKA9gTgeoFwPQAoI0OulWT11oEwiFz7cwbErzNxWtEYBB+VY76Vh4DWrH8IOoGQ7Ocg1CqMRLPltmxvs1/SHaP4dcAJePYyyUCRIzrTB8tE8FoL9DUMwl61kQQ87Rmy2PS2rgB0a1ci18RudEJH57OsY02y/+83/sZdBKr4FXQTApBvprGgQCg9UEAM+h9F6ugJDkC3gJPBEvRGrYoYCBX9IxEcS5K4i6cZAHIw8oXQ4mLBb35YH5d7OekadtTV1UZSjaEIPH4nQzYNwgjAHNwDuWGYpZc7lzPfX1cQur5oBorfzDf+zi0yVTuSkuxBI2Q+PhQDIUEnMLo1TBCZLufGw/ixbQa0KB8CTODjPohdY78IQmfDjmW7Yo/doAX6GqIiAtDHaYswSmeMubV81kp11L6hy2PdAcgblfslOKC1IiKRmyRxZgV/8++DS8BFrxXi5Hd/U6MeSKdqEsEKhpBRsgRMbAtuG4KU/+9ry5brzP/lPVMv1EPOQegharrVcgZUhVHFxNPcp9VFtlOWkL437C0WABWypFRGsV0sb5Hn2zYBwvUGoKl10v1knDgo0y7XA8Pfv0UACnjaK33Co9gJQAOe64FkNvtZAHQdjz9v2Nz2GSa3jYej2W3KGuZ9ixGdIVSoKT13B2s5AHkGheST6qn0erHv5AIgAAU+LVfw/wq3CEAV7clBKDDGZG9/5oVXx/oyYARczcqH5GyH8eFplTawFvAtrtXLGpNrQDGbejupB3omlIHQGc/ErzOcGSRs8zrhAbbuL1Tco/JfbLlNwHOmi2kIcs3owbdwNpYtynDQhsFcgvuG9/YapGFvYX22zZcAU0/GwA2LJ/4AmGF9mwEbBu98Y3cMF+uAGQCj2HVp3BbPuo3IlqxAy5wHAq4OfARmEBXGfNIBa0BIsG0ecwC67merHgRpZLwocrWaovuTxew/V0txJQ2DWeae3WAGbdhb2DB4+wRw7w5g8Qpv88liyGtoWHzMi4C9fAEHbBi8kwUKu2xNAdBxaGBLbJdZux1LwAGECYAEm6wyfpelJrEgFnRDxESwgyUxIUsVMwjVy5AYO0bG89Auu1/5BF38KqjBHlUAYXsteNCGwTeWNuwtk4JMkrlzGNizA1hm69g1Nix+zDOBW0aBeRZZGqBh8M4emfWNADDT+zqMjQyESdQFHfDbZECCLRgdHeCTe8CBaKJY1rDnBRCIAuGW4TYAZeFG8ZuMkGiQ1IEwGCJtHZBmy1obBsvVMnDD3jIAerti3LEBOMjGcOpa3WfD4ic9t6oveDtLfw7QMHjnH6wPAybW6yaG4+8D4HIQfvtDIVtLejpBFsVvUI7NIBHw3DUjRzL3rDVtsYPOkAScuX3coNDynT2VYJCkn+PjqvUD8hVbS8NgjphGxcANe8sAGNoVY/824BCBtIaGxRe8pLKZdpMkTvXiJ2toGHzSNHDPScAyq3er4qPyGaNc7JCRXWLT2TjwGmCOeQashq6+qSpZmp8vojQpheF58ncdZVjLnjWPHr4VWKTKxrHGUqq97qXu3jp0wPy+eEC/DYNZsZAO6IEb9pY9lNCuGPcNV830ZmkM9dmw+OKfbdcXvJMPdY0Ng0/7GnDXKcDMccBS7MwdKz8KCAKQIgY0MWGCtr4TOHAasMwOkTqf6unyuLykfd254nkb7qsw/iVg7jhgmSX31Vpd9yRHeLx+zRhjEGRbB6wDYT8NdymyubzDzCCGfpMJWfSRYfr9HP/aMgBm7YoxNQHMbQHm+ID6aFh8yS93tAvGQb7da2gYfPoXgbtPAqaPA+a3AEubgGU1RM6B060fgkRoCzj+TcD+04CFE4BldZdRc4/YxlxgjJMewSiwN1zWfsOngdljq3EmY08vm5i/7j5yIMqpvupKyGoNg9lngYosl9wY/0dZdrMzYl8Ne8sAWNOu2MA3zw/F2CoNiy99XbvftrcLriz6PhsGn3U9cM9xMODObQYWCMANwPJ49UliuW6SaqqBn/gGYP8pwPyJwNIxwDK76ahDeN6uXYCuYyABkEza4LbpY5WEWdSLxjF26/dQB0SJ6r4ByAN6NQxmkWcqrnQ00x1DEDJFjR8CcNWGvWVPp6ZdMQ6OVOCb3wAscPJ6NCy+7PerkP5Q3tBY1PrT9tEw+JwbgPu2AlNbgVkCcCOwtAFYcgAuiwWlM/XqDjMEbP9t4MB2YO54YJFMo/5gHIcALV1TRZ17FXOhPtvgtvkqf9H4kvHDlyKK4l6VzvVSBF22uwjOb7pbw+CfcwBSkyeFEHAUx/yw9JTyEbo27C17Ol3aFWNuAlgIn9QxO2tYfNlbK6MvaxeMRYquvL9rTcPgJ30TuH8LcHAzMOugX3QALo21WXBZLEHwRF1OgHS2eOgbgIPHA7PHAezNu7QFWFZ7JnXJ5rnqxHEulvlzwyVNN3+wern5Yovl7SXLGwvn4riLWO4fgMRJXcPd/+pmOymELEhRzBxJAo9gVL4kwVnbsLccgHEpWi3epocCAMeBRU5eTcPiy/6qtl0wpvhA+2gYfO7NwOQm4OBGYGaDs+5ExYDGgqP+ccAkINaVpB8GTv4d4OBxwNw2YGFrxYCmV0YxLNYheCXau7EhV3ga3Lb8g4+R45uoGLADgHWqhsBXA8K1AZADyRvuvtkBSArh+i9DsQhCOtf0UUgW/7aiYW/Z0+nRrhizoxXwFhyAi5y4rGHxU66qAFhT3rDSIVdpGHzencDejcDBDcDsBDBP1uX1CMJRwFiQIBzxieL3KIY1YW5MPOxNwLRb8gs0aghAss1GZ1O+SFHsdRPt0i/PLHu++dFb/x4mXfhcbWxhfCtYMFr/uWvKxfDaAcg7ipPCvFOVpuo3HrCjYW/ZA+rRrti6TS6MVQ+L4NPH2nx698GnXF0BsKa8Iab4dFZpGHz+JLBvApieqAA4J8CPOQuOBBAOV0CUYbIskRkAecrvAdNbXc/aDCxSpyT4CEIyTgRgneiLIp3nP6fs+a4A4N8B8/48CUC+ZGJA29fpuLmxJW+5h5kNFg2jiWHSi0r0Uv4pCoZsxw8DUfnhd4Vk0XGdGvaWPaBV2hVjdjgA0BlpkQ/K9bmn/HOVqtClvKEBqlfD4AtmgP3jDsBxB6DA7tdbcvYzJvQJkii2n4NOeMpbgJktbYPGACiF3wFoEx1ZMNe/4jnPLXu+KwD4t/5SO/iMBcXuesHylyACMBPDgzGg7opM8mEHIGdwrfGA1rC37AH10a64Yr4APvvOSdwEPOVbKxu+K2pdKRTmdI3dqkPPVgbSTBGAY8AsATjWniBdx0QxJylOFCcr6HBiw1P/CDgU3EgEIMW52M8YkLolQRddIN1AyKWiBretf9MJQN6HsaCPxe4rvgDdHOcOxDIAcmDFDXvLnk4f7Yqt63gEIB/Yoj+4p9xaAbBHeUPM8qF2aRh84QQwNQYcGgdmx4C50WqCFngNsgSvQ+Dxu4MuiawhwIAXVk1O+e/A7CZgThY1dcno1nHL2oDIyZULpBsAFTBZ9pjT0QQgn2V6ufRicS8QRgbs5ZYpEsENDejBfpoLrwAOjgIzZMBRZ0AHoUC+SOA56xJwNlEyTFw5FxBPeWvlzpnbANCdQ1eSGTRybMuydgMggVBsKmtYoC6Mt8znZxsZMLzAxoAOvsh+ydDqtXx4FIDl8L/omQ7A0QqA82S/ERdTI22mNfaTuBIIxR4BhKe+y61punQC+MytI/Zz/c9EuvyBeetLAfGZ5WOMZ9j2/gqABB1fMLsHAVBqhfTcyH5d9MByEdzs+B50Z7voGZX+NzNSsd8cwUcG5ASRKYbdHRNYwhhDIHRgGmO0gFP+HJh15jOXjnyKblVT5Cbfoq+yJOszF8P8+VnNPlICkMAzds/YLxlYznrJwIpO6egTPMqA5ZNDAB6iCCYAyYBcBqTRQ0e4630SxZyQJQIvMJ8mSeLrYe+p/GzGfnTpEIBy6US/out+K1wg+brs88rHmDOgAVCMnrEfxxMte1Mt6j7u9zzKgIXzczEBOJIB0BnCJoqgIfDEhM58SWzJEPGJe9hfVH42un/Mfxl9bgSiBySIBWnAJBDGEDAB8QWFA8wO3/a+wH4+rg4RLPYLul8tCI8CsJmJMQAOuwFC9qMI9g9Z0CxhZz65K0wfFBPqu7PEyVdWAOTHVlTcpxhXHZLz1w0ZA6EDLhkCskRf0sw4dRYC0PQ/vVSRAYPo7QCdj7GqVOSMeBSAzUzMxZcDMwLgcKX/zbv45SQlHXDIgagJc+bjZBqAWhUoH/Y+B2D0J7rFa6LYDRmzomsAaOeKqxEvbWacHQB08JkRIteSXiSBLYJOLB+X4xrzAzY7vgfd2S4RAKkDDgPzNEAIxMASSWF38WsgkuXLyXTRSRCe/DduSZMBMwe6ObTd8JBj24Aot07uDObPP9XsIzUGFPs5+JJ/M6oT4buxHv9X7BeY8KgOWDg/Z58GTC9Xq5FxTXOw9c3Cm6k5fPcjgbHbgAlvVG2tH1T3Oavoq6BlniZ+12n5u/2sDbOvasqoFg8x2Lnbcd1GdhSAhXN+7qMrAC4sA8sORJ6yHwD28z+Ft4fdv8UyqUDrDmCEBcpZ39kLS6aq9l4D2rLb/KYsFTPWdfbvh86vQu2s1K/K+zIjTsXIVQ9a59Egs4Y6sZfIA/EcSp/jEXv8BWcAhxaA+SVgSQAkGAMICcwVlNLlqTc9Gbv/HAA7MrL4+f1VlXwrUq7SvCoyGcrrWpGhuur2fNGYwM8YT67hT3s1LaZvqn5MLM0bzmHMmIFSgdFNj/mIBct63NhFZwEzDsBFgpDPeanNgATfCtGsX9TIKwNrg9tuVkhlng7TI/YArX1VkXKrEe1l2SynN1RCsFJsqnQv3UIMxhwIRjU5AGN9QUteVz3BUAvahuNgjC3HxLAND7nBp/cgONXF5wCz8xUDGgCjKPbvevlzcKUHH2ag6cnYzepYBB9Zi2FxDJdjoXJv1WDFiLJ6MKqKZUzoQFTfj2HmwTKcTpVWvcxHKm6kKgoORAEvVclPD6NdzLXpMT8IYNPcLV7yJGB2AVhYrAC4SNA5AxKM9ryDPE5fs6eeVKWGZ2M3S3MQfEyJUKV8L1ZpJXpVJ9pLilmlAxWkVJHKwIhjjD9TtVXVm1HdOy/pJiaMFRWM+bo0rWl4yM1N7oPhTJecC8wRgAttBjQWdBBGESwgSiV0Pb9DRgu0TY19N+M1mRKh8niqFx3rRDsLqjgl9yaGXT80vcL1wnE252PAZCzAHQCoiqoW3yYWFIt664fUpKaREr1NPakH6XkuOQ+YDwy4FMSwgU8GSRSz0UJx3Vx/5vFNbrs/EiLRY+v4ACITww6iJEodQKwBIyBRv9vwhKzUW6z66TUGEwhDS3ezqusAyNxnJn8xa1KRPSFts9YfFB/QDZcAm78CnDBT5U8rCqjfc3yh8Gn/hGd/MsKf1+QzYJ4891Jye13iy1cAE9cDJ+6FpYrEkidxDN3OtXR+FwBGMezoMmxJLOumAuD4J4rxJrfdH/XCoLGFVKiUbw+LAPQqWWaMMLrd6/+JycSIm85w9lOpt1j1MwAwFTiqAWEUxeYH5ENn/jInUVHeMXQ/f/jRePvCa4DhTwLHfBc4frGqqaNJzLPw6iZxV+HTplFGvZrXZT45N39+HW3TujlZv8D6fp8HRq8Dts9XIOR5YtakgBgdrrrt5Qsq8Ssd0BhQ4HMwmVitAWHAY/LbLDQNQDaTVJ8Q6W4qVB51OOqDZDPVB3TLOBepW5jmqaLbec3jGgBGMSxvvemDYkQ9GoKF1ShUCSKCqBeQrvmfVZPC1keBjXcCmw911tTJ8q5XgOLaQgA+x/OdWA2EGZ98gbjleTHdQHQN+2iwls3nK3/Zhj3VeQhovYzdxmArSwQgDRA3QiSCJUrTnjfl4KozRCSCCeYmt90EoJJbVCk/1+FiCwFZxLk4dRfLFia6x8LbYkD9v9cXtLG6+O4AYQRfrgPygVIcqyhTXcWFOJH8fh3rz7EKwnUArq8mcGwK2MCC1i7WY7Zenh56feHT/jE3yliE4TZncd636gPFCKWavGhcRx2J+cvs9MlSw0Ty3cCm+c7n0G0MExdW4BMIbTXE9UCynvyCCX+Ovm4gbByA/xisVgJPpXrzLj4EoRJjJIZrWHArS9iprK+KcefgiyB0XVKGjOmCmW9xhRVMUSyRFnNeFGEdI2q+/HFXclkp9WsAbgTG9wGj08CI64WxRk/OTDcUAvBHXSLQxcVCDMQSWbzv+1e7WVbz+k5w2tJtsbcCYV6WJY7hmAsDA7r1Sz3OgOgoM+KTOJbcjSI5yGIaNE1uuwlAAU/MF+tF5/0sIghVLdVdM2S0bSzHx2Mi+FTxXf8X925NC4BycK8QwfmgVX1LlcFiykEMcL2BndJJ7aQfijKfxLGDwAhByM7aC5U4qwPzNwufNnNuOH4VZaCPlPo2AahqFqoPVFc14ga2m+WEEL0cAz9kdPrOmMu8r1o/rTsXz7f9oswFs+jO6LAqkvC3Ggg5Fg6mwW03CUI6X12h8lyfcz3QHqr3DIl64DbqaQKc9mI87QXACD6vpJqY0EVxz2CEyCI5eMSGX2e7VtI5J4yTRyZhscrvt1nQuivOAaNLlYESwcySgiVbr37Bfd0/u31yEgg2FVaiPCeVOguqAfGov0iR0R9JABJ0bnwk9nMxw+fOh55EbgRhzozrBUA1polN9CLwok5HEEUQBjFMQB7D+j656PW+IrJ8O/bBCo4sGFdGejqiyYCx3mKe9/JtTiBvmI5OFiTisg9LtJFF7gZGDrUbHKs79+hyu5hSaUvh1foFr3r/6vZJCiXgCDwVVFJ7MVmRLsrGltuFCc68yFdACMDAflwR4QM3HPoKgIExt4gz42SuaQb8hBOE2oZmlu+KFlKR3QSssMJxDPWbbjpfLoJrxG8CYT8MKGZSVTCxYFTIb84nkCxCIPLDiby30gXFghaF4c2ReR466Uu2fvoFr3r/fKAEFxvpqMcd9yonIrkuK5LLV7MVCM+/uDJCyIC2J8a0z1iwqyESgMl15Sa33QKgmtPEBnp11mwuXgO70Ud4DHWzfgDYC3zBEOk7HlA6XKyHQzb8HgGoCSQLqsxorIy1Bxie7Wx0rFaf+wr9Xv32C+56/7HbJ5VHtRYT+GJrsehHcya57PyKAQk6+vBkBZPpjPEExlwU59awg3C24W6KBsC6tqHR+MidyVG3i3rdAnAsH2T093XT+zLr197MTA80h3SfsZP2UqpCrPQ46oF317VrpeiKXTJ9MhMLkgGdCacKG/mupV9w1/vnwyGgCDCKWzJe3lqsyzLWZWe6/kc/oKzgKH4jC7oolhdC4jiuzM0WPo+cPQ2AsX1obFCTO5Jzn566PwbReiwnfTWjI4KvDoh1juh+aT+WKSYD3i8Aql2rJk+VsVQly5kkddv2FvHT61icqO7Fr71/IkLNXOi0FQjV0046oBy6wZ922Q95ICqDEaL4XWw3COcf9Mw73DFB9AqE6wZAAS8XuzGQIDKf+oVkqxt00ttAc+YT0PJ9qRFSB8xoye5Xu1ZVeCSgCLbYLVNswoncHxoeLwCzBGjBNki/4BX3z9lXgUCyIIGmhova83cRgO5Te9yLgP3MfmsBS8xs8/U67ePQOqy9umBUruDchqo8sHSd3PMfT5ifo+ack8eFHI6QEcnT5GvdOnVdXof+ptJ+BVPWceiaRHA8Us/nkACo8mzqlqmWrbFDppT5A5UIZm7CPA2Vgm3QfsEd909kKIqB1qJAKCBG8ZstZz3xHOAAiwmpDIdng1maZQAkZzsHZ537YfQrwNyxoQ+HakrnS0h1mUA1C96TdJTmORyhC3oeqdwROi+GDhkFI6bYNrcNDEDeAkXwQizPRpmnIs3OdqZPSaRFUcbchHlgie6agq2kX7Dd/+d8lUJVXuUzk8ERmS+2vfd4uvN2VOV5rSwb0y3JhgIh9wJeN3YMQCIgR78Q+nDEVYBYZUrUpbXFnM7COSdf7N4IPvtDnT2BY/h8Chh10MXQeYGS+7GGjaQiABpuNIFiECnzdWJMIUHcazLptC7YivsF8/7FgLFMqpiQL5TuNbKfA/DC46rqqAbAwIKWK+timRUBEiNGsOQsyQm+Gpjd4n046hbT84KPuYjOmHHyp92gcgDS2OoIuVIeh/xyUkaVwyEWdLrewHE3uBUDcKIwnq40HpDXL+n3CzbaKdguel5VnFJl2awaghLQBTzteZ0cjLq2A2n0M6EPh2pC57Wg41poLzZsAZNso0Hw6eVR/J8bF9YjWGmVCpGKwQLBRCcrbiSxNLgVAxCF8XSl8YDHHFPW7xeFBRwv/rGqOKUBkODzqgdWPYAM53vTASMQu4Bx9J+69OHIF+N71F1O1gUB+AsBfFqKC+4Wi4BWX+CYgOTAU36wdMVNVKka3MoBWBhPxyiuko3xkSX9fvGMkqsDlzzHC1N6SQ4DoINOe7KelWWTheziObeKCdARApD1AdVnRH048gKUAmAEYi6Oh4DJV4VoGDWqjq4XLbO5o1jBoimEPhPJmwu9FvnTLgdgYTwd2wyXbMyRKen3i2eXXB245FlVYUpVxUpGiLtmGBlrTEhVUwV8dEkVKAq3MHJ1uzRbRx+OOgDWFX6MsXJU/36lJoEoA2AKvw8+uwTEDIBbStdOs8ddDsDCeDom7ZdszBIs6fcL9ror2C75US9IxJJsEsHdGFBil4yYuUwknofJgF4XcEUfjrz+X7fKo4EJJ//PkMORO6FrVjQMeL5kJhZMMXzLwNZCt1nzDFgYT8cQwpLt4hDON0i/X7ys5OrAJVe0S/ISgFY7j9ZvnQ7I3+lyqpYaL98CWp/N+nDkZdhi6bW8An1kP3fRTLKVWlwF6RZCH2L4zDDR0k1IqeTNb2OQSYNbOQMWxtMxeqtkY6I+ny9VEz6btfb7xc+XXB249AoXv85+tIBVgJJ6n4lf6oV+mfjdDJNMH0wAVFX90GMk1f5TxlS3Fggh92DyN0IORy5665KIfCktsl+K3VsGtpVOWOMiuDCerlSnjQ2rB+n3C+pIBdulz8wqonrNPLKgwKaC5B3s53qhXVq6oDNg6sOhqvqhEr3V2VNLBjmnSSNdrOLJ1zkAu6VPRjFcFz4fXDJ8i45hG94Gt3IGjOFYA8TTlQZ/qGH1oP1+8ZtlT1MAtHK8mQg25zOZUSCLIliWcbw8wfW5Ln04ssqnHX04euiCk6/3de66MPpuAQVZAEFkw2MKFw6a1wEL4+lSBvmAOMhD8vkOkFX77feLNw14YT/ssmc4A6oOdHBEkwXlgjH2k4Nal6wB4fIuX9LzZjAmorNeHMo5Tc0OewHwDTUh9HXxfGJsYkAbAAAgAElEQVS/uvCpoAcew6zBBrdyBlQwwoDxdLZWXLDFkHyF8xGE/fb7xR8XXByAAVC1oB18HQYIT+8uGfP75SCUs1o64he8v4j6cIQ+IqkPhxrBCHjdjBH6AblQkAeY1ondukSiELmsUPpjbyp7XuvDgAXxdNZVvWCLIfmKg6Bbhrjup98v3lVwcQLw8gqA5v9zC9jErutltg8gMxDWWMBaMVkmANWFyEV6R0uH2I1IzW7ypbkQOTP5f2ch9KsFkwp0kQlDAOmxzHpscGuGAQvi6VD4RgmAg/b7xZVlT5MATNXwqQc6KGwf2U2uGV2uzg3D4ua7fDnPwZcKgIdq9GaIBPZb0YdD7hgyIFWMXiH0eQ5vXS5HcMkc++9lz2t9GLAgns7KxxZsCkgdtN8vWD+vYDMAUpcja7lOR9eLVcIP4tcuob/3AOHCdW02VTX62ApB4Mv1v24gnPy9HiH03fJ366KYHYTHsgBBg1s5AxbG0+HLZaOp65i+ln6/YM5EwdYBwGj1cmUkE7+8THLNdAHhwrUOXtcrO/pwhF4cct2oN68BMDCfmsJM/n6PEPoYPp8bH3kCkbtjji2tJJA962YAWBBPZ0WBCrbYsFoOf9pDAiENk179fkuvf9nTXewKcBSjsn7ldonWbgQpx+26otaLIwAlfi2QQSJY3Yjy5i9dmsFM/oEDMM/Z7Uf0RiYUA7J+ToNbOQC3e0WBBm9qLad6HICG1ZK1XB5PoxnuOOIcxSXe/Of8xHV/P+FpwN47gKUpYHmuSve0pKZgCKSq5wqniWE1WZz/xouBm74KTMwBI17lVBXwtWSs+8/vL45Ff3vhpcAnvwos8d48DZX3M2hx9XIAnu0IIO0chu35AOgLL0yuG/jOmwbg028G/mNz1YWdETbm4I5BrFlov+EtD2wIo7l+Atg8D2xY7iw3V5diEqO54mnj6XdMAYcU+6gon7A3NSO2qFjlyZYDkAX6uD5Iam44YaUfVNDNxaJcLIPXcGGpfi6PnZdVD1wPspQBX/wl4OaNwN6Jqg+xwrxslcVFuYJblehkcYYZGPS3L20BxueBcS8nwg5H5kZkx6TQSbXFZcCQKadx5Cz5mPurAFxrRaa17pAR2PFC+ElSHKQ/0QjQcgCyGyM9v3SnsDBRJgL6msWCf6IfWeUJac8UFlpY8500DcCfvgb43hiwZwyYVhd2D/VSrKGAmIDnBkiafEcN9cprHgKMzgNjS1V7rRjRlceyrqif6KAkMgXIM+6tAnDl+zSL36O9+U8p9jGHQo285/2XA/AnXeNnKAorDXH/AILwbSvLEz6Ql2+cAf/3XcCdw8DkKHBwpOpFbE2wadzIdyh3jjNQirYWEwYq+/zJwMh8pf+xKNSwM6DZMmzNRRbM2K+2Ii6TlFrAWfd5V3i/F7IgT2LBF5LbIdkqxLPWvtzlAGQ3RpU3Y7AiixMxLOUB2t7pKQ8M0qCTnp8HkojJgNqaMEJesQv4AR3Iw8DB4QqAs+6SWRiqgJgY0HVDAdBA4Ba4xN7ndlSFAAjAYX4IPO5dBDMAdS2i+Jx7XTf1eEdTDfgAQnR34p/wQkRmjNAoByDT/ugFphXAmjAEn8qaPQAgZCs0lSckCNmVigEbFMsPBBE3DcBX7gLuawH7hoAD7EM8DMw48AhATrjtQwiXoqkTEwWd7LOneXNCbz6Tiq/TInb2M8ZzIFrTQbGiy92oGz7pXl/7jvdAJnb2470IbB3T77Sai+hyAP5voTqW6sKwFAc/TAdc5+3dvcsTrvPVYSK4SQb8xV3+6IaAqSHg0FDVh3iOIFTIFxtit9orL5Z/LD1Q4s+B8OnHVuXwhhdd5DoLGsgCCJ04q66X/Ju/vSaeAxDPvbdtmdtKDV90gVEPIl/xySkviOhmAEjrlzSkwj40SlQZYZ39I+8JBMx8mZryhOsKwqYB+KpdVSDFvhYwPVR9BD7uyX4SwRS59nNI+bRck/DzJ05v12M0nY8fAk8iWL5BB5qASPGRCi8EVjzv3mqpkC9ACrrwhKukB67GhpqRRowQMqCiYbj8oOoHeUWpdYIBAUj8c8WjrjyhNIJ1unzjDPjqXdUjJAAP8TMEzLYq9uOHICQALe/EwWe+QgddAqCzzD8+vgIgg0qp+5nYjaDzCgjmnCYone0klqP4JSgvvK+6LoFPoFMlkPGh+0rPWta4RHTNJJQz4M8EAGoNTPVU8opS64CC9zoAWTFChcq7lCdch6s3L4J/2QFIEBKA1P9mHIBmhPh3Ai354RyAAmWsR/PRs6vOR8Z8FMPS97yxtIlYgVB/I7jC0rIKSfLXF1EEB+BFFjQ3jCLA49OWsRTTEPzvzQEwry7VrZ5KwzAQAPssT9jw1dcHgCrORQCS/bgn+1HsCYQSveaHkzvGv1scgU/6R55Y1YIxhvOm1EZekQWl8wVDxJgwc88QiJc6AKX/meHDawX9z16M/Em7bO8Q08GBP/jEkAEVjMBoAFWXUjRA3KtNwOBXW3EkAZhrALktpC6lKtTV4OU7RHB+3kHWgv/zrnYZl2kCkF4uF8MGQGc+MqEYUCA0n1tkwxbw4ScHAHr71Q7W4++c8czwcBAmHVB/c7Bcek9b3FuwbdD/kjGWgzJjQ3thGmVA3jhfOyU+RxB6FamOFp8NrhsTgLy8Cpzm5QlVptAU+6CiNgXCaIQ0BcDYV8b0P4pi30vfIxD5+w72C9aliegW8MHzqrmh/meuFhYi0pKbs6D9fsh/n1XFMrYMbPgUByCZz6J+uEknDA9AornWFRb01WZEsACoHhOqyC7wdetT0QAK2KqOb5MCUvPyhLE0oQxzqaYNXL5xBvyVXe12vByLADjXAvgxBvSPGFGMIjCmJbEW8HfntxtQmxT0cmxp9UPAdKAZ1upA6EB7qgDo6oCUxXRtPVSpAwJpnUhuxAqWCCYK1MBExZljY5S8SYr+pxAFAuBayhNG26jw8usCQLX0SAAkwwcAEngyQizaXoziIli+Oe7/9kJvNk1LmBMe9ECO3XRB7aPeF0EYHNVPdT8gj016YBcWtBfBVYJuz7mF7VgGY/pO8f5WdQ1/7U67nIKNS7j0wIbDPFZsyNHHY7od/xdlEHj8CcC3TgCWHgGAPSxiSdt4312u/8SPAl8/Dlh4pDeZW2PD4J1c9+uyDaIDkgEJQKnTfG/N8nUAmu5HUnMW5ARbPfEuIHy/ACjRK7FL5pOR4RaxgTHofKl8r/S1ZWBnAGDKefbn3AFIPRPXB7sFiVQimKVgGdl5ooNwLQ1/1U+DQGSXQ9r5Evy1q9rZbP1lGQDZsPpzI8APHgXgod7qUx11YtBbFzC+/C+BL7SAWwhgdoLkONSLqy5oLogYft3ZI1F7EAC+phsAnekokhP4HIzml/PvthQWmPB9LJ7jxkcSr14jWj4/0wFlgJD5eoDw6fe4DzAYPHokWhHJZ3TFSkn4h7YOSOBwEtiMTv1aY0uktFYTmI2/43EMQmCuAJmUE0gmVD8EFdPpdnxhVhqzDr8F4NMtYM9Jfg98EVTeNu9Q2OFZBX7vr9vtgm/lcezczZ61ZNN8DCvilYCdPXqNDQpAlfGTKm0M6AA0PTAyoMSx64cRfPQHXsniOTI+fEWDFGp+Qb9BeySRBV2kpl0QxxGAlHDmkI56X6z+EP7UDYSdRgh/IouwIZ36lHabBE0GJ0r10Rgb/xA/tt/j/6aMAf+7R4CxzuBXWRGULwBfIrY6UNfpvLae7n0I+LO/reoLMqiVMbW38oUhkNkQIzZO7tIweGePcmWlAFTjAYHPVGwXxWoLYblEDkLuTT8MDPhXLJ4jALpaJB+ggU6xfgJknT7IKXIQXh4Y0FZCog+wxiUTwSkXUbSMV1rB/A31OXWuFpPUda/mRHKi1e6U+hA7Zq7l+A+UAfDtHg/LrptkQpZ727cRWOL9542Pa3rOvuOqagUltgtmJM08j4/PILbIDKz6w5PAHsbraTnMGdZWIwIzxIfeK0rn578J3LAVuH8CODRahV/FFQ/1IumIvXP1QudNfyNT8oVqcHviPcBd48A0g2RDuoDqHdb2SalZAdG9dnfDkAE0gXnH5ijWCDbKCq5/MRiV0QD8HgHQ63jG0hdsLGxA3x9Bw1Asli7hO3BwApgng/Gjvq01IHrXJ7q3Cz7E++YziF2rs1ZLZ+8H9jJsSoECWXj6igmR87aLgfbGq4GvbgLu2gjsHwdmCEIPSI1h+SkCRjpfUC3iNWcpoRrcnrYbuGsUOMBo7QBCxSTG/igxVcBIVGPWM1h1JYQPnyKNExGZMDIJ9b66eEBGxPDY1Y5nv+GCjfGAxD+DDpiawphABWZPjwNzNLAEIH4XCH0M7/5c93bBfI8Yk2cgVAdvdT10ifDkBWC/r9lGH51NhIsnsWHOfPmEUKT94WeAG8eAO8aAfWPAwVEHISNQlKQUglJjJExqC+H6Nq93kOpUg9szbwLuHa66QzFWkaFieXxi6hgVHOMCYGRuJ+5V4jYJIDKI9KlsAvFDq8QDrnb8NWVPh9EwdFkQ79TlSMIsN0Mi5s9MoOGno4U6f3YAvefL7Y7rvdoFLxOANSA8f7xSgWmd0kCQbmZ6mTLEnJ0UqWLhUkxlrBn6n3wWuGkYuGukCsufGq2iojnRFpafsU7MDxErJuZhYCsJosHtWTcBe1oeq+hxigJgXBrMmTBPnJKLrr+VED54ibHYvZos8sO+DNcrHrDX8YVVyglAKud0LtMjFPtNMz6QLDY7VomLJd671AEH4Xu+3g7nWq28ISvX58/hguOBg8vtFQvV/hEzxfqOevuTfpjri8vAWz8L3NYCfjBc6ZYHmBcitnFd06pxyb8W4gPlgonBqffTtdTg9pybqiVNBssyUsdUD7eGO9amnf3sXtxQipl7Wg/sD4A8AwHIyZMYky50Tp/xgN2OL8y051qw2hXzwRCEdT2nmck1RxHG+w5jeO9NFQBpR6ldMIMXlFWgVndqF2dVFsJzuOgRwMElB6DcI6rznemD0RnbwQiSRS3g7Z+tVIl7PC9kahiYZm6IizuLigliT/VoUog+p8P9l3wJ7qGEanB77k3VczroUToWLCsABud4ypaLCUoxf9i/9w9ADiICULrQRWuIB6w7nuZrwaZwLBGwClSqSyz3AhHbaRGEFGOmC44D72UVgjW2C2Z4lIF4ArjodODQcqUGqAxfcpG4mJVuVqcL5tbs2z/veV0tYK/nhTAqesYNHdO5PCJZos+WuzxHJIViuXFyJxupNLg976ZK2lizUKodilGUgzyGhokF8yw5Mf+qRkjdjfuDtwkkm7DTkNaBaQ2ox1q3eMD8+B6O3H6em8Kx1Ccx9ptWl9iYIUAAWrI3I3nHgPdOtsO5eOuxXXBdj0V1vOL/so3Cxef60tlSpYwveKf0pAu6ohfdJ8k4CUqgvr5jV6VGTBKALeCAh+VbZLTnh5gu6D44A6H8cVlkNK95O1WkBrfn31R5HSy+JCwPplAxRegE/2T+AloGncNmbQyogUQx/KwB4gHj8YWNTwRAOW0FIIIndoqNkTAxz/bd09XDGLBdMM6/pLKi5whAX60gCK2ujxzEAqGL2pQ1Jis5AJEAFHvTujYAKjRf+SEugm1d2COQLU/DAwQ44caEw8AtZzSIPgAvuKkdrWMM6M7xCMBoiBn4YpCE2NCfxWAA5MEuwvCCEICwlnhAHV+YORfDsWJGgPpMKwg1b9QpFnzHbD2BK2JGul9s8KkYW17vLALQRTCBpzXZpS4gtCXXMAkduuAy8E7PijPWprXJ5CR38ygw1fJDohh2BlRAgq2OeN7uTWc1D0AFNtmL54ESBsCaJcLkDajxj5ZXRiCIGA0waDwgjy8sk5+HY+X9ppUbJSCp6TnFCMXwny1WAFQ8rUAc2wUrRL6mXTAefWnFfnz3FpbagQKLAqAzoZjAKkkpXkNO5GCEvOMLFXOnnC4xIKOjnQGNdWSM+GqHQGd7JSsxUf+JzQLwhTdV4je1nQvr1MkPGtlf9yP2Dy+gAqZ6rQytfvdHSDxgLwBF8AmAYjHWluEDiKGMiqOVvtejXTBOuRSYJwDJAARgZAGWL9Nk+IM3SzgTydE4eec1nZHbtDaNAf1Dpd/SMx2END6kD0oXtFhBXmcY+OY6AFChnKnzl7NfdMR3qCAae2B+VVMYXASvDs3/X/zHJZcB84vuiqABEo0QPnhnwqQLyRURmZBPytnwHde0M1vN2lR6picoKULaxHDIEdHkW2iWg4/7b5zb7DSQAVd0/griV2JYojfpwRGEYsGBrOBmx/OgP5sAKANkcbFzNWTRnX/GSGImMYH/LYlk+gGvdT+bW+SWH+Ig1GqL5QeTtR2EYj5LVHfjw/ZDwL8yJ6TB7UU3VVoTjTYxYDK+Ivv7dzNAZIxpZSiU8jjKgIWTcykZkBawDBBnQdMr5QeTKI5iWCB09AmEb7+ucnOQ/aTPWn6wuzyS4u+R0Ob6CUGqJpIDA97AdqINbgRgBJ69CG4Jp6q/ckjXqB/RKla4WpkO2ODgHoynigA0JiLwaNiEt95YQKJ4FRC+7brKzRH9jZbN6iJYuSHm9I5iOAOhHNJfZkh+gxsBKPbLu3+JgaWDdojhMO5kkDWSlNTg4B6MpyIAjf3IggJgMD4MCARjFMU9QCgAykhSKnUCYHB9JB0wy5aTRUxmup4h+Q1uAmDs+hpXgFLnB6ULONOn5xACNJqxghsc3IPxVBGAiQG9aLeilWUJW1FvVXEN0TKp1C6At19TMSCBpz1dHtT/JH7N9yaxp6QkF73KBxYIr10nAMproB44qQGTj6sjUrtOFPtLeFQHLES9AdDFrq1E6M13MaxVCTNAXNFThIylLcor40zxtgDAPKuVwDMrOKw+SBTbtR2MND7sZwC7Qvm4wqHa4T/uIrhb+7n0EgbQdTijoyg+agWXT8llDsAFWr/B8qP1K7bT0pvtVwHhW6+t2C/m8svvZlawi2CKe37nhFtapkDnILRqBQA+v04AjMyn79EIkXO/DnzyCBwVweX4wxs9B4rRZgyPVFqykgDd+5JSpBU5r0vHyHz+jsc3ub0KABsZMCyQgeExKyFPVIz3lmcM6OfPAGCADYPE67Jfs6h7G0o+xvi7oyK4cLZfOgpsXwC2Lq9MwuuVERonKn4nSJrcXnQKcM7dwMMXgYcsVxkSebJgzOWPqdB1ad2f3gpsnwK2LXWeR9m3danUIV1lBSCPArBwtp+7DThuBti6UDWDmWA/DvXk8LRptfPtNUlihYZTOPCi04GH3wFsnwGOW6iAs5n3GeJJ+KLoE+9VDClQ8R6vOQHYegDYwuY3S6H/iJ8jb11ck0q9Qhoc9QMWgPBZJwFbpoFN88DGRWBiqQIgWyJY3lPozaGJ1KTEPh36zpTkJrcXPRE44S7g+Cng2DlgyyKwaclfFoIwvCwx9Zn3Q1DmIPx/2/sSaMuusszvjfXq1ZRUElJkKsBEGQyYhJCBSkUqAW1tsBdpuxEVaBzowXZqe1g90G2LotjQdmMjKqtBxQERdAWUAkUlZNBGkQRNyIAEMAkxpFKpqjfUG3t9//m/c/+737njPq9uVeqcte66b7jnnn32/s6///3v//++Tz0dmD0KzC4DM6vAFpd/0L3Gh6yTDgnvLwKzAWDGiH/ThcC2OWDrErB1pRgQisIQhAa+AED+HEEY6uNLyrRnZLSl6tSbrgLOeBQ44yiw8ziwfaV4UGbdegmA5QMTLFlqsfn7XecDW+eAmePAltXiXnkuZSBkRcm4UGXtU2uo3xsAZgz6y54JzMwDWzkgBOAqMMVBCSAUObh8QuN/CiTgcWAuyWhL1amvvBbY+VgxbW477paa7gIBqCnUrbUBiQuhAKDUot13IbBlDtiyBEyvtO5VDxvvVfxW/JkWNFrCeK8NAGsY7BsvKQC4hQCkJNaKy2LRIsg6SJ3IQSe1onKKC2CsOYMeN+0Dtj0ObDsGbFsEZmWp5S74g2Ir2uA22BScAJGA+dJFwPQ8ML0ETAUAkgDTPq9zdK/+sMWpPF19NxYwA4g3PtsHxAE4SQC6FdSgmGWRRIJLZJll8EGKjHiX1jwaN10HzD4BbD0GzC4WrsKMW2pNobZoCu6CLCDfCTqzgg6sr+wFphaAKQfgZHKvpRSYg7HN5XCL2AbAZwPrZGaj6ippXhgn0kqmU1woxnHedg5AATuWHig2FE1uVRwoxoX+Wcbg89S3AqCKPONcCi8oPtVP+9++G3j+oSK2xRBFDElUxbTS+3nvc4FpDsjxllXQoJg8FgdCQoGJJTTicLcQ6vPL6wbg9cDM4cJv27oAzFA5ky9/UOSvmg8oP86n0dICBn25JwjARWDSAUgBHN6vfdbv10AbARh8X91vDM2ss+NvAECKPVLCsHoyUgRqrlbnRwB933OBc+4DXrIC0IEmiLnE75di8HsyAcjzWUVGUi6uICMpVwwJVMXdeOk3XAxc+Hng+vV2esAYw+sWoP31r3eLcLwQBeQUrEHh4Jo2h4vDmJPuAyMLGAeEn7uqbgB+I7DlSWBGCwe31Gb9aL20kGDb/EGRxY6WTz8f2wtM8l4pgL1SgM8esHCvsuylME4nn9cfQLtldg6TZ0kUKorAfij23vAPCmqp3fcCl60XFINid1PlZrf41/dnApB6wSQjutUfIDJR8CGIQOwWEH7DywpKrWc8CFzqRLHkVYrB2jS2FQH5vkuBycXCAlIUUAAkCM2iRBA6+ARCe7DjYmQduLYTleiQ/XTTS4DpI+6nLhZW2nzVCEBaMLd+soIGqjD1ampdugiYWCpeBKA9bBJC9ActAk8LES26SqsftInLZ44dQif4Igdhym5WLrPDyuYH/7HTCNwDnPko8LXrBccjQaioe6BiKad3+QY/MGTH6rS3OBvCnQDuAIyqhiDkQ9RX+29yE3on8IwjxQPI8zkTiApGU3oVkD/4fGDieAuAdMw5MFQjEgg1DYsUku+a3uI0TGBfV7PotwHwaOEmbHEATvuDIutni6UAQoFRIFRYhfe/dhEw7tbe9Of0Si1g8HkrwRcevDajz07gIJ7n05rYyWIpb4ya/7vv8PRdFpj/LXDmkQLAnA4jCCOlTBRN/rFMAJKgkkVHpGUjySSBSFeg7/azqk8EgbSEq8UDRACLKDXSyaQ7Br//DcA4LSCtwnKhTEkQcmAIQhtM+Uaajl0uS9NatITXWzpzfcdNB4DpY+6nBgDaCtanYLN6fCj4u1ay0QIqtML/EYC61wSA9tAJeP6eWsAoDysFpg1eB0HIQRCIIkVeCqQf/05P3WCB+UPA+CPAzvmCaFWDKEuYcl1yMN+Y2dckqGTeHPEvvWDSNhOAfbefX0A6rS8CUw8X9066bFIfdqMHJID++DJgLACQumyc3gyAEYRRKFCLD1eu5ODLF6QvXedx0w3A1BwwxdAJLTXjd8seQnGrZ9bPFxLyA7WIKON63tYtCQBN/sv9QPm6BkLp0vl9t/m6ietR6fbyBA4gnXtORwRRpNnTtPpW6gWLH83lKqcOFTEnDiKtoHwy8RNFhrefyeztbnrBfbWfgttsP+kIyO32ELD1cHHvInrlvWs6TsnB7qAUlg/suFtAWkE55zYQ0QpqcALoNCXTEt7A3KoaDwGQfqoAOEUBa7fUbKctltwCajVbxvSiyvoasM0BaBKwwdKb9fN7NfcqBWGiSWykWXER0umeacUEonQgCKRfIgDFjya5yq8Wfsfs8dYgiuMxgpAg/vnMzu6mF0z6Zj5APdvPQec0TEosnvQosGOhaLuIYvnwEYSithE52F1XFAA0p5yigD4otCqygFKnpHUpLYP0OcKURYv6Mj4MNR433QhM0gL6QongawOg+6rl9CswKoSkEIxPyTsuAPigCYBmAXVfYcVf+n0SRYw6dP1YwNgHsgSajiJP429RrpWOM6cxDiJB6NINM4w7LbUGMQUwB/M9mZ3dSy+YVG0EoBiDBST5ddZ+PkCsAiIlQZDa3LVatJ0WXG2PbL98AB+4omB3oP/HgTUhmGgBfRqWf2TTrUSjExDSP/qWzQDgfAFAWyzR8rkFtDAKX75jo6nUguZxZ8NByHbvvqBQ36T1swcsBaBAGGRg40Ir+rt9WUDhQ5ZAU7Es2e9LLzglqHRxNkbeuW+oQRRls5jaMjnK0a9ecNf2R4LAwO829kQB3LTtEYQPUwzQAWgW0AGo8AQH0ljp/V17pm0KRcEifGuNOnocO1rACQbKPXhs8TtNwVr5uh+n6Zf3wDgu29g2FdMtOc8B6PdpFj08ZFrplw+ZA5FTvAQQ0/BT36FPDkRqBT9Jag7xYlQItY0f88j78sZzCcKPZlrAQfSCK9uvB4h577SCotUiEJ8opq8IQFl/PUBPEoBLxbRE62LSqG4dFB8r5bHcOtiOQSqT5T7RKzYDgJx+BUCCTxZQCwhaQc9oKcEnEBKknj5FsJ1LAPo9xoWWPWDy+6IIoqbeaO0VA+zHB0zxIQDKkn1GgtXiRxMIAx0Vn0Db+lkuFjLRCt5WEwD71Qvu2H5OfekD5FaciQay/GIbFgBXriwAyGmJADR1ck3DwTE3TQ4B0LetzBJErTYAr2BBSI3HTS8tLKBZPo/fWQDZp197Z3scjGb5BDp/L3+njMweB6B83Gj9wj3atOsPWin9WgXCFlVO/3ctf4iD8XkBkH5USlAZlNPZAQqARr5vxu1yjmH0givbX0UQKI63o0Wun/xHuR8E4VnPK5JQLd4VNttTBvK2uoiKOUf/f+GjwMNBh0NMV6J0c0NpcRv7mrYv3kh8/uHxYp+bVpwLp3R7sts2YzouSq3KGa+q7+x7Co4nazAerRKsVlV1QitF59dyyFZaYY0HMu9mWL3gtvZXMbymBIFMZ1ov2h0B+LTLisxgW+Eq5uU92iZ72ud9vvR+4JFp4NjkRh2ONi0OB1/UBCkvEYRhfuNs4OmhhiPKnFQlx6aAjMnSXJUAACAASURBVPjmz1w41nnwO4cCIBvBwZgTAOUHRq3gyDExD4zRGVYEnpm5LqmQc0M5esFt7acFl0SlHiBxuTkYxxdaihUC4QVXFu5FCUD5QtJl85sjGA0ziQxqeu/fem+hw0F2fLLQGxFlYMRvo7v1WmIVtpt1DFkXvOR7LwJ2HSkyoZmEypoVVe8p7b6qEMnidGG/Vl/L2aPOIwuA1pAIQE3DAmFa4j9f7CPaFpCHKujr5xzZesGdHqAqKz5X+FLRAl58le+jui+kTBALMcgZ73CDBkpN2/7+bfcWOhwUyCEAjQTcAVhKdjkPc2RajewKyu/n1//qJcA2uhBMRGXQOcn9U6JIOjXHQqSYOsVoQp1HNgAvz8yny80H5PVz9H6RqVd849WtXQ/zA0Ow2ayGLJ474L0G79vvbulwkJi8BGCg4S01SKqofoNvSIC+5zkhFUupV8rUTpJN06KpaBkFQm5M1HlkA3AyM5/u9Zl38zrk6f0iU6/4hmscgK5ISUtCTowyDqb7UxwsqFJW3fo/vbuIBJEZ1YRgyHwQKNi0KEl1OKTCZJdxtPDn//v8ooaDaVgqFyiTD2IKfcjZS4Fo+7g+HXOPv84jG4DIzKfLzQf8KVfI/FNKrQ6h94tfz+vOA9cGAAbrpylY2SDlVTTt+uCnV3/V3a7DQQAysJAwobZJgUXi78Qayhd812WeiOAZzEyUiAkHMeu5BF5FwZQAWLPwknkLQy9CrPMy8+lIHZFzvN3T+YbV+8X7c64OHHix74V6zIxB+RJ0wQ+UU992tYoFy3fcXcTDxQkoPsCUhFIczKVCegSg5B8A/PILN9ZwxBSxtiKiUAOi7JW0dLTustF8AGbm0/1o3vjjnSGdj+lYlGwdRO8XN+c1wABIoHk6k61yuSCJITq3jDY9Vx0BqK++uwAfX6JkI/hME0SC1EGguiQ+isqcQRLrF6/0jO2w+6FMnZhyZYsQ1W50qOHgPX1NXndtODsfgMwHzMin+0+ZN0S9YOllMzWfLwKQSS396P3iY3kNOLDPM1y065H4gOW3p4uTDkB8zWdb7FgbdDhEgJkCUDRvogTmd/vPv3BVAUBuvylNzAAYi4hisVQnEHoIqWblrxqm4Mx8ujfljT+YjsWBYgIOc0oJPsq1slCpH71fKybJOEoAuuVTRSCnYlmU6P/Z4iSJEcbLv+Yu9/1EAh7JKEXDKxq4ChUiKymRbwjgHdcUWTARgLYXHSr2LOU+BV7MVwzxwOfkOWybYAGZD5iRT0edjpxD6VhcOQ6j94tP51wdOHBdMeXa9OqWRcmWXA1XLUIUH6zyCwlAs3z+YBkfs1u+VIejJEF3ckrjI9T0y/aMA2+/tgAg08VURKT8vbKMUgAMIGzzAcOi5HknHQAz8+l+MW/829KxhtH7tTz+jIMAJPCYMULAWd6fvi+EY9ouoZBM/Kx/4LUBgFLgNC5o16FrE8JJVJgkiFhaQQBv3+dVbMrWVsC8UxFRkjjaVsW2DtRdOJ/vAyohVYK7A+bTvTdj8HlqTMcaRu/XxHkzjgNkIOWuDr8jnYYDKDutgpUhra0uAlAyCCUAK8BXcjBXgLCk/h0D/hcByDxFAdAzoFUqUBYRJTUcMWdPP7ONL6i5bLQeALJRQ+bT/W7G4AuAOXq/lsGdcRgAY+glLkYclJVTsa6ptCX3uQjAKINQstFrAZKIwWxQIhIJuovB/Nx+r2LzFCwlj8Y0evl/MYk0kieVtcvrwGUnHQCVjjVkPl3mItQsIPuElx9G79dOzDgMgGkAWlNyBJn8xKprBRC+zgEo4LWRgcdVcOCjjlNvmx84DrzNAahaFZWLygKWxUNibIhTcPD9BMLLa65bzreAMSGVoXvJ/Cgh1WUfO+XTZS5CDYDs9GH1fnOrIDcAkABTTDCCLYK0Cwi/586WcKJUiEpC8CCBYDsiiSplqUIUmOjf+o2tIiKVUJbgU5uSWl4DWwX4+PcXnrQATBNS+8yny1yEopdcay+930y5YhgAg+9n2OoUeI5TdQer+32fdhmGoOBZanBo+g1yEKU4dYgFSvqB//vZBIBt9RshkTbW8ZZZ2hUgvDL3iU3uux4LSBM0ZD7dPRnTH08VAIfV+2XAOucQAMuVcKfFSD/+IAABsEoGwYAoHZIKEEYxRIHwLS8pUuhjFVs6/ZZhIVWyxVKBBIRXnbQATBNS+8ynI4tBzkEACv+chlUVIKE/5cRGsWmlKfIzudc3APLQSlg3E2OCyVRc1kpU3DgBmKoQsWtlBcswjPu+nfTYtBL+GQdgOf16GCZW6pXlBCqWSgqJypoOAFfXXDifbwFJLvi5HAjlnUsiIe6AjOp4iQNQHRlT2PlgJCUbbc2s+v/hFwFb/q7gm6HlYpBbmTV2sscQyy/qFBj2v0/cAdz/HGD7NDA1AUyOOU+1CwWOewNjKj6/O03F1/WuugW4/XJgfBoYmwDGdH7IxB5kLPIB+I8AfNwZgga5ck2fJbEm8V9zNWPfrasbgMuPAcuseJ8Exsb9FdBhA+7gaQNKB6TfcgCYug+YJT+g89aoBDMmIMScP12uTKj13uDv8zsKig/uJ1uQOsnojm3qB5P5ACRBH3OhPuzzRN9DV88HqQLEWPJnvTy5nm/t/1s4BcuSpRZtGAu4fi+wtBVYEyccrYwn6hF8/FkJp9bKxAKVFsn/d8urgbHPA9NPOEOWl4+2cfoFHhfVrJTZPKHSj5daOtup6JyCpPx8rHWRVQ7WOlrYCMx8AHIzlxkALPD9c0VB+x/A3E/+E2fUYHXdF7KTGwdvTd0AHP9r4PgWYG0KWBdfsBdsMPfPrKKsoL9XAVLAvO2fFylCE4cKliyrDVZNcGS1CqEYhWFiAZV+XntaURdTLmpCEbpchTYLqi6NrkMCzLzt5Xc4HwyJmmkJ+Z73jQOh4NWeDUZiK1K08f0EXt7CMHVawIk7gaVpYJUA9LI1Ao8bzKX1cytoFtFfpdCIWz7rgzHgth8u0oPGDwETc8CEMySUzFaikgtlpW1Ta8JqNba7lVljSRgW+Q6ZP/57WQvj6fydBjXfAjKbgEvMLwWCvhNoipgNpnQshlS4IGFWzIk6ylWwAz93ETLxGWB5ClidLABoIOS7pmGfG+33YAG5mND0G8F4678vkiPJczNOAC4UyQm2N8w94kirFlfIAl7i402d6dbPWWAtrsjOFiuCvAJZOQE0pHTFsckHYDeCvhNgipQNxoAz8/8IPr5nbvH2jd+6AThJAE4AqwTdZKEBLDoDgU4+YVkPHIBoPwareOt/BkDexsMFAFnbzNJYm0IDnVwbt4uyur1kwL7Tp+iZM/08WT9Rc7DHUmuYTr/x+6o4ovvu9fjBbgR9JyA+omwwxvZI5ULg6ZW7y9FPf9QNwKm/CgCcKABovh8ByVy/UCtJq2f+X1yYJPGU27lIZLbuEWDsWBHesZeDz4iURLUWa1TE47LqK12fZmd3OXidFctqm92KatVs1jAEsNv6sdymaa2g8+xUL4I+Pn2beCgbLGWHI/h8G3oTr45iK86POlbBU9yKI/AcfLR+ouQwH9BfmmbLlTHboOnZ/T9+5vaf8FUaAThXsFOQ45mUcgZCWTAxe0UQ+urYMO1/37GtxQmoLCBtRSp30LrDp2SFdzYMgk/R+VNwvwR9mwQDsaspGSfJgYDYNTbp8psCQFJxEIBkQjDrxt8dXCUIY+COH5MVFPi8SOn2n/QYLZ9Gp0cxANIP5IvAkzVzxivRydnKNzBa8fddM84b6AFyAriMF2pajk9kYIeoClXmA3AQgr5NQEHMBqMVFMNaIOayNRL/vhlH3RZwmhbQQUcAasrVVGz4EtjCu/3dfb/ID3PbT7uKAZ/MhcIC0vqRTo4W0IBIEAmEtFwCYqjW03bcmdwBYeoWgetUbrR8snrloiR2drpACf+rD4D9EvTVjIJu7HBV+781X752Czj9lwUZkTEgcPoNPp5Nv4oBRhCG6dd+1DkMz1JIhR1BAHJ7zwqO3fIRRM5tmDK5CoQKsSgOeBYBKFZULTqcB9r6Ni5KYmd3WKDUA0BlhNLM8EbT1QBXBU72aI5ZjUcVOxz7WLkQ8d37vsart/uA6RcPsxNSAtAXHDYNC1AEpf9s01kKwuBwGU7HgVt/1jtD1e60fgQigSe/j5bQp+KYpGB+H62jT7P8/ZypBIC8Dhcx8eY9wF015abhmnoAyJ5WSrKeNgKO9SHxnT/LSasJBim5lRjWBEIVeROInKL1qunybRawLgASdEy74qjaNNzJCgqEEYzBGvK0297mAFSHEIB6ebKDgc8J1ksmV8t29f1en6L5v6cxIK5iK6Xne/5jCTiFcTqVn/r/tWDPWwXnEPTVgIKUHU7ljASawKefIwDpMdRxRB+wFgD+RREDJABpwSzz2c0LfxczVjkVKwaYgtBBezu3SvX08d39P5uO3QKahXMQciourZRAGKZWar/YZ1xXRPe8wQr2AUK7TvbOVTZBXx4MBECRnConUBSFEXT6mf/TK+/qmzAF/0UBOPqBZYF52HrTFCw2LH5G8UCzJEko5nZqmRnPh/uCXmpnVpDTsIPPwKApOaSA2QLDLSHf97iPx0tpISLfz7bl4iFfsUsnj+HZWEeOYDCDnDmCvZkEgedcCjxGseIhBYt3vx049HwMLRh8gA9gh2MoH9ABqKJzxf0McO7XlSAU4HzhYYFq+5D7hwBu/98OQLlIBCKnW39SlXNY+nqeiq2dkQg+gnGPb9/ZpT0lq6MV5D96gLCwgDmCwbdnCvZmCgY/dxy47xxg5SWuUjigYPHFbwA+fyGwfr2rXrMvPB+vp3L3GHCgi9JOHQCkRVPppeUBigXLFymyejYTB4YsgfA20ofRAlYB0FfAlvQqP0/TsX5PLOB5DNu471cmIwiBaRww/F01J+mz2pqChxUMZvpJlmBv3iTocsW4dzewfhkGFix+2febXDAeJO/YEILBB7pU1g8LQFo98QASVGYNQ6DZfEG3fnEqrgLhbf/HV15anbkFNCvohWSl9XPQ2XTM/2s3I4DwPIZwBEDfgitH0Ek6N6x+u/iD7T4g/YdBBYPpWHEaHlqwNw+AQa4Yj54JrJO+aQDB4pt+oCAyYvOPEIQDCgYfeF/9U3AbAMX7ItAlVtAspKZdz5SOlvA2pstxjES3wJ+92NgAGK2gwi78QoVfEhBeQACqNNP1RdoA18kKdgDhxkUI/zKIYDCnqyzB3jwAJnLFOEIW7QEEi1/1Y21ywVglCAcQDD5/Efj7M4CVrZ5AKlkhxeQUaxBI4nvFzxf8IfCVC4HV7cC6ZEX5nen3VX1vAGLZq8ysrvHY+QBwbGfI2E6JpLvdX+ksthpUvQrmX/sVDGZVUJZgb17vJHLFeGQcmCdVb5+Cxd/5xjZ6QzzMLOQBBIOfTV2Ps4HFHQ7CLQUQmUrV0rgKJMsCjsxGAqTn/hzw0EXA4tnAyg5gbTYBorKkUyLnkB9YVhTxu+kT13iccwtwdBewPAus+b2ar9xJAafqfgMQO4dh+J9+BHe5gqZZZzYok1JJUcpaR6bp93P+W/N6p0KuGIemgEWKgPQhWPxdP7NBLhiHKYHUp2DwpZ8rLOD8tmJQVplOLxAqmbRKC6EDYC7/CeCRPcCx3cDSrsISrs04CPm9ArZk55UvKAspYLqPaPdR4/H0g8DRHcDyVr/X6VabLHk2PhjpPVZY7d5xwF6CwS9y/4LbbVyQsEKIufGiKe0p2JvXOx3kinF0GjhOQY+oNRtljji9TQPf/fOV9IZY4Gq4D8Hgy/4W+Oo2YG5bUUy04vUcLCqSJVRWszJbNgxSmMau+q/Ao2cBR88EjtOqbgNWWaTkIFz3YiWrF4nAjtN0nBZrJnU+/8PA3CxwfMYB6LUra3oglL0tps6wlVha5rLiqd9AdDfB4Je6U0s/0BXTDYh80Sr2FOzNA2AXuWIszABL1JaKWq1R+nwGeM17OsoFY5XTVw/B4Cv+Djg0C8xvLYqJCECzgsxmZlq9T8e0XGUyaUizavPtxoFr/zvw2BnA0Z3A8e2FVV3x6c4sqwObckeyhiXAowUSADhD1XhceDMwx37lvU4XxVN2n3rJIocygkr/Vbs7fe+EdBLcfaXXQ3IPWIrpBB6XlnwpR76jYG9e7/SQKzarxM7qJFj8mg8UarMV9IZ4gvNDD8HgKx8HDs8A8zMFAFnPYQPDl0Co2g4fpDZLqKCxT0/7fhJ4fCdwbFvhRiwRgJruCOwUgCpeCvUjZmEFxhfk9W969kW/B8xvKQqnVgg+B6CB0MsI7P70AHgmd2n1NQ0rv7FvALIlVYK73MnQCDLThSGZoDpuP7uCeuX5n8zroB5yxThGnQ0CgyBMxY63Aq/5aBHG6EBviDlOLV0Eg1+0AByZLgbl+HRxnZXJoqqttA4ODovlJZVuSjTQFtq+NwNPbHMAzramdVpVs6wEoPtdNg37wJfvsYiJP9NFqvHY+7vAwjSwxAeNxVO8T6aNVRRRlT6hHrJ0Ovaw0WDJCKng7g86APvNB9wg2JvXO33IFWOBgn8EIf2nRLD4tbe1+AU7yAWbZeskGHwVdd2mgAUCcNKnJgLQrZ/V9/Jnn5JUYmnAE3hCmv3+t8AWQfSzyPK/POOgJgDdsgqA5nfJAvLdLV+bz0kK4RqPZ3wQWJxyAPqDVhZQyQr7gyaXI9axWCFVAGLvRUhV46PgLnUWBs0HbBPszeudPuWKsTRZAJDTo8l8ui/42juL5veQC7ZpsEow+OrZQlqVVuH4FLA8WVyDAOTAmHUQCAWQkOlsQAwDt/9/AE8SgPQpNa07+AhAA6HLXbb5Xr4IaAMfv/eGvP5NzyYA7UGjBWTWjh40v9fSyscHLtaxhJWxFVsNNAXH1khw983+DYPmA5aCvXkdNIBccemfceooAfhAAcA+6A2xLuAGucxrzgKOMexDfV9OwbS2BB/BEoqLSrBoYGgJ3E8qLcIEsP/ngCPuUy7S13L3wb6PU56/m/Xj4Ps0TKCXQA6AXuNeZY3HMz5QANAeND1kwcKXlj6wOZQ+b7R+Pi0PD0DeFAfk590CKg8qncfoFzIRVWVqfFfBhgn25vXOAHLFWCDbvPstBsJZ4LUPt+jdesgFg+qVptWq11bg2gtgfuLiRAAgQeg+oEmsOujsXb5SsAoCIN/3vx04OlNM6Yv0tdx1MKvK7/TFjVmeCD4HQQQhf159eV7/pmc/kwCcKABoeYvR0oept7SEoZQ0Tr1lPuPQFlAtO0nyAcWhpzw/FSjFzGjLx+RGvxzoSeC1hwsA9klvaFN5FAy+9mJgnhaQ0qqagglADo4c9AhCDpJPl5ZommQ8738HcGw6AJBW1VecZv0cePwOY0/wl1lAD/WUCx0mMlDLr8bjmb+Dwp3x4nkDYbD0thIO5aNtfmDi/xGEeRawxhs7Vb/q2huABQJwAlhyy2cC0xoggjAAUCWWAkksOiIY978TmOOqeqqwqAx3WGhHK06n7TDwOcAV/iipPAKjwgrZm2o8nkUA0gKmAHTrp+o9MTrEYvq44o9pZIOtgmu8mafCV72YAKT/RwAy5OPOuVlAAk9Oule6xQRTWUKlWtkU/IvAHAHti5oIwDK841ZPFtCmdr0U8PaC9hVultd4CIC8P2Ztt/m5/qC11TJXlJDGGpfGAmYODgFoCxACkLpuWh3KCgqE8gNVZK4KtxgjJAB/2X1Krao1rfN7CWZf3LSBT4uAEIyWBVpipL7GgwA0AW25GbGENBTRx3rm1M2w39mmrFVwjTd1Kn+VAZALEE5LtIDyMWUBvbLNLGHgd5H/V07BDp7r3uU+Jadgn3ptxekA5MBri0/Wp4wzBjDbCnkMWMqVpE8GJwLQqvfc0pqbkVj5aNk7gbCxgJno30cAjntowtXNaZ1suvSKNhsYTcVKmw9F5xGE+94dfEoP+JYhD/8OC8eIPUsUHokVVKB78XszbzAF4Pvd//PCKVGIpOAr78mn4DZOm8YC1jco+w6EFTDDPJqeCEBZBa5GffVbhmQ8DtZW5TYOvPhXip0GTuu22lTMLSw+aAVl9QhEWjurI/aQiLJkTMLsX9R3r/ymZ73fp1+37OU9hunXSkdl7T3QrhKCtlCM59k2i5CMMSIAGdqxEIwrmptzTsCEut5yilKoJLAcxCq3fe8tLCDBFwO+tKjyuxSCMdYEXoeDrHcHvu0tTwLzmwHA4N/Gh6zNCqqeOSxC2lb8tQSiMwbuqXIqAcjFh2JjBKGJyShQG6ygVbfJegULWBYcMR3rvb6oCRaQwFPgl1M5rR7/JtBZOIZWx/0+s4QeY5z/1/X2tFnAxPpFELaVkdLN8MWGVr4pCBsfMHN8bmTKfCjZ0Ncp456/x58zLzfw6Qf3ABd8pUgEYmqk5bGyek06IQl1bkXScnlN/u8L24Gdx1qVq91KQvrpgwaAAw9p+wnXPw1YjyWMGtDo2ASOFGMU7SIEUzdYD34vMPmXwLbHgdkFYAtlGiim6DpxJtvq9LtlVr/aWKEB8pUXAOOPAFPzwBTZ9r04vdQ9Ts4pAZ3cd+yHxgfMAOH+vcA69/9Uxijmz/AerYpdar1lNSMYzV+vWY/34I8DY58Gph8Bpo8A04vAFEFIknIHohGVR62QhFRSYjQE6qFri2z3iaPAhHNNlxKwArI0Q1IAxwfReacbC5gBPp66/5ICgLKCtqnsrKKlrFZUFPKOr7osMTtdsxzqQRZ93Q1MPARMPllohUxRqkEK6gShOP0S+dY2hlRv99y+ovRi7IiTnTvLqmg6xDPYpqAUgRgsoR7MxgJmgHD/c4E1FXu7FRRbvEgd7evXWlbPpp9EgUjiJpwe6zwOMlvpAWCMVusJYPIYMOlSDZRpoGiNxKzbdIQlXONMWJbGtw4svdgz3El47nzTRvPrrKptAJT6ZrzfintvAJgx4vsvdQvIXK5VYF3sUZxmJUvgA1FOvwF8spKyBtM1y6EepI4LqVMedbEaTp0EIKdPKh5FqYYqSxgo2jgFr13j6XXHnOiSZOeBVSvyC8qC2r05FVvVw9cAMAOA178AWPMp2LJaaekiCPXExwHw660n1oB/niGQazwOkkSepbJ/72I1x4CJ+cJ6lYI1riccrVicUuVSmIW82pkwnHHVOKbFsOozQGkFkwewnBES37ABYMaAX39ZAUCCb82nIlo+40p2gNnvsoKunxH1xGwA/LOzdQOQJPIuHzV2GBg7Cow7AI0l33XfjOsv6oVodes6ISbBsAZMX+kJxU56KY7pkmFVhOciuvTzSt05v0+ryuT/9gDrZNe4wPMsI7VJP3GcP7gUOOdvgL1rRYJ0ZI5IV3hV4/wrGYPPU3/AiRhYusy2K7mU999P+z90ObD7LuBZK0Xdkeq9NSX2+o4HLwfWlopFCC0fgciBMtAFC8CGrYXVoVjnU2G7rTXrzh4kfRzLY1kyGwBoeiGcPiXb5eAzdXWnazPCSScb4j3xfmav8Cx2p50lAMW0VXINitCogl2r9H2dcctWwQxQsn6ZTBbMNtcgdKIbiZj51VcBk38CXPxoQcfCUg8pjcYgZScw/momACnXyr4leBhs5QaBTHpf7X8dMPYJYO8XgAv9e8QJlAZZq8D4xSuANYKPJQn0AR2AHKy1MACKe9nfFI6IEqduEWoHIJ9wlsVKLekoMCa9EAegSTYQeM4TXco2SEMkAHEbBZoj4bbYtdyCVrFqGXgTSxgXYTZeHLi9AMjEQRCVUXP/n4KUaaT8vVTi+Rtg7GPAuYcAWlMCgUVkQfJ2Q12yBvPXMwHImhDWwf81imsTiLSEvHZkr+jY/p9CQRD4p8DOBwteItai05qn31FFdfLlFxYWgCDUIkRkj/TxbCEi/89jfPZ3X2VqYSJQbmUNQY3HQT7hbv2sLoerVwKQHNEEoCsm8R4MhPRjXUGzVEIKIoY7yaEYuY4dgGb5RXruoSgtSCLLarkICQ9f6QNykGjFdjsIBaI4kGlt8W+Rg5g0HJ8qAp47nihAzFpuWtPIMBZJlASILvR6fQ0DCVbJCkJOJCqnk4pGpb99tZ8MopyiKDX7WWDiwYKXiEQOehCrgKh+eJQ+EQHo1Lby/zRlyf8TIbf9XS5ftIb8I92YugH4ay2pLusorl7dAoonWtMwQSTdOFuQSLTGHyIC8kxSIQuA4hwU2WUAoO4/grBcDbsfWElSzg+JCoYDoEGM1ixSkHzgF/wG7y8sIa3J7JPAGWuFJSQIaU01iJHUiYP4e33BrPOHmG/JMaOfTZVYRhwGav87vWKPJ9/rSH4IOGO5sITqg/ggxXs4TOaBAECbeoOsgfl+DrQShFqcEIhyyt0MbMusEkx76iAZXKM8BvXiZAGlF+KaIbaadYpem4aDgpJZQz6YJABV5VcHAJZ0v4FxX6KG5UpYs0KnqjhRuagEVgPglYAl9ciHf8mdUrJh0Qx9vkDBzBywfbkYQIGwahA/kglATsHsDzKA0BATiPyZ4NEDwIeoa/uFYKKXL2f24nQoIgd9R3yQCMTFqwIAfdBWI7+yB5ZLECYLETd85YJl+2YAUNosLIel/xYlu4Jsl6bhNhD6it4WJCvA2Zc4Gxo73RcgJeOqFmGR6rcChLYACyGojmEYdj59KnZ+tIQRhH9IvWA2hiREjDeRI9Cly7fMF3EtWRFawhQIf5IJwE56wdTIYdt7tp9ys1K8JnoJvod9Wn682PNkP4hUy1ndWgstAtBDMLYN5/6PAc5DGNoF4SrZfN+4+IhT8jqwg2Cp8ThIJ5vfSWBXAVCrWN9SMxDK+skaOvhoAc8me654pmUB3f0wyt+E8FyRAGmPlOEoiSD2qgvmAKoOm52fAuiTDHSyIRxx+lI0QxxADubfF5vffMmSajrWlP7nmZ3dSy+4r/ZzAUEHnQ8R70HsXlK+PgJsW68G4XYGZj0EY2EYATCAT6tAhmE0DXcC4faapcwMgAIfLb0kuzT9Qmw5uwAAIABJREFUSi+EfeALkSrpBovbrQDnkm8wAo8/E3i+CCsZ98NCpAp8cUekZyBavI4ET/TnaAk/RQCyAXy6uNSPA0i+wMeB6ePA5HFgZq2wpNGK3FUDAHmv3fSCe7afX8CB4UNEEOolVi/3obastNwJ9cO5BOBKEQMsAcifHWzRAigWWAlCn5K2bQYAOe1KMjTIR2kRUhKVS7IrLia0v+3xwHMZMCbYNP0KfG79zAqK5DxOvyEuWu6VD5KSHy2YAEQAfpaRdl5UkuUctIpBnCIIl4psD03FtIIP1ADAlBuJM47EqqUX3LX9kSBQcuuyftK78xUkHyQ+RLqHZ3Fv1KcgLj5kAQ1s0Qo6IA1nHhNLQzA8ZxvBXuNx8DcS5UYpNnoYxsCnUIqvZo0F3wPTMa7Hv53HOJVbS/l+5bumX7d+5WLE44hxIRJB2NMCqj9ixwuE90svWCaIA6bAp959EKeWChAyA0PTOV2unGMQveCO7bfqHbcS4rJR7Ewqnw5AWhLuImg2uFQAXAVs8RGmntW4+g2hB3P79L/EJ9zGvqrxOPibiVihAOgrWQOf/EBfBcsPNBBqW9Hv6zzGqFzmoXz3B9AePgXiq6bgiv4YOB9QHS8AfpkAFMMjrWAcQA0iO9XJiQyAnos2vV7ESHOOQfWCO7Zf7F40mZFQScRKAYBaSU6vAVcTgN7xXHiUFpDTMK2dFh56912BTiDcvpkATIXzCL4g3WXTZ4jpGfjoF/oihL+fx+0yWUABLwIwtYKKIabgCzHQvi2ggBKn0McEQDaKT5cGkIOo6SuyYzEfjQB0EM5nZgAPoxe8of3sgSqCQM3jkdFLvpRvR13+7UVRuhUFSavNO6otwp88ZZ3+t4M6HLtch6OT9AG/q9cmtf//gV1JDYcnQ2zY6/YakfSrU+Pg1M45NqPt3IEtoM7WFHokyrWKkooglCMWLYjiUXMtK3g8Uzd1WL3gDe3vRRCoUEYCwGtYFxxqgA2E/jI20F5hhmQod98BHNnlxOTig1aGiDanO21yV4DygWuB8YeB6fnC9WEtiKVVKeE0ZGiXWczeJoWMIig5a9V5DA1ANoKDeDylZ9NSXxyAsiKawrQqmCv2HVf5e8aRoxfc1n7xs+khItAUvojvyWryxVcWJZksVSyZoQRA3dcAoHzax4Gj2wtu6FVKM7gMgti02jbV476oUJJs1j/AbA1mQ3Pm8eTRsoZDtR+xZKCiEKmMXTIeXHPGdhYArX8FwG4DGMEnAHIK4yvT58nWC2b73cexaZgWWaEKgU1gjNbPP7PvOYGsUSBkv3hBtmRWNzxjTk9RWktvxp6POj0vARjY9sWkFel8RWxegjIF4RjwAOnZWMPBTGjqvHmszxJOBUD3xyznL2bqROvoP3N3q84jG4C7M/PpcvMBef0cvV9k6hXv+2Yno5QfGArRbaCC0mWv2YtF3ecerNDhkNZIIsXQRv5dlTtGADJSz2gEE1EJQM//026HdIEZLC8B6A0tk0g1Ja8DuzJdphS82QBEZj5dbj7gxZN5er/IZI+67pscgE7QaDOUMyC0Wb8+gXjuR4F5J6YsaXnFhBoAGEVvUhb60jISgCQnoh/OLBgvIrL8v7DdFkEYM5dtNg97tvz5zJqzdfIBmJlPl5sP+DJP5xtW7xffnzeh7H+Z+3+RpkyWT1YxuURJYVtx6T0fCTocouQV85VkHRIGegEuEv/YKpkA/JceVmL8kv6t5/9pu62tfiPWcFQVEa0DZ9WcLJEPwMx8uvfnjT9IgZyj94t/ldeA/S9tMaGa9SNdmsIxbvVscVJ1GScoMt4UPwhAsmMZ0aXzQBsvdGRBjQz0FUpEJRAJQOq4KAnBdz+sfiPJ3bOYn8fsykyVWMfiN3BOzckS+QDMzKe7OW/88aqQzsfE5kH1fvGjeQ0wADodmVGwOeiMsUqHrGOnS4UFy9P/wAEojkEnI+IqOIJQNLgpCXhcmLAtD/D+kgQE235L93tj+YBqgTX9BiCeW/NedT4AmQ+YkU/3sbzxBymQuZhm8g1T+QbV+wWFdjKO/Te2mEFNlCb6gPF708VJ1TXHgKd91GnZpDfi1k/gM2vqU3DUnCuBmNQe3P9vw6pe229KOvB0K1k+ZS+rnrfM2AlA3JMZtah/EZKZT3drxuDz1O/yxAwu9JgJxr3lQfR+8aa8Buy/wdWQZAVl+ZzCrG3q9c/YrkmHy3IRYryAAqAkEBIlopJxNNUbER+fA/H+/+AAdP9PmS9dazicJybm7mlB8nR2dI1HvgVkOlZGPt2nM29GCamcGZjAwlQ+vvrV+8X/zGsAAUiLVPp/wd+zaTMFWw+/kAA0GQQnpCw5mDsAMIrcRB5mC/+MAffTwgfwKY2KfmCZ6ZIkUShrxXxBX4yYaV8Hzmcn13jUA8CMfDqWYeQcSkhVOl8U6uxH7xekrsg49h8oiCENgC5TUG5vKxxT8f2aRtOtcAKQ1s8soPuOVUIwpchNlEEIOyNSIrrvv3hwnckWIZPZsnbcDyzTpvg3lU8mpZQqozyfK74aj3wAKh1LgrsD5tMxiz/nkGD1sHq/YNFOxkEAcuW7oqmXlisuQOT7VV2jwi/kTgj1RkoZhBje8Z83SCAEEJZW0C3gff8tADCt4VASaWIBK0HI9q8BF5yUAMzIp8tNx5Jg9bB6v/jdDPSRns0BWIZeUitIo9IhHmhXTvzCPQddccnZ76U1V/IvC4SBCFyg26DFNg7c++Mhhb6qiCikT7WVUmr6lYn2nRKyrdZ51GMBlZIc07GUBdMjny6XCiUmpA6j94vMZbgBMFo552pu27PXAqXTyAUQcitOQjAm9xX0N9pIwIPmSCmH5QuPqER0L4kDYgp9zOUL6fYxkbZcFceyAreAF3GlV+NRDwAz8uksnT3jiILVSmpWNlhMze+k94vMZfgGAPJeHDjpCrgM01Tdry9OzvmYAzAqLVWIwEShwzbRwwSEn+MqP6bQK5tZlWyhjCCCsC19Xv7gOnBRbgp7cu/5AOyVjqVMmA75dJZ9nHF0yohWNlhMxKnS+0XmMtwAmFq4imnYbrEqNJPc+9kfd62RKh0On8qV9hXZ9askEPgAfI56ziocUgVbzGT28lEtRMoKtg7lBHtznfZNA+CQ+XQWM8k4uglWK/NLYKzS+8U9GReXD0g/Tyvh4Ne17Yb4Zbr6g6y7/aNWcoPpjKRTsJIags5IJwkEAv6en05S6GUBfRWsUExZyVZVQCQwrgN7Wfdd41GPBczIp8ODeXfTSbBa6YYxlY8/p3q/udc3C+jTbtvqt2oadnB2m4oNgMn0W0p+hYWHWbwg9yU/0Kb9EIy+5y2hiCit4UgKyTeAkN8Valk4Le/ldlONRz4AWWBRM6fdIPfHstw/G+SE5rMnVQ/kA5AkLHS0ak7V7reXfhgACaBqDtD3e/nmc5k9kA/A80JReq+U38zGVp3ObJo/BvAOD3dtwiWar9zEHsgHIGlFubqSx7+Jja36anLLcDvvgwA+NDpDfILv+qlzuXwAXuSjrkKemlO2e3U1uWUYnL8dwB/5e2apca9LNv+vsQfyAUheX4VguB+mzIsaG9ntqxhF4Xbe3QD+n7/uHLAW9wQ1tblMRQ/UA0CaHC7plXEh+q4T0OWcfhleYTSHBK0EH/mi+fcRuKQn4I6fWpeoB4AevCz3HOOm9yb3F5mBlZBNclYCj1aRfyfrbgPCTR6AzK+vD4CyglX7jpmN7HY66d1E0ctdIrEEE4wEIMlam+Pk7YF6AMj7EwAVbU82vTerCwhAXopJN9zVI+AYrOeULLZgErY2x8nZA/kAJGWr0naUWdFpy2cT+oCWjpdjLFxE5UzYIBBpEUX5nLnlvAktb76SPVAfAOUHpiAMm96bsVtCAMaKALICMyxDq6cXfycA+b/mOLl6oF4AiqBRIEzBp7/X2Af0+fi1XIioMIlAI+AIPIGPmeROWV3j1Zuvyu2B+gHoFfZiDS2lC0LiY52WUADkQoTTMH1BFSYRdHoRfKSu5v9qrizMHYPT+vx6ARhSuDcAzzmDo5ZGHT1PAKYMwQxME2jiSo/gEwBrrq+u41ZOy++oD4BaCcsXTPiSI3ey8s4KGoG8QwCMFM+0ggQhLR0BF19SXuD/ayakz7uR0/TsMcxg3SjfqWNA0hsrga/ojaq/8WPcC+YIk4Ke4CMSuB2XVht1Oj8zIfXlU8BtU8DhmYRXWdfrdF1fgr3+S8At48CD04DVjXQSDO70PTUnaJ5uOCwsIIFHSSFy1pKPWCDsZxCpw8UVgKSPxLXM937OzxxAljzcPAbcswU4Qh4V3UN8mKoeKm/bu78IfKJQa8VD48CylHQiL3O3/qg5Rf30BKACMtJXjXKQcfBSK8Dfqc3KVCwuN2VFGRnm/yKZtq4Re5ifyQQgM2A+BeB3GHaZBo5MAIue0l7Kt3cC4xhw+5eL7TuCkJk1jBtyerbUfYG5ExjZ/pqrxE5fAOrOq5SmowVIrRp1IyT2R6+fg0bgVYG4CsyZe2UsaiOGKXr4Sfp9k8CxCYAFSKyvXeY1o1BxQux91yMtfsHPutgnnyUuUvhc0ZsgUXib+nVkq6+ZKaABIHsgVZnuwD9sVo66rrR4ImdhLGSQ8zPL/JgBQxeU1ouWkO9PTgDzbgmXxrzMkatl3keivfG5x4r4IRcz5BfkO5vEZ0kgpIfBZ8yKjlL17syy0tMNcOn9dl4Fy6dLFabj1Mpvow9Ify+I4Nlo9Xt+ZqU9VdJpqZh4QDDyxUyYOYJwHDg+DhgI/WUVZl7aSEt93+GO9Ia2iuZKOfA7lhp9JpvAVy61w2mOwO5hmCgMHC1H9O24gu6UD9jP+ZmbtLRaSsei9SL4XDPbAEh/kGQ/pSUcc0lbApFWb67lQUhpVnLBsoKqqZclFMmUtrxPcwxl3X7vOCAtYLSCcugFQmqhdssH7HU+RznjiOlYXA8wqkOfkItTAom+oKygca4ES8jY+N3z7fSG4hfUtp3ihUHruVSsFy1iRvNP+1N7A5BdJACmVpAgZPhGOyCigEjlPLudn7kvFtOxuB4g6OjD8UWLRkCZFRwrLCEXJQQhp2K+37lQeBCRX1A7KPQto1prFEmSYn2mB9EAsO+kYfk8KQhZF8yjVz5gp/MztyOUjiW9bCUhEBhKRCCgSis45uQ/PhX/xfFWMgOnWu2gxB0TF/o0kEZ/kCDM1Ts+3RHYnwVUL6XhDFrAswfIB6w6P1MrTulY0sum1VICglKwCEACqvQFCUK3gHcsFQCM/ILayqP1k9JshVqrncMalOYYvgcGAyCvIwuod8YBJQmZpmGJeyRwkGw4n8jJOJQNw3idLFhMRNB0SgASTJyKoy/4ieXCeFfJBUeV2SoAclFyR0bbm1OHTUiN0/DTAwD7zQeM52dqj8VsGEkVE2jKetG7AEhQ0frJAv6RC0trC1skl+IWlNinGLbSaZg7Mc0xfA8MbgF1LQV1z08A2G8+oM7PVF9Ms2GUE0gQyp+Lwu2yagLgR9ZaYpkSypQ6a6Q2DCqzpkvietXIFdoZfuieGmcOD0DeP0HEbBhNwYPmA/L8zJQsATAKnguEqS+XTqkE4YfWWwCUFZTksYAYwZfIBeN9Tw0cjOwu8gDIZqsoSSvhEeQDiiGYFoyWiSDRypWgi69UP5sc5fIcquSCNeXqe2X9ZAHfM7Khe2pcOB+AT41+aO5iRD3QAHBEHd9ctuiBBoANEkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cvAFgg4GR9kADwJF2f3PxBoANBkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cfOxqYJ2au9RdPtdp/khoEOlglDYT39V1PzQFXLsMXAlgt9PCxJKPbufyf8/KHIPfBPAZABf79Xc5XQ0ZQ1Q7360NbxoHrlsDvs5ZRsgo0une06by6X1mZvtP99PNAp4F4LsBXA5gjw8EGTeqaGF4QhzQF80CX7cAvGIdeDYAfhdZ2sTKUcVrpE7nd31N5gj8e2dIo2osk7NZpMdK0Z19tv+bJ4F9K8D1ACj8yfNSikHeg+5Z969m57Y/8/ZP+dPLKZhP/rcA+AYAF7g1oRUhEMUzFMt6eSJfX78b2DkPfM0i8GIAX+uWlAMppreUUErn8p2gzTl+2flg/sDbTkvIOik+CP20//mzwAXzwDcCuNTPJeFXpEpM6QEjIHm/zTF8D7T5gATYNQCe69aAloRTGulfBESBSYNyxR5g/Bhw7hKwZwl4vk9LnM5JmsBzUyDGAX3B8G23Mz/g9BuUa/0IiutfMkj7zwKmngAuXSvOpUvAWYBtF4BTnspIj/O8zPaf7qdvWITw6eZA0JLQEhKEGgxZhUj/dz3NzSKwbR44exnYvVKcy+mM5Km0JhxInUtrGkmzCPicg3W5LMGkQiZZTm9xS9Z3+4m2o8C5c4X15pTKW2Lb+fCx7WLtjYxzqiql29Icw/dA5SqYf6RTTilg+lYCIXmICKQ4IK9wxfSJY8AZK8CuFWDnanEua9ZTAMsaCog3Dt92O/MvnRGBtGwkqKRmMEkqCaa+2k+0LQDTh4rP88UHj74kF1WaATo9QHQ7mmP4HugYhtEKj4PB6ZQ+FS0hQahpldPya1kXTOqNY8DscgG+HavAttUCvBxInitrkgL4lcO33c7spBdM3kAuSnq2nx9gQfAh4JyVwvrxwel2z3p4aMlzH6DM2z/lT+8aB+Q/OT4EEqckWQSBkGD6EQKQnDCLwBSnYgcf32fXioGUFawC4esyu7CXXnDP9tOCsyD4KLB1rmgvX7zfbu2WG/Jtme0/3U/vKxBNAMoi0KcjkATCN3HOEr3UAjDrwOP71rXixYEkeKMFlSX8ocwR6KUXTJ7AaNE2tF8WfA4Ye7Kw1mwvX/yZn+eKnvcrfzC6IK/ObP/pfnpfAGQnySoISBqUXyAASS1AK0JfagWYcRDOrAF66TxZQU7jBOEbM0egH71gcgXSFZAV54NQtj9YcNIpbONCyh8Ygi8CVospApDuB63g92W2/3Q/vW8AsqM4gLIKBBIH8bcJwMCNMX68BTqBb8s6sGWtsIA6jwDk662ZI9CvXjA5A6NVa2t/IAicnC/aGV+8T74IQPm/AmGuBc+8/VP+9IEAyLslAKMV/LgAyIUInfnjwPQqMOOgI/DstQ5Mr7UAqMF8V2YXDqoXXNl+EQQ6N9v29aKdesUpWJZbAPyPme0/3U8fGIDssDid/pUASCvCaXgJmFguAEfgEXT27gDkuwaUg/nbmSMwjF7whvbLhSDL5TwwvdRqo9oqHzACkCB8U2b7T/fThwIgO01T1IMCoAZxGRhbKoAXQUcQTjkI+a4B5e5FzjGsXvCG9gdqrLGFYrpVG/UuHzBOw2/LaXxzbh43DKeoJwlAHqLndSs4udoCoIBHQE45EPk3DuitmYOQoxdctp8+rFwIWsGFYiFFoLGNchcEQC6e+OJC5J2Z7T/dTx/aApYdJ37AyJK/DIwvFxYvWr0IwEn/H1Opco5sveDUhSAAF4HJpQJkWixp6k2n4IYfMGf0amDHev2I8+l4/UbvNw8Eozw72wJePOJ8und7EkKj9ztKGA1/7WwATo44n45pWI3e7/AAGPWZ2QBkYHCU+XTMfGGQmYIxjd7vqOE0+PXzATjifDrKtTZ6v4MP/MlyRj4AR5xPF+VaqZLJF1UzKdPV6P2eLDDr3I58AI44n07ZMARbo/d78gMubWE+AEecT8e9YOn2Uheu0fs9tUCYD8AR59MpG6bR+z21gKfW1gNAz4geRT5dTEZo9H5PPRDmAzBmRM8BJzqfLiYjSKKr0fs9dYBYDwBHmE9XtRfMsIz04aQZ1+j9npygrA+Akqs8wfl0BCCTWRq935MTYL1aVQ8Ao1zlAnAi8+kEQGZTNXq/vYb75Pt/fQAcUT5dBGCj93vyAaxXi+oDoFLyT3A+3Rcavd9eY3xS/z8fgCQX/LPR3SOzkon55jg1eyAfgD8M4NcAPD6aDmBtB1e4NMDNcer1QD4AbwbwxwDe4UvRE9wHZG1gNSXDLlwLNcep1QP5APxzzwj9IIAPnXhT5ORc5EYCA9HNcWr1QD4AmRH6FQBMTSZZH98ZmD5Bh5g1FopiNns1x6nTA/kAvAfAEwDudnI+EvQxPfkEzYfaCXRSBluQMB7YHKdGD+QDsBNBH/9+AkAobqTADGK7Inw1x8nfA/kA7EXQt8kgrGAGMfBxZ5Cv5ji5eyAfgL0I+r68uR0QmUFoBQU8vfNvzXHy9kA9AORoMw7CdGQCjoUZDwL4kv/+8OZ1gJhBIjGDgMh3vTavBc035/RAPgD7JegjODfhiMwgoqeJwNPPTaB6Ezq/hq+sB4AcXeXEP+ZhGVo9vRimIQD5v5oPAZCupgDI9wg8/qz/1Xz55usyeyAfgMMQ9GU2Op4eAchpOIJQQEz/VuPlm6/K7IH6AMjgGzdl6QtyX5jWjpQFevF3lq3xf6yhrOlIAUgQCojR8gmE+l9Nl2++JrMH6gEgR5UA5KYsc+AZmCbQCDi+IvgEQMob1XBEAHIajgBMLV+0kCdws6aGu3zqfkV9AGTwjftg3JRVVRAtHQEXX/wbAcoXP5d5CID8GoJKvqDAloKOoIz/y7x8c3pmD4zhaqwjRzCYyQg5gr2ZgsFTLweWr8XQgsXjbwLWrnNtMlKgNoLBmZAa7PTCAuYIBlMvlWQswwr2UlUw45jdDSx8HbD+Ctd+HVCwePKbgJV9aASDM8Yg59TWFDysYPBtmYK91IbNOHaPA/M7gUXKXA4hWDz79cA8+W0aweCMURj+1HYfcBjBYO54MMY3tGDv8I3nmWSHOzYOLJ0LLPGXAQWLz3oB8MQUsEa16kYwOG8whjh74yJkUMFgbsNlCfYO0epwissVY34bsHw2sEIRkAEEi/dcU0SP5qhF1ggG5w3GEGdXr4L5134Fg4kAjuDQgr1DtDqcUmZETwArZwAru4BVqsv0KVh8/o3F4v0QXZBGMDhvMIY4u3MYhv95Zh+Cu1xBcxuOU/HfeDIq5cv7FuwdotXhlCBXjOXZAnyrO4BV6in0IVh8wStLuWCsUAyvEQzOG5ABz+4eB+R/ewnu/kOP/3G/l4kJTERlljQtIot2e53/IwO2OPl4FLtcnCqAp9cahT56CBZf+LpSLhhz1N5qBIPzBmTAs/sLRHcTDKbiNHdBGGymOC/3hglEvgjAnoK9A7Y4+XgiV4zVWYDAs/etxaubYPFFP1QkLtCIP8neaASD8wZkwLP7AyC/tJNg8L/xLNBu+YBdBXsHbHEFAINcMVamgdWZAoRrfPdXm8KitLdmgYveWAq+2y7iMqfuRjA4b1AGOLt/APJLqwSD3+y5T1yI0AoSbAxMMzGV1o8/My2ro2DvAK2t+GgiV4zj4+3AIwDXtwBrVJeuECze+9aW4Dut4PxkIhYsdetGMDhvoDqcPRgA+SWp4O4veQ5Uv/mAGwR78+6rQq4Yq9PAOi2fA4/vBkKudKVU7VZw77uKvWFuZbtcMNb5v0YwOG9g+jx7cADyi6Pg7gccgIxlcA5TKhaD01yYKBmVFpBZMfx/m2Bvny3t8LGqoqTliZbVI+gMgHwnMAnCIFi897cLAAZ6QyzFzzSCwXkD1OPs4QDIL5XgLmk5JHk/SD5gKdibd38VcsVYGmuBTaAzEHLHgyCcaokB7/1IkUET5IKxwF5pBIPzBqbPs4cHIC/AaeqvPL9pmHxAE+zts6VdLCD/lcgVY3UyWD0Bj1ZwqgCggXA7sPfWAoAJvaEtZBrB4Lyx6efsPADyCtmCvf00s/NnOsgVY3m8BTRZPZuGBUACdArY+5lWDqGmYbIrLHEx0ggG5w1OH2fnA7CPizQfaXqgUw80AGywMdIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0BxoAjrT7m4s3AGwwMNIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0B8ZYNMbkX+ZekpuIiOQrPar+xs889HJg6jZg5jAwvVZ8B+ll9PlO5/Fc/o+ECjnHfi8zYfkvM5ulmp4qJXVqx5deD4zfAkw/CGxdAZgoHfuh131QkaI5hu8Bs4Ds8B0AWLnIRGCBsFfn87JffDMwdjOw5R5g8giwZa34jnQQUwDo99wBfJ4TM7COiNdlaj2rA/jeV/vfDeATAP4UGH8I2Lrc6gc+SHqY4oMZ74VSKM0xfA+UUzB/oBUUCKMl6zSQ/PsXqZD5KQC/A0w/DEwcAcYXgYnVwppwADuBkefnCim90FmBWXwnK87Uen53BI8sbuwqaz9p5UgnQhBS+ZN1zE8Ak0utviCwq8DI8/nx5hi+Bzb4gJzKZE1SEFZZgS9/2pWR/gTAJ4HJQ8DEMWB8ARhfBsaWCwDquwQKvvNgHXvOcYVbPFJPkw+dDxC/W1Y4tWDpw/Rlgo4lo1T4/KxTihDNpJwj3/UiMLXemprjffC7eWpzDN8DlYsQDiKtVxzEqoHkyX9HRizW+nIgaQnvAiaeBCbmC0s4tgSMu2rMePAR9X252jXklaTFU108K0MHav/nvJ6ZxVVk9OI7GR2IZoGQNc/HgbHgIwqILIVujuF7oOMqWFawCoRxkfEIB5CWgkREBCNf9wMTc8A4QciBWyoGz16rwNgaML5eWKpctYZL3N+TWLX0gvtuP0HHk2n16JDyxXmVhfU0qywbJbr5GSuXKxA/sV5Y9UYWdnjwyS3qKKgarWA69Wg6fjQOIK0HadnIjPVFB+AiME4AuiUkCFnESyCSkmAuU7Cjm15wX+2X2ifBRn9A8mKcW2UFjULVQcgVDl80u40SYh763FfvquhLCxitoBYUsoJfjXKttByMq9CKcHn4sPuCbgXNJwyWkECcz5Q376UX3LNncZyQAAADEklEQVT9fFgIJs6lBBwtn3Tt6FpIz4RWnuQxPh2XIGzm4CwQ9hWIFgBTK0gQHiIAJddKq0ELQh+KL1qUR4MvSEsoENIKrgALHNiMox+94K7tl9qnnMio8MSf6SNwGpYVjCDk/Ju7isq496fCqX0BkDeqlWwKwic1gAQSpzGREnFgREz01eALLvvq2Kfi45m6cf3qBXdsfxRbJMho8dimqOhEK8cXQRr9QVpvPoDNMXQP9A3ACELFxPh+jACkP0fLIKFCCRRqKuPUdqjlC9o07JZwKVNHeBC94DQcZO0XAAkmgotAk9QYrR9f/BvByYfMSATDVMzwTXMM3QMDAVAgVHCZ7/MaQK4QZUHiNCbBQlqUw74YCb7gcmYkelC9YFlwvVv7RRAorTuBkECU9asCID9/x9B935zYzyKkqpfiNHxcA0gLQgvBAaPVkCqm3h2AtC5m/RyEqzw/4xhGL3hD++MmslgqCbgUfLKAcRrmTlBzDN0DA1tAXUlWcDm1IOIIJAjlT/Fd05lbFQFwjdtgGcewesFt7Rc/Gx8iWjUCjGCT1YvWT1MwgUqrf3NG45tTbcu0aximWx9xENcEQHGbcYAEwtSXSqY0gnCdgeuMI0cvuGx/FUGgFhwEYrR80QckWN+X0fjm1DwAWv8RgJFilJZBznz0pQg+AZAAlVWh1GvGka0XzB0cCQi30aSGVa9AF62fLOB7MhrfnJoPwPER59Px+o3e76mL5Kwp2G57xPl0kxc3er+nLvyKtLmhfUC78RHn081ONnq/pzcAR5xPR9mRRu/31IVgvgUccT4dNaobvd/TGYAjzqejumqj93s6A3DE+XRUg2VSCjdaGr3fUw+I+VPwiPPpqJjO8J1Nw43e7ymHwHoAKMFd7QErAeEE5NNJMb3R+z3lsGcNzgfgiPPpomJ6o/d76oGwPgCOKJ8uKqY3er+nKwBHmE+noqRG7/fUA199U/AI8+kEwEbv93QHoEhZTnA+nYqSGr3fBoAtaiqBUImdm5hPJwA2er+nKwBHnE+X1gUzSbnR+z11wPj/AeCpPDD3t7rvAAAAAElFTkSuQmCC",
    dM = "uniform sampler2D weightMap;varying vec2 vOffset0;varying vec2 vOffset1;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 a;a.x=texture2D(weightMap,vOffset0).a;a.y=texture2D(weightMap,vOffset1).g;a.wz=texture2D(weightMap,uv).rb;vec4 color=inputColor;if(dot(a,vec4(1.0))>=1e-5){bool h=max(a.x,a.z)>max(a.y,a.w);vec4 blendingOffset=vec4(0.0,a.y,0.0,a.w);vec2 blendingWeight=a.yw;movec(bvec4(h),blendingOffset,vec4(a.x,0.0,a.z,0.0));movec(bvec2(h),blendingWeight,a.xz);blendingWeight/=dot(blendingWeight,vec2(1.0));vec4 blendingCoord=blendingOffset*vec4(texelSize,-texelSize)+uv.xyxy;color=blendingWeight.x*texture2D(inputBuffer,blendingCoord.xy);color+=blendingWeight.y*texture2D(inputBuffer,blendingCoord.zw);}outputColor=color;}",
    fM = "varying vec2 vOffset0;varying vec2 vOffset1;void mainSupport(const in vec2 uv){vOffset0=uv+texelSize*vec2(1.0,0.0);vOffset1=uv+texelSize*vec2(0.0,1.0);}",
    pM = class extends Cn {
        constructor({
            blendFunction: t = Ae.SRC,
            preset: e = Un.MEDIUM,
            edgeDetectionMode: n = Zp.COLOR,
            predicationMode: i = $w.DISABLED
        } = {}) {
            let s, r;
            super("SMAAEffect", dM, {
                vertexShader: fM,
                blendFunction: t,
                attributes: qn.CONVOLUTION | qn.DEPTH,
                uniforms: new Map([
                    ["weightMap", new Ce(null)]
                ])
            }), arguments.length > 1 && (s = arguments[0], r = arguments[1], arguments.length > 2 && (e = arguments[2]), arguments.length > 3 && (n = arguments[3])), this.renderTargetEdges = new nn(1, 1, {
                depthBuffer: !1
            }), this.renderTargetEdges.texture.name = "SMAA.Edges", this.renderTargetWeights = this.renderTargetEdges.clone(), this.renderTargetWeights.texture.name = "SMAA.Weights", this.uniforms.get("weightMap").value = this.renderTargetWeights.texture, this.clearPass = new Ch(!0, !1, !1), this.clearPass.overrideClearColor = new Le(0), this.clearPass.overrideClearAlpha = 1, this.edgeDetectionPass = new Ki(new lM), this.edgeDetectionMaterial.edgeDetectionMode = n, this.edgeDetectionMaterial.predicationMode = i, this.weightsPass = new Ki(new uM);
            const o = new Hp;
            o.onLoad = () => {
                const t = new wt(s);
                t.name = "SMAA.Search", t.magFilter = Vt, t.minFilter = Vt, t.generateMipmaps = !1, t.needsUpdate = !0, t.flipY = !0, this.weightsMaterial.searchTexture = t;
                const e = new wt(r);
                e.name = "SMAA.Area", e.magFilter = Ht, e.minFilter = Ht, e.generateMipmaps = !1, e.needsUpdate = !0, e.flipY = !1, this.weightsMaterial.areaTexture = e, this.dispatchEvent({
                    type: "load"
                })
            }, o.itemStart("search"), o.itemStart("area"), void 0 !== s && void 0 !== r ? (o.itemEnd("search"), o.itemEnd("area")) : typeof Image < "u" && (s = new Image, r = new Image, s.addEventListener("load", (() => o.itemEnd("search"))), r.addEventListener("load", (() => o.itemEnd("area"))), s.src = vf, r.src = yf), this.applyPreset(e)
        }
        get edgesTexture() {
            return this.renderTargetEdges.texture
        }
        getEdgesTexture() {
            return this.edgesTexture
        }
        get weightsTexture() {
            return this.renderTargetWeights.texture
        }
        getWeightsTexture() {
            return this.weightsTexture
        }
        get edgeDetectionMaterial() {
            return this.edgeDetectionPass.fullscreenMaterial
        }
        get colorEdgesMaterial() {
            return this.edgeDetectionMaterial
        }
        getEdgeDetectionMaterial() {
            return this.edgeDetectionMaterial
        }
        get weightsMaterial() {
            return this.weightsPass.fullscreenMaterial
        }
        getWeightsMaterial() {
            return this.weightsMaterial
        }
        setEdgeDetectionThreshold(t) {
            this.edgeDetectionMaterial.edgeDetectionThreshold = t
        }
        setOrthogonalSearchSteps(t) {
            this.weightsMaterial.orthogonalSearchSteps = t
        }
        applyPreset(t) {
            const e = this.edgeDetectionMaterial,
                n = this.weightsMaterial;
            switch (t) {
                case Un.LOW:
                    e.edgeDetectionThreshold = .15, n.orthogonalSearchSteps = 4, n.diagonalDetection = !1, n.cornerDetection = !1;
                    break;
                case Un.MEDIUM:
                    e.edgeDetectionThreshold = .1, n.orthogonalSearchSteps = 8, n.diagonalDetection = !1, n.cornerDetection = !1;
                    break;
                case Un.HIGH:
                    e.edgeDetectionThreshold = .1, n.orthogonalSearchSteps = 16, n.diagonalSearchSteps = 8, n.cornerRounding = 25, n.diagonalDetection = !0, n.cornerDetection = !0;
                    break;
                case Un.ULTRA:
                    e.edgeDetectionThreshold = .05, n.orthogonalSearchSteps = 32, n.diagonalSearchSteps = 16, n.cornerRounding = 25, n.diagonalDetection = !0, n.cornerDetection = !0
            }
        }
        setDepthTexture(t, e = Oi) {
            this.edgeDetectionMaterial.depthBuffer = t, this.edgeDetectionMaterial.depthPacking = e
        }
        update(t, e, n) {
            this.clearPass.render(t, this.renderTargetEdges), this.edgeDetectionPass.render(t, e, this.renderTargetEdges), this.weightsPass.render(t, this.renderTargetEdges, this.renderTargetWeights)
        }
        setSize(t, e) {
            this.edgeDetectionMaterial.setSize(t, e), this.weightsMaterial.setSize(t, e), this.renderTargetEdges.setSize(t, e), this.renderTargetWeights.setSize(t, e)
        }
        dispose() {
            const {
                searchTexture: t,
                areaTexture: e
            } = this.weightsMaterial;
            null !== t && null !== e && (t.dispose(), e.dispose()), super.dispose()
        }
        static get searchImageDataURL() {
            return vf
        }
        static get areaImageDataURL() {
            return yf
        }
    },
    mM = "uniform float offset;uniform float darkness;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){const vec2 center=vec2(0.5);vec3 color=inputColor.rgb;\n#if VIGNETTE_TECHNIQUE == 0\nfloat d=distance(uv,center);color*=smoothstep(0.8,offset*0.799,d*(darkness+offset));\n#else\nvec2 coord=(uv-center)*vec2(offset);color=mix(color,vec3(1.0-darkness),dot(coord,coord));\n#endif\noutputColor=vec4(color,inputColor.a);}",
    gM = class extends Cn {
        constructor({
            blendFunction: t,
            eskil: e = !1,
            technique: n = (e ? vs.ESKIL : vs.DEFAULT),
            offset: i = .5,
            darkness: s = .5
        } = {}) {
            super("VignetteEffect", mM, {
                blendFunction: t,
                defines: new Map([
                    ["VIGNETTE_TECHNIQUE", n.toFixed(0)]
                ]),
                uniforms: new Map([
                    ["offset", new Ce(i)],
                    ["darkness", new Ce(s)]
                ])
            })
        }
        get technique() {
            return Number(this.defines.get("VIGNETTE_TECHNIQUE"))
        }
        set technique(t) {
            this.technique !== t && (this.defines.set("VIGNETTE_TECHNIQUE", t.toFixed(0)), this.setChanged())
        }
        get eskil() {
            return this.technique === vs.ESKIL
        }
        set eskil(t) {
            this.technique = t ? vs.ESKIL : vs.DEFAULT
        }
        getTechnique() {
            return this.technique
        }
        setTechnique(t) {
            this.technique = t
        }
        get offset() {
            return this.uniforms.get("offset").value
        }
        set offset(t) {
            this.uniforms.get("offset").value = t
        }
        getOffset() {
            return this.offset
        }
        setOffset(t) {
            this.offset = t
        }
        get darkness() {
            return this.uniforms.get("darkness").value
        }
        set darkness(t) {
            this.uniforms.get("darkness").value = t
        }
        getDarkness() {
            return this.darkness
        }
        setDarkness(t) {
            this.darkness = t
        }
    },
    vM = "#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#define packFloatToRGBA(v) packDepthToRGBA(v)\n#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#if DEPTH_PACKING == 3201\nuniform lowp sampler2D depthBuffer;\n#elif defined(GL_FRAGMENT_PRECISION_HIGH)\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nuniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}float readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNear,cameraFar);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNear,cameraFar);\n#endif\n}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}FRAGMENT_HEAD void main(){FRAGMENT_MAIN_UV vec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGE color0.a=clamp(color0.a,0.0,1.0);gl_FragColor=color0;\n#ifdef ENCODE_OUTPUT\n#include <colorspace_fragment>\n#endif\n#include <dithering_fragment>\n}",
    yM = "uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEAD void main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORT gl_Position=vec4(position.xy,1.0,1.0);}",
    xM = class extends It {
        constructor(t, e, n, i, s = !1) {
            super({
                name: "EffectMaterial",
                defines: {
                    THREE_REVISION: ns.replace(/\D+/g, ""),
                    DEPTH_PACKING: "0",
                    ENCODE_OUTPUT: "1"
                },
                uniforms: {
                    inputBuffer: new Ce(null),
                    depthBuffer: new Ce(null),
                    resolution: new Ce(new Q),
                    texelSize: new Ce(new Q),
                    cameraNear: new Ce(.3),
                    cameraFar: new Ce(1e3),
                    aspect: new Ce(1),
                    time: new Ce(0)
                },
                blending: 0,
                toneMapped: !1,
                depthWrite: !1,
                depthTest: !1,
                dithering: s
            }), t && this.setShaderParts(t), e && this.setDefines(e), n && this.setUniforms(n), this.copyCameraSettings(i)
        }
        set inputBuffer(t) {
            this.uniforms.inputBuffer.value = t
        }
        setInputBuffer(t) {
            this.uniforms.inputBuffer.value = t
        }
        get depthBuffer() {
            return this.uniforms.depthBuffer.value
        }
        set depthBuffer(t) {
            this.uniforms.depthBuffer.value = t
        }
        get depthPacking() {
            return Number(this.defines.DEPTH_PACKING)
        }
        set depthPacking(t) {
            this.defines.DEPTH_PACKING = t.toFixed(0), this.needsUpdate = !0
        }
        setDepthBuffer(t, e = Oi) {
            this.depthBuffer = t, this.depthPacking = e
        }
        setShaderData(t) {
            this.setShaderParts(t.shaderParts), this.setDefines(t.defines), this.setUniforms(t.uniforms), this.setExtensions(t.extensions)
        }
        setShaderParts(t) {
            return this.fragmentShader = vM.replace(dt.FRAGMENT_HEAD, t.get(dt.FRAGMENT_HEAD) || "").replace(dt.FRAGMENT_MAIN_UV, t.get(dt.FRAGMENT_MAIN_UV) || "").replace(dt.FRAGMENT_MAIN_IMAGE, t.get(dt.FRAGMENT_MAIN_IMAGE) || ""), this.vertexShader = yM.replace(dt.VERTEX_HEAD, t.get(dt.VERTEX_HEAD) || "").replace(dt.VERTEX_MAIN_SUPPORT, t.get(dt.VERTEX_MAIN_SUPPORT) || ""), this.needsUpdate = !0, this
        }
        setDefines(t) {
            for (const e of t.entries()) this.defines[e[0]] = e[1];
            return this.needsUpdate = !0, this
        }
        setUniforms(t) {
            for (const e of t.entries()) this.uniforms[e[0]] = e[1];
            return this
        }
        setExtensions(t) {
            this.extensions = {};
            for (const e of t) this.extensions[e] = !0;
            return this
        }
        get encodeOutput() {
            return void 0 !== this.defines.ENCODE_OUTPUT
        }
        set encodeOutput(t) {
            this.encodeOutput !== t && (t ? this.defines.ENCODE_OUTPUT = "1" : delete this.defines.ENCODE_OUTPUT, this.needsUpdate = !0)
        }
        isOutputEncodingEnabled(t) {
            return this.encodeOutput
        }
        setOutputEncodingEnabled(t) {
            this.encodeOutput = t
        }
        get time() {
            return this.uniforms.time.value
        }
        set time(t) {
            this.uniforms.time.value = t
        }
        setDeltaTime(t) {
            this.uniforms.time.value += t
        }
        adoptCameraSettings(t) {
            this.copyCameraSettings(t)
        }
        copyCameraSettings(t) {
            t && (this.uniforms.cameraNear.value = t.near, this.uniforms.cameraFar.value = t.far, t instanceof Pt ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = !0)
        }
        setSize(t, e) {
            const n = this.uniforms;
            n.resolution.value.set(t, e), n.texelSize.value.set(1 / t, 1 / e), n.aspect.value = t / e
        }
        static get Section() {
            return dt
        }
    };

function xf(t, e, n) {
    for (const i of e) {
        const e = "$1" + t + i.charAt(0).toUpperCase() + i.slice(1),
            s = new RegExp("([^\\.])(\\b" + i + "\\b)", "g");
        for (const t of n.entries()) null !== t[1] && n.set(t[0], t[1].replace(s, e))
    }
}

function bM(t, e, n) {
    let i = e.getFragmentShader(),
        s = e.getVertexShader();
    const r = void 0 !== i && /mainImage/.test(i),
        o = void 0 !== i && /mainUv/.test(i);
    if (n.attributes |= e.getAttributes(), void 0 === i) throw new Error(`Missing fragment shader (${e.name})`);
    if (o && n.attributes & qn.CONVOLUTION) throw new Error(`Effects that transform UVs are incompatible with convolution effects (${e.name})`);
    if (!r && !o) throw new Error(`Could not find mainImage or mainUv function (${e.name})`); {
        const a = /\w+\s+(\w+)\([\w\s,]*\)\s*{/g,
            l = n.shaderParts;
        let c = l.get(dt.FRAGMENT_HEAD) || "",
            h = l.get(dt.FRAGMENT_MAIN_UV) || "",
            u = l.get(dt.FRAGMENT_MAIN_IMAGE) || "",
            d = l.get(dt.VERTEX_HEAD) || "",
            p = l.get(dt.VERTEX_MAIN_SUPPORT) || "";
        const f = new Set,
            m = new Set;
        if (o && (h += `\t${t}MainUv(UV);\n`, n.uvTransformation = !0), null !== s && /mainSupport/.test(s)) {
            const e = /mainSupport *\([\w\s]*?uv\s*?\)/.test(s);
            p += `\t${t}MainSupport(`, p += e ? "vUv);\n" : ");\n";
            for (const t of s.matchAll(/(?:varying\s+\w+\s+([\S\s]*?);)/g))
                for (const e of t[1].split(/\s*,\s*/)) n.varyings.add(e), f.add(e), m.add(e);
            for (const t of s.matchAll(a)) m.add(t[1])
        }
        for (const t of i.matchAll(a)) m.add(t[1]);
        for (const t of e.defines.keys()) m.add(t.replace(/\([\w\s,]*\)/g, ""));
        for (const t of e.uniforms.keys()) m.add(t);
        m.delete("while"), m.delete("for"), m.delete("if"), e.uniforms.forEach(((e, i) => n.uniforms.set(t + i.charAt(0).toUpperCase() + i.slice(1), e))), e.defines.forEach(((e, i) => n.defines.set(t + i.charAt(0).toUpperCase() + i.slice(1), e)));
        const g = new Map([
            ["fragment", i],
            ["vertex", s]
        ]);
        xf(t, m, n.defines), xf(t, m, g), i = g.get("fragment"), s = g.get("vertex");
        const v = e.blendMode;
        if (n.blendModes.set(v.blendFunction, v), r) {
            null !== e.inputColorSpace && e.inputColorSpace !== n.colorSpace && (u += e.inputColorSpace === rt ? "color0 = sRGBTransferOETF(color0);\n\t" : "color0 = sRGBToLinear(color0);\n\t"), "" !== e.outputColorSpace ? n.colorSpace = e.outputColorSpace : null !== e.inputColorSpace && (n.colorSpace = e.inputColorSpace);
            const s = /MainImage *\([\w\s,]*?depth[\w\s,]*?\)/;
            u += `${t}MainImage(color0, UV, `, n.attributes & qn.DEPTH && s.test(i) && (u += "depth, ", n.readDepth = !0), u += "color1);\n\t";
            const r = t + "BlendOpacity";
            n.uniforms.set(r, v.opacity), u += `color0 = blend${v.blendFunction}(color0, color1, ${r});\n\n\t`, c += `uniform float ${r};\n\n`
        }
        if (c += i + "\n", null !== s && (d += s + "\n"), l.set(dt.FRAGMENT_HEAD, c), l.set(dt.FRAGMENT_MAIN_UV, h), l.set(dt.FRAGMENT_MAIN_IMAGE, u), l.set(dt.VERTEX_HEAD, d), l.set(dt.VERTEX_MAIN_SUPPORT, p), null !== e.extensions)
            for (const t of e.extensions) n.extensions.add(t)
    }
}
var bf = class extends Vn {
        constructor(t, ...e) {
            super("EffectPass"), this.fullscreenMaterial = new xM(null, null, null, t), this.listener = t => this.handleEvent(t), this.effects = [], this.setEffects(e), this.skipRendering = !1, this.minTime = 1, this.maxTime = Number.POSITIVE_INFINITY, this.timeScale = 1
        }
        set mainScene(t) {
            for (const e of this.effects) e.mainScene = t
        }
        set mainCamera(t) {
            this.fullscreenMaterial.copyCameraSettings(t);
            for (const e of this.effects) e.mainCamera = t
        }
        get encodeOutput() {
            return this.fullscreenMaterial.encodeOutput
        }
        set encodeOutput(t) {
            this.fullscreenMaterial.encodeOutput = t
        }
        get dithering() {
            return this.fullscreenMaterial.dithering
        }
        set dithering(t) {
            const e = this.fullscreenMaterial;
            e.dithering = t, e.needsUpdate = !0
        }
        setEffects(t) {
            for (const t of this.effects) t.removeEventListener("change", this.listener);
            this.effects = t.sort(((t, e) => e.attributes - t.attributes));
            for (const t of this.effects) t.addEventListener("change", this.listener)
        }
        updateMaterial() {
            const t = new O_;
            let e = 0;
            for (const n of this.effects)
                if (n.blendMode.blendFunction === Ae.DST) t.attributes |= n.getAttributes() & qn.DEPTH;
                else {
                    if (t.attributes & n.getAttributes() & qn.CONVOLUTION) throw new Error(`Convolution effects cannot be merged (${n.name})`);
                    bM("e" + e++, n, t)
                }
            let n = t.shaderParts.get(dt.FRAGMENT_HEAD),
                i = t.shaderParts.get(dt.FRAGMENT_MAIN_IMAGE),
                s = t.shaderParts.get(dt.FRAGMENT_MAIN_UV);
            const r = /\bblend\b/g;
            for (const e of t.blendModes.values()) n += e.getShaderCode().replace(r, `blend${e.blendFunction}`) + "\n";
            t.attributes & qn.DEPTH ? (t.readDepth && (i = "float depth = readDepth(UV);\n\n\t" + i), this.needsDepthTexture = null === this.getDepthTexture()) : this.needsDepthTexture = !1, t.colorSpace === rt && (i += "color0 = sRGBToLinear(color0);\n\t"), t.uvTransformation ? (s = "vec2 transformedUv = vUv;\n" + s, t.defines.set("UV", "transformedUv")) : t.defines.set("UV", "vUv"), t.shaderParts.set(dt.FRAGMENT_HEAD, n), t.shaderParts.set(dt.FRAGMENT_MAIN_IMAGE, i), t.shaderParts.set(dt.FRAGMENT_MAIN_UV, s);
            for (const [e, n] of t.shaderParts) null !== n && t.shaderParts.set(e, n.trim().replace(/^#/, "\n#"));
            this.skipRendering = 0 === e, this.needsSwap = !this.skipRendering, this.fullscreenMaterial.setShaderData(t)
        }
        recompile() {
            this.updateMaterial()
        }
        getDepthTexture() {
            return this.fullscreenMaterial.depthBuffer
        }
        setDepthTexture(t, e = Oi) {
            this.fullscreenMaterial.depthBuffer = t, this.fullscreenMaterial.depthPacking = e;
            for (const n of this.effects) n.setDepthTexture(t, e)
        }
        render(t, e, n, i, s) {
            for (const n of this.effects) n.update(t, e, i);
            if (!this.skipRendering || this.renderToScreen) {
                const s = this.fullscreenMaterial;
                s.inputBuffer = e.texture, s.time += i * this.timeScale, t.setRenderTarget(this.renderToScreen ? null : n), t.render(this.scene, this.camera)
            }
        }
        setSize(t, e) {
            this.fullscreenMaterial.setSize(t, e);
            for (const n of this.effects) n.setSize(t, e)
        }
        initialize(t, e, n) {
            this.renderer = t;
            for (const i of this.effects) i.initialize(t, e, n);
            this.updateMaterial(), void 0 !== n && n !== Qt && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1")
        }
        dispose() {
            super.dispose();
            for (const t of this.effects) t.removeEventListener("change", this.listener), t.dispose()
        }
        handleEvent(t) {
            if ("change" === t.type) this.recompile()
        }
    },
    yn = Object.freeze({
        Linear: Object.freeze({
            None: function(t) {
                return t
            },
            In: function(t) {
                return t
            },
            Out: function(t) {
                return t
            },
            InOut: function(t) {
                return t
            }
        }),
        Quadratic: Object.freeze({
            In: function(t) {
                return t * t
            },
            Out: function(t) {
                return t * (2 - t)
            },
            InOut: function(t) {
                return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1)
            }
        }),
        Cubic: Object.freeze({
            In: function(t) {
                return t * t * t
            },
            Out: function(t) {
                return --t * t * t + 1
            },
            InOut: function(t) {
                return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2)
            }
        }),
        Quartic: Object.freeze({
            In: function(t) {
                return t * t * t * t
            },
            Out: function(t) {
                return 1 - --t * t * t * t
            },
            InOut: function(t) {
                return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2)
            }
        }),
        Quintic: Object.freeze({
            In: function(t) {
                return t * t * t * t * t
            },
            Out: function(t) {
                return --t * t * t * t * t + 1
            },
            InOut: function(t) {
                return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2)
            }
        }),
        Sinusoidal: Object.freeze({
            In: function(t) {
                return 1 - Math.sin((1 - t) * Math.PI / 2)
            },
            Out: function(t) {
                return Math.sin(t * Math.PI / 2)
            },
            InOut: function(t) {
                return .5 * (1 - Math.sin(Math.PI * (.5 - t)))
            }
        }),
        Exponential: Object.freeze({
            In: function(t) {
                return 0 === t ? 0 : Math.pow(1024, t - 1)
            },
            Out: function(t) {
                return 1 === t ? 1 : 1 - Math.pow(2, -10 * t)
            },
            InOut: function(t) {
                return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * (2 - Math.pow(2, -10 * (t - 1)))
            }
        }),
        Circular: Object.freeze({
            In: function(t) {
                return 1 - Math.sqrt(1 - t * t)
            },
            Out: function(t) {
                return Math.sqrt(1 - --t * t)
            },
            InOut: function(t) {
                return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
            }
        }),
        Elastic: Object.freeze({
            In: function(t) {
                return 0 === t ? 0 : 1 === t ? 1 : -Math.pow(2, 10 * (t - 1)) * Math.sin(5 * (t - 1.1) * Math.PI)
            },
            Out: function(t) {
                return 0 === t ? 0 : 1 === t ? 1 : Math.pow(2, -10 * t) * Math.sin(5 * (t - .1) * Math.PI) + 1
            },
            InOut: function(t) {
                return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? -.5 * Math.pow(2, 10 * (t - 1)) * Math.sin(5 * (t - 1.1) * Math.PI) : .5 * Math.pow(2, -10 * (t - 1)) * Math.sin(5 * (t - 1.1) * Math.PI) + 1
            }
        }),
        Back: Object.freeze({
            In: function(t) {
                var e = 1.70158;
                return 1 === t ? 1 : t * t * ((e + 1) * t - e)
            },
            Out: function(t) {
                var e = 1.70158;
                return 0 === t ? 0 : --t * t * ((e + 1) * t + e) + 1
            },
            InOut: function(t) {
                var e = 2.5949095;
                return (t *= 2) < 1 ? t * t * ((e + 1) * t - e) * .5 : .5 * ((t -= 2) * t * ((e + 1) * t + e) + 2)
            }
        }),
        Bounce: Object.freeze({
            In: function(t) {
                return 1 - yn.Bounce.Out(1 - t)
            },
            Out: function(t) {
                return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
            },
            InOut: function(t) {
                return t < .5 ? .5 * yn.Bounce.In(2 * t) : .5 * yn.Bounce.Out(2 * t - 1) + .5
            }
        }),
        generatePow: function(t) {
            return void 0 === t && (t = 4), t = (t = t < Number.EPSILON ? Number.EPSILON : t) > 1e4 ? 1e4 : t, {
                In: function(e) {
                    return Math.pow(e, t)
                },
                Out: function(e) {
                    return 1 - Math.pow(1 - e, t)
                },
                InOut: function(e) {
                    return e < .5 ? Math.pow(2 * e, t) / 2 : (1 - Math.pow(2 - 2 * e, t)) / 2 + .5
                }
            }
        }
    }),
    bs = function() {
        return performance.now()
    },
    AM = function() {
        function t() {
            this._tweens = {}, this._tweensAddedDuringUpdate = {}
        }
        return t.prototype.getAll = function() {
            var t = this;
            return Object.keys(this._tweens).map((function(e) {
                return t._tweens[e]
            }))
        }, t.prototype.removeAll = function() {
            this._tweens = {}
        }, t.prototype.add = function(t) {
            this._tweens[t.getId()] = t, this._tweensAddedDuringUpdate[t.getId()] = t
        }, t.prototype.remove = function(t) {
            delete this._tweens[t.getId()], delete this._tweensAddedDuringUpdate[t.getId()]
        }, t.prototype.update = function(t, e) {
            void 0 === t && (t = bs()), void 0 === e && (e = !1);
            var n = Object.keys(this._tweens);
            if (0 === n.length) return !1;
            for (; n.length > 0;) {
                this._tweensAddedDuringUpdate = {};
                for (var i = 0; i < n.length; i++) {
                    var s = this._tweens[n[i]],
                        r = !e;
                    s && !1 === s.update(t, r) && !e && delete this._tweens[n[i]]
                }
                n = Object.keys(this._tweensAddedDuringUpdate)
            }
            return !0
        }, t
    }(),
    cr = {
        Linear: function(t, e) {
            var n = t.length - 1,
                i = n * e,
                s = Math.floor(i),
                r = cr.Utils.Linear;
            return e < 0 ? r(t[0], t[1], i) : e > 1 ? r(t[n], t[n - 1], n - i) : r(t[s], t[s + 1 > n ? n : s + 1], i - s)
        },
        Bezier: function(t, e) {
            for (var n = 0, i = t.length - 1, s = Math.pow, r = cr.Utils.Bernstein, o = 0; o <= i; o++) n += s(1 - e, i - o) * s(e, o) * t[o] * r(i, o);
            return n
        },
        CatmullRom: function(t, e) {
            var n = t.length - 1,
                i = n * e,
                s = Math.floor(i),
                r = cr.Utils.CatmullRom;
            return t[0] === t[n] ? (e < 0 && (s = Math.floor(i = n * (1 + e))), r(t[(s - 1 + n) % n], t[s], t[(s + 1) % n], t[(s + 2) % n], i - s)) : e < 0 ? t[0] - (r(t[0], t[0], t[1], t[1], -i) - t[0]) : e > 1 ? t[n] - (r(t[n], t[n], t[n - 1], t[n - 1], i - n) - t[n]) : r(t[s ? s - 1 : 0], t[s], t[n < s + 1 ? n : s + 1], t[n < s + 2 ? n : s + 2], i - s)
        },
        Utils: {
            Linear: function(t, e, n) {
                return (e - t) * n + t
            },
            Bernstein: function(t, e) {
                var n = cr.Utils.Factorial;
                return n(t) / n(e) / n(t - e)
            },
            Factorial: function() {
                var t = [1];
                return function(e) {
                    var n = 1;
                    if (t[e]) return t[e];
                    for (var i = e; i > 1; i--) n *= i;
                    return t[e] = n, n
                }
            }(),
            CatmullRom: function(t, e, n, i, s) {
                var r = .5 * (n - t),
                    o = .5 * (i - e),
                    a = s * s;
                return (2 * e - 2 * n + r + o) * (s * a) + (-3 * e + 3 * n - 2 * r - o) * a + r * s + e
            }
        }
    },
    SM = function() {
        function t() {}
        return t.nextId = function() {
            return t._nextId++
        }, t._nextId = 0, t
    }(),
    Xc = new AM,
    _M = function() {
        function t(t, e) {
            void 0 === e && (e = Xc), this._object = t, this._group = e, this._isPaused = !1, this._pauseStart = 0, this._valuesStart = {}, this._valuesEnd = {}, this._valuesStartRepeat = {}, this._duration = 1e3, this._isDynamic = !1, this._initialRepeat = 0, this._repeat = 0, this._yoyo = !1, this._isPlaying = !1, this._reversed = !1, this._delayTime = 0, this._startTime = 0, this._easingFunction = yn.Linear.None, this._interpolationFunction = cr.Linear, this._chainedTweens = [], this._onStartCallbackFired = !1, this._onEveryStartCallbackFired = !1, this._id = SM.nextId(), this._isChainStopped = !1, this._propertiesAreSetUp = !1, this._goToEnd = !1
        }
        return t.prototype.getId = function() {
            return this._id
        }, t.prototype.isPlaying = function() {
            return this._isPlaying
        }, t.prototype.isPaused = function() {
            return this._isPaused
        }, t.prototype.getDuration = function() {
            return this._duration
        }, t.prototype.to = function(t, e) {
            if (void 0 === e && (e = 1e3), this._isPlaying) throw new Error("Can not call Tween.to() while Tween is already started or paused. Stop the Tween first.");
            return this._valuesEnd = t, this._propertiesAreSetUp = !1, this._duration = e < 0 ? 0 : e, this
        }, t.prototype.duration = function(t) {
            return void 0 === t && (t = 1e3), this._duration = t < 0 ? 0 : t, this
        }, t.prototype.dynamic = function(t) {
            return void 0 === t && (t = !1), this._isDynamic = t, this
        }, t.prototype.start = function(t, e) {
            if (void 0 === t && (t = bs()), void 0 === e && (e = !1), this._isPlaying) return this;
            if (this._group && this._group.add(this), this._repeat = this._initialRepeat, this._reversed)
                for (var n in this._reversed = !1, this._valuesStartRepeat) this._swapEndStartRepeatValues(n), this._valuesStart[n] = this._valuesStartRepeat[n];
            if (this._isPlaying = !0, this._isPaused = !1, this._onStartCallbackFired = !1, this._onEveryStartCallbackFired = !1, this._isChainStopped = !1, this._startTime = t, this._startTime += this._delayTime, !this._propertiesAreSetUp || e) {
                if (this._propertiesAreSetUp = !0, !this._isDynamic) {
                    var i = {};
                    for (var s in this._valuesEnd) i[s] = this._valuesEnd[s];
                    this._valuesEnd = i
                }
                this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat, e)
            }
            return this
        }, t.prototype.startFromCurrentValues = function(t) {
            return this.start(t, !0)
        }, t.prototype._setupProperties = function(t, e, n, i, s) {
            for (var r in n) {
                var o = t[r],
                    a = Array.isArray(o),
                    l = a ? "array" : typeof o,
                    c = !a && Array.isArray(n[r]);
                if ("undefined" !== l && "function" !== l) {
                    if (c) {
                        if (0 === (g = n[r]).length) continue;
                        for (var h = [o], u = 0, d = g.length; u < d; u += 1) {
                            var p = this._handleRelativeValue(o, g[u]);
                            if (isNaN(p)) {
                                c = !1, console.warn("Found invalid interpolation list. Skipping.");
                                break
                            }
                            h.push(p)
                        }
                        c && (n[r] = h)
                    }
                    if ("object" !== l && !a || !o || c)(typeof e[r] > "u" || s) && (e[r] = o), a || (e[r] *= 1), i[r] = c ? n[r].slice().reverse() : e[r] || 0;
                    else {
                        e[r] = a ? [] : {};
                        var f = o;
                        for (var m in f) e[r][m] = f[m];
                        i[r] = a ? [] : {};
                        var g = n[r];
                        if (!this._isDynamic) {
                            var v = {};
                            for (var m in g) v[m] = g[m];
                            n[r] = g = v
                        }
                        this._setupProperties(f, e[r], g, i[r], s)
                    }
                }
            }
        }, t.prototype.stop = function() {
            return this._isChainStopped || (this._isChainStopped = !0, this.stopChainedTweens()), this._isPlaying ? (this._group && this._group.remove(this), this._isPlaying = !1, this._isPaused = !1, this._onStopCallback && this._onStopCallback(this._object), this) : this
        }, t.prototype.end = function() {
            return this._goToEnd = !0, this.update(1 / 0), this
        }, t.prototype.pause = function(t) {
            return void 0 === t && (t = bs()), this._isPaused || !this._isPlaying || (this._isPaused = !0, this._pauseStart = t, this._group && this._group.remove(this)), this
        }, t.prototype.resume = function(t) {
            return void 0 === t && (t = bs()), this._isPaused && this._isPlaying ? (this._isPaused = !1, this._startTime += t - this._pauseStart, this._pauseStart = 0, this._group && this._group.add(this), this) : this
        }, t.prototype.stopChainedTweens = function() {
            for (var t = 0, e = this._chainedTweens.length; t < e; t++) this._chainedTweens[t].stop();
            return this
        }, t.prototype.group = function(t) {
            return void 0 === t && (t = Xc), this._group = t, this
        }, t.prototype.delay = function(t) {
            return void 0 === t && (t = 0), this._delayTime = t, this
        }, t.prototype.repeat = function(t) {
            return void 0 === t && (t = 0), this._initialRepeat = t, this._repeat = t, this
        }, t.prototype.repeatDelay = function(t) {
            return this._repeatDelayTime = t, this
        }, t.prototype.yoyo = function(t) {
            return void 0 === t && (t = !1), this._yoyo = t, this
        }, t.prototype.easing = function(t) {
            return void 0 === t && (t = yn.Linear.None), this._easingFunction = t, this
        }, t.prototype.interpolation = function(t) {
            return void 0 === t && (t = cr.Linear), this._interpolationFunction = t, this
        }, t.prototype.chain = function() {
            for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
            return this._chainedTweens = t, this
        }, t.prototype.onStart = function(t) {
            return this._onStartCallback = t, this
        }, t.prototype.onEveryStart = function(t) {
            return this._onEveryStartCallback = t, this
        }, t.prototype.onUpdate = function(t) {
            return this._onUpdateCallback = t, this
        }, t.prototype.onRepeat = function(t) {
            return this._onRepeatCallback = t, this
        }, t.prototype.onComplete = function(t) {
            return this._onCompleteCallback = t, this
        }, t.prototype.onStop = function(t) {
            return this._onStopCallback = t, this
        }, t.prototype.update = function(t, e) {
            var n, i = this;
            if (void 0 === t && (t = bs()), void 0 === e && (e = !0), this._isPaused) return !0;
            var s, r = this._startTime + this._duration;
            if (!this._goToEnd && !this._isPlaying) {
                if (t > r) return !1;
                e && this.start(t, !0)
            }
            if (this._goToEnd = !1, t < this._startTime) return !0;
            !1 === this._onStartCallbackFired && (this._onStartCallback && this._onStartCallback(this._object), this._onStartCallbackFired = !0), !1 === this._onEveryStartCallbackFired && (this._onEveryStartCallback && this._onEveryStartCallback(this._object), this._onEveryStartCallbackFired = !0);
            var o = t - this._startTime,
                a = this._duration + (null !== (n = this._repeatDelayTime) && void 0 !== n ? n : this._delayTime),
                l = this._duration + this._repeat * a,
                c = function() {
                    if (0 === i._duration || o > l) return 1;
                    var t = Math.trunc(o / a),
                        e = o - t * a,
                        n = Math.min(e / i._duration, 1);
                    return 0 === n && o === i._duration ? 1 : n
                }(),
                h = this._easingFunction(c);
            if (this._updateProperties(this._object, this._valuesStart, this._valuesEnd, h), this._onUpdateCallback && this._onUpdateCallback(this._object, c), 0 === this._duration || o >= this._duration) {
                if (this._repeat > 0) {
                    var u = Math.min(Math.trunc((o - this._duration) / a) + 1, this._repeat);
                    for (s in isFinite(this._repeat) && (this._repeat -= u), this._valuesStartRepeat) !this._yoyo && "string" == typeof this._valuesEnd[s] && (this._valuesStartRepeat[s] = this._valuesStartRepeat[s] + parseFloat(this._valuesEnd[s])), this._yoyo && this._swapEndStartRepeatValues(s), this._valuesStart[s] = this._valuesStartRepeat[s];
                    return this._yoyo && (this._reversed = !this._reversed), this._startTime += a * u, this._onRepeatCallback && this._onRepeatCallback(this._object), this._onEveryStartCallbackFired = !1, !0
                }
                this._onCompleteCallback && this._onCompleteCallback(this._object);
                for (var d = 0, p = this._chainedTweens.length; d < p; d++) this._chainedTweens[d].start(this._startTime + this._duration, !1);
                return this._isPlaying = !1, !1
            }
            return !0
        }, t.prototype._updateProperties = function(t, e, n, i) {
            for (var s in n)
                if (void 0 !== e[s]) {
                    var r = e[s] || 0,
                        o = n[s],
                        a = Array.isArray(t[s]),
                        l = Array.isArray(o);
                    !a && l ? t[s] = this._interpolationFunction(o, i) : "object" == typeof o && o ? this._updateProperties(t[s], r, o, i) : "number" == typeof(o = this._handleRelativeValue(r, o)) && (t[s] = r + (o - r) * i)
                }
        }, t.prototype._handleRelativeValue = function(t, e) {
            return "string" != typeof e ? e : "+" === e.charAt(0) || "-" === e.charAt(0) ? t + parseFloat(e) : parseFloat(e)
        }, t.prototype._swapEndStartRepeatValues = function(t) {
            var e = this._valuesStartRepeat[t],
                n = this._valuesEnd[t];
            this._valuesStartRepeat[t] = "string" == typeof n ? this._valuesStartRepeat[t] + parseFloat(n) : this._valuesEnd[t], this._valuesEnd[t] = e
        }, t
    }(),
    ci = Xc;
ci.getAll.bind(ci), ci.removeAll.bind(ci), ci.add.bind(ci);
var wM = ci.remove.bind(ci),
    MM = ci.update.bind(ci);
const Jp = parseInt(ns.replace(/\D+/g, "")),
    $p = Jp >= 125 ? "uv1" : "uv2";

function Af(t, e) {
    if (0 === e) return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), t;
    if (2 === e || 1 === e) {
        let n = t.getIndex();
        if (null === n) {
            const e = [],
                i = t.getAttribute("position");
            if (void 0 === i) return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), t;
            for (let t = 0; t < i.count; t++) e.push(t);
            t.setIndex(e), n = t.getIndex()
        }
        const i = n.count - 2,
            s = [];
        if (n)
            if (2 === e)
                for (let t = 1; t <= i; t++) s.push(n.getX(0)), s.push(n.getX(t)), s.push(n.getX(t + 1));
            else
                for (let t = 0; t < i; t++) t % 2 == 0 ? (s.push(n.getX(t)), s.push(n.getX(t + 1)), s.push(n.getX(t + 2))) : (s.push(n.getX(t + 2)), s.push(n.getX(t + 1)), s.push(n.getX(t)));
        s.length / 3 !== i && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
        const r = t.clone();
        return r.setIndex(s), r.clearGroups(), r
    }
    return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), t
}
var EM = Object.defineProperty,
    TM = (t, e, n) => e in t ? EM(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : t[e] = n,
    ae = (t, e, n) => (TM(t, "symbol" != typeof e ? e + "" : e, n), n);
class CM extends ct {
    constructor(t, e) {
        super(), ae(this, "isTransformControls", !0), ae(this, "visible", !1), ae(this, "domElement"), ae(this, "raycaster", new Kp), ae(this, "gizmo"), ae(this, "plane"), ae(this, "tempVector", new U), ae(this, "tempVector2", new U), ae(this, "tempQuaternion", new bt), ae(this, "unit", {
            X: new U(1, 0, 0),
            Y: new U(0, 1, 0),
            Z: new U(0, 0, 1)
        }), ae(this, "pointStart", new U), ae(this, "pointEnd", new U), ae(this, "offset", new U), ae(this, "rotationAxis", new U), ae(this, "startNorm", new U), ae(this, "endNorm", new U), ae(this, "rotationAngle", 0), ae(this, "cameraPosition", new U), ae(this, "cameraQuaternion", new bt), ae(this, "cameraScale", new U), ae(this, "parentPosition", new U), ae(this, "parentQuaternion", new bt), ae(this, "parentQuaternionInv", new bt), ae(this, "parentScale", new U), ae(this, "worldPositionStart", new U), ae(this, "worldQuaternionStart", new bt), ae(this, "worldScaleStart", new U), ae(this, "worldPosition", new U), ae(this, "worldQuaternion", new bt), ae(this, "worldQuaternionInv", new bt), ae(this, "worldScale", new U), ae(this, "eye", new U), ae(this, "positionStart", new U), ae(this, "quaternionStart", new bt), ae(this, "scaleStart", new U), ae(this, "camera"), ae(this, "object"), ae(this, "enabled", !0), ae(this, "axis", null), ae(this, "mode", "translate"), ae(this, "translationSnap", null), ae(this, "rotationSnap", null), ae(this, "scaleSnap", null), ae(this, "space", "world"), ae(this, "size", 1), ae(this, "dragging", !1), ae(this, "showX", !0), ae(this, "showY", !0), ae(this, "showZ", !0), ae(this, "changeEvent", {
            type: "change"
        }), ae(this, "mouseDownEvent", {
            type: "mouseDown",
            mode: this.mode
        }), ae(this, "mouseUpEvent", {
            type: "mouseUp",
            mode: this.mode
        }), ae(this, "objectChangeEvent", {
            type: "objectChange"
        }), ae(this, "intersectObjectWithRay", ((t, e, n) => {
            const i = e.intersectObject(t, !0);
            for (let t = 0; t < i.length; t++)
                if (i[t].object.visible || n) return i[t];
            return !1
        })), ae(this, "attach", (t => (this.object = t, this.visible = !0, this))), ae(this, "detach", (() => (this.object = void 0, this.visible = !1, this.axis = null, this))), ae(this, "reset", (() => this.enabled ? (this.dragging && void 0 !== this.object && (this.object.position.copy(this.positionStart), this.object.quaternion.copy(this.quaternionStart), this.object.scale.copy(this.scaleStart), this.dispatchEvent(this.changeEvent), this.dispatchEvent(this.objectChangeEvent), this.pointStart.copy(this.pointEnd)), this) : this)), ae(this, "updateMatrixWorld", (() => {
            void 0 !== this.object && (this.object.updateMatrixWorld(), null === this.object.parent ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : this.object.parent.matrixWorld.decompose(this.parentPosition, this.parentQuaternion, this.parentScale), this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this.worldScale), this.parentQuaternionInv.copy(this.parentQuaternion).invert(), this.worldQuaternionInv.copy(this.worldQuaternion).invert()), this.camera.updateMatrixWorld(), this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this.cameraScale), this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(), super.updateMatrixWorld()
        })), ae(this, "pointerHover", (t => {
            if (void 0 === this.object || !0 === this.dragging) return;
            this.raycaster.setFromCamera(t, this.camera);
            const e = this.intersectObjectWithRay(this.gizmo.picker[this.mode], this.raycaster);
            this.axis = e ? e.object.name : null
        })), ae(this, "pointerDown", (t => {
            if (void 0 !== this.object && !0 !== this.dragging && 0 === t.button && null !== this.axis) {
                this.raycaster.setFromCamera(t, this.camera);
                const e = this.intersectObjectWithRay(this.plane, this.raycaster, !0);
                if (e) {
                    let t = this.space;
                    if ("scale" === this.mode ? t = "local" : ("E" === this.axis || "XYZE" === this.axis || "XYZ" === this.axis) && (t = "world"), "local" === t && "rotate" === this.mode) {
                        const t = this.rotationSnap;
                        "X" === this.axis && t && (this.object.rotation.x = Math.round(this.object.rotation.x / t) * t), "Y" === this.axis && t && (this.object.rotation.y = Math.round(this.object.rotation.y / t) * t), "Z" === this.axis && t && (this.object.rotation.z = Math.round(this.object.rotation.z / t) * t)
                    }
                    this.object.updateMatrixWorld(), this.object.parent && this.object.parent.updateMatrixWorld(), this.positionStart.copy(this.object.position), this.quaternionStart.copy(this.object.quaternion), this.scaleStart.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this.worldScaleStart), this.pointStart.copy(e.point).sub(this.worldPositionStart)
                }
                this.dragging = !0, this.mouseDownEvent.mode = this.mode, this.dispatchEvent(this.mouseDownEvent)
            }
        })), ae(this, "pointerMove", (t => {
            const e = this.axis,
                n = this.mode,
                i = this.object;
            let s = this.space;
            if ("scale" === n ? s = "local" : ("E" === e || "XYZE" === e || "XYZ" === e) && (s = "world"), void 0 === i || null === e || !1 === this.dragging || -1 !== t.button) return;
            this.raycaster.setFromCamera(t, this.camera);
            const r = this.intersectObjectWithRay(this.plane, this.raycaster, !0);
            if (r) {
                if (this.pointEnd.copy(r.point).sub(this.worldPositionStart), "translate" === n) this.offset.copy(this.pointEnd).sub(this.pointStart), "local" === s && "XYZ" !== e && this.offset.applyQuaternion(this.worldQuaternionInv), -1 === e.indexOf("X") && (this.offset.x = 0), -1 === e.indexOf("Y") && (this.offset.y = 0), -1 === e.indexOf("Z") && (this.offset.z = 0), "local" === s && "XYZ" !== e ? this.offset.applyQuaternion(this.quaternionStart).divide(this.parentScale) : this.offset.applyQuaternion(this.parentQuaternionInv).divide(this.parentScale), i.position.copy(this.offset).add(this.positionStart), this.translationSnap && ("local" === s && (i.position.applyQuaternion(this.tempQuaternion.copy(this.quaternionStart).invert()), -1 !== e.search("X") && (i.position.x = Math.round(i.position.x / this.translationSnap) * this.translationSnap), -1 !== e.search("Y") && (i.position.y = Math.round(i.position.y / this.translationSnap) * this.translationSnap), -1 !== e.search("Z") && (i.position.z = Math.round(i.position.z / this.translationSnap) * this.translationSnap), i.position.applyQuaternion(this.quaternionStart)), "world" === s && (i.parent && i.position.add(this.tempVector.setFromMatrixPosition(i.parent.matrixWorld)), -1 !== e.search("X") && (i.position.x = Math.round(i.position.x / this.translationSnap) * this.translationSnap), -1 !== e.search("Y") && (i.position.y = Math.round(i.position.y / this.translationSnap) * this.translationSnap), -1 !== e.search("Z") && (i.position.z = Math.round(i.position.z / this.translationSnap) * this.translationSnap), i.parent && i.position.sub(this.tempVector.setFromMatrixPosition(i.parent.matrixWorld))));
                else if ("scale" === n) {
                    if (-1 !== e.search("XYZ")) {
                        let t = this.pointEnd.length() / this.pointStart.length();
                        this.pointEnd.dot(this.pointStart) < 0 && (t *= -1), this.tempVector2.set(t, t, t)
                    } else this.tempVector.copy(this.pointStart), this.tempVector2.copy(this.pointEnd), this.tempVector.applyQuaternion(this.worldQuaternionInv), this.tempVector2.applyQuaternion(this.worldQuaternionInv), this.tempVector2.divide(this.tempVector), -1 === e.search("X") && (this.tempVector2.x = 1), -1 === e.search("Y") && (this.tempVector2.y = 1), -1 === e.search("Z") && (this.tempVector2.z = 1);
                    i.scale.copy(this.scaleStart).multiply(this.tempVector2), this.scaleSnap && this.object && (-1 !== e.search("X") && (this.object.scale.x = Math.round(i.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), -1 !== e.search("Y") && (i.scale.y = Math.round(i.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), -1 !== e.search("Z") && (i.scale.z = Math.round(i.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap))
                } else if ("rotate" === n) {
                    this.offset.copy(this.pointEnd).sub(this.pointStart);
                    const t = 20 / this.worldPosition.distanceTo(this.tempVector.setFromMatrixPosition(this.camera.matrixWorld));
                    "E" === e ? (this.rotationAxis.copy(this.eye), this.rotationAngle = this.pointEnd.angleTo(this.pointStart), this.startNorm.copy(this.pointStart).normalize(), this.endNorm.copy(this.pointEnd).normalize(), this.rotationAngle *= this.endNorm.cross(this.startNorm).dot(this.eye) < 0 ? 1 : -1) : "XYZE" === e ? (this.rotationAxis.copy(this.offset).cross(this.eye).normalize(), this.rotationAngle = this.offset.dot(this.tempVector.copy(this.rotationAxis).cross(this.eye)) * t) : ("X" === e || "Y" === e || "Z" === e) && (this.rotationAxis.copy(this.unit[e]), this.tempVector.copy(this.unit[e]), "local" === s && this.tempVector.applyQuaternion(this.worldQuaternion), this.rotationAngle = this.offset.dot(this.tempVector.cross(this.eye).normalize()) * t), this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap), "local" === s && "E" !== e && "XYZE" !== e ? (i.quaternion.copy(this.quaternionStart), i.quaternion.multiply(this.tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this.parentQuaternionInv), i.quaternion.copy(this.tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), i.quaternion.multiply(this.quaternionStart).normalize())
                }
                this.dispatchEvent(this.changeEvent), this.dispatchEvent(this.objectChangeEvent)
            }
        })), ae(this, "pointerUp", (t => {
            0 === t.button && (this.dragging && null !== this.axis && (this.mouseUpEvent.mode = this.mode, this.dispatchEvent(this.mouseUpEvent)), this.dragging = !1, this.axis = null)
        })), ae(this, "getPointer", (t => {
            var e;
            if (this.domElement && null != (e = this.domElement.ownerDocument) && e.pointerLockElement) return {
                x: 0,
                y: 0,
                button: t.button
            }; {
                const e = t.changedTouches ? t.changedTouches[0] : t,
                    n = this.domElement.getBoundingClientRect();
                return {
                    x: (e.clientX - n.left) / n.width * 2 - 1,
                    y: -(e.clientY - n.top) / n.height * 2 + 1,
                    button: t.button
                }
            }
        })), ae(this, "onPointerHover", (t => {
            if (this.enabled) switch (t.pointerType) {
                case "mouse":
                case "pen":
                    this.pointerHover(this.getPointer(t))
            }
        })), ae(this, "onPointerDown", (t => {
            !this.enabled || !this.domElement || (this.domElement.style.touchAction = "none", this.domElement.ownerDocument.addEventListener("pointermove", this.onPointerMove), this.pointerHover(this.getPointer(t)), this.pointerDown(this.getPointer(t)))
        })), ae(this, "onPointerMove", (t => {
            this.enabled && this.pointerMove(this.getPointer(t))
        })), ae(this, "onPointerUp", (t => {
            !this.enabled || !this.domElement || (this.domElement.style.touchAction = "", this.domElement.ownerDocument.removeEventListener("pointermove", this.onPointerMove), this.pointerUp(this.getPointer(t)))
        })), ae(this, "getMode", (() => this.mode)), ae(this, "setMode", (t => {
            this.mode = t
        })), ae(this, "setTranslationSnap", (t => {
            this.translationSnap = t
        })), ae(this, "setRotationSnap", (t => {
            this.rotationSnap = t
        })), ae(this, "setScaleSnap", (t => {
            this.scaleSnap = t
        })), ae(this, "setSize", (t => {
            this.size = t
        })), ae(this, "setSpace", (t => {
            this.space = t
        })), ae(this, "update", (() => {
            console.warn("THREE.TransformControls: update function has no more functionality and therefore has been deprecated.")
        })), ae(this, "connect", (t => {
            t === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'), this.domElement = t, this.domElement.addEventListener("pointerdown", this.onPointerDown), this.domElement.addEventListener("pointermove", this.onPointerHover), this.domElement.ownerDocument.addEventListener("pointerup", this.onPointerUp)
        })), ae(this, "dispose", (() => {
            var t, e, n, i, s, r;
            null == (t = this.domElement) || t.removeEventListener("pointerdown", this.onPointerDown), null == (e = this.domElement) || e.removeEventListener("pointermove", this.onPointerHover), null == (i = null == (n = this.domElement) ? void 0 : n.ownerDocument) || i.removeEventListener("pointermove", this.onPointerMove), null == (r = null == (s = this.domElement) ? void 0 : s.ownerDocument) || r.removeEventListener("pointerup", this.onPointerUp), this.traverse((t => {
                const e = t;
                e.geometry && e.geometry.dispose(), e.material && e.material.dispose()
            }))
        })), this.domElement = e, this.camera = t, this.gizmo = new PM, this.add(this.gizmo), this.plane = new RM, this.add(this.plane);
        const n = (t, e) => {
            let n = e;
            Object.defineProperty(this, t, {
                get: function() {
                    return void 0 !== n ? n : e
                },
                set: function(e) {
                    n !== e && (n = e, this.plane[t] = e, this.gizmo[t] = e, this.dispatchEvent({
                        type: t + "-changed",
                        value: e
                    }), this.dispatchEvent(this.changeEvent))
                }
            }), this[t] = e, this.plane[t] = e, this.gizmo[t] = e
        };
        n("camera", this.camera), n("object", this.object), n("enabled", this.enabled), n("axis", this.axis), n("mode", this.mode), n("translationSnap", this.translationSnap), n("rotationSnap", this.rotationSnap), n("scaleSnap", this.scaleSnap), n("space", this.space), n("size", this.size), n("dragging", this.dragging), n("showX", this.showX), n("showY", this.showY), n("showZ", this.showZ), n("worldPosition", this.worldPosition), n("worldPositionStart", this.worldPositionStart), n("worldQuaternion", this.worldQuaternion), n("worldQuaternionStart", this.worldQuaternionStart), n("cameraPosition", this.cameraPosition), n("cameraQuaternion", this.cameraQuaternion), n("pointStart", this.pointStart), n("pointEnd", this.pointEnd), n("rotationAxis", this.rotationAxis), n("rotationAngle", this.rotationAngle), n("eye", this.eye), void 0 !== e && this.connect(e)
    }
}
class PM extends ct {
    constructor() {
        super(), ae(this, "isTransformControlsGizmo", !0), ae(this, "type", "TransformControlsGizmo"), ae(this, "tempVector", new U(0, 0, 0)), ae(this, "tempEuler", new Gn), ae(this, "alignVector", new U(0, 1, 0)), ae(this, "zeroVector", new U(0, 0, 0)), ae(this, "lookAtMatrix", new Xe), ae(this, "tempQuaternion", new bt), ae(this, "tempQuaternion2", new bt), ae(this, "identityQuaternion", new bt), ae(this, "unitX", new U(1, 0, 0)), ae(this, "unitY", new U(0, 1, 0)), ae(this, "unitZ", new U(0, 0, 1)), ae(this, "gizmo"), ae(this, "picker"), ae(this, "helper"), ae(this, "rotationAxis", new U), ae(this, "cameraPosition", new U), ae(this, "worldPositionStart", new U), ae(this, "worldQuaternionStart", new bt), ae(this, "worldPosition", new U), ae(this, "worldQuaternion", new bt), ae(this, "eye", new U), ae(this, "camera", null), ae(this, "enabled", !0), ae(this, "axis", null), ae(this, "mode", "translate"), ae(this, "space", "world"), ae(this, "size", 1), ae(this, "dragging", !1), ae(this, "showX", !0), ae(this, "showY", !0), ae(this, "showZ", !0), ae(this, "updateMatrixWorld", (() => {
            let t = this.space;
            "scale" === this.mode && (t = "local");
            const e = "local" === t ? this.worldQuaternion : this.identityQuaternion;
            this.gizmo.translate.visible = "translate" === this.mode, this.gizmo.rotate.visible = "rotate" === this.mode, this.gizmo.scale.visible = "scale" === this.mode, this.helper.translate.visible = "translate" === this.mode, this.helper.rotate.visible = "rotate" === this.mode, this.helper.scale.visible = "scale" === this.mode;
            let n = [];
            n = n.concat(this.picker[this.mode].children), n = n.concat(this.gizmo[this.mode].children), n = n.concat(this.helper[this.mode].children);
            for (let t = 0; t < n.length; t++) {
                const i = n[t];
                let s;
                i.visible = !0, i.rotation.set(0, 0, 0), i.position.copy(this.worldPosition), (s = this.camera.isOrthographicCamera ? (this.camera.top - this.camera.bottom) / this.camera.zoom : this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), i.scale.set(1, 1, 1).multiplyScalar(s * this.size / 7), "helper" !== i.tag) ? (i.quaternion.copy(e), "translate" === this.mode || "scale" === this.mode ? (("X" === i.name || "XYZX" === i.name) && Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(e).dot(this.eye)) > .99 && (i.scale.set(1e-10, 1e-10, 1e-10), i.visible = !1), ("Y" === i.name || "XYZY" === i.name) && Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(e).dot(this.eye)) > .99 && (i.scale.set(1e-10, 1e-10, 1e-10), i.visible = !1), ("Z" === i.name || "XYZZ" === i.name) && Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(e).dot(this.eye)) > .99 && (i.scale.set(1e-10, 1e-10, 1e-10), i.visible = !1), "XY" === i.name && Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(e).dot(this.eye)) < .2 && (i.scale.set(1e-10, 1e-10, 1e-10), i.visible = !1), "YZ" === i.name && Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(e).dot(this.eye)) < .2 && (i.scale.set(1e-10, 1e-10, 1e-10), i.visible = !1), "XZ" === i.name && Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(e).dot(this.eye)) < .2 && (i.scale.set(1e-10, 1e-10, 1e-10), i.visible = !1), -1 !== i.name.search("X") && (this.alignVector.copy(this.unitX).applyQuaternion(e).dot(this.eye) < 0 ? "fwd" === i.tag ? i.visible = !1 : i.scale.x *= -1 : "bwd" === i.tag && (i.visible = !1)), -1 !== i.name.search("Y") && (this.alignVector.copy(this.unitY).applyQuaternion(e).dot(this.eye) < 0 ? "fwd" === i.tag ? i.visible = !1 : i.scale.y *= -1 : "bwd" === i.tag && (i.visible = !1)), -1 !== i.name.search("Z") && (this.alignVector.copy(this.unitZ).applyQuaternion(e).dot(this.eye) < 0 ? "fwd" === i.tag ? i.visible = !1 : i.scale.z *= -1 : "bwd" === i.tag && (i.visible = !1))) : "rotate" === this.mode && (this.tempQuaternion2.copy(e), this.alignVector.copy(this.eye).applyQuaternion(this.tempQuaternion.copy(e).invert()), -1 !== i.name.search("E") && i.quaternion.setFromRotationMatrix(this.lookAtMatrix.lookAt(this.eye, this.zeroVector, this.unitY)), "X" === i.name && (this.tempQuaternion.setFromAxisAngle(this.unitX, Math.atan2(-this.alignVector.y, this.alignVector.z)), this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2, this.tempQuaternion), i.quaternion.copy(this.tempQuaternion)), "Y" === i.name && (this.tempQuaternion.setFromAxisAngle(this.unitY, Math.atan2(this.alignVector.x, this.alignVector.z)), this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2, this.tempQuaternion), i.quaternion.copy(this.tempQuaternion)), "Z" === i.name && (this.tempQuaternion.setFromAxisAngle(this.unitZ, Math.atan2(this.alignVector.y, this.alignVector.x)), this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2, this.tempQuaternion), i.quaternion.copy(this.tempQuaternion))), i.visible = i.visible && (-1 === i.name.indexOf("X") || this.showX), i.visible = i.visible && (-1 === i.name.indexOf("Y") || this.showY), i.visible = i.visible && (-1 === i.name.indexOf("Z") || this.showZ), i.visible = i.visible && (-1 === i.name.indexOf("E") || this.showX && this.showY && this.showZ), i.material.tempOpacity = i.material.tempOpacity || i.material.opacity, i.material.tempColor = i.material.tempColor || i.material.color.clone(), i.material.color.copy(i.material.tempColor), i.material.opacity = i.material.tempOpacity, this.enabled ? this.axis && (i.name === this.axis || this.axis.split("").some((function(t) {
                    return i.name === t
                })) ? (i.material.opacity = 1, i.material.color.lerp(new Le(1, 1, 1), .5)) : (i.material.opacity *= .25, i.material.color.lerp(new Le(1, 1, 1), .5))) : (i.material.opacity *= .5, i.material.color.lerp(new Le(1, 1, 1), .5))) : (i.visible = !1, "AXIS" === i.name ? (i.position.copy(this.worldPositionStart), i.visible = !!this.axis, "X" === this.axis && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, 0, 0)), i.quaternion.copy(e).multiply(this.tempQuaternion), Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(e).dot(this.eye)) > .9 && (i.visible = !1)), "Y" === this.axis && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, 0, Math.PI / 2)), i.quaternion.copy(e).multiply(this.tempQuaternion), Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(e).dot(this.eye)) > .9 && (i.visible = !1)), "Z" === this.axis && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, Math.PI / 2, 0)), i.quaternion.copy(e).multiply(this.tempQuaternion), Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(e).dot(this.eye)) > .9 && (i.visible = !1)), "XYZE" === this.axis && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, Math.PI / 2, 0)), this.alignVector.copy(this.rotationAxis), i.quaternion.setFromRotationMatrix(this.lookAtMatrix.lookAt(this.zeroVector, this.alignVector, this.unitY)), i.quaternion.multiply(this.tempQuaternion), i.visible = this.dragging), "E" === this.axis && (i.visible = !1)) : "START" === i.name ? (i.position.copy(this.worldPositionStart), i.visible = this.dragging) : "END" === i.name ? (i.position.copy(this.worldPosition), i.visible = this.dragging) : "DELTA" === i.name ? (i.position.copy(this.worldPositionStart), i.quaternion.copy(this.worldQuaternionStart), this.tempVector.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), this.tempVector.applyQuaternion(this.worldQuaternionStart.clone().invert()), i.scale.copy(this.tempVector), i.visible = this.dragging) : (i.quaternion.copy(e), this.dragging ? i.position.copy(this.worldPositionStart) : i.position.copy(this.worldPosition), this.axis && (i.visible = -1 !== this.axis.search(i.name))))
            }
            super.updateMatrixWorld()
        }));
        const t = new At({
                depthTest: !1,
                depthWrite: !1,
                transparent: !0,
                side: 2,
                fog: !1,
                toneMapped: !1
            }),
            e = new Zi({
                depthTest: !1,
                depthWrite: !1,
                transparent: !0,
                linewidth: 1,
                fog: !1,
                toneMapped: !1
            }),
            n = t.clone();
        n.opacity = .15;
        const i = t.clone();
        i.opacity = .33;
        const s = t.clone();
        s.color.set(16711680);
        const r = t.clone();
        r.color.set(65280);
        const o = t.clone();
        o.color.set(255);
        const a = t.clone();
        a.opacity = .25;
        const l = a.clone();
        l.color.set(16776960);
        const c = a.clone();
        c.color.set(65535);
        const h = a.clone();
        h.color.set(16711935), t.clone().color.set(16776960);
        const u = e.clone();
        u.color.set(16711680);
        const d = e.clone();
        d.color.set(65280);
        const p = e.clone();
        p.color.set(255);
        const f = e.clone();
        f.color.set(65535);
        const m = e.clone();
        m.color.set(16711935);
        const g = e.clone();
        g.color.set(16776960);
        const v = e.clone();
        v.color.set(7895160);
        const y = g.clone();
        y.opacity = .25;
        const x = new pn(0, .05, .2, 12, 1, !1),
            b = new Sn(.125, .125, .125),
            A = new ht;
        A.setAttribute("position", new Fe([0, 0, 0, 1, 0, 0], 3));
        const S = (t, e) => {
                const n = new ht,
                    i = [];
                for (let n = 0; n <= 64 * e; ++n) i.push(0, Math.cos(n / 32 * Math.PI) * t, Math.sin(n / 32 * Math.PI) * t);
                return n.setAttribute("position", new Fe(i, 3)), n
            },
            w = {
                X: [
                    [new be(x, s), [1, 0, 0],
                        [0, 0, -Math.PI / 2], null, "fwd"
                    ],
                    [new be(x, s), [1, 0, 0],
                        [0, 0, Math.PI / 2], null, "bwd"
                    ],
                    [new at(A, u)]
                ],
                Y: [
                    [new be(x, r), [0, 1, 0], null, null, "fwd"],
                    [new be(x, r), [0, 1, 0],
                        [Math.PI, 0, 0], null, "bwd"
                    ],
                    [new at(A, d), null, [0, 0, Math.PI / 2]]
                ],
                Z: [
                    [new be(x, o), [0, 0, 1],
                        [Math.PI / 2, 0, 0], null, "fwd"
                    ],
                    [new be(x, o), [0, 0, 1],
                        [-Math.PI / 2, 0, 0], null, "bwd"
                    ],
                    [new at(A, p), null, [0, -Math.PI / 2, 0]]
                ],
                XYZ: [
                    [new be(new wi(.1, 0), a.clone()), [0, 0, 0],
                        [0, 0, 0]
                    ]
                ],
                XY: [
                    [new be(new Ot(.295, .295), l.clone()), [.15, .15, 0]],
                    [new at(A, g), [.18, .3, 0], null, [.125, 1, 1]],
                    [new at(A, g), [.3, .18, 0],
                        [0, 0, Math.PI / 2],
                        [.125, 1, 1]
                    ]
                ],
                YZ: [
                    [new be(new Ot(.295, .295), c.clone()), [0, .15, .15],
                        [0, Math.PI / 2, 0]
                    ],
                    [new at(A, f), [0, .18, .3],
                        [0, 0, Math.PI / 2],
                        [.125, 1, 1]
                    ],
                    [new at(A, f), [0, .3, .18],
                        [0, -Math.PI / 2, 0],
                        [.125, 1, 1]
                    ]
                ],
                XZ: [
                    [new be(new Ot(.295, .295), h.clone()), [.15, 0, .15],
                        [-Math.PI / 2, 0, 0]
                    ],
                    [new at(A, m), [.18, 0, .3], null, [.125, 1, 1]],
                    [new at(A, m), [.3, 0, .18],
                        [0, -Math.PI / 2, 0],
                        [.125, 1, 1]
                    ]
                ]
            },
            _ = {
                X: [
                    [new be(new pn(.2, 0, 1, 4, 1, !1), n), [.6, 0, 0],
                        [0, 0, -Math.PI / 2]
                    ]
                ],
                Y: [
                    [new be(new pn(.2, 0, 1, 4, 1, !1), n), [0, .6, 0]]
                ],
                Z: [
                    [new be(new pn(.2, 0, 1, 4, 1, !1), n), [0, 0, .6],
                        [Math.PI / 2, 0, 0]
                    ]
                ],
                XYZ: [
                    [new be(new wi(.2, 0), n)]
                ],
                XY: [
                    [new be(new Ot(.4, .4), n), [.2, .2, 0]]
                ],
                YZ: [
                    [new be(new Ot(.4, .4), n), [0, .2, .2],
                        [0, Math.PI / 2, 0]
                    ]
                ],
                XZ: [
                    [new be(new Ot(.4, .4), n), [.2, 0, .2],
                        [-Math.PI / 2, 0, 0]
                    ]
                ]
            },
            M = {
                START: [
                    [new be(new wi(.01, 2), i), null, null, null, "helper"]
                ],
                END: [
                    [new be(new wi(.01, 2), i), null, null, null, "helper"]
                ],
                DELTA: [
                    [new at((() => {
                        const t = new ht;
                        return t.setAttribute("position", new Fe([0, 0, 0, 1, 1, 1], 3)), t
                    })(), i), null, null, null, "helper"]
                ],
                X: [
                    [new at(A, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
                ],
                Y: [
                    [new at(A, i.clone()), [0, -1e3, 0],
                        [0, 0, Math.PI / 2],
                        [1e6, 1, 1], "helper"
                    ]
                ],
                Z: [
                    [new at(A, i.clone()), [0, 0, -1e3],
                        [0, -Math.PI / 2, 0],
                        [1e6, 1, 1], "helper"
                    ]
                ]
            },
            T = {
                X: [
                    [new at(S(1, .5), u)],
                    [new be(new wi(.04, 0), s), [0, 0, .99], null, [1, 3, 1]]
                ],
                Y: [
                    [new at(S(1, .5), d), null, [0, 0, -Math.PI / 2]],
                    [new be(new wi(.04, 0), r), [0, 0, .99], null, [3, 1, 1]]
                ],
                Z: [
                    [new at(S(1, .5), p), null, [0, Math.PI / 2, 0]],
                    [new be(new wi(.04, 0), o), [.99, 0, 0], null, [1, 3, 1]]
                ],
                E: [
                    [new at(S(1.25, 1), y), null, [0, Math.PI / 2, 0]],
                    [new be(new pn(.03, 0, .15, 4, 1, !1), y), [1.17, 0, 0],
                        [0, 0, -Math.PI / 2],
                        [1, 1, .001]
                    ],
                    [new be(new pn(.03, 0, .15, 4, 1, !1), y), [-1.17, 0, 0],
                        [0, 0, Math.PI / 2],
                        [1, 1, .001]
                    ],
                    [new be(new pn(.03, 0, .15, 4, 1, !1), y), [0, -1.17, 0],
                        [Math.PI, 0, 0],
                        [1, 1, .001]
                    ],
                    [new be(new pn(.03, 0, .15, 4, 1, !1), y), [0, 1.17, 0],
                        [0, 0, 0],
                        [1, 1, .001]
                    ]
                ],
                XYZE: [
                    [new at(S(1, 1), v), null, [0, Math.PI / 2, 0]]
                ]
            },
            E = {
                AXIS: [
                    [new at(A, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
                ]
            },
            C = {
                X: [
                    [new be(new lr(1, .1, 4, 24), n), [0, 0, 0],
                        [0, -Math.PI / 2, -Math.PI / 2]
                    ]
                ],
                Y: [
                    [new be(new lr(1, .1, 4, 24), n), [0, 0, 0],
                        [Math.PI / 2, 0, 0]
                    ]
                ],
                Z: [
                    [new be(new lr(1, .1, 4, 24), n), [0, 0, 0],
                        [0, 0, -Math.PI / 2]
                    ]
                ],
                E: [
                    [new be(new lr(1.25, .1, 2, 24), n)]
                ],
                XYZE: [
                    [new be(new Or(.7, 10, 8), n)]
                ]
            },
            R = {
                X: [
                    [new be(b, s), [.8, 0, 0],
                        [0, 0, -Math.PI / 2]
                    ],
                    [new at(A, u), null, null, [.8, 1, 1]]
                ],
                Y: [
                    [new be(b, r), [0, .8, 0]],
                    [new at(A, d), null, [0, 0, Math.PI / 2],
                        [.8, 1, 1]
                    ]
                ],
                Z: [
                    [new be(b, o), [0, 0, .8],
                        [Math.PI / 2, 0, 0]
                    ],
                    [new at(A, p), null, [0, -Math.PI / 2, 0],
                        [.8, 1, 1]
                    ]
                ],
                XY: [
                    [new be(b, l), [.85, .85, 0], null, [2, 2, .2]],
                    [new at(A, g), [.855, .98, 0], null, [.125, 1, 1]],
                    [new at(A, g), [.98, .855, 0],
                        [0, 0, Math.PI / 2],
                        [.125, 1, 1]
                    ]
                ],
                YZ: [
                    [new be(b, c), [0, .85, .85], null, [.2, 2, 2]],
                    [new at(A, f), [0, .855, .98],
                        [0, 0, Math.PI / 2],
                        [.125, 1, 1]
                    ],
                    [new at(A, f), [0, .98, .855],
                        [0, -Math.PI / 2, 0],
                        [.125, 1, 1]
                    ]
                ],
                XZ: [
                    [new be(b, h), [.85, 0, .85], null, [2, .2, 2]],
                    [new at(A, m), [.855, 0, .98], null, [.125, 1, 1]],
                    [new at(A, m), [.98, 0, .855],
                        [0, -Math.PI / 2, 0],
                        [.125, 1, 1]
                    ]
                ],
                XYZX: [
                    [new be(new Sn(.125, .125, .125), a.clone()), [1.1, 0, 0]]
                ],
                XYZY: [
                    [new be(new Sn(.125, .125, .125), a.clone()), [0, 1.1, 0]]
                ],
                XYZZ: [
                    [new be(new Sn(.125, .125, .125), a.clone()), [0, 0, 1.1]]
                ]
            },
            P = {
                X: [
                    [new be(new pn(.2, 0, .8, 4, 1, !1), n), [.5, 0, 0],
                        [0, 0, -Math.PI / 2]
                    ]
                ],
                Y: [
                    [new be(new pn(.2, 0, .8, 4, 1, !1), n), [0, .5, 0]]
                ],
                Z: [
                    [new be(new pn(.2, 0, .8, 4, 1, !1), n), [0, 0, .5],
                        [Math.PI / 2, 0, 0]
                    ]
                ],
                XY: [
                    [new be(b, n), [.85, .85, 0], null, [3, 3, .2]]
                ],
                YZ: [
                    [new be(b, n), [0, .85, .85], null, [.2, 3, 3]]
                ],
                XZ: [
                    [new be(b, n), [.85, 0, .85], null, [3, .2, 3]]
                ],
                XYZX: [
                    [new be(new Sn(.2, .2, .2), n), [1.1, 0, 0]]
                ],
                XYZY: [
                    [new be(new Sn(.2, .2, .2), n), [0, 1.1, 0]]
                ],
                XYZZ: [
                    [new be(new Sn(.2, .2, .2), n), [0, 0, 1.1]]
                ]
            },
            D = {
                X: [
                    [new at(A, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
                ],
                Y: [
                    [new at(A, i.clone()), [0, -1e3, 0],
                        [0, 0, Math.PI / 2],
                        [1e6, 1, 1], "helper"
                    ]
                ],
                Z: [
                    [new at(A, i.clone()), [0, 0, -1e3],
                        [0, -Math.PI / 2, 0],
                        [1e6, 1, 1], "helper"
                    ]
                ]
            },
            I = t => {
                const e = new ct;
                for (let n in t)
                    for (let i = t[n].length; i--;) {
                        const s = t[n][i][0].clone(),
                            r = t[n][i][1],
                            o = t[n][i][2],
                            a = t[n][i][3],
                            l = t[n][i][4];
                        s.name = n, s.tag = l, r && s.position.set(r[0], r[1], r[2]), o && s.rotation.set(o[0], o[1], o[2]), a && s.scale.set(a[0], a[1], a[2]), s.updateMatrix();
                        const c = s.geometry.clone();
                        c.applyMatrix4(s.matrix), s.geometry = c, s.renderOrder = 1 / 0, s.position.set(0, 0, 0), s.rotation.set(0, 0, 0), s.scale.set(1, 1, 1), e.add(s)
                    }
                return e
            };
        this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = I(w)), this.add(this.gizmo.rotate = I(T)), this.add(this.gizmo.scale = I(R)), this.add(this.picker.translate = I(_)), this.add(this.picker.rotate = I(C)), this.add(this.picker.scale = I(P)), this.add(this.helper.translate = I(M)), this.add(this.helper.rotate = I(E)), this.add(this.helper.scale = I(D)), this.picker.translate.visible = !1, this.picker.rotate.visible = !1, this.picker.scale.visible = !1
    }
}
class RM extends be {
    constructor() {
        super(new Ot(1e5, 1e5, 2, 2), new At({
            visible: !1,
            wireframe: !0,
            side: 2,
            transparent: !0,
            opacity: .1,
            toneMapped: !1
        })), ae(this, "isTransformControlsPlane", !0), ae(this, "type", "TransformControlsPlane"), ae(this, "unitX", new U(1, 0, 0)), ae(this, "unitY", new U(0, 1, 0)), ae(this, "unitZ", new U(0, 0, 1)), ae(this, "tempVector", new U), ae(this, "dirVector", new U), ae(this, "alignVector", new U), ae(this, "tempMatrix", new Xe), ae(this, "identityQuaternion", new bt), ae(this, "cameraQuaternion", new bt), ae(this, "worldPosition", new U), ae(this, "worldQuaternion", new bt), ae(this, "eye", new U), ae(this, "axis", null), ae(this, "mode", "translate"), ae(this, "space", "world"), ae(this, "updateMatrixWorld", (() => {
            let t = this.space;
            switch (this.position.copy(this.worldPosition), "scale" === this.mode && (t = "local"), this.unitX.set(1, 0, 0).applyQuaternion("local" === t ? this.worldQuaternion : this.identityQuaternion), this.unitY.set(0, 1, 0).applyQuaternion("local" === t ? this.worldQuaternion : this.identityQuaternion), this.unitZ.set(0, 0, 1).applyQuaternion("local" === t ? this.worldQuaternion : this.identityQuaternion), this.alignVector.copy(this.unitY), this.mode) {
                case "translate":
                case "scale":
                    switch (this.axis) {
                        case "X":
                            this.alignVector.copy(this.eye).cross(this.unitX), this.dirVector.copy(this.unitX).cross(this.alignVector);
                            break;
                        case "Y":
                            this.alignVector.copy(this.eye).cross(this.unitY), this.dirVector.copy(this.unitY).cross(this.alignVector);
                            break;
                        case "Z":
                            this.alignVector.copy(this.eye).cross(this.unitZ), this.dirVector.copy(this.unitZ).cross(this.alignVector);
                            break;
                        case "XY":
                            this.dirVector.copy(this.unitZ);
                            break;
                        case "YZ":
                            this.dirVector.copy(this.unitX);
                            break;
                        case "XZ":
                            this.alignVector.copy(this.unitZ), this.dirVector.copy(this.unitY);
                            break;
                        case "XYZ":
                        case "E":
                            this.dirVector.set(0, 0, 0)
                    }
                    break;
                default:
                    this.dirVector.set(0, 0, 0)
            }
            0 === this.dirVector.length() ? this.quaternion.copy(this.cameraQuaternion) : (this.tempMatrix.lookAt(this.tempVector.set(0, 0, 0), this.dirVector, this.alignVector), this.quaternion.setFromRotationMatrix(this.tempMatrix)), super.updateMatrixWorld()
        }))
    }
}
var DM = Object.defineProperty,
    IM = (t, e, n) => e in t ? DM(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : t[e] = n,
    He = (t, e, n) => (IM(t, "symbol" != typeof e ? e + "" : e, n), n);
const ma = new Ir,
    Sf = new ji,
    LM = Math.cos(Math.PI / 180 * 70),
    _f = (t, e) => (t % e + e) % e;
class OM extends hi {
    constructor(t, e) {
        super(), He(this, "object"), He(this, "domElement"), He(this, "enabled", !0), He(this, "target", new U), He(this, "minDistance", 0), He(this, "maxDistance", 1 / 0), He(this, "minZoom", 0), He(this, "maxZoom", 1 / 0), He(this, "minPolarAngle", 0), He(this, "maxPolarAngle", Math.PI), He(this, "minAzimuthAngle", -1 / 0), He(this, "maxAzimuthAngle", 1 / 0), He(this, "enableDamping", !1), He(this, "dampingFactor", .05), He(this, "enableZoom", !0), He(this, "zoomSpeed", 1), He(this, "enableRotate", !0), He(this, "rotateSpeed", 1), He(this, "enablePan", !0), He(this, "panSpeed", 1), He(this, "screenSpacePanning", !0), He(this, "keyPanSpeed", 7), He(this, "zoomToCursor", !1), He(this, "autoRotate", !1), He(this, "autoRotateSpeed", 2), He(this, "reverseOrbit", !1), He(this, "reverseHorizontalOrbit", !1), He(this, "reverseVerticalOrbit", !1), He(this, "keys", {
            LEFT: "ArrowLeft",
            UP: "ArrowUp",
            RIGHT: "ArrowRight",
            BOTTOM: "ArrowDown"
        }), He(this, "mouseButtons", {
            LEFT: Os.ROTATE,
            MIDDLE: Os.DOLLY,
            RIGHT: Os.PAN
        }), He(this, "touches", {
            ONE: Bs.ROTATE,
            TWO: Bs.DOLLY_PAN
        }), He(this, "target0"), He(this, "position0"), He(this, "zoom0"), He(this, "_domElementKeyEvents", null), He(this, "getPolarAngle"), He(this, "getAzimuthalAngle"), He(this, "setPolarAngle"), He(this, "setAzimuthalAngle"), He(this, "getDistance"), He(this, "listenToKeyEvents"), He(this, "stopListenToKeyEvents"), He(this, "saveState"), He(this, "reset"), He(this, "update"), He(this, "connect"), He(this, "dispose"), this.object = t, this.domElement = e, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.getPolarAngle = () => c.phi, this.getAzimuthalAngle = () => c.theta, this.setPolarAngle = t => {
            let e = _f(t, 2 * Math.PI),
                i = c.phi;
            i < 0 && (i += 2 * Math.PI), e < 0 && (e += 2 * Math.PI);
            let s = Math.abs(e - i);
            2 * Math.PI - s < s && (e < i ? e += 2 * Math.PI : i += 2 * Math.PI), h.phi = e - i, n.update()
        }, this.setAzimuthalAngle = t => {
            let e = _f(t, 2 * Math.PI),
                i = c.theta;
            i < 0 && (i += 2 * Math.PI), e < 0 && (e += 2 * Math.PI);
            let s = Math.abs(e - i);
            2 * Math.PI - s < s && (e < i ? e += 2 * Math.PI : i += 2 * Math.PI), h.theta = e - i, n.update()
        }, this.getDistance = () => n.object.position.distanceTo(n.target), this.listenToKeyEvents = t => {
            t.addEventListener("keydown", Z), this._domElementKeyEvents = t
        }, this.stopListenToKeyEvents = () => {
            this._domElementKeyEvents.removeEventListener("keydown", Z), this._domElementKeyEvents = null
        }, this.saveState = () => {
            n.target0.copy(n.target), n.position0.copy(n.object.position), n.zoom0 = n.object.zoom
        }, this.reset = () => {
            n.target.copy(n.target0), n.object.position.copy(n.position0), n.object.zoom = n.zoom0, n.object.updateProjectionMatrix(), n.dispatchEvent(i), n.update(), a = o.NONE
        }, this.update = (() => {
            const e = new U,
                s = new U(0, 1, 0),
                r = (new bt).setFromUnitVectors(t.up, s),
                p = r.clone().invert(),
                f = new U,
                m = new bt,
                g = 2 * Math.PI;
            return function() {
                const v = n.object.position;
                r.setFromUnitVectors(t.up, s), p.copy(r).invert(), e.copy(v).sub(n.target), e.applyQuaternion(r), c.setFromVector3(e), n.autoRotate && a === o.NONE && C(2 * Math.PI / 60 / 60 * n.autoRotateSpeed), n.enableDamping ? (c.theta += h.theta * n.dampingFactor, c.phi += h.phi * n.dampingFactor) : (c.theta += h.theta, c.phi += h.phi);
                let y = n.minAzimuthAngle,
                    x = n.maxAzimuthAngle;
                isFinite(y) && isFinite(x) && (y < -Math.PI ? y += g : y > Math.PI && (y -= g), x < -Math.PI ? x += g : x > Math.PI && (x -= g), c.theta = y <= x ? Math.max(y, Math.min(x, c.theta)) : c.theta > (y + x) / 2 ? Math.max(y, c.theta) : Math.min(x, c.theta)), c.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, c.phi)), c.makeSafe(), !0 === n.enableDamping ? n.target.addScaledVector(d, n.dampingFactor) : n.target.add(d), n.zoomToCursor && _ || n.object.isOrthographicCamera ? c.radius = N(c.radius) : c.radius = N(c.radius * u), e.setFromSpherical(c), e.applyQuaternion(p), v.copy(n.target).add(e), n.object.matrixAutoUpdate || n.object.updateMatrix(), n.object.lookAt(n.target), !0 === n.enableDamping ? (h.theta *= 1 - n.dampingFactor, h.phi *= 1 - n.dampingFactor, d.multiplyScalar(1 - n.dampingFactor)) : (h.set(0, 0, 0), d.set(0, 0, 0));
                let b = !1;
                if (n.zoomToCursor && _) {
                    let i = null;
                    if (n.object instanceof Pt && n.object.isPerspectiveCamera) {
                        const t = e.length();
                        i = N(t * u);
                        const s = t - i;
                        n.object.position.addScaledVector(S, s), n.object.updateMatrixWorld()
                    } else if (n.object.isOrthographicCamera) {
                        const t = new U(w.x, w.y, 0);
                        t.unproject(n.object), n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / u)), n.object.updateProjectionMatrix(), b = !0;
                        const s = new U(w.x, w.y, 0);
                        s.unproject(n.object), n.object.position.sub(s).add(t), n.object.updateMatrixWorld(), i = e.length()
                    } else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), n.zoomToCursor = !1;
                    null !== i && (n.screenSpacePanning ? n.target.set(0, 0, -1).transformDirection(n.object.matrix).multiplyScalar(i).add(n.object.position) : (ma.origin.copy(n.object.position), ma.direction.set(0, 0, -1).transformDirection(n.object.matrix), Math.abs(n.object.up.dot(ma.direction)) < LM ? t.lookAt(n.target) : (Sf.setFromNormalAndCoplanarPoint(n.object.up, n.target), ma.intersectPlane(Sf, n.target))))
                } else n.object instanceof Ci && n.object.isOrthographicCamera && (b = 1 !== u, b && (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / u)), n.object.updateProjectionMatrix()));
                return u = 1, _ = !1, !!(b || f.distanceToSquared(n.object.position) > l || 8 * (1 - m.dot(n.object.quaternion)) > l) && (n.dispatchEvent(i), f.copy(n.object.position), m.copy(n.object.quaternion), b = !1, !0)
            }
        })(), this.connect = t => {
            n.domElement = t, n.domElement.style.touchAction = "none", n.domElement.addEventListener("contextmenu", J), n.domElement.addEventListener("pointerdown", X), n.domElement.addEventListener("pointercancel", Y), n.domElement.addEventListener("wheel", q)
        }, this.dispose = () => {
            var t, e, i, s, r, o;
            n.domElement && (n.domElement.style.touchAction = "auto"), null == (t = n.domElement) || t.removeEventListener("contextmenu", J), null == (e = n.domElement) || e.removeEventListener("pointerdown", X), null == (i = n.domElement) || i.removeEventListener("pointercancel", Y), null == (s = n.domElement) || s.removeEventListener("wheel", q), null == (r = n.domElement) || r.ownerDocument.removeEventListener("pointermove", K), null == (o = n.domElement) || o.ownerDocument.removeEventListener("pointerup", Y), null !== n._domElementKeyEvents && n._domElementKeyEvents.removeEventListener("keydown", Z)
        };
        const n = this,
            i = {
                type: "change"
            },
            s = {
                type: "start"
            },
            r = {
                type: "end"
            },
            o = {
                NONE: -1,
                ROTATE: 0,
                DOLLY: 1,
                PAN: 2,
                TOUCH_ROTATE: 3,
                TOUCH_PAN: 4,
                TOUCH_DOLLY_PAN: 5,
                TOUCH_DOLLY_ROTATE: 6
            };
        let a = o.NONE;
        const l = 1e-6,
            c = new hf,
            h = new hf;
        let u = 1;
        const d = new U,
            p = new Q,
            f = new Q,
            m = new Q,
            g = new Q,
            v = new Q,
            y = new Q,
            x = new Q,
            b = new Q,
            A = new Q,
            S = new U,
            w = new Q;
        let _ = !1;
        const M = [],
            T = {};

        function E() {
            return Math.pow(.95, n.zoomSpeed)
        }

        function C(t) {
            n.reverseOrbit || n.reverseHorizontalOrbit ? h.theta += t : h.theta -= t
        }

        function R(t) {
            n.reverseOrbit || n.reverseVerticalOrbit ? h.phi += t : h.phi -= t
        }
        const P = (() => {
                const t = new U;
                return function(e, n) {
                    t.setFromMatrixColumn(n, 0), t.multiplyScalar(-e), d.add(t)
                }
            })(),
            D = (() => {
                const t = new U;
                return function(e, i) {
                    !0 === n.screenSpacePanning ? t.setFromMatrixColumn(i, 1) : (t.setFromMatrixColumn(i, 0), t.crossVectors(n.object.up, t)), t.multiplyScalar(e), d.add(t)
                }
            })(),
            I = (() => {
                const t = new U;
                return function(e, i) {
                    const s = n.domElement;
                    if (s && n.object instanceof Pt && n.object.isPerspectiveCamera) {
                        const r = n.object.position;
                        t.copy(r).sub(n.target);
                        let o = t.length();
                        o *= Math.tan(n.object.fov / 2 * Math.PI / 180), P(2 * e * o / s.clientHeight, n.object.matrix), D(2 * i * o / s.clientHeight, n.object.matrix)
                    } else s && n.object instanceof Ci && n.object.isOrthographicCamera ? (P(e * (n.object.right - n.object.left) / n.object.zoom / s.clientWidth, n.object.matrix), D(i * (n.object.top - n.object.bottom) / n.object.zoom / s.clientHeight, n.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), n.enablePan = !1)
                }
            })();

        function L(t) {
            n.object instanceof Pt && n.object.isPerspectiveCamera || n.object instanceof Ci && n.object.isOrthographicCamera ? u /= t : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1)
        }

        function O(t) {
            n.object instanceof Pt && n.object.isPerspectiveCamera || n.object instanceof Ci && n.object.isOrthographicCamera ? u *= t : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1)
        }

        function B(t) {
            if (!n.zoomToCursor || !n.domElement) return;
            _ = !0;
            const e = n.domElement.getBoundingClientRect(),
                i = t.clientX - e.left,
                s = t.clientY - e.top,
                r = e.width,
                o = e.height;
            w.x = i / r * 2 - 1, w.y = -s / o * 2 + 1, S.set(w.x, w.y, 1).unproject(n.object).sub(n.object.position).normalize()
        }

        function N(t) {
            return Math.max(n.minDistance, Math.min(n.maxDistance, t))
        }

        function F(t) {
            p.set(t.clientX, t.clientY)
        }

        function k(t) {
            g.set(t.clientX, t.clientY)
        }

        function z() {
            if (1 == M.length) p.set(M[0].pageX, M[0].pageY);
            else {
                const t = .5 * (M[0].pageX + M[1].pageX),
                    e = .5 * (M[0].pageY + M[1].pageY);
                p.set(t, e)
            }
        }

        function G() {
            if (1 == M.length) g.set(M[0].pageX, M[0].pageY);
            else {
                const t = .5 * (M[0].pageX + M[1].pageX),
                    e = .5 * (M[0].pageY + M[1].pageY);
                g.set(t, e)
            }
        }

        function H() {
            const t = M[0].pageX - M[1].pageX,
                e = M[0].pageY - M[1].pageY,
                n = Math.sqrt(t * t + e * e);
            x.set(0, n)
        }

        function V(t) {
            if (1 == M.length) f.set(t.pageX, t.pageY);
            else {
                const e = tt(t),
                    n = .5 * (t.pageX + e.x),
                    i = .5 * (t.pageY + e.y);
                f.set(n, i)
            }
            m.subVectors(f, p).multiplyScalar(n.rotateSpeed);
            const e = n.domElement;
            e && (C(2 * Math.PI * m.x / e.clientHeight), R(2 * Math.PI * m.y / e.clientHeight)), p.copy(f)
        }

        function W(t) {
            if (1 == M.length) v.set(t.pageX, t.pageY);
            else {
                const e = tt(t),
                    n = .5 * (t.pageX + e.x),
                    i = .5 * (t.pageY + e.y);
                v.set(n, i)
            }
            y.subVectors(v, g).multiplyScalar(n.panSpeed), I(y.x, y.y), g.copy(v)
        }

        function j(t) {
            const e = tt(t),
                i = t.pageX - e.x,
                s = t.pageY - e.y,
                r = Math.sqrt(i * i + s * s);
            b.set(0, r), A.set(0, Math.pow(b.y / x.y, n.zoomSpeed)), L(A.y), x.copy(b)
        }

        function X(t) {
            var e, i;
            !1 !== n.enabled && (0 === M.length && (null == (e = n.domElement) || e.ownerDocument.addEventListener("pointermove", K), null == (i = n.domElement) || i.ownerDocument.addEventListener("pointerup", Y)), function(t) {
                M.push(t)
            }(t), "touch" === t.pointerType ? function(t) {
                switch ($(t), M.length) {
                    case 1:
                        switch (n.touches.ONE) {
                            case Bs.ROTATE:
                                if (!1 === n.enableRotate) return;
                                z(), a = o.TOUCH_ROTATE;
                                break;
                            case Bs.PAN:
                                if (!1 === n.enablePan) return;
                                G(), a = o.TOUCH_PAN;
                                break;
                            default:
                                a = o.NONE
                        }
                        break;
                    case 2:
                        switch (n.touches.TWO) {
                            case Bs.DOLLY_PAN:
                                if (!1 === n.enableZoom && !1 === n.enablePan) return;
                                n.enableZoom && H(), n.enablePan && G(), a = o.TOUCH_DOLLY_PAN;
                                break;
                            case Bs.DOLLY_ROTATE:
                                if (!1 === n.enableZoom && !1 === n.enableRotate) return;
                                n.enableZoom && H(), n.enableRotate && z(), a = o.TOUCH_DOLLY_ROTATE;
                                break;
                            default:
                                a = o.NONE
                        }
                        break;
                    default:
                        a = o.NONE
                }
                a !== o.NONE && n.dispatchEvent(s)
            }(t) : function(t) {
                let e;
                switch (t.button) {
                    case 0:
                        e = n.mouseButtons.LEFT;
                        break;
                    case 1:
                        e = n.mouseButtons.MIDDLE;
                        break;
                    case 2:
                        e = n.mouseButtons.RIGHT;
                        break;
                    default:
                        e = -1
                }
                switch (e) {
                    case Os.DOLLY:
                        if (!1 === n.enableZoom) return;
                        (function(t) {
                            B(t), x.set(t.clientX, t.clientY)
                        })(t), a = o.DOLLY;
                        break;
                    case Os.ROTATE:
                        if (t.ctrlKey || t.metaKey || t.shiftKey) {
                            if (!1 === n.enablePan) return;
                            k(t), a = o.PAN
                        } else {
                            if (!1 === n.enableRotate) return;
                            F(t), a = o.ROTATE
                        }
                        break;
                    case Os.PAN:
                        if (t.ctrlKey || t.metaKey || t.shiftKey) {
                            if (!1 === n.enableRotate) return;
                            F(t), a = o.ROTATE
                        } else {
                            if (!1 === n.enablePan) return;
                            k(t), a = o.PAN
                        }
                        break;
                    default:
                        a = o.NONE
                }
                a !== o.NONE && n.dispatchEvent(s)
            }(t))
        }

        function K(t) {
            !1 !== n.enabled && ("touch" === t.pointerType ? function(t) {
                switch ($(t), a) {
                    case o.TOUCH_ROTATE:
                        if (!1 === n.enableRotate) return;
                        V(t), n.update();
                        break;
                    case o.TOUCH_PAN:
                        if (!1 === n.enablePan) return;
                        W(t), n.update();
                        break;
                    case o.TOUCH_DOLLY_PAN:
                        if (!1 === n.enableZoom && !1 === n.enablePan) return;
                        (function(t) {
                            n.enableZoom && j(t), n.enablePan && W(t)
                        })(t), n.update();
                        break;
                    case o.TOUCH_DOLLY_ROTATE:
                        if (!1 === n.enableZoom && !1 === n.enableRotate) return;
                        (function(t) {
                            n.enableZoom && j(t), n.enableRotate && V(t)
                        })(t), n.update();
                        break;
                    default:
                        a = o.NONE
                }
            }(t) : function(t) {
                if (!1 !== n.enabled) switch (a) {
                    case o.ROTATE:
                        if (!1 === n.enableRotate) return;
                        ! function(t) {
                            f.set(t.clientX, t.clientY), m.subVectors(f, p).multiplyScalar(n.rotateSpeed);
                            const e = n.domElement;
                            e && (C(2 * Math.PI * m.x / e.clientHeight), R(2 * Math.PI * m.y / e.clientHeight)), p.copy(f), n.update()
                        }(t);
                        break;
                    case o.DOLLY:
                        if (!1 === n.enableZoom) return;
                        ! function(t) {
                            b.set(t.clientX, t.clientY), A.subVectors(b, x), A.y > 0 ? L(E()) : A.y < 0 && O(E()), x.copy(b), n.update()
                        }(t);
                        break;
                    case o.PAN:
                        if (!1 === n.enablePan) return;
                        ! function(t) {
                            v.set(t.clientX, t.clientY), y.subVectors(v, g).multiplyScalar(n.panSpeed), I(y.x, y.y), g.copy(v), n.update()
                        }(t)
                }
            }(t))
        }

        function Y(t) {
            var e, i, s;
            (function(t) {
                delete T[t.pointerId];
                for (let e = 0; e < M.length; e++)
                    if (M[e].pointerId == t.pointerId) return void M.splice(e, 1)
            })(t), 0 === M.length && (null == (e = n.domElement) || e.releasePointerCapture(t.pointerId), null == (i = n.domElement) || i.ownerDocument.removeEventListener("pointermove", K), null == (s = n.domElement) || s.ownerDocument.removeEventListener("pointerup", Y)), n.dispatchEvent(r), a = o.NONE
        }

        function q(t) {
            !1 === n.enabled || !1 === n.enableZoom || a !== o.NONE && a !== o.ROTATE || (t.preventDefault(), n.dispatchEvent(s), function(t) {
                B(t), t.deltaY < 0 ? O(E()) : t.deltaY > 0 && L(E()), n.update()
            }(t), n.dispatchEvent(r))
        }

        function Z(t) {
            !1 === n.enabled || !1 === n.enablePan || function(t) {
                let e = !1;
                switch (t.code) {
                    case n.keys.UP:
                        I(0, n.keyPanSpeed), e = !0;
                        break;
                    case n.keys.BOTTOM:
                        I(0, -n.keyPanSpeed), e = !0;
                        break;
                    case n.keys.LEFT:
                        I(n.keyPanSpeed, 0), e = !0;
                        break;
                    case n.keys.RIGHT:
                        I(-n.keyPanSpeed, 0), e = !0
                }
                e && (t.preventDefault(), n.update())
            }(t)
        }

        function J(t) {
            !1 !== n.enabled && t.preventDefault()
        }

        function $(t) {
            let e = T[t.pointerId];
            void 0 === e && (e = new Q, T[t.pointerId] = e), e.set(t.pageX, t.pageY)
        }

        function tt(t) {
            const e = t.pointerId === M[0].pointerId ? M[1] : M[0];
            return T[e.pointerId]
        }
        void 0 !== e && this.connect(e), this.update()
    }
}

function Ua(t) {
    if (typeof TextDecoder < "u") return (new TextDecoder).decode(t);
    let e = "";
    for (let n = 0, i = t.length; n < i; n++) e += String.fromCharCode(t[n]);
    try {
        return decodeURIComponent(escape(e))
    } catch {
        return e
    }
}
const As = "srgb",
    Pi = "srgb-linear",
    wf = 3001,
    BM = 3e3;
class UM extends is {
    constructor(t) {
        super(t), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register((function(t) {
            return new GM(t)
        })), this.register((function(t) {
            return new HM(t)
        })), this.register((function(t) {
            return new ZM(t)
        })), this.register((function(t) {
            return new JM(t)
        })), this.register((function(t) {
            return new $M(t)
        })), this.register((function(t) {
            return new WM(t)
        })), this.register((function(t) {
            return new XM(t)
        })), this.register((function(t) {
            return new jM(t)
        })), this.register((function(t) {
            return new KM(t)
        })), this.register((function(t) {
            return new zM(t)
        })), this.register((function(t) {
            return new YM(t)
        })), this.register((function(t) {
            return new VM(t)
        })), this.register((function(t) {
            return new qM(t)
        })), this.register((function(t) {
            return new QM(t)
        })), this.register((function(t) {
            return new FM(t)
        })), this.register((function(t) {
            return new eE(t)
        })), this.register((function(t) {
            return new tE(t)
        }))
    }
    load(t, e, n, i) {
        const s = this;
        let r;
        if ("" !== this.resourcePath) r = this.resourcePath;
        else if ("" !== this.path) {
            const e = ao.extractUrlBase(t);
            r = ao.resolveURL(e, this.path)
        } else r = ao.extractUrlBase(t);
        this.manager.itemStart(t);
        const o = function(e) {
                i ? i(e) : console.error(e), s.manager.itemError(t), s.manager.itemEnd(t)
            },
            a = new qa(this.manager);
        a.setPath(this.path), a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(t, (function(n) {
            try {
                s.parse(n, r, (function(n) {
                    e(n), s.manager.itemEnd(t)
                }), o)
            } catch (t) {
                o(t)
            }
        }), n, o)
    }
    setDRACOLoader(t) {
        return this.dracoLoader = t, this
    }
    setDDSLoader() {
        throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
    }
    setKTX2Loader(t) {
        return this.ktx2Loader = t, this
    }
    setMeshoptDecoder(t) {
        return this.meshoptDecoder = t, this
    }
    register(t) {
        return -1 === this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.push(t), this
    }
    unregister(t) {
        return -1 !== this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1), this
    }
    parse(t, e, n, i) {
        let s;
        const r = {},
            o = {};
        if ("string" == typeof t) s = JSON.parse(t);
        else if (t instanceof ArrayBuffer)
            if (Ua(new Uint8Array(t.slice(0, 4))) === em) {
                try {
                    r[et.KHR_BINARY_GLTF] = new nE(t)
                } catch (t) {
                    return void(i && i(t))
                }
                s = JSON.parse(r[et.KHR_BINARY_GLTF].content)
            } else s = JSON.parse(Ua(new Uint8Array(t)));
        else s = t;
        if (void 0 === s.asset || s.asset.version[0] < 2) return void(i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
        const a = new mE(s, {
            path: e || this.resourcePath || "",
            crossOrigin: this.crossOrigin,
            requestHeader: this.requestHeader,
            manager: this.manager,
            ktx2Loader: this.ktx2Loader,
            meshoptDecoder: this.meshoptDecoder
        });
        a.fileLoader.setRequestHeader(this.requestHeader);
        for (let t = 0; t < this.pluginCallbacks.length; t++) {
            const e = this.pluginCallbacks[t](a);
            e.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), o[e.name] = e, r[e.name] = !0
        }
        if (s.extensionsUsed)
            for (let t = 0; t < s.extensionsUsed.length; ++t) {
                const e = s.extensionsUsed[t],
                    n = s.extensionsRequired || [];
                switch (e) {
                    case et.KHR_MATERIALS_UNLIT:
                        r[e] = new kM;
                        break;
                    case et.KHR_DRACO_MESH_COMPRESSION:
                        r[e] = new iE(s, this.dracoLoader);
                        break;
                    case et.KHR_TEXTURE_TRANSFORM:
                        r[e] = new sE;
                        break;
                    case et.KHR_MESH_QUANTIZATION:
                        r[e] = new rE;
                        break;
                    default:
                        n.indexOf(e) >= 0 && void 0 === o[e] && console.warn('THREE.GLTFLoader: Unknown extension "' + e + '".')
                }
            }
        a.setExtensions(r), a.setPlugins(o), a.parse(n, i)
    }
    parseAsync(t, e) {
        const n = this;
        return new Promise((function(i, s) {
            n.parse(t, e, i, s)
        }))
    }
}

function NM() {
    let t = {};
    return {
        get: function(e) {
            return t[e]
        },
        add: function(e, n) {
            t[e] = n
        },
        remove: function(e) {
            delete t[e]
        },
        removeAll: function() {
            t = {}
        }
    }
}
const et = {
    KHR_BINARY_GLTF: "KHR_binary_glTF",
    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
    KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
    KHR_MATERIALS_IOR: "KHR_materials_ior",
    KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
    KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
    KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
    KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
    KHR_MATERIALS_VOLUME: "KHR_materials_volume",
    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
    KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
    EXT_MATERIALS_BUMP: "EXT_materials_bump",
    EXT_TEXTURE_WEBP: "EXT_texture_webp",
    EXT_TEXTURE_AVIF: "EXT_texture_avif",
    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
    EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
class FM {
    constructor(t) {
        this.parser = t, this.name = et.KHR_LIGHTS_PUNCTUAL, this.cache = {
            refs: {},
            uses: {}
        }
    }
    _markDefs() {
        const t = this.parser,
            e = this.parser.json.nodes || [];
        for (let n = 0, i = e.length; n < i; n++) {
            const i = e[n];
            i.extensions && i.extensions[this.name] && void 0 !== i.extensions[this.name].light && t._addNodeRef(this.cache, i.extensions[this.name].light)
        }
    }
    _loadLight(t) {
        const e = this.parser,
            n = "light:" + t;
        let i = e.cache.get(n);
        if (i) return i;
        const s = e.json,
            r = ((s.extensions && s.extensions[this.name] || {}).lights || [])[t];
        let o;
        const a = new Le(16777215);
        void 0 !== r.color && a.setRGB(r.color[0], r.color[1], r.color[2], Pi);
        const l = void 0 !== r.range ? r.range : 0;
        switch (r.type) {
            case "directional":
                o = new l_(a), o.target.position.set(0, 0, -1), o.add(o.target);
                break;
            case "point":
                o = new Xp(a), o.distance = l;
                break;
            case "spot":
                o = new Wp(a), o.distance = l, r.spot = r.spot || {}, r.spot.innerConeAngle = void 0 !== r.spot.innerConeAngle ? r.spot.innerConeAngle : 0, r.spot.outerConeAngle = void 0 !== r.spot.outerConeAngle ? r.spot.outerConeAngle : Math.PI / 4, o.angle = r.spot.outerConeAngle, o.penumbra = 1 - r.spot.innerConeAngle / r.spot.outerConeAngle, o.target.position.set(0, 0, -1), o.add(o.target);
                break;
            default:
                throw new Error("THREE.GLTFLoader: Unexpected light type: " + r.type)
        }
        return o.position.set(0, 0, 0), o.decay = 2, Mi(o, r), void 0 !== r.intensity && (o.intensity = r.intensity), o.name = e.createUniqueName(r.name || "light_" + t), i = Promise.resolve(o), e.cache.add(n, i), i
    }
    getDependency(t, e) {
        if ("light" === t) return this._loadLight(e)
    }
    createNodeAttachment(t) {
        const e = this,
            n = this.parser,
            i = n.json.nodes[t],
            s = (i.extensions && i.extensions[this.name] || {}).light;
        return void 0 === s ? null : this._loadLight(s).then((function(t) {
            return n._getNodeRef(e.cache, s, t)
        }))
    }
}
class kM {
    constructor() {
        this.name = et.KHR_MATERIALS_UNLIT
    }
    getMaterialType() {
        return At
    }
    extendParams(t, e, n) {
        const i = [];
        t.color = new Le(1, 1, 1), t.opacity = 1;
        const s = e.pbrMetallicRoughness;
        if (s) {
            if (Array.isArray(s.baseColorFactor)) {
                const e = s.baseColorFactor;
                t.color.setRGB(e[0], e[1], e[2], Pi), t.opacity = e[3]
            }
            void 0 !== s.baseColorTexture && i.push(n.assignTexture(t, "map", s.baseColorTexture, As))
        }
        return Promise.all(i)
    }
}
class zM {
    constructor(t) {
        this.parser = t, this.name = et.KHR_MATERIALS_EMISSIVE_STRENGTH
    }
    extendMaterialParams(t, e) {
        const n = this.parser.json.materials[t];
        if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
        const i = n.extensions[this.name].emissiveStrength;
        return void 0 !== i && (e.emissiveIntensity = i), Promise.resolve()
    }
}
class GM {
    constructor(t) {
        this.parser = t, this.name = et.KHR_MATERIALS_CLEARCOAT
    }
    getMaterialType(t) {
        const e = this.parser.json.materials[t];
        return e.extensions && e.extensions[this.name] ? di : null
    }
    extendMaterialParams(t, e) {
        const n = this.parser,
            i = n.json.materials[t];
        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
        const s = [],
            r = i.extensions[this.name];
        if (void 0 !== r.clearcoatFactor && (e.clearcoat = r.clearcoatFactor), void 0 !== r.clearcoatTexture && s.push(n.assignTexture(e, "clearcoatMap", r.clearcoatTexture)), void 0 !== r.clearcoatRoughnessFactor && (e.clearcoatRoughness = r.clearcoatRoughnessFactor), void 0 !== r.clearcoatRoughnessTexture && s.push(n.assignTexture(e, "clearcoatRoughnessMap", r.clearcoatRoughnessTexture)), void 0 !== r.clearcoatNormalTexture && (s.push(n.assignTexture(e, "clearcoatNormalMap", r.clearcoatNormalTexture)), void 0 !== r.clearcoatNormalTexture.scale)) {
            const t = r.clearcoatNormalTexture.scale;
            e.clearcoatNormalScale = new Q(t, t)
        }
        return Promise.all(s)
    }
}
class HM {
    constructor(t) {
        this.parser = t, this.name = et.KHR_MATERIALS_DISPERSION
    }
    getMaterialType(t) {
        const e = this.parser.json.materials[t];
        return e.extensions && e.extensions[this.name] ? di : null
    }
    extendMaterialParams(t, e) {
        const n = this.parser.json.materials[t];
        if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
        const i = n.extensions[this.name];
        return e.dispersion = void 0 !== i.dispersion ? i.dispersion : 0, Promise.resolve()
    }
}
class VM {
    constructor(t) {
        this.parser = t, this.name = et.KHR_MATERIALS_IRIDESCENCE
    }
    getMaterialType(t) {
        const e = this.parser.json.materials[t];
        return e.extensions && e.extensions[this.name] ? di : null
    }
    extendMaterialParams(t, e) {
        const n = this.parser,
            i = n.json.materials[t];
        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
        const s = [],
            r = i.extensions[this.name];
        return void 0 !== r.iridescenceFactor && (e.iridescence = r.iridescenceFactor), void 0 !== r.iridescenceTexture && s.push(n.assignTexture(e, "iridescenceMap", r.iridescenceTexture)), void 0 !== r.iridescenceIor && (e.iridescenceIOR = r.iridescenceIor), void 0 === e.iridescenceThicknessRange && (e.iridescenceThicknessRange = [100, 400]), void 0 !== r.iridescenceThicknessMinimum && (e.iridescenceThicknessRange[0] = r.iridescenceThicknessMinimum), void 0 !== r.iridescenceThicknessMaximum && (e.iridescenceThicknessRange[1] = r.iridescenceThicknessMaximum), void 0 !== r.iridescenceThicknessTexture && s.push(n.assignTexture(e, "iridescenceThicknessMap", r.iridescenceThicknessTexture)), Promise.all(s)
    }
}
class WM {
    constructor(t) {
        this.parser = t, this.name = et.KHR_MATERIALS_SHEEN
    }
    getMaterialType(t) {
        const e = this.parser.json.materials[t];
        return e.extensions && e.extensions[this.name] ? di : null
    }
    extendMaterialParams(t, e) {
        const n = this.parser,
            i = n.json.materials[t];
        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
        const s = [];
        e.sheenColor = new Le(0, 0, 0), e.sheenRoughness = 0, e.sheen = 1;
        const r = i.extensions[this.name];
        if (void 0 !== r.sheenColorFactor) {
            const t = r.sheenColorFactor;
            e.sheenColor.setRGB(t[0], t[1], t[2], Pi)
        }
        return void 0 !== r.sheenRoughnessFactor && (e.sheenRoughness = r.sheenRoughnessFactor), void 0 !== r.sheenColorTexture && s.push(n.assignTexture(e, "sheenColorMap", r.sheenColorTexture, As)), void 0 !== r.sheenRoughnessTexture && s.push(n.assignTexture(e, "sheenRoughnessMap", r.sheenRoughnessTexture)), Promise.all(s)
    }
}
class XM {
    constructor(t) {
        this.parser = t, this.name = et.KHR_MATERIALS_TRANSMISSION
    }
    getMaterialType(t) {
        const e = this.parser.json.materials[t];
        return e.extensions && e.extensions[this.name] ? di : null
    }
    extendMaterialParams(t, e) {
        const n = this.parser,
            i = n.json.materials[t];
        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
        const s = [],
            r = i.extensions[this.name];
        return void 0 !== r.transmissionFactor && (e.transmission = r.transmissionFactor), void 0 !== r.transmissionTexture && s.push(n.assignTexture(e, "transmissionMap", r.transmissionTexture)), Promise.all(s)
    }
}
class jM {
    constructor(t) {
        this.parser = t, this.name = et.KHR_MATERIALS_VOLUME
    }
    getMaterialType(t) {
        const e = this.parser.json.materials[t];
        return e.extensions && e.extensions[this.name] ? di : null
    }
    extendMaterialParams(t, e) {
        const n = this.parser,
            i = n.json.materials[t];
        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
        const s = [],
            r = i.extensions[this.name];
        e.thickness = void 0 !== r.thicknessFactor ? r.thicknessFactor : 0, void 0 !== r.thicknessTexture && s.push(n.assignTexture(e, "thicknessMap", r.thicknessTexture)), e.attenuationDistance = r.attenuationDistance || 1 / 0;
        const o = r.attenuationColor || [1, 1, 1];
        return e.attenuationColor = (new Le).setRGB(o[0], o[1], o[2], Pi), Promise.all(s)
    }
}
class KM {
    constructor(t) {
        this.parser = t, this.name = et.KHR_MATERIALS_IOR
    }
    getMaterialType(t) {
        const e = this.parser.json.materials[t];
        return e.extensions && e.extensions[this.name] ? di : null
    }
    extendMaterialParams(t, e) {
        const n = this.parser.json.materials[t];
        if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
        const i = n.extensions[this.name];
        return e.ior = void 0 !== i.ior ? i.ior : 1.5, Promise.resolve()
    }
}
class YM {
    constructor(t) {
        this.parser = t, this.name = et.KHR_MATERIALS_SPECULAR
    }
    getMaterialType(t) {
        const e = this.parser.json.materials[t];
        return e.extensions && e.extensions[this.name] ? di : null
    }
    extendMaterialParams(t, e) {
        const n = this.parser,
            i = n.json.materials[t];
        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
        const s = [],
            r = i.extensions[this.name];
        e.specularIntensity = void 0 !== r.specularFactor ? r.specularFactor : 1, void 0 !== r.specularTexture && s.push(n.assignTexture(e, "specularIntensityMap", r.specularTexture));
        const o = r.specularColorFactor || [1, 1, 1];
        return e.specularColor = (new Le).setRGB(o[0], o[1], o[2], Pi), void 0 !== r.specularColorTexture && s.push(n.assignTexture(e, "specularColorMap", r.specularColorTexture, As)), Promise.all(s)
    }
}
class QM {
    constructor(t) {
        this.parser = t, this.name = et.EXT_MATERIALS_BUMP
    }
    getMaterialType(t) {
        const e = this.parser.json.materials[t];
        return e.extensions && e.extensions[this.name] ? di : null
    }
    extendMaterialParams(t, e) {
        const n = this.parser,
            i = n.json.materials[t];
        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
        const s = [],
            r = i.extensions[this.name];
        return e.bumpScale = void 0 !== r.bumpFactor ? r.bumpFactor : 1, void 0 !== r.bumpTexture && s.push(n.assignTexture(e, "bumpMap", r.bumpTexture)), Promise.all(s)
    }
}
class qM {
    constructor(t) {
        this.parser = t, this.name = et.KHR_MATERIALS_ANISOTROPY
    }
    getMaterialType(t) {
        const e = this.parser.json.materials[t];
        return e.extensions && e.extensions[this.name] ? di : null
    }
    extendMaterialParams(t, e) {
        const n = this.parser,
            i = n.json.materials[t];
        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
        const s = [],
            r = i.extensions[this.name];
        return void 0 !== r.anisotropyStrength && (e.anisotropy = r.anisotropyStrength), void 0 !== r.anisotropyRotation && (e.anisotropyRotation = r.anisotropyRotation), void 0 !== r.anisotropyTexture && s.push(n.assignTexture(e, "anisotropyMap", r.anisotropyTexture)), Promise.all(s)
    }
}
class ZM {
    constructor(t) {
        this.parser = t, this.name = et.KHR_TEXTURE_BASISU
    }
    loadTexture(t) {
        const e = this.parser,
            n = e.json,
            i = n.textures[t];
        if (!i.extensions || !i.extensions[this.name]) return null;
        const s = i.extensions[this.name],
            r = e.options.ktx2Loader;
        if (!r) {
            if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
            return null
        }
        return e.loadTextureImage(t, s.source, r)
    }
}
class JM {
    constructor(t) {
        this.parser = t, this.name = et.EXT_TEXTURE_WEBP, this.isSupported = null
    }
    loadTexture(t) {
        const e = this.name,
            n = this.parser,
            i = n.json,
            s = i.textures[t];
        if (!s.extensions || !s.extensions[e]) return null;
        const r = s.extensions[e],
            o = i.images[r.source];
        let a = n.textureLoader;
        if (o.uri) {
            const t = n.options.manager.getHandler(o.uri);
            null !== t && (a = t)
        }
        return this.detectSupport().then((function(s) {
            if (s) return n.loadTextureImage(t, r.source, a);
            if (i.extensionsRequired && i.extensionsRequired.indexOf(e) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
            return n.loadTexture(t)
        }))
    }
    detectSupport() {
        return this.isSupported || (this.isSupported = new Promise((function(t) {
            const e = new Image;
            e.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", e.onload = e.onerror = function() {
                t(1 === e.height)
            }
        }))), this.isSupported
    }
}
class $M {
    constructor(t) {
        this.parser = t, this.name = et.EXT_TEXTURE_AVIF, this.isSupported = null
    }
    loadTexture(t) {
        const e = this.name,
            n = this.parser,
            i = n.json,
            s = i.textures[t];
        if (!s.extensions || !s.extensions[e]) return null;
        const r = s.extensions[e],
            o = i.images[r.source];
        let a = n.textureLoader;
        if (o.uri) {
            const t = n.options.manager.getHandler(o.uri);
            null !== t && (a = t)
        }
        return this.detectSupport().then((function(s) {
            if (s) return n.loadTextureImage(t, r.source, a);
            if (i.extensionsRequired && i.extensionsRequired.indexOf(e) >= 0) throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
            return n.loadTexture(t)
        }))
    }
    detectSupport() {
        return this.isSupported || (this.isSupported = new Promise((function(t) {
            const e = new Image;
            e.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", e.onload = e.onerror = function() {
                t(1 === e.height)
            }
        }))), this.isSupported
    }
}
class eE {
    constructor(t) {
        this.name = et.EXT_MESHOPT_COMPRESSION, this.parser = t
    }
    loadBufferView(t) {
        const e = this.parser.json,
            n = e.bufferViews[t];
        if (n.extensions && n.extensions[this.name]) {
            const t = n.extensions[this.name],
                i = this.parser.getDependency("buffer", t.buffer),
                s = this.parser.options.meshoptDecoder;
            if (!s || !s.supported) {
                if (e.extensionsRequired && e.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                return null
            }
            return i.then((function(e) {
                const n = t.byteOffset || 0,
                    i = t.byteLength || 0,
                    r = t.count,
                    o = t.byteStride,
                    a = new Uint8Array(e, n, i);
                return s.decodeGltfBufferAsync ? s.decodeGltfBufferAsync(r, o, a, t.mode, t.filter).then((function(t) {
                    return t.buffer
                })) : s.ready.then((function() {
                    const e = new ArrayBuffer(r * o);
                    return s.decodeGltfBuffer(new Uint8Array(e), r, o, a, t.mode, t.filter), e
                }))
            }))
        }
        return null
    }
}
class tE {
    constructor(t) {
        this.name = et.EXT_MESH_GPU_INSTANCING, this.parser = t
    }
    createNodeMesh(t) {
        const e = this.parser.json,
            n = e.nodes[t];
        if (!n.extensions || !n.extensions[this.name] || void 0 === n.mesh) return null;
        const i = e.meshes[n.mesh];
        for (const t of i.primitives)
            if (t.mode !== Ln.TRIANGLES && t.mode !== Ln.TRIANGLE_STRIP && t.mode !== Ln.TRIANGLE_FAN && void 0 !== t.mode) return null;
        const s = n.extensions[this.name].attributes,
            r = [],
            o = {};
        for (const t in s) r.push(this.parser.getDependency("accessor", s[t]).then((e => (o[t] = e, o[t]))));
        return r.length < 1 ? null : (r.push(this.parser.createNodeMesh(t)), Promise.all(r).then((t => {
            const e = t.pop(),
                n = e.isGroup ? e.children : [e],
                i = t[0].count,
                s = [];
            for (const t of n) {
                const e = new Xe,
                    n = new U,
                    r = new bt,
                    a = new U(1, 1, 1),
                    l = new Rp(t.geometry, t.material, i);
                for (let t = 0; t < i; t++) o.TRANSLATION && n.fromBufferAttribute(o.TRANSLATION, t), o.ROTATION && r.fromBufferAttribute(o.ROTATION, t), o.SCALE && a.fromBufferAttribute(o.SCALE, t), l.setMatrixAt(t, e.compose(n, r, a));
                for (const e in o)
                    if ("_COLOR_0" === e) {
                        const t = o[e];
                        l.instanceColor = new Uc(t.array, t.itemSize, t.normalized)
                    } else "TRANSLATION" !== e && "ROTATION" !== e && "SCALE" !== e && t.geometry.setAttribute(e, o[e]);
                ct.prototype.copy.call(l, t), this.parser.assignFinalMaterial(l), s.push(l)
            }
            return e.isGroup ? (e.clear(), e.add(...s), e) : s[0]
        })))
    }
}
const em = "glTF",
    $r = 12,
    Mf = {
        JSON: 1313821514,
        BIN: 5130562
    };
class nE {
    constructor(t) {
        this.name = et.KHR_BINARY_GLTF, this.content = null, this.body = null;
        const e = new DataView(t, 0, 12);
        if (this.header = {
                magic: Ua(new Uint8Array(t.slice(0, 4))),
                version: e.getUint32(4, !0),
                length: e.getUint32(8, !0)
            }, this.header.magic !== em) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
        if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
        const n = this.header.length - 12,
            i = new DataView(t, 12);
        let s = 0;
        for (; s < n;) {
            const e = i.getUint32(s, !0);
            s += 4;
            const n = i.getUint32(s, !0);
            if (s += 4, n === Mf.JSON) {
                const n = new Uint8Array(t, 12 + s, e);
                this.content = Ua(n)
            } else if (n === Mf.BIN) {
                const n = 12 + s;
                this.body = t.slice(n, n + e)
            }
            s += e
        }
        if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.")
    }
}
class iE {
    constructor(t, e) {
        if (!e) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
        this.name = et.KHR_DRACO_MESH_COMPRESSION, this.json = t, this.dracoLoader = e, this.dracoLoader.preload()
    }
    decodePrimitive(t, e) {
        const n = this.json,
            i = this.dracoLoader,
            s = t.extensions[this.name].bufferView,
            r = t.extensions[this.name].attributes,
            o = {},
            a = {},
            l = {};
        for (const t in r) {
            const e = jc[t] || t.toLowerCase();
            o[e] = r[t]
        }
        for (const e in t.attributes) {
            const i = jc[e] || e.toLowerCase();
            if (void 0 !== r[e]) {
                const s = n.accessors[t.attributes[e]],
                    r = pr[s.componentType];
                l[i] = r.name, a[i] = !0 === s.normalized
            }
        }
        return e.getDependency("bufferView", s).then((function(t) {
            return new Promise((function(e, n) {
                i.decodeDracoFile(t, (function(t) {
                    for (const e in t.attributes) {
                        const n = t.attributes[e],
                            i = a[e];
                        void 0 !== i && (n.normalized = i)
                    }
                    e(t)
                }), o, l, Pi, n)
            }))
        }))
    }
}
class sE {
    constructor() {
        this.name = et.KHR_TEXTURE_TRANSFORM
    }
    extendTexture(t, e) {
        return (void 0 === e.texCoord || e.texCoord === t.channel) && void 0 === e.offset && void 0 === e.rotation && void 0 === e.scale || (t = t.clone(), void 0 !== e.texCoord && (t.channel = e.texCoord), void 0 !== e.offset && t.offset.fromArray(e.offset), void 0 !== e.rotation && (t.rotation = e.rotation), void 0 !== e.scale && t.repeat.fromArray(e.scale), t.needsUpdate = !0), t
    }
}
class rE {
    constructor() {
        this.name = et.KHR_MESH_QUANTIZATION
    }
}
class tm extends _o {
    constructor(t, e, n, i) {
        super(t, e, n, i)
    }
    copySampleValue_(t) {
        const e = this.resultBuffer,
            n = this.sampleValues,
            i = this.valueSize,
            s = t * i * 3 + i;
        for (let t = 0; t !== i; t++) e[t] = n[s + t];
        return e
    }
    interpolate_(t, e, n, i) {
        const s = this.resultBuffer,
            r = this.sampleValues,
            o = this.valueSize,
            a = 2 * o,
            l = 3 * o,
            c = i - e,
            h = (n - e) / c,
            u = h * h,
            d = u * h,
            p = t * l,
            f = p - l,
            m = -2 * d + 3 * u,
            g = d - u,
            v = 1 - m,
            y = g - u + h;
        for (let t = 0; t !== o; t++) {
            const e = r[f + t + o],
                n = r[f + t + a] * c,
                i = r[p + t + o],
                l = r[p + t] * c;
            s[t] = v * e + y * n + m * i + g * l
        }
        return s
    }
}
const oE = new bt;
class aE extends tm {
    interpolate_(t, e, n, i) {
        const s = super.interpolate_(t, e, n, i);
        return oE.fromArray(s).normalize().toArray(s), s
    }
}
const Ln = {
        FLOAT: 5126,
        FLOAT_MAT3: 35675,
        FLOAT_MAT4: 35676,
        FLOAT_VEC2: 35664,
        FLOAT_VEC3: 35665,
        FLOAT_VEC4: 35666,
        LINEAR: 9729,
        REPEAT: 10497,
        SAMPLER_2D: 35678,
        POINTS: 0,
        LINES: 1,
        LINE_LOOP: 2,
        LINE_STRIP: 3,
        TRIANGLES: 4,
        TRIANGLE_STRIP: 5,
        TRIANGLE_FAN: 6,
        UNSIGNED_BYTE: 5121,
        UNSIGNED_SHORT: 5123
    },
    pr = {
        5120: Int8Array,
        5121: Uint8Array,
        5122: Int16Array,
        5123: Uint16Array,
        5125: Uint32Array,
        5126: Float32Array
    },
    Ef = {
        9728: Vt,
        9729: Ht,
        9984: tp,
        9985: wa,
        9986: to,
        9987: Ei
    },
    Tf = {
        33071: Yi,
        33648: Ca,
        10497: $i
    },
    hc = {
        SCALAR: 1,
        VEC2: 2,
        VEC3: 3,
        VEC4: 4,
        MAT2: 4,
        MAT3: 9,
        MAT4: 16
    },
    jc = {
        POSITION: "position",
        NORMAL: "normal",
        TANGENT: "tangent",
        ...Jp >= 152 ? {
            TEXCOORD_0: "uv",
            TEXCOORD_1: "uv1",
            TEXCOORD_2: "uv2",
            TEXCOORD_3: "uv3"
        } : {
            TEXCOORD_0: "uv",
            TEXCOORD_1: "uv2"
        },
        COLOR_0: "color",
        WEIGHTS_0: "skinWeight",
        JOINTS_0: "skinIndex"
    },
    Xi = {
        scale: "scale",
        translation: "position",
        rotation: "quaternion",
        weights: "morphTargetInfluences"
    },
    lE = {
        CUBICSPLINE: void 0,
        LINEAR: _r,
        STEP: fo
    },
    uc = {
        OPAQUE: "OPAQUE",
        MASK: "MASK",
        BLEND: "BLEND"
    };

function cE(t) {
    return void 0 === t.DefaultMaterial && (t.DefaultMaterial = new wh({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: li
    })), t.DefaultMaterial
}

function fs(t, e, n) {
    for (const i in n.extensions) void 0 === t[i] && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[i] = n.extensions[i])
}

function Mi(t, e) {
    void 0 !== e.extras && ("object" == typeof e.extras ? Object.assign(t.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras))
}

function hE(t, e, n) {
    let i = !1,
        s = !1,
        r = !1;
    for (let t = 0, n = e.length; t < n; t++) {
        const n = e[t];
        if (void 0 !== n.POSITION && (i = !0), void 0 !== n.NORMAL && (s = !0), void 0 !== n.COLOR_0 && (r = !0), i && s && r) break
    }
    if (!i && !s && !r) return Promise.resolve(t);
    const o = [],
        a = [],
        l = [];
    for (let c = 0, h = e.length; c < h; c++) {
        const h = e[c];
        if (i) {
            const e = void 0 !== h.POSITION ? n.getDependency("accessor", h.POSITION) : t.attributes.position;
            o.push(e)
        }
        if (s) {
            const e = void 0 !== h.NORMAL ? n.getDependency("accessor", h.NORMAL) : t.attributes.normal;
            a.push(e)
        }
        if (r) {
            const e = void 0 !== h.COLOR_0 ? n.getDependency("accessor", h.COLOR_0) : t.attributes.color;
            l.push(e)
        }
    }
    return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l)]).then((function(e) {
        const n = e[0],
            o = e[1],
            a = e[2];
        return i && (t.morphAttributes.position = n), s && (t.morphAttributes.normal = o), r && (t.morphAttributes.color = a), t.morphTargetsRelative = !0, t
    }))
}

function uE(t, e) {
    if (t.updateMorphTargets(), void 0 !== e.weights)
        for (let n = 0, i = e.weights.length; n < i; n++) t.morphTargetInfluences[n] = e.weights[n];
    if (e.extras && Array.isArray(e.extras.targetNames)) {
        const n = e.extras.targetNames;
        if (t.morphTargetInfluences.length === n.length) {
            t.morphTargetDictionary = {};
            for (let e = 0, i = n.length; e < i; e++) t.morphTargetDictionary[n[e]] = e
        } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
    }
}

function dE(t) {
    let e;
    const n = t.extensions && t.extensions[et.KHR_DRACO_MESH_COMPRESSION];
    if (e = n ? "draco:" + n.bufferView + ":" + n.indices + ":" + dc(n.attributes) : t.indices + ":" + dc(t.attributes) + ":" + t.mode, void 0 !== t.targets)
        for (let n = 0, i = t.targets.length; n < i; n++) e += ":" + dc(t.targets[n]);
    return e
}

function dc(t) {
    let e = "";
    const n = Object.keys(t).sort();
    for (let i = 0, s = n.length; i < s; i++) e += n[i] + ":" + t[n[i]] + ";";
    return e
}

function Kc(t) {
    switch (t) {
        case Int8Array:
            return 1 / 127;
        case Uint8Array:
            return 1 / 255;
        case Int16Array:
            return 1 / 32767;
        case Uint16Array:
            return 1 / 65535;
        default:
            throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
    }
}

function fE(t) {
    return t.search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/) ? "image/jpeg" : t.search(/\.webp($|\?)/i) > 0 || 0 === t.search(/^data\:image\/webp/) ? "image/webp" : "image/png"
}
const pE = new Xe;
class mE {
    constructor(t = {}, e = {}) {
        this.json = t, this.extensions = {}, this.plugins = {}, this.options = e, this.cache = new NM, this.associations = new Map, this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = {
            refs: {},
            uses: {}
        }, this.cameraCache = {
            refs: {},
            uses: {}
        }, this.lightCache = {
            refs: {},
            uses: {}
        }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
        let n = !1,
            i = !1,
            s = -1;
        typeof navigator < "u" && typeof navigator.userAgent < "u" && (n = !0 === /^((?!chrome|android).)*safari/i.test(navigator.userAgent), i = navigator.userAgent.indexOf("Firefox") > -1, s = i ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), typeof createImageBitmap > "u" || n || i && s < 98 ? this.textureLoader = new Vp(this.options.manager) : this.textureLoader = new jp(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new qa(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
    }
    setExtensions(t) {
        this.extensions = t
    }
    setPlugins(t) {
        this.plugins = t
    }
    parse(t, e) {
        const n = this,
            i = this.json,
            s = this.extensions;
        this.cache.removeAll(), this.nodeCache = {}, this._invokeAll((function(t) {
            return t._markDefs && t._markDefs()
        })), Promise.all(this._invokeAll((function(t) {
            return t.beforeRoot && t.beforeRoot()
        }))).then((function() {
            return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")])
        })).then((function(e) {
            const r = {
                scene: e[0][i.scene || 0],
                scenes: e[0],
                animations: e[1],
                cameras: e[2],
                asset: i.asset,
                parser: n,
                userData: {}
            };
            return fs(s, r, i), Mi(r, i), Promise.all(n._invokeAll((function(t) {
                return t.afterRoot && t.afterRoot(r)
            }))).then((function() {
                for (const t of r.scenes) t.updateMatrixWorld();
                t(r)
            }))
        })).catch(e)
    }
    _markDefs() {
        const t = this.json.nodes || [],
            e = this.json.skins || [],
            n = this.json.meshes || [];
        for (let n = 0, i = e.length; n < i; n++) {
            const i = e[n].joints;
            for (let e = 0, n = i.length; e < n; e++) t[i[e]].isBone = !0
        }
        for (let e = 0, i = t.length; e < i; e++) {
            const i = t[e];
            void 0 !== i.mesh && (this._addNodeRef(this.meshCache, i.mesh), void 0 !== i.skin && (n[i.mesh].isSkinnedMesh = !0)), void 0 !== i.camera && this._addNodeRef(this.cameraCache, i.camera)
        }
    }
    _addNodeRef(t, e) {
        void 0 !== e && (void 0 === t.refs[e] && (t.refs[e] = t.uses[e] = 0), t.refs[e]++)
    }
    _getNodeRef(t, e, n) {
        if (t.refs[e] <= 1) return n;
        const i = n.clone(),
            s = (t, e) => {
                const n = this.associations.get(t);
                null != n && this.associations.set(e, n);
                for (const [n, i] of t.children.entries()) s(i, e.children[n])
            };
        return s(n, i), i.name += "_instance_" + t.uses[e]++, i
    }
    _invokeOne(t) {
        const e = Object.values(this.plugins);
        e.push(this);
        for (let n = 0; n < e.length; n++) {
            const i = t(e[n]);
            if (i) return i
        }
        return null
    }
    _invokeAll(t) {
        const e = Object.values(this.plugins);
        e.unshift(this);
        const n = [];
        for (let i = 0; i < e.length; i++) {
            const s = t(e[i]);
            s && n.push(s)
        }
        return n
    }
    getDependency(t, e) {
        const n = t + ":" + e;
        let i = this.cache.get(n);
        if (!i) {
            switch (t) {
                case "scene":
                    i = this.loadScene(e);
                    break;
                case "node":
                    i = this._invokeOne((function(t) {
                        return t.loadNode && t.loadNode(e)
                    }));
                    break;
                case "mesh":
                    i = this._invokeOne((function(t) {
                        return t.loadMesh && t.loadMesh(e)
                    }));
                    break;
                case "accessor":
                    i = this.loadAccessor(e);
                    break;
                case "bufferView":
                    i = this._invokeOne((function(t) {
                        return t.loadBufferView && t.loadBufferView(e)
                    }));
                    break;
                case "buffer":
                    i = this.loadBuffer(e);
                    break;
                case "material":
                    i = this._invokeOne((function(t) {
                        return t.loadMaterial && t.loadMaterial(e)
                    }));
                    break;
                case "texture":
                    i = this._invokeOne((function(t) {
                        return t.loadTexture && t.loadTexture(e)
                    }));
                    break;
                case "skin":
                    i = this.loadSkin(e);
                    break;
                case "animation":
                    i = this._invokeOne((function(t) {
                        return t.loadAnimation && t.loadAnimation(e)
                    }));
                    break;
                case "camera":
                    i = this.loadCamera(e);
                    break;
                default:
                    if (i = this._invokeOne((function(n) {
                            return n != this && n.getDependency && n.getDependency(t, e)
                        })), !i) throw new Error("Unknown type: " + t)
            }
            this.cache.add(n, i)
        }
        return i
    }
    getDependencies(t) {
        let e = this.cache.get(t);
        if (!e) {
            const n = this,
                i = this.json[t + ("mesh" === t ? "es" : "s")] || [];
            e = Promise.all(i.map((function(e, i) {
                return n.getDependency(t, i)
            }))), this.cache.add(t, e)
        }
        return e
    }
    loadBuffer(t) {
        const e = this.json.buffers[t],
            n = this.fileLoader;
        if (e.type && "arraybuffer" !== e.type) throw new Error("THREE.GLTFLoader: " + e.type + " buffer type is not supported.");
        if (void 0 === e.uri && 0 === t) return Promise.resolve(this.extensions[et.KHR_BINARY_GLTF].body);
        const i = this.options;
        return new Promise((function(t, s) {
            n.load(ao.resolveURL(e.uri, i.path), t, void 0, (function() {
                s(new Error('THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".'))
            }))
        }))
    }
    loadBufferView(t) {
        const e = this.json.bufferViews[t];
        return this.getDependency("buffer", e.buffer).then((function(t) {
            const n = e.byteLength || 0,
                i = e.byteOffset || 0;
            return t.slice(i, i + n)
        }))
    }
    loadAccessor(t) {
        const e = this,
            n = this.json,
            i = this.json.accessors[t];
        if (void 0 === i.bufferView && void 0 === i.sparse) {
            const t = hc[i.type],
                e = pr[i.componentType],
                n = !0 === i.normalized,
                s = new e(i.count * t);
            return Promise.resolve(new Xt(s, t, n))
        }
        const s = [];
        return void 0 !== i.bufferView ? s.push(this.getDependency("bufferView", i.bufferView)) : s.push(null), void 0 !== i.sparse && (s.push(this.getDependency("bufferView", i.sparse.indices.bufferView)), s.push(this.getDependency("bufferView", i.sparse.values.bufferView))), Promise.all(s).then((function(t) {
            const s = t[0],
                r = hc[i.type],
                o = pr[i.componentType],
                a = o.BYTES_PER_ELEMENT,
                l = a * r,
                c = i.byteOffset || 0,
                h = void 0 !== i.bufferView ? n.bufferViews[i.bufferView].byteStride : void 0,
                u = !0 === i.normalized;
            let d, p;
            if (h && h !== l) {
                const t = Math.floor(c / h),
                    n = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + t + ":" + i.count;
                let l = e.cache.get(n);
                l || (d = new o(s, t * h, i.count * h / a), l = new gh(d, h / a), e.cache.add(n, l)), p = new Qn(l, r, c % h / a, u)
            } else d = null === s ? new o(i.count * r) : new o(s, c, i.count * r), p = new Xt(d, r, u);
            if (void 0 !== i.sparse) {
                const e = hc.SCALAR,
                    n = pr[i.sparse.indices.componentType],
                    a = i.sparse.indices.byteOffset || 0,
                    l = i.sparse.values.byteOffset || 0,
                    c = new n(t[1], a, i.sparse.count * e),
                    h = new o(t[2], l, i.sparse.count * r);
                null !== s && (p = new Xt(p.array.slice(), p.itemSize, p.normalized));
                for (let t = 0, e = c.length; t < e; t++) {
                    const e = c[t];
                    if (p.setX(e, h[t * r]), r >= 2 && p.setY(e, h[t * r + 1]), r >= 3 && p.setZ(e, h[t * r + 2]), r >= 4 && p.setW(e, h[t * r + 3]), r >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                }
            }
            return p
        }))
    }
    loadTexture(t) {
        const e = this.json,
            n = this.options,
            i = e.textures[t].source,
            s = e.images[i];
        let r = this.textureLoader;
        if (s.uri) {
            const t = n.manager.getHandler(s.uri);
            null !== t && (r = t)
        }
        return this.loadTextureImage(t, i, r)
    }
    loadTextureImage(t, e, n) {
        const i = this,
            s = this.json,
            r = s.textures[t],
            o = s.images[e],
            a = (o.uri || o.bufferView) + ":" + r.sampler;
        if (this.textureCache[a]) return this.textureCache[a];
        const l = this.loadImageSource(e, n).then((function(e) {
            e.flipY = !1, e.name = r.name || o.name || "", "" === e.name && "string" == typeof o.uri && !1 === o.uri.startsWith("data:image/") && (e.name = o.uri);
            const n = (s.samplers || {})[r.sampler] || {};
            return e.magFilter = Ef[n.magFilter] || Ht, e.minFilter = Ef[n.minFilter] || Ei, e.wrapS = Tf[n.wrapS] || $i, e.wrapT = Tf[n.wrapT] || $i, i.associations.set(e, {
                textures: t
            }), e
        })).catch((function() {
            return null
        }));
        return this.textureCache[a] = l, l
    }
    loadImageSource(t, e) {
        const n = this.json,
            i = this.options;
        if (void 0 !== this.sourceCache[t]) return this.sourceCache[t].then((t => t.clone()));
        const s = n.images[t],
            r = self.URL || self.webkitURL;
        let o = s.uri || "",
            a = !1;
        if (void 0 !== s.bufferView) o = this.getDependency("bufferView", s.bufferView).then((function(t) {
            a = !0;
            const e = new Blob([t], {
                type: s.mimeType
            });
            return o = r.createObjectURL(e), o
        }));
        else if (void 0 === s.uri) throw new Error("THREE.GLTFLoader: Image " + t + " is missing URI and bufferView");
        const l = Promise.resolve(o).then((function(t) {
            return new Promise((function(n, s) {
                let r = n;
                !0 === e.isImageBitmapLoader && (r = function(t) {
                    const e = new wt(t);
                    e.needsUpdate = !0, n(e)
                }), e.load(ao.resolveURL(t, i.path), r, void 0, s)
            }))
        })).then((function(t) {
            return !0 === a && r.revokeObjectURL(o), Mi(t, s), t.userData.mimeType = s.mimeType || fE(s.uri), t
        })).catch((function(t) {
            throw console.error("THREE.GLTFLoader: Couldn't load texture", o), t
        }));
        return this.sourceCache[t] = l, l
    }
    assignTexture(t, e, n, i) {
        const s = this;
        return this.getDependency("texture", n.index).then((function(r) {
            if (!r) return null;
            if (void 0 !== n.texCoord && n.texCoord > 0 && ((r = r.clone()).channel = n.texCoord), s.extensions[et.KHR_TEXTURE_TRANSFORM]) {
                const t = void 0 !== n.extensions ? n.extensions[et.KHR_TEXTURE_TRANSFORM] : void 0;
                if (t) {
                    const e = s.associations.get(r);
                    r = s.extensions[et.KHR_TEXTURE_TRANSFORM].extendTexture(r, t), s.associations.set(r, e)
                }
            }
            return void 0 !== i && ("number" == typeof i && (i = i === wf ? As : Pi), "colorSpace" in r ? r.colorSpace = i : r.encoding = i === As ? wf : BM), t[e] = r, r
        }))
    }
    assignFinalMaterial(t) {
        const e = t.geometry;
        let n = t.material;
        const i = void 0 === e.attributes.tangent,
            s = void 0 !== e.attributes.color,
            r = void 0 === e.attributes.normal;
        if (t.isPoints) {
            const t = "PointsMaterial:" + n.uuid;
            let e = this.cache.get(t);
            e || (e = new xs, en.prototype.copy.call(e, n), e.color.copy(n.color), e.map = n.map, e.sizeAttenuation = !1, this.cache.add(t, e)), n = e
        } else if (t.isLine) {
            const t = "LineBasicMaterial:" + n.uuid;
            let e = this.cache.get(t);
            e || (e = new Zi, en.prototype.copy.call(e, n), e.color.copy(n.color), e.map = n.map, this.cache.add(t, e)), n = e
        }
        if (i || s || r) {
            let t = "ClonedMaterial:" + n.uuid + ":";
            i && (t += "derivative-tangents:"), s && (t += "vertex-colors:"), r && (t += "flat-shading:");
            let e = this.cache.get(t);
            e || (e = n.clone(), s && (e.vertexColors = !0), r && (e.flatShading = !0), i && (e.normalScale && (e.normalScale.y *= -1), e.clearcoatNormalScale && (e.clearcoatNormalScale.y *= -1)), this.cache.add(t, e), this.associations.set(e, this.associations.get(n))), n = e
        }
        t.material = n
    }
    getMaterialType() {
        return wh
    }
    loadMaterial(t) {
        const e = this,
            n = this.json,
            i = this.extensions,
            s = n.materials[t];
        let r;
        const o = {},
            a = [];
        if ((s.extensions || {})[et.KHR_MATERIALS_UNLIT]) {
            const t = i[et.KHR_MATERIALS_UNLIT];
            r = t.getMaterialType(), a.push(t.extendParams(o, s, e))
        } else {
            const n = s.pbrMetallicRoughness || {};
            if (o.color = new Le(1, 1, 1), o.opacity = 1, Array.isArray(n.baseColorFactor)) {
                const t = n.baseColorFactor;
                o.color.setRGB(t[0], t[1], t[2], Pi), o.opacity = t[3]
            }
            void 0 !== n.baseColorTexture && a.push(e.assignTexture(o, "map", n.baseColorTexture, As)), o.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1, o.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1, void 0 !== n.metallicRoughnessTexture && (a.push(e.assignTexture(o, "metalnessMap", n.metallicRoughnessTexture)), a.push(e.assignTexture(o, "roughnessMap", n.metallicRoughnessTexture))), r = this._invokeOne((function(e) {
                return e.getMaterialType && e.getMaterialType(t)
            })), a.push(Promise.all(this._invokeAll((function(e) {
                return e.extendMaterialParams && e.extendMaterialParams(t, o)
            }))))
        }!0 === s.doubleSided && (o.side = 2);
        const l = s.alphaMode || uc.OPAQUE;
        if (l === uc.BLEND ? (o.transparent = !0, o.depthWrite = !1) : (o.transparent = !1, l === uc.MASK && (o.alphaTest = void 0 !== s.alphaCutoff ? s.alphaCutoff : .5)), void 0 !== s.normalTexture && r !== At && (a.push(e.assignTexture(o, "normalMap", s.normalTexture)), o.normalScale = new Q(1, 1), void 0 !== s.normalTexture.scale)) {
            const t = s.normalTexture.scale;
            o.normalScale.set(t, t)
        }
        if (void 0 !== s.occlusionTexture && r !== At && (a.push(e.assignTexture(o, "aoMap", s.occlusionTexture)), void 0 !== s.occlusionTexture.strength && (o.aoMapIntensity = s.occlusionTexture.strength)), void 0 !== s.emissiveFactor && r !== At) {
            const t = s.emissiveFactor;
            o.emissive = (new Le).setRGB(t[0], t[1], t[2], Pi)
        }
        return void 0 !== s.emissiveTexture && r !== At && a.push(e.assignTexture(o, "emissiveMap", s.emissiveTexture, As)), Promise.all(a).then((function() {
            const n = new r(o);
            return s.name && (n.name = s.name), Mi(n, s), e.associations.set(n, {
                materials: t
            }), s.extensions && fs(i, n, s), n
        }))
    }
    createUniqueName(t) {
        const e = gt.sanitizeNodeName(t || "");
        return e in this.nodeNamesUsed ? e + "_" + ++this.nodeNamesUsed[e] : (this.nodeNamesUsed[e] = 0, e)
    }
    loadGeometries(t) {
        const e = this,
            n = this.extensions,
            i = this.primitiveCache;

        function s(t) {
            return n[et.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(t, e).then((function(n) {
                return Cf(n, t, e)
            }))
        }
        const r = [];
        for (let n = 0, o = t.length; n < o; n++) {
            const o = t[n],
                a = dE(o),
                l = i[a];
            if (l) r.push(l.promise);
            else {
                let t;
                t = o.extensions && o.extensions[et.KHR_DRACO_MESH_COMPRESSION] ? s(o) : Cf(new ht, o, e), i[a] = {
                    primitive: o,
                    promise: t
                }, r.push(t)
            }
        }
        return Promise.all(r)
    }
    loadMesh(t) {
        const e = this,
            n = this.json,
            i = this.extensions,
            s = n.meshes[t],
            r = s.primitives,
            o = [];
        for (let t = 0, e = r.length; t < e; t++) {
            const e = void 0 === r[t].material ? cE(this.cache) : this.getDependency("material", r[t].material);
            o.push(e)
        }
        return o.push(e.loadGeometries(r)), Promise.all(o).then((function(n) {
            const o = n.slice(0, n.length - 1),
                a = n[n.length - 1],
                l = [];
            for (let n = 0, c = a.length; n < c; n++) {
                const c = a[n],
                    h = r[n];
                let u;
                const d = o[n];
                if (h.mode === Ln.TRIANGLES || h.mode === Ln.TRIANGLE_STRIP || h.mode === Ln.TRIANGLE_FAN || void 0 === h.mode) u = !0 === s.isSkinnedMesh ? new hS(c, d) : new be(c, d), !0 === u.isSkinnedMesh && u.normalizeSkinWeights(), h.mode === Ln.TRIANGLE_STRIP ? u.geometry = Af(u.geometry, 1) : h.mode === Ln.TRIANGLE_FAN && (u.geometry = Af(u.geometry, 2));
                else if (h.mode === Ln.LINES) u = new mo(c, d);
                else if (h.mode === Ln.LINE_STRIP) u = new at(c, d);
                else if (h.mode === Ln.LINE_LOOP) u = new fS(c, d);
                else {
                    if (h.mode !== Ln.POINTS) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + h.mode);
                    u = new so(c, d)
                }
                Object.keys(u.geometry.morphAttributes).length > 0 && uE(u, s), u.name = e.createUniqueName(s.name || "mesh_" + t), Mi(u, s), h.extensions && fs(i, u, h), e.assignFinalMaterial(u), l.push(u)
            }
            for (let n = 0, i = l.length; n < i; n++) e.associations.set(l[n], {
                meshes: t,
                primitives: n
            });
            if (1 === l.length) return s.extensions && fs(i, l[0], s), l[0];
            const c = new Fn;
            s.extensions && fs(i, c, s), e.associations.set(c, {
                meshes: t
            });
            for (let t = 0, e = l.length; t < e; t++) c.add(l[t]);
            return c
        }))
    }
    loadCamera(t) {
        let e;
        const n = this.json.cameras[t],
            i = n[n.type];
        if (i) return "perspective" === n.type ? e = new Pt(_i.radToDeg(i.yfov), i.aspectRatio || 1, i.znear || 1, i.zfar || 2e6) : "orthographic" === n.type && (e = new Ci(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)), n.name && (e.name = this.createUniqueName(n.name)), Mi(e, n), Promise.resolve(e);
        console.warn("THREE.GLTFLoader: Missing camera parameters.")
    }
    loadSkin(t) {
        const e = this.json.skins[t],
            n = [];
        for (let t = 0, i = e.joints.length; t < i; t++) n.push(this._loadNodeShallow(e.joints[t]));
        return void 0 !== e.inverseBindMatrices ? n.push(this.getDependency("accessor", e.inverseBindMatrices)) : n.push(null), Promise.all(n).then((function(t) {
            const n = t.pop(),
                i = t,
                s = [],
                r = [];
            for (let t = 0, o = i.length; t < o; t++) {
                const o = i[t];
                if (o) {
                    s.push(o);
                    const e = new Xe;
                    null !== n && e.fromArray(n.array, 16 * t), r.push(e)
                } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', e.joints[t])
            }
            return new yh(s, r)
        }))
    }
    loadAnimation(t) {
        const e = this.json,
            n = this,
            i = e.animations[t],
            s = i.name ? i.name : "animation_" + t,
            r = [],
            o = [],
            a = [],
            l = [],
            c = [];
        for (let t = 0, e = i.channels.length; t < e; t++) {
            const e = i.channels[t],
                n = i.samplers[e.sampler],
                s = e.target,
                h = s.node,
                u = void 0 !== i.parameters ? i.parameters[n.input] : n.input,
                d = void 0 !== i.parameters ? i.parameters[n.output] : n.output;
            void 0 !== s.node && (r.push(this.getDependency("node", h)), o.push(this.getDependency("accessor", u)), a.push(this.getDependency("accessor", d)), l.push(n), c.push(s))
        }
        return Promise.all([Promise.all(r), Promise.all(o), Promise.all(a), Promise.all(l), Promise.all(c)]).then((function(t) {
            const e = t[0],
                i = t[1],
                r = t[2],
                o = t[3],
                a = t[4],
                l = [];
            for (let t = 0, s = e.length; t < s; t++) {
                const s = e[t],
                    c = i[t],
                    h = r[t],
                    u = o[t],
                    d = a[t];
                if (void 0 === s) continue;
                s.updateMatrix && s.updateMatrix();
                const p = n._createAnimationTracks(s, c, h, u, d);
                if (p)
                    for (let t = 0; t < p.length; t++) l.push(p[t])
            }
            return new JS(s, void 0, l)
        }))
    }
    createNodeMesh(t) {
        const e = this.json,
            n = this,
            i = e.nodes[t];
        return void 0 === i.mesh ? null : n.getDependency("mesh", i.mesh).then((function(t) {
            const e = n._getNodeRef(n.meshCache, i.mesh, t);
            return void 0 !== i.weights && e.traverse((function(t) {
                if (t.isMesh)
                    for (let e = 0, n = i.weights.length; e < n; e++) t.morphTargetInfluences[e] = i.weights[e]
            })), e
        }))
    }
    loadNode(t) {
        const e = this,
            n = this.json.nodes[t],
            i = e._loadNodeShallow(t),
            s = [],
            r = n.children || [];
        for (let t = 0, n = r.length; t < n; t++) s.push(e.getDependency("node", r[t]));
        const o = void 0 === n.skin ? Promise.resolve(null) : e.getDependency("skin", n.skin);
        return Promise.all([i, Promise.all(s), o]).then((function(t) {
            const e = t[0],
                n = t[1],
                i = t[2];
            null !== i && e.traverse((function(t) {
                t.isSkinnedMesh && t.bind(i, pE)
            }));
            for (let t = 0, i = n.length; t < i; t++) e.add(n[t]);
            return e
        }))
    }
    _loadNodeShallow(t) {
        const e = this.json,
            n = this.extensions,
            i = this;
        if (void 0 !== this.nodeCache[t]) return this.nodeCache[t];
        const s = e.nodes[t],
            r = s.name ? i.createUniqueName(s.name) : "",
            o = [],
            a = i._invokeOne((function(e) {
                return e.createNodeMesh && e.createNodeMesh(t)
            }));
        return a && o.push(a), void 0 !== s.camera && o.push(i.getDependency("camera", s.camera).then((function(t) {
            return i._getNodeRef(i.cameraCache, s.camera, t)
        }))), i._invokeAll((function(e) {
            return e.createNodeAttachment && e.createNodeAttachment(t)
        })).forEach((function(t) {
            o.push(t)
        })), this.nodeCache[t] = Promise.all(o).then((function(e) {
            let o;
            if (o = !0 === s.isBone ? new Pp : e.length > 1 ? new Fn : 1 === e.length ? e[0] : new ct, o !== e[0])
                for (let t = 0, n = e.length; t < n; t++) o.add(e[t]);
            if (s.name && (o.userData.name = s.name, o.name = r), Mi(o, s), s.extensions && fs(n, o, s), void 0 !== s.matrix) {
                const t = new Xe;
                t.fromArray(s.matrix), o.applyMatrix4(t)
            } else void 0 !== s.translation && o.position.fromArray(s.translation), void 0 !== s.rotation && o.quaternion.fromArray(s.rotation), void 0 !== s.scale && o.scale.fromArray(s.scale);
            return i.associations.has(o) || i.associations.set(o, {}), i.associations.get(o).nodes = t, o
        })), this.nodeCache[t]
    }
    loadScene(t) {
        const e = this.extensions,
            n = this.json.scenes[t],
            i = this,
            s = new Fn;
        n.name && (s.name = i.createUniqueName(n.name)), Mi(s, n), n.extensions && fs(e, s, n);
        const r = n.nodes || [],
            o = [];
        for (let t = 0, e = r.length; t < e; t++) o.push(i.getDependency("node", r[t]));
        return Promise.all(o).then((function(t) {
            for (let e = 0, n = t.length; e < n; e++) s.add(t[e]);
            return i.associations = (t => {
                const e = new Map;
                for (const [t, n] of i.associations)(t instanceof en || t instanceof wt) && e.set(t, n);
                return t.traverse((t => {
                    const n = i.associations.get(t);
                    null != n && e.set(t, n)
                })), e
            })(s), s
        }))
    }
    _createAnimationTracks(t, e, n, i, s) {
        const r = [],
            o = t.name ? t.name : t.uuid,
            a = [];
        let l;
        switch (Xi[s.path] === Xi.weights ? t.traverse((function(t) {
            t.morphTargetInfluences && a.push(t.name ? t.name : t.uuid)
        })) : a.push(o), Xi[s.path]) {
            case Xi.weights:
                l = Tr;
                break;
            case Xi.rotation:
                l = Ds;
                break;
            case Xi.position:
            case Xi.scale:
                l = Cr;
                break;
            default:
                if (1 === n.itemSize) l = Tr;
                else l = Cr
        }
        const c = void 0 !== i.interpolation ? lE[i.interpolation] : _r,
            h = this._getArrayFromAccessor(n);
        for (let t = 0, n = a.length; t < n; t++) {
            const n = new l(a[t] + "." + Xi[s.path], e.array, h, c);
            "CUBICSPLINE" === i.interpolation && this._createCubicSplineTrackInterpolant(n), r.push(n)
        }
        return r
    }
    _getArrayFromAccessor(t) {
        let e = t.array;
        if (t.normalized) {
            const t = Kc(e.constructor),
                n = new Float32Array(e.length);
            for (let i = 0, s = e.length; i < s; i++) n[i] = e[i] * t;
            e = n
        }
        return e
    }
    _createCubicSplineTrackInterpolant(t) {
        t.createInterpolant = function(t) {
            return new(this instanceof Ds ? aE : tm)(this.times, this.values, this.getValueSize() / 3, t)
        }, t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0
    }
}

function gE(t, e, n) {
    const i = e.attributes,
        s = new Tn;
    if (void 0 === i.POSITION) return; {
        const t = n.json.accessors[i.POSITION],
            e = t.min,
            r = t.max;
        if (void 0 === e || void 0 === r) return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
        if (s.set(new U(e[0], e[1], e[2]), new U(r[0], r[1], r[2])), t.normalized) {
            const e = Kc(pr[t.componentType]);
            s.min.multiplyScalar(e), s.max.multiplyScalar(e)
        }
    }
    const r = e.targets;
    if (void 0 !== r) {
        const t = new U,
            e = new U;
        for (let i = 0, s = r.length; i < s; i++) {
            const s = r[i];
            if (void 0 !== s.POSITION) {
                const i = n.json.accessors[s.POSITION],
                    r = i.min,
                    o = i.max;
                if (void 0 !== r && void 0 !== o) {
                    if (e.setX(Math.max(Math.abs(r[0]), Math.abs(o[0]))), e.setY(Math.max(Math.abs(r[1]), Math.abs(o[1]))), e.setZ(Math.max(Math.abs(r[2]), Math.abs(o[2]))), i.normalized) {
                        const t = Kc(pr[i.componentType]);
                        e.multiplyScalar(t)
                    }
                    t.max(e)
                } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
            }
        }
        s.expandByVector(t)
    }
    t.boundingBox = s;
    const o = new Hn;
    s.getCenter(o.center), o.radius = s.min.distanceTo(s.max) / 2, t.boundingSphere = o
}

function Cf(t, e, n) {
    const i = e.attributes,
        s = [];

    function r(e, i) {
        return n.getDependency("accessor", e).then((function(e) {
            t.setAttribute(i, e)
        }))
    }
    for (const e in i) {
        const n = jc[e] || e.toLowerCase();
        n in t.attributes || s.push(r(i[e], n))
    }
    if (void 0 !== e.indices && !t.index) {
        const i = n.getDependency("accessor", e.indices).then((function(e) {
            t.setIndex(e)
        }));
        s.push(i)
    }
    return Mi(t, e), gE(t, e, n), Promise.all(s).then((function() {
        return void 0 !== e.targets ? hE(t, e.targets, n) : t
    }))
}
const vE = "srgb";
class Rh extends is {
    constructor(t) {
        super(t), this.defaultDPI = 90, this.defaultUnit = "px"
    }
    load(t, e, n, i) {
        const s = this,
            r = new qa(s.manager);
        r.setPath(s.path), r.setRequestHeader(s.requestHeader), r.setWithCredentials(s.withCredentials), r.load(t, (function(n) {
            try {
                e(s.parse(n))
            } catch (e) {
                i ? i(e) : console.error(e), s.manager.itemError(t)
            }
        }), n, i)
    }
    parse(t) {
        const e = this;

        function n(t, e, n, s, r, o, a, l) {
            if (0 == e || 0 == n) return void t.lineTo(l.x, l.y);
            s = s * Math.PI / 180, e = Math.abs(e), n = Math.abs(n);
            const c = (a.x - l.x) / 2,
                h = (a.y - l.y) / 2,
                u = Math.cos(s) * c + Math.sin(s) * h,
                d = -Math.sin(s) * c + Math.cos(s) * h;
            let p = e * e,
                f = n * n;
            const m = u * u,
                g = d * d,
                v = m / p + g / f;
            if (v > 1) {
                const t = Math.sqrt(v);
                p = (e *= t) * e, f = (n *= t) * n
            }
            const y = p * g + f * m,
                x = (p * f - y) / y;
            let b = Math.sqrt(Math.max(0, x));
            r === o && (b = -b);
            const A = b * e * d / n,
                S = -b * n * u / e,
                w = Math.cos(s) * A - Math.sin(s) * S + (a.x + l.x) / 2,
                _ = Math.sin(s) * A + Math.cos(s) * S + (a.y + l.y) / 2,
                M = i(1, 0, (u - A) / e, (d - S) / n),
                T = i((u - A) / e, (d - S) / n, (-u - A) / e, (-d - S) / n) % (2 * Math.PI);
            t.currentPath.absellipse(w, _, e, n, M, M + T, 0 === o, s)
        }

        function i(t, e, n, i) {
            const s = t * n + e * i,
                r = Math.sqrt(t * t + e * e) * Math.sqrt(n * n + i * i);
            let o = Math.acos(Math.max(-1, Math.min(1, s / r)));
            return t * i - e * n < 0 && (o = -o), o
        }

        function s(t, e) {
            e = Object.assign({}, e);
            let n = {};
            if (t.hasAttribute("class")) {
                const e = t.getAttribute("class").split(/\s/).filter(Boolean).map((t => t.trim()));
                for (let t = 0; t < e.length; t++) n = Object.assign(n, m["." + e[t]])
            }

            function i(i, s, r) {
                void 0 === r && (r = function(t) {
                    return t.startsWith("url") && console.warn("SVGLoader: url access in attributes is not implemented."), t
                }), t.hasAttribute(i) && (e[s] = r(t.getAttribute(i))), n[i] && (e[s] = r(n[i])), t.style && "" !== t.style[i] && (e[s] = r(t.style[i]))
            }

            function s(t) {
                return Math.max(0, Math.min(1, c(t)))
            }

            function r(t) {
                return Math.max(0, c(t))
            }
            return t.hasAttribute("id") && (n = Object.assign(n, m["#" + t.getAttribute("id")])), i("fill", "fill"), i("fill-opacity", "fillOpacity", s), i("fill-rule", "fillRule"), i("opacity", "opacity", s), i("stroke", "stroke"), i("stroke-opacity", "strokeOpacity", s), i("stroke-width", "strokeWidth", r), i("stroke-linejoin", "strokeLineJoin"), i("stroke-linecap", "strokeLineCap"), i("stroke-miterlimit", "strokeMiterLimit", r), i("visibility", "visibility"), e
        }

        function r(t, e) {
            return t - (e - t)
        }

        function o(t, e, n) {
            if ("string" != typeof t) throw new TypeError("Invalid input: " + typeof t);
            const i = {
                SEPARATOR: /[ \t\r\n\,.\-+]/,
                WHITESPACE: /[ \t\r\n]/,
                DIGIT: /[\d]/,
                SIGN: /[-+]/,
                POINT: /\./,
                COMMA: /,/,
                EXP: /e/i,
                FLAGS: /[01]/
            };
            let s = 0,
                r = !0,
                o = "",
                a = "";
            const l = [];

            function c(t, e, n) {
                const i = new SyntaxError('Unexpected character "' + t + '" at index ' + e + ".");
                throw i.partial = n, i
            }

            function h() {
                "" !== o && ("" === a ? l.push(Number(o)) : l.push(Number(o) * Math.pow(10, Number(a)))), o = "", a = ""
            }
            let u;
            const d = t.length;
            for (let p = 0; p < d; p++)
                if (u = t[p], Array.isArray(e) && e.includes(l.length % n) && i.FLAGS.test(u)) s = 1, o = u, h();
                else {
                    if (0 === s) {
                        if (i.WHITESPACE.test(u)) continue;
                        if (i.DIGIT.test(u) || i.SIGN.test(u)) {
                            s = 1, o = u;
                            continue
                        }
                        if (i.POINT.test(u)) {
                            s = 2, o = u;
                            continue
                        }
                        i.COMMA.test(u) && (r && c(u, p, l), r = !0)
                    }
                    if (1 === s) {
                        if (i.DIGIT.test(u)) {
                            o += u;
                            continue
                        }
                        if (i.POINT.test(u)) {
                            o += u, s = 2;
                            continue
                        }
                        if (i.EXP.test(u)) {
                            s = 3;
                            continue
                        }
                        i.SIGN.test(u) && 1 === o.length && i.SIGN.test(o[0]) && c(u, p, l)
                    }
                    if (2 === s) {
                        if (i.DIGIT.test(u)) {
                            o += u;
                            continue
                        }
                        if (i.EXP.test(u)) {
                            s = 3;
                            continue
                        }
                        i.POINT.test(u) && "." === o[o.length - 1] && c(u, p, l)
                    }
                    if (3 === s) {
                        if (i.DIGIT.test(u)) {
                            a += u;
                            continue
                        }
                        if (i.SIGN.test(u)) {
                            if ("" === a) {
                                a += u;
                                continue
                            }
                            1 === a.length && i.SIGN.test(a) && c(u, p, l)
                        }
                    }
                    i.WHITESPACE.test(u) ? (h(), s = 0, r = !1) : i.COMMA.test(u) ? (h(), s = 0, r = !0) : i.SIGN.test(u) ? (h(), s = 1, o = u) : i.POINT.test(u) ? (h(), s = 2, o = u) : c(u, p, l)
                }
            return h(), l
        }
        const a = ["mm", "cm", "in", "pt", "pc", "px"],
            l = {
                mm: {
                    mm: 1,
                    cm: .1,
                    in: 1 / 25.4,
                    pt: 72 / 25.4,
                    pc: 6 / 25.4,
                    px: -1
                },
                cm: {
                    mm: 10,
                    cm: 1,
                    in: 1 / 2.54,
                    pt: 72 / 2.54,
                    pc: 6 / 2.54,
                    px: -1
                },
                in: {
                    mm: 25.4,
                    cm: 2.54,
                    in: 1,
                    pt: 72,
                    pc: 6,
                    px: -1
                },
                pt: {
                    mm: 25.4 / 72,
                    cm: 2.54 / 72,
                    in: 1 / 72,
                    pt: 1,
                    pc: 6 / 72,
                    px: -1
                },
                pc: {
                    mm: 25.4 / 6,
                    cm: 2.54 / 6,
                    in: 1 / 6,
                    pt: 12,
                    pc: 1,
                    px: -1
                },
                px: {
                    px: 1
                }
            };

        function c(t) {
            let n, i = "px";
            if ("string" == typeof t || t instanceof String)
                for (let e = 0, n = a.length; e < n; e++) {
                    const n = a[e];
                    if (t.endsWith(n)) {
                        i = n, t = t.substring(0, t.length - n.length);
                        break
                    }
                }
            return "px" === i && "px" !== e.defaultUnit ? n = l.in[e.defaultUnit] / e.defaultDPI : (n = l[i][e.defaultUnit], n < 0 && (n = l[i].in * e.defaultDPI)), n * parseFloat(t)
        }

        function h(t) {
            const e = t.elements;
            return e[0] * e[4] - e[1] * e[3] < 0
        }

        function u(t) {
            const e = t.elements,
                n = e[0] * e[3] + e[1] * e[4];
            if (0 === n) return !1;
            const i = d(t),
                s = p(t);
            return Math.abs(n / (i * s)) > Number.EPSILON
        }

        function d(t) {
            const e = t.elements;
            return Math.sqrt(e[0] * e[0] + e[1] * e[1])
        }

        function p(t) {
            const e = t.elements;
            return Math.sqrt(e[3] * e[3] + e[4] * e[4])
        }
        const f = [],
            m = {},
            g = [],
            v = new We,
            y = new We,
            x = new We,
            b = new We,
            A = new Q,
            S = new U,
            w = new We,
            _ = (new DOMParser).parseFromString(t, "image/svg+xml");
        return function t(e, i) {
            if (1 !== e.nodeType) return;
            const a = function(t) {
                if (!(t.hasAttribute("transform") || "use" === t.nodeName && (t.hasAttribute("x") || t.hasAttribute("y")))) return null;
                const e = function(t) {
                    const e = new We,
                        n = v;
                    if ("use" === t.nodeName && (t.hasAttribute("x") || t.hasAttribute("y"))) {
                        const n = c(t.getAttribute("x")),
                            i = c(t.getAttribute("y"));
                        e.translate(n, i)
                    }
                    if (t.hasAttribute("transform")) {
                        const i = t.getAttribute("transform").split(")");
                        for (let t = i.length - 1; t >= 0; t--) {
                            const s = i[t].trim();
                            if ("" === s) continue;
                            const r = s.indexOf("("),
                                a = s.length;
                            if (r > 0 && r < a) {
                                const t = s.slice(0, r),
                                    e = o(s.slice(r + 1));
                                switch (n.identity(), t) {
                                    case "translate":
                                        if (e.length >= 1) {
                                            const t = e[0];
                                            let i = 0;
                                            e.length >= 2 && (i = e[1]), n.translate(t, i)
                                        }
                                        break;
                                    case "rotate":
                                        if (e.length >= 1) {
                                            let t = 0,
                                                i = 0,
                                                s = 0;
                                            t = e[0] * Math.PI / 180, e.length >= 3 && (i = e[1], s = e[2]), y.makeTranslation(-i, -s), x.makeRotation(t), b.multiplyMatrices(x, y), y.makeTranslation(i, s), n.multiplyMatrices(y, b)
                                        }
                                        break;
                                    case "scale":
                                        if (e.length >= 1) {
                                            const t = e[0];
                                            let i = t;
                                            e.length >= 2 && (i = e[1]), n.scale(t, i)
                                        }
                                        break;
                                    case "skewX":
                                        1 === e.length && n.set(1, Math.tan(e[0] * Math.PI / 180), 0, 0, 1, 0, 0, 0, 1);
                                        break;
                                    case "skewY":
                                        1 === e.length && n.set(1, 0, 0, Math.tan(e[0] * Math.PI / 180), 1, 0, 0, 0, 1);
                                        break;
                                    case "matrix":
                                        6 === e.length && n.set(e[0], e[2], e[4], e[1], e[3], e[5], 0, 0, 1)
                                }
                            }
                            e.premultiply(n)
                        }
                    }
                    return e
                }(t);
                return g.length > 0 && e.premultiply(g[g.length - 1]), w.copy(e), g.push(e), e
            }(e);
            let l = !1,
                _ = null;
            switch (e.nodeName) {
                case "svg":
                case "g":
                    i = s(e, i);
                    break;
                case "style":
                    ! function(t) {
                        if (t.sheet && t.sheet.cssRules && t.sheet.cssRules.length)
                            for (let e = 0; e < t.sheet.cssRules.length; e++) {
                                const n = t.sheet.cssRules[e];
                                if (1 !== n.type) continue;
                                const i = n.selectorText.split(/,/gm).filter(Boolean).map((t => t.trim()));
                                for (let t = 0; t < i.length; t++) {
                                    const e = Object.fromEntries(Object.entries(n.style).filter((([, t]) => "" !== t)));
                                    m[i[t]] = Object.assign(m[i[t]] || {}, e)
                                }
                            }
                    }(e);
                    break;
                case "path":
                    i = s(e, i), e.hasAttribute("d") && (_ = function(t) {
                        const e = new ds,
                            i = new Q,
                            s = new Q,
                            a = new Q;
                        let l = !0,
                            c = !1;
                        const h = t.getAttribute("d");
                        if ("" === h || "none" === h) return null;
                        const u = h.match(/[a-df-z][^a-df-z]*/gi);
                        for (let t = 0, h = u.length; t < h; t++) {
                            const h = u[t],
                                d = h.charAt(0),
                                p = h.slice(1).trim();
                            let f;
                            switch (!0 === l && (c = !0, l = !1), d) {
                                case "M":
                                    f = o(p);
                                    for (let t = 0, n = f.length; t < n; t += 2) i.x = f[t + 0], i.y = f[t + 1], s.x = i.x, s.y = i.y, 0 === t ? e.moveTo(i.x, i.y) : e.lineTo(i.x, i.y), 0 === t && a.copy(i);
                                    break;
                                case "H":
                                    f = o(p);
                                    for (let t = 0, n = f.length; t < n; t++) i.x = f[t], s.x = i.x, s.y = i.y, e.lineTo(i.x, i.y), 0 === t && !0 === c && a.copy(i);
                                    break;
                                case "V":
                                    f = o(p);
                                    for (let t = 0, n = f.length; t < n; t++) i.y = f[t], s.x = i.x, s.y = i.y, e.lineTo(i.x, i.y), 0 === t && !0 === c && a.copy(i);
                                    break;
                                case "L":
                                    f = o(p);
                                    for (let t = 0, n = f.length; t < n; t += 2) i.x = f[t + 0], i.y = f[t + 1], s.x = i.x, s.y = i.y, e.lineTo(i.x, i.y), 0 === t && !0 === c && a.copy(i);
                                    break;
                                case "C":
                                    f = o(p);
                                    for (let t = 0, n = f.length; t < n; t += 6) e.bezierCurveTo(f[t + 0], f[t + 1], f[t + 2], f[t + 3], f[t + 4], f[t + 5]), s.x = f[t + 2], s.y = f[t + 3], i.x = f[t + 4], i.y = f[t + 5], 0 === t && !0 === c && a.copy(i);
                                    break;
                                case "S":
                                    f = o(p);
                                    for (let t = 0, n = f.length; t < n; t += 4) e.bezierCurveTo(r(i.x, s.x), r(i.y, s.y), f[t + 0], f[t + 1], f[t + 2], f[t + 3]), s.x = f[t + 0], s.y = f[t + 1], i.x = f[t + 2], i.y = f[t + 3], 0 === t && !0 === c && a.copy(i);
                                    break;
                                case "Q":
                                    f = o(p);
                                    for (let t = 0, n = f.length; t < n; t += 4) e.quadraticCurveTo(f[t + 0], f[t + 1], f[t + 2], f[t + 3]), s.x = f[t + 0], s.y = f[t + 1], i.x = f[t + 2], i.y = f[t + 3], 0 === t && !0 === c && a.copy(i);
                                    break;
                                case "T":
                                    f = o(p);
                                    for (let t = 0, n = f.length; t < n; t += 2) {
                                        const n = r(i.x, s.x),
                                            o = r(i.y, s.y);
                                        e.quadraticCurveTo(n, o, f[t + 0], f[t + 1]), s.x = n, s.y = o, i.x = f[t + 0], i.y = f[t + 1], 0 === t && !0 === c && a.copy(i)
                                    }
                                    break;
                                case "A":
                                    f = o(p, [3, 4], 7);
                                    for (let t = 0, r = f.length; t < r; t += 7) {
                                        if (f[t + 5] == i.x && f[t + 6] == i.y) continue;
                                        const r = i.clone();
                                        i.x = f[t + 5], i.y = f[t + 6], s.x = i.x, s.y = i.y, n(e, f[t], f[t + 1], f[t + 2], f[t + 3], f[t + 4], r, i), 0 === t && !0 === c && a.copy(i)
                                    }
                                    break;
                                case "m":
                                    f = o(p);
                                    for (let t = 0, n = f.length; t < n; t += 2) i.x += f[t + 0], i.y += f[t + 1], s.x = i.x, s.y = i.y, 0 === t ? e.moveTo(i.x, i.y) : e.lineTo(i.x, i.y), 0 === t && a.copy(i);
                                    break;
                                case "h":
                                    f = o(p);
                                    for (let t = 0, n = f.length; t < n; t++) i.x += f[t], s.x = i.x, s.y = i.y, e.lineTo(i.x, i.y), 0 === t && !0 === c && a.copy(i);
                                    break;
                                case "v":
                                    f = o(p);
                                    for (let t = 0, n = f.length; t < n; t++) i.y += f[t], s.x = i.x, s.y = i.y, e.lineTo(i.x, i.y), 0 === t && !0 === c && a.copy(i);
                                    break;
                                case "l":
                                    f = o(p);
                                    for (let t = 0, n = f.length; t < n; t += 2) i.x += f[t + 0], i.y += f[t + 1], s.x = i.x, s.y = i.y, e.lineTo(i.x, i.y), 0 === t && !0 === c && a.copy(i);
                                    break;
                                case "c":
                                    f = o(p);
                                    for (let t = 0, n = f.length; t < n; t += 6) e.bezierCurveTo(i.x + f[t + 0], i.y + f[t + 1], i.x + f[t + 2], i.y + f[t + 3], i.x + f[t + 4], i.y + f[t + 5]), s.x = i.x + f[t + 2], s.y = i.y + f[t + 3], i.x += f[t + 4], i.y += f[t + 5], 0 === t && !0 === c && a.copy(i);
                                    break;
                                case "s":
                                    f = o(p);
                                    for (let t = 0, n = f.length; t < n; t += 4) e.bezierCurveTo(r(i.x, s.x), r(i.y, s.y), i.x + f[t + 0], i.y + f[t + 1], i.x + f[t + 2], i.y + f[t + 3]), s.x = i.x + f[t + 0], s.y = i.y + f[t + 1], i.x += f[t + 2], i.y += f[t + 3], 0 === t && !0 === c && a.copy(i);
                                    break;
                                case "q":
                                    f = o(p);
                                    for (let t = 0, n = f.length; t < n; t += 4) e.quadraticCurveTo(i.x + f[t + 0], i.y + f[t + 1], i.x + f[t + 2], i.y + f[t + 3]), s.x = i.x + f[t + 0], s.y = i.y + f[t + 1], i.x += f[t + 2], i.y += f[t + 3], 0 === t && !0 === c && a.copy(i);
                                    break;
                                case "t":
                                    f = o(p);
                                    for (let t = 0, n = f.length; t < n; t += 2) {
                                        const n = r(i.x, s.x),
                                            o = r(i.y, s.y);
                                        e.quadraticCurveTo(n, o, i.x + f[t + 0], i.y + f[t + 1]), s.x = n, s.y = o, i.x = i.x + f[t + 0], i.y = i.y + f[t + 1], 0 === t && !0 === c && a.copy(i)
                                    }
                                    break;
                                case "a":
                                    f = o(p, [3, 4], 7);
                                    for (let t = 0, r = f.length; t < r; t += 7) {
                                        if (0 == f[t + 5] && 0 == f[t + 6]) continue;
                                        const r = i.clone();
                                        i.x += f[t + 5], i.y += f[t + 6], s.x = i.x, s.y = i.y, n(e, f[t], f[t + 1], f[t + 2], f[t + 3], f[t + 4], r, i), 0 === t && !0 === c && a.copy(i)
                                    }
                                    break;
                                case "Z":
                                case "z":
                                    e.currentPath.autoClose = !0, e.currentPath.curves.length > 0 && (i.copy(a), e.currentPath.currentPoint.copy(i), l = !0);
                                    break;
                                default:
                                    console.warn(h)
                            }
                            c = !1
                        }
                        return e
                    }(e));
                    break;
                case "rect":
                    i = s(e, i), _ = function(t) {
                        const e = c(t.getAttribute("x") || 0),
                            n = c(t.getAttribute("y") || 0),
                            i = c(t.getAttribute("rx") || t.getAttribute("ry") || 0),
                            s = c(t.getAttribute("ry") || t.getAttribute("rx") || 0),
                            r = c(t.getAttribute("width")),
                            o = c(t.getAttribute("height")),
                            a = .448084975506,
                            l = new ds;
                        return l.moveTo(e + i, n), l.lineTo(e + r - i, n), (0 !== i || 0 !== s) && l.bezierCurveTo(e + r - i * a, n, e + r, n + s * a, e + r, n + s), l.lineTo(e + r, n + o - s), (0 !== i || 0 !== s) && l.bezierCurveTo(e + r, n + o - s * a, e + r - i * a, n + o, e + r - i, n + o), l.lineTo(e + i, n + o), (0 !== i || 0 !== s) && l.bezierCurveTo(e + i * a, n + o, e, n + o - s * a, e, n + o - s), l.lineTo(e, n + s), (0 !== i || 0 !== s) && l.bezierCurveTo(e, n + s * a, e + i * a, n, e + i, n), l
                    }(e);
                    break;
                case "polygon":
                    i = s(e, i), _ = function(t) {
                        function e(t, e, n) {
                            const r = c(e),
                                o = c(n);
                            0 === s ? i.moveTo(r, o) : i.lineTo(r, o), s++
                        }
                        const n = /([+-]?\d*\.?\d+(?:e[+-]?\d+)?)(?:,|\s)([+-]?\d*\.?\d+(?:e[+-]?\d+)?)/g,
                            i = new ds;
                        let s = 0;
                        return t.getAttribute("points").replace(n, e), i.currentPath.autoClose = !0, i
                    }(e);
                    break;
                case "polyline":
                    i = s(e, i), _ = function(t) {
                        function e(t, e, n) {
                            const r = c(e),
                                o = c(n);
                            0 === s ? i.moveTo(r, o) : i.lineTo(r, o), s++
                        }
                        const n = /([+-]?\d*\.?\d+(?:e[+-]?\d+)?)(?:,|\s)([+-]?\d*\.?\d+(?:e[+-]?\d+)?)/g,
                            i = new ds;
                        let s = 0;
                        return t.getAttribute("points").replace(n, e), i.currentPath.autoClose = !1, i
                    }(e);
                    break;
                case "circle":
                    i = s(e, i), _ = function(t) {
                        const e = c(t.getAttribute("cx") || 0),
                            n = c(t.getAttribute("cy") || 0),
                            i = c(t.getAttribute("r") || 0),
                            s = new fr;
                        s.absarc(e, n, i, 0, 2 * Math.PI);
                        const r = new ds;
                        return r.subPaths.push(s), r
                    }(e);
                    break;
                case "ellipse":
                    i = s(e, i), _ = function(t) {
                        const e = c(t.getAttribute("cx") || 0),
                            n = c(t.getAttribute("cy") || 0),
                            i = c(t.getAttribute("rx") || 0),
                            s = c(t.getAttribute("ry") || 0),
                            r = new fr;
                        r.absellipse(e, n, i, s, 0, 2 * Math.PI);
                        const o = new ds;
                        return o.subPaths.push(r), o
                    }(e);
                    break;
                case "line":
                    i = s(e, i), _ = function(t) {
                        const e = c(t.getAttribute("x1") || 0),
                            n = c(t.getAttribute("y1") || 0),
                            i = c(t.getAttribute("x2") || 0),
                            s = c(t.getAttribute("y2") || 0),
                            r = new ds;
                        return r.moveTo(e, n), r.lineTo(i, s), r.currentPath.autoClose = !1, r
                    }(e);
                    break;
                case "defs":
                    l = !0;
                    break;
                case "use":
                    i = s(e, i);
                    const a = (e.getAttributeNS("http://www.w3.org/1999/xlink", "href") || "").substring(1),
                        h = e.viewportElement.getElementById(a);
                    h ? t(h, i) : console.warn("SVGLoader: 'use node' references non-existent node id: " + a)
            }
            _ && (void 0 !== i.fill && "none" !== i.fill && _.color.setStyle(i.fill, vE), function(t, e) {
                function n(t) {
                    S.set(t.x, t.y, 1).applyMatrix3(e), t.set(S.x, S.y)
                }

                function i(t) {
                    const n = t.xRadius,
                        i = t.yRadius,
                        s = Math.cos(t.aRotation),
                        r = Math.sin(t.aRotation),
                        o = new U(n * s, n * r, 0),
                        a = new U(-i * r, i * s, 0),
                        l = o.applyMatrix3(e),
                        c = a.applyMatrix3(e),
                        u = v.set(l.x, c.x, 0, l.y, c.y, 0, 0, 0, 1),
                        d = y.copy(u).invert(),
                        p = x.copy(d).transpose().multiply(d).elements,
                        f = function(t, e, n) {
                            let i, s, r, o, a;
                            const l = t + n,
                                c = t - n,
                                h = Math.sqrt(c * c + 4 * e * e);
                            return l > 0 ? (i = .5 * (l + h), a = 1 / i, s = t * a * n - e * a * e) : l < 0 ? s = .5 * (l - h) : (i = .5 * h, s = -.5 * h), r = c > 0 ? c + h : c - h, Math.abs(r) > 2 * Math.abs(e) ? (a = -2 * e / r, o = 1 / Math.sqrt(1 + a * a), r = a * o) : 0 === Math.abs(e) ? (r = 1, o = 0) : (a = -.5 * r / e, r = 1 / Math.sqrt(1 + a * a), o = a * r), c > 0 && (a = r, r = -o, o = a), {
                                rt1: i,
                                rt2: s,
                                cs: r,
                                sn: o
                            }
                        }(p[0], p[1], p[4]),
                        m = Math.sqrt(f.rt1),
                        g = Math.sqrt(f.rt2);
                    if (t.xRadius = 1 / m, t.yRadius = 1 / g, t.aRotation = Math.atan2(f.sn, f.cs), !((t.aEndAngle - t.aStartAngle) % (2 * Math.PI) < Number.EPSILON)) {
                        const n = y.set(m, 0, 0, 0, g, 0, 0, 0, 1),
                            i = x.set(f.cs, f.sn, 0, -f.sn, f.cs, 0, 0, 0, 1),
                            s = n.multiply(i).multiply(u),
                            r = t => {
                                const {
                                    x: e,
                                    y: n
                                } = new U(Math.cos(t), Math.sin(t), 0).applyMatrix3(s);
                                return Math.atan2(n, e)
                            };
                        t.aStartAngle = r(t.aStartAngle), t.aEndAngle = r(t.aEndAngle), h(e) && (t.aClockwise = !t.aClockwise)
                    }
                }

                function s(t) {
                    const n = d(e),
                        i = p(e);
                    t.xRadius *= n, t.yRadius *= i;
                    const s = n > Number.EPSILON ? Math.atan2(e.elements[1], e.elements[0]) : Math.atan2(-e.elements[3], e.elements[4]);
                    t.aRotation += s, h(e) && (t.aStartAngle *= -1, t.aEndAngle *= -1, t.aClockwise = !t.aClockwise)
                }
                const r = t.subPaths;
                for (let t = 0, o = r.length; t < o; t++) {
                    const o = r[t].curves;
                    for (let t = 0; t < o.length; t++) {
                        const r = o[t];
                        r.isLineCurve ? (n(r.v1), n(r.v2)) : r.isCubicBezierCurve ? (n(r.v0), n(r.v1), n(r.v2), n(r.v3)) : r.isQuadraticBezierCurve ? (n(r.v0), n(r.v1), n(r.v2)) : r.isEllipseCurve && (A.set(r.aX, r.aY), n(A), r.aX = A.x, r.aY = A.y, u(e) ? i(r) : s(r))
                    }
                }
            }(_, w), f.push(_), _.userData = {
                node: e,
                style: i
            });
            const M = e.childNodes;
            for (let e = 0; e < M.length; e++) {
                const n = M[e];
                l && "style" !== n.nodeName && "defs" !== n.nodeName || t(n, i)
            }
            a && (g.pop(), g.length > 0 ? w.copy(g[g.length - 1]) : w.identity())
        }(_.documentElement, {
            fill: "#000",
            fillOpacity: 1,
            strokeOpacity: 1,
            strokeWidth: 1,
            strokeLineJoin: "miter",
            strokeLineCap: "butt",
            strokeMiterLimit: 4
        }), {
            paths: f,
            xml: _.documentElement
        }
    }
    static createShapes(t) {
        const e = 0,
            n = 1,
            i = 2,
            s = 3,
            r = 4,
            o = 5,
            a = 6,
            l = {
                loc: e,
                t: 0
            };

        function c(t, n, s, r) {
            const o = t.x,
                a = n.x,
                c = s.x,
                u = r.x,
                d = t.y,
                p = n.y,
                f = s.y,
                m = r.y,
                g = (u - c) * (d - f) - (m - f) * (o - c),
                v = (m - f) * (a - o) - (u - c) * (p - d),
                y = g / v,
                x = ((a - o) * (d - f) - (p - d) * (o - c)) / v;
            if (0 === v && 0 !== g || y <= 0 || y >= 1 || x < 0 || x > 1) return null;
            if (0 === g && 0 === v) {
                for (let c = 0; c < 2; c++) {
                    if (h(0 === c ? s : r, t, n), l.loc == e) {
                        const t = 0 === c ? s : r;
                        return {
                            x: t.x,
                            y: t.y,
                            t: l.t
                        }
                    }
                    if (l.loc == i) {
                        return {
                            x: +(o + l.t * (a - o)).toPrecision(10),
                            y: +(d + l.t * (p - d)).toPrecision(10),
                            t: l.t
                        }
                    }
                }
                return null
            }
            for (let i = 0; i < 2; i++)
                if (h(0 === i ? s : r, t, n), l.loc == e) {
                    const t = 0 === i ? s : r;
                    return {
                        x: t.x,
                        y: t.y,
                        t: l.t
                    }
                }
            return {
                x: +(o + y * (a - o)).toPrecision(10),
                y: +(d + y * (p - d)).toPrecision(10),
                t: y
            }
        }

        function h(t, c, h) {
            const u = h.x - c.x,
                d = h.y - c.y,
                p = t.x - c.x,
                f = t.y - c.y,
                m = u * f - p * d;
            if (t.x === c.x && t.y === c.y) return l.loc = e, void(l.t = 0);
            if (t.x === h.x && t.y === h.y) return l.loc = n, void(l.t = 1);
            if (m < -Number.EPSILON) return void(l.loc = s);
            if (m > Number.EPSILON) return void(l.loc = r);
            if (u * p < 0 || d * f < 0) return void(l.loc = o);
            if (Math.sqrt(u * u + d * d) < Math.sqrt(p * p + f * f)) return void(l.loc = a);
            let g;
            g = 0 !== u ? p / u : f / d, l.loc = i, l.t = g
        }

        function u(t, e, n) {
            const i = new Q;
            e.getCenter(i);
            const s = [];
            return n.forEach((e => {
                e.boundingBox.containsPoint(i) && function(t, e) {
                    const n = [],
                        i = [];
                    for (let s = 1; s < t.length; s++) {
                        const r = t[s - 1],
                            o = t[s];
                        for (let t = 1; t < e.length; t++) {
                            const s = c(r, o, e[t - 1], e[t]);
                            null !== s && void 0 === n.find((t => t.t <= s.t + Number.EPSILON && t.t >= s.t - Number.EPSILON)) && (n.push(s), i.push(new Q(s.x, s.y)))
                        }
                    }
                    return i
                }(t, e.points).forEach((t => {
                    s.push({
                        identifier: e.identifier,
                        isCW: e.isCW,
                        point: t
                    })
                }))
            })), s.sort(((t, e) => t.point.x - e.point.x)), s
        }
        let d = 999999999,
            p = -999999999,
            f = t.subPaths.map((t => {
                const e = t.getPoints();
                let n = -999999999,
                    i = 999999999,
                    s = -999999999,
                    r = 999999999;
                for (let t = 0; t < e.length; t++) {
                    const o = e[t];
                    o.y > n && (n = o.y), o.y < i && (i = o.y), o.x > s && (s = o.x), o.x < r && (r = o.x)
                }
                return p <= s && (p = s + 1), d >= r && (d = r - 1), {
                    curves: t.curves,
                    points: e,
                    isCW: Es.isClockWise(e),
                    identifier: -1,
                    boundingBox: new A_(new Q(r, i), new Q(s, n))
                }
            }));
        f = f.filter((t => t.points.length > 1));
        for (let t = 0; t < f.length; t++) f[t].identifier = t;
        const m = f.map((e => function(t, e, n, i, s) {
                (null == s || "" === s) && (s = "nonzero");
                const r = new Q;
                t.boundingBox.getCenter(r);
                const o = u([new Q(n, r.y), new Q(i, r.y)], t.boundingBox, e);
                o.sort(((t, e) => t.point.x - e.point.x));
                const a = [],
                    l = [];
                o.forEach((e => {
                    e.identifier === t.identifier ? a.push(e) : l.push(e)
                }));
                const c = a[0].point.x,
                    h = [];
                let d = 0;
                for (; d < l.length && l[d].point.x < c;) h.length > 0 && h[h.length - 1] === l[d].identifier ? h.pop() : h.push(l[d].identifier), d++;
                if (h.push(t.identifier), "evenodd" === s) {
                    const e = h.length % 2 == 0,
                        n = h[h.length - 2];
                    return {
                        identifier: t.identifier,
                        isHole: e,
                        for: n
                    }
                }
                if ("nonzero" === s) {
                    let n = !0,
                        i = null,
                        s = null;
                    for (let t = 0; t < h.length; t++) {
                        const r = h[t];
                        n ? (s = e[r].isCW, n = !1, i = r) : s !== e[r].isCW && (s = e[r].isCW, n = !0)
                    }
                    return {
                        identifier: t.identifier,
                        isHole: n,
                        for: i
                    }
                }
                console.warn('fill-rule: "' + s + '" is currently not implemented.')
            }(e, f, d, p, t.userData ? t.userData.style.fillRule : void 0))),
            g = [];
        return f.forEach((t => {
            if (!m[t.identifier].isHole) {
                const e = new Ji;
                e.curves = t.curves, m.filter((e => e.isHole && e.for === t.identifier)).forEach((t => {
                    const n = f[t.identifier],
                        i = new fr;
                    i.curves = n.curves, e.holes.push(i)
                })), g.push(e)
            }
        })), g
    }
    static getStrokeStyle(t, e, n, i, s) {
        return {
            strokeColor: e = void 0 !== e ? e : "#000",
            strokeWidth: t = void 0 !== t ? t : 1,
            strokeLineJoin: n = void 0 !== n ? n : "miter",
            strokeLineCap: i = void 0 !== i ? i : "butt",
            strokeMiterLimit: s = void 0 !== s ? s : 4
        }
    }
    static pointsToStroke(t, e, n, i) {
        const s = [],
            r = [],
            o = [];
        if (0 === Rh.pointsToStrokeWithBuffers(t, e, n, i, s, r, o)) return null;
        const a = new ht;
        return a.setAttribute("position", new Fe(s, 3)), a.setAttribute("normal", new Fe(r, 3)), a.setAttribute("uv", new Fe(o, 2)), a
    }
    static pointsToStrokeWithBuffers(t, e, n, i, s, r, o, a) {
        const l = new Q,
            c = new Q,
            h = new Q,
            u = new Q,
            d = new Q,
            p = new Q,
            f = new Q,
            m = new Q,
            g = new Q,
            v = new Q,
            y = new Q,
            x = new Q,
            b = new Q,
            A = new Q,
            S = new Q,
            w = new Q,
            _ = new Q;
        n = void 0 !== n ? n : 12, i = void 0 !== i ? i : .001, a = void 0 !== a ? a : 0;
        const M = (t = function(t) {
            let e = !1;
            for (let n = 1, s = t.length - 1; n < s; n++)
                if (t[n].distanceTo(t[n + 1]) < i) {
                    e = !0;
                    break
                }
            if (!e) return t;
            const n = [];
            n.push(t[0]);
            for (let e = 1, s = t.length - 1; e < s; e++) t[e].distanceTo(t[e + 1]) >= i && n.push(t[e]);
            return n.push(t[t.length - 1]), n
        }(t)).length;
        if (M < 2) return 0;
        const T = t[0].equals(t[M - 1]);
        let E, C, R = t[0];
        const P = e.strokeWidth / 2,
            D = 1 / (M - 1);
        let I, L, U, O, B = 0,
            N = !1,
            F = 0,
            k = 3 * a,
            z = 2 * a;
        G(t[0], t[1], l).multiplyScalar(P), m.copy(t[0]).sub(l), g.copy(t[0]).add(l), v.copy(m), y.copy(g);
        for (let n = 1; n < M; n++) {
            E = t[n], C = n === M - 1 ? T ? t[1] : void 0 : t[n + 1];
            const i = l;
            if (G(R, E, i), h.copy(i).multiplyScalar(P), x.copy(E).sub(h), b.copy(E).add(h), I = B + D, L = !1, void 0 !== C) {
                G(E, C, c), h.copy(c).multiplyScalar(P), A.copy(E).sub(h), S.copy(E).add(h), U = !0, h.subVectors(C, R), i.dot(h) < 0 && (U = !1), 1 === n && (N = U), h.subVectors(C, E), h.normalize();
                const t = Math.abs(i.dot(h));
                if (t > Number.EPSILON) {
                    const n = P / t;
                    h.multiplyScalar(-n), u.subVectors(E, R), d.copy(u).setLength(n).add(h), w.copy(d).negate();
                    const i = d.length(),
                        s = u.length();
                    u.divideScalar(s), p.subVectors(C, E);
                    const r = p.length();
                    switch (p.divideScalar(r), u.dot(w) < s && p.dot(w) < r && (L = !0), _.copy(d).add(E), w.add(E), O = !1, L ? U ? (S.copy(w), b.copy(w)) : (A.copy(w), x.copy(w)) : W(), e.strokeLineJoin) {
                        case "bevel":
                            j(U, L, I);
                            break;
                        case "round":
                            X(U, L), U ? V(E, x, A, I, 0) : V(E, S, b, I, 1);
                            break;
                        default:
                            const t = P * e.strokeMiterLimit / i;
                            if (t < 1) {
                                if ("miter-clip" !== e.strokeLineJoin) {
                                    j(U, L, I);
                                    break
                                }
                                X(U, L), U ? (p.subVectors(_, x).multiplyScalar(t).add(x), f.subVectors(_, A).multiplyScalar(t).add(A), H(x, I, 0), H(p, I, 0), H(E, I, .5), H(E, I, .5), H(p, I, 0), H(f, I, 0), H(E, I, .5), H(f, I, 0), H(A, I, 0)) : (p.subVectors(_, b).multiplyScalar(t).add(b), f.subVectors(_, S).multiplyScalar(t).add(S), H(b, I, 1), H(p, I, 1), H(E, I, .5), H(E, I, .5), H(p, I, 1), H(f, I, 1), H(E, I, .5), H(f, I, 1), H(S, I, 1))
                            } else L ? (U ? (H(g, B, 1), H(m, B, 0), H(_, I, 0), H(g, B, 1), H(_, I, 0), H(w, I, 1)) : (H(g, B, 1), H(m, B, 0), H(_, I, 1), H(m, B, 0), H(w, I, 0), H(_, I, 1)), U ? A.copy(_) : S.copy(_)) : U ? (H(x, I, 0), H(_, I, 0), H(E, I, .5), H(E, I, .5), H(_, I, 0), H(A, I, 0)) : (H(b, I, 1), H(_, I, 1), H(E, I, .5), H(E, I, .5), H(_, I, 1), H(S, I, 1)), O = !0
                    }
                } else W()
            } else W();
            !T && n === M - 1 && K(t[0], v, y, U, !0, B), B = I, R = E, m.copy(A), g.copy(S)
        }
        if (T) {
            if (L && s) {
                let t = _,
                    e = w;
                N !== U && (t = w, e = _), U ? (O || N) && (e.toArray(s, 0), e.toArray(s, 9), O && t.toArray(s, 3)) : (O || !N) && (e.toArray(s, 3), e.toArray(s, 9), O && t.toArray(s, 0))
            }
        } else K(E, x, b, U, !1, I);
        return F;

        function G(t, e, n) {
            return n.subVectors(e, t), n.set(-n.y, n.x).normalize()
        }

        function H(t, e, n) {
            s && (s[k] = t.x, s[k + 1] = t.y, s[k + 2] = 0, r && (r[k] = 0, r[k + 1] = 0, r[k + 2] = 1), k += 3, o && (o[z] = e, o[z + 1] = n, z += 2)), F += 3
        }

        function V(t, e, i, s, r) {
            l.copy(e).sub(t).normalize(), c.copy(i).sub(t).normalize();
            let o = Math.PI;
            const a = l.dot(c);
            Math.abs(a) < 1 && (o = Math.abs(Math.acos(a))), o /= n, h.copy(e);
            for (let e = 0, i = n - 1; e < i; e++) u.copy(h).rotateAround(t, o), H(h, s, r), H(u, s, r), H(t, s, .5), h.copy(u);
            H(u, s, r), H(i, s, r), H(t, s, .5)
        }

        function W() {
            H(g, B, 1), H(m, B, 0), H(x, I, 0), H(g, B, 1), H(x, I, 0), H(b, I, 1)
        }

        function j(t, e, n) {
            e ? t ? (H(g, B, 1), H(m, B, 0), H(x, I, 0), H(g, B, 1), H(x, I, 0), H(w, I, 1), H(x, n, 0), H(A, n, 0), H(w, n, .5)) : (H(g, B, 1), H(m, B, 0), H(b, I, 1), H(m, B, 0), H(w, I, 0), H(b, I, 1), H(b, n, 1), H(w, n, 0), H(S, n, 1)) : t ? (H(x, n, 0), H(A, n, 0), H(E, n, .5)) : (H(b, n, 1), H(S, n, 0), H(E, n, .5))
        }

        function X(t, e) {
            e && (t ? (H(g, B, 1), H(m, B, 0), H(x, I, 0), H(g, B, 1), H(x, I, 0), H(w, I, 1), H(x, B, 0), H(E, I, .5), H(w, I, 1), H(E, I, .5), H(A, B, 0), H(w, I, 1)) : (H(g, B, 1), H(m, B, 0), H(b, I, 1), H(m, B, 0), H(w, I, 0), H(b, I, 1), H(b, B, 1), H(w, I, 0), H(E, I, .5), H(E, I, .5), H(w, I, 0), H(S, B, 1)))
        }

        function K(t, n, i, r, a, d) {
            switch (e.strokeLineCap) {
                case "round":
                    a ? V(t, i, n, d, .5) : V(t, n, i, d, .5);
                    break;
                case "square":
                    if (a) l.subVectors(n, t), c.set(l.y, -l.x), h.addVectors(l, c).add(t), u.subVectors(c, l).add(t), r ? (h.toArray(s, 3), u.toArray(s, 0), u.toArray(s, 9)) : (h.toArray(s, 3), 1 === o[7] ? u.toArray(s, 9) : h.toArray(s, 9), u.toArray(s, 0));
                    else {
                        l.subVectors(i, t), c.set(l.y, -l.x), h.addVectors(l, c).add(t), u.subVectors(c, l).add(t);
                        const e = s.length;
                        r ? (h.toArray(s, e - 3), u.toArray(s, e - 6), u.toArray(s, e - 12)) : (u.toArray(s, e - 6), h.toArray(s, e - 3), u.toArray(s, e - 12))
                    }
            }
        }
    }
}
const yE = /^[og]\s*(.+)?/,
    xE = /^mtllib /,
    bE = /^usemtl /,
    AE = /^usemap /,
    Pf = new U,
    fc = new U,
    Rf = new U,
    Df = new U,
    Dn = new U;

function SE() {
    const t = {
        objects: [],
        object: {},
        vertices: [],
        normals: [],
        colors: [],
        uvs: [],
        materials: {},
        materialLibraries: [],
        startObject: function(t, e) {
            if (this.object && !1 === this.object.fromDeclaration) return this.object.name = t, void(this.object.fromDeclaration = !1 !== e);
            const n = this.object && "function" == typeof this.object.currentMaterial ? this.object.currentMaterial() : void 0;
            if (this.object && "function" == typeof this.object._finalize && this.object._finalize(!0), this.object = {
                    name: t || "",
                    fromDeclaration: !1 !== e,
                    geometry: {
                        vertices: [],
                        normals: [],
                        colors: [],
                        uvs: [],
                        hasUVIndices: !1
                    },
                    materials: [],
                    smooth: !0,
                    startMaterial: function(t, e) {
                        const n = this._finalize(!1);
                        n && (n.inherited || n.groupCount <= 0) && this.materials.splice(n.index, 1);
                        const i = {
                            index: this.materials.length,
                            name: t || "",
                            mtllib: Array.isArray(e) && e.length > 0 ? e[e.length - 1] : "",
                            smooth: void 0 !== n ? n.smooth : this.smooth,
                            groupStart: void 0 !== n ? n.groupEnd : 0,
                            groupEnd: -1,
                            groupCount: -1,
                            inherited: !1,
                            clone: function(t) {
                                const e = {
                                    index: "number" == typeof t ? t : this.index,
                                    name: this.name,
                                    mtllib: this.mtllib,
                                    smooth: this.smooth,
                                    groupStart: 0,
                                    groupEnd: -1,
                                    groupCount: -1,
                                    inherited: !1
                                };
                                return e.clone = this.clone.bind(e), e
                            }
                        };
                        return this.materials.push(i), i
                    },
                    currentMaterial: function() {
                        if (this.materials.length > 0) return this.materials[this.materials.length - 1]
                    },
                    _finalize: function(t) {
                        const e = this.currentMaterial();
                        if (e && -1 === e.groupEnd && (e.groupEnd = this.geometry.vertices.length / 3, e.groupCount = e.groupEnd - e.groupStart, e.inherited = !1), t && this.materials.length > 1)
                            for (let t = this.materials.length - 1; t >= 0; t--) this.materials[t].groupCount <= 0 && this.materials.splice(t, 1);
                        return t && 0 === this.materials.length && this.materials.push({
                            name: "",
                            smooth: this.smooth
                        }), e
                    }
                }, n && n.name && "function" == typeof n.clone) {
                const t = n.clone(0);
                t.inherited = !0, this.object.materials.push(t)
            }
            this.objects.push(this.object)
        },
        finalize: function() {
            this.object && "function" == typeof this.object._finalize && this.object._finalize(!0)
        },
        parseVertexIndex: function(t, e) {
            const n = parseInt(t, 10);
            return 3 * (n >= 0 ? n - 1 : n + e / 3)
        },
        parseNormalIndex: function(t, e) {
            const n = parseInt(t, 10);
            return 3 * (n >= 0 ? n - 1 : n + e / 3)
        },
        parseUVIndex: function(t, e) {
            const n = parseInt(t, 10);
            return 2 * (n >= 0 ? n - 1 : n + e / 2)
        },
        addVertex: function(t, e, n) {
            const i = this.vertices,
                s = this.object.geometry.vertices;
            s.push(i[t + 0], i[t + 1], i[t + 2]), s.push(i[e + 0], i[e + 1], i[e + 2]), s.push(i[n + 0], i[n + 1], i[n + 2])
        },
        addVertexPoint: function(t) {
            const e = this.vertices;
            this.object.geometry.vertices.push(e[t + 0], e[t + 1], e[t + 2])
        },
        addVertexLine: function(t) {
            const e = this.vertices;
            this.object.geometry.vertices.push(e[t + 0], e[t + 1], e[t + 2])
        },
        addNormal: function(t, e, n) {
            const i = this.normals,
                s = this.object.geometry.normals;
            s.push(i[t + 0], i[t + 1], i[t + 2]), s.push(i[e + 0], i[e + 1], i[e + 2]), s.push(i[n + 0], i[n + 1], i[n + 2])
        },
        addFaceNormal: function(t, e, n) {
            const i = this.vertices,
                s = this.object.geometry.normals;
            Pf.fromArray(i, t), fc.fromArray(i, e), Rf.fromArray(i, n), Dn.subVectors(Rf, fc), Df.subVectors(Pf, fc), Dn.cross(Df), Dn.normalize(), s.push(Dn.x, Dn.y, Dn.z), s.push(Dn.x, Dn.y, Dn.z), s.push(Dn.x, Dn.y, Dn.z)
        },
        addColor: function(t, e, n) {
            const i = this.colors,
                s = this.object.geometry.colors;
            void 0 !== i[t] && s.push(i[t + 0], i[t + 1], i[t + 2]), void 0 !== i[e] && s.push(i[e + 0], i[e + 1], i[e + 2]), void 0 !== i[n] && s.push(i[n + 0], i[n + 1], i[n + 2])
        },
        addUV: function(t, e, n) {
            const i = this.uvs,
                s = this.object.geometry.uvs;
            s.push(i[t + 0], i[t + 1]), s.push(i[e + 0], i[e + 1]), s.push(i[n + 0], i[n + 1])
        },
        addDefaultUV: function() {
            const t = this.object.geometry.uvs;
            t.push(0, 0), t.push(0, 0), t.push(0, 0)
        },
        addUVLine: function(t) {
            const e = this.uvs;
            this.object.geometry.uvs.push(e[t + 0], e[t + 1])
        },
        addFace: function(t, e, n, i, s, r, o, a, l) {
            const c = this.vertices.length;
            let h = this.parseVertexIndex(t, c),
                u = this.parseVertexIndex(e, c),
                d = this.parseVertexIndex(n, c);
            if (this.addVertex(h, u, d), this.addColor(h, u, d), void 0 !== o && "" !== o) {
                const t = this.normals.length;
                h = this.parseNormalIndex(o, t), u = this.parseNormalIndex(a, t), d = this.parseNormalIndex(l, t), this.addNormal(h, u, d)
            } else this.addFaceNormal(h, u, d);
            if (void 0 !== i && "" !== i) {
                const t = this.uvs.length;
                h = this.parseUVIndex(i, t), u = this.parseUVIndex(s, t), d = this.parseUVIndex(r, t), this.addUV(h, u, d), this.object.geometry.hasUVIndices = !0
            } else this.addDefaultUV()
        },
        addPointGeometry: function(t) {
            this.object.geometry.type = "Points";
            const e = this.vertices.length;
            for (let n = 0, i = t.length; n < i; n++) {
                const i = this.parseVertexIndex(t[n], e);
                this.addVertexPoint(i), this.addColor(i)
            }
        },
        addLineGeometry: function(t, e) {
            this.object.geometry.type = "Line";
            const n = this.vertices.length,
                i = this.uvs.length;
            for (let e = 0, i = t.length; e < i; e++) this.addVertexLine(this.parseVertexIndex(t[e], n));
            for (let t = 0, n = e.length; t < n; t++) this.addUVLine(this.parseUVIndex(e[t], i))
        }
    };
    return t.startObject("", !1), t
}
class _E extends is {
    constructor(t) {
        super(t), this.materials = null
    }
    load(t, e, n, i) {
        const s = this,
            r = new qa(this.manager);
        r.setPath(this.path), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials), r.load(t, (function(n) {
            try {
                e(s.parse(n))
            } catch (e) {
                i ? i(e) : console.error(e), s.manager.itemError(t)
            }
        }), n, i)
    }
    setMaterials(t) {
        return this.materials = t, this
    }
    parse(t) {
        const e = new SE; - 1 !== t.indexOf("\r\n") && (t = t.replace(/\r\n/g, "\n")), -1 !== t.indexOf("\\\n") && (t = t.replace(/\\\n/g, ""));
        const n = t.split("\n");
        let i = "",
            s = "",
            r = 0,
            o = [];
        const a = "function" == typeof "".trimLeft;
        for (let t = 0, l = n.length; t < l; t++)
            if (i = n[t], i = a ? i.trimLeft() : i.trim(), r = i.length, 0 !== r && (s = i.charAt(0), "#" !== s))
                if ("v" === s) {
                    const t = i.split(/\s+/);
                    switch (t[0]) {
                        case "v":
                            e.vertices.push(parseFloat(t[1]), parseFloat(t[2]), parseFloat(t[3])), t.length >= 7 ? e.colors.push(parseFloat(t[4]), parseFloat(t[5]), parseFloat(t[6])) : e.colors.push(void 0, void 0, void 0);
                            break;
                        case "vn":
                            e.normals.push(parseFloat(t[1]), parseFloat(t[2]), parseFloat(t[3]));
                            break;
                        case "vt":
                            e.uvs.push(parseFloat(t[1]), parseFloat(t[2]))
                    }
                } else if ("f" === s) {
            const t = i.substr(1).trim().split(/\s+/),
                n = [];
            for (let e = 0, i = t.length; e < i; e++) {
                const i = t[e];
                if (i.length > 0) {
                    const t = i.split("/");
                    n.push(t)
                }
            }
            const s = n[0];
            for (let t = 1, i = n.length - 1; t < i; t++) {
                const i = n[t],
                    r = n[t + 1];
                e.addFace(s[0], i[0], r[0], s[1], i[1], r[1], s[2], i[2], r[2])
            }
        } else if ("l" === s) {
            const t = i.substring(1).trim().split(" ");
            let n = [];
            const s = [];
            if (-1 === i.indexOf("/")) n = t;
            else
                for (let e = 0, i = t.length; e < i; e++) {
                    const i = t[e].split("/");
                    "" !== i[0] && n.push(i[0]), "" !== i[1] && s.push(i[1])
                }
            e.addLineGeometry(n, s)
        } else if ("p" === s) {
            const t = i.substr(1).trim().split(" ");
            e.addPointGeometry(t)
        } else if (null !== (o = yE.exec(i))) {
            const t = (" " + o[0].substr(1).trim()).substr(1);
            e.startObject(t)
        } else if (bE.test(i)) e.object.startMaterial(i.substring(7).trim(), e.materialLibraries);
        else if (xE.test(i)) e.materialLibraries.push(i.substring(7).trim());
        else if (AE.test(i)) console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');
        else if ("s" === s) {
            if (o = i.split(" "), o.length > 1) {
                const t = o[1].trim().toLowerCase();
                e.object.smooth = "0" !== t && "off" !== t
            } else e.object.smooth = !0;
            const t = e.object.currentMaterial();
            t && (t.smooth = e.object.smooth)
        } else {
            if ("\0" === i) continue;
            console.warn('THREE.OBJLoader: Unexpected line: "' + i + '"')
        }
        e.finalize();
        const l = new Fn;
        if (l.materialLibraries = [].concat(e.materialLibraries), !0 == !(1 === e.objects.length && 0 === e.objects[0].geometry.vertices.length))
            for (let t = 0, n = e.objects.length; t < n; t++) {
                const n = e.objects[t],
                    i = n.geometry,
                    s = n.materials,
                    r = "Line" === i.type,
                    o = "Points" === i.type;
                let a = !1;
                if (0 === i.vertices.length) continue;
                const c = new ht;
                c.setAttribute("position", new Fe(i.vertices, 3)), i.normals.length > 0 && c.setAttribute("normal", new Fe(i.normals, 3)), i.colors.length > 0 && (a = !0, c.setAttribute("color", new Fe(i.colors, 3))), !0 === i.hasUVIndices && c.setAttribute("uv", new Fe(i.uvs, 2));
                const h = [];
                for (let t = 0, n = s.length; t < n; t++) {
                    const n = s[t],
                        i = n.name + "_" + n.smooth + "_" + a;
                    let l = e.materials[i];
                    if (null !== this.materials)
                        if (l = this.materials.create(n.name), !r || !l || l instanceof Zi) {
                            if (o && l && !(l instanceof xs)) {
                                const t = new xs({
                                    size: 10,
                                    sizeAttenuation: !1
                                });
                                en.prototype.copy.call(t, l), t.color.copy(l.color), t.map = l.map, l = t
                            }
                        } else {
                            const t = new Zi;
                            en.prototype.copy.call(t, l), t.color.copy(l.color), l = t
                        }
                    void 0 === l && (l = r ? new Zi : o ? new xs({
                        size: 1,
                        sizeAttenuation: !1
                    }) : new kp, l.name = n.name, l.flatShading = !n.smooth, l.vertexColors = a, e.materials[i] = l), h.push(l)
                }
                let u;
                if (h.length > 1) {
                    for (let t = 0, e = s.length; t < e; t++) {
                        const e = s[t];
                        c.addGroup(e.groupStart, e.groupCount, t)
                    }
                    u = r ? new mo(c, h) : o ? new so(c, h) : new be(c, h)
                } else u = r ? new mo(c, h[0]) : o ? new so(c, h[0]) : new be(c, h[0]);
                u.name = n.name, l.add(u)
            } else if (e.vertices.length > 0) {
                const t = new xs({
                        size: 1,
                        sizeAttenuation: !1
                    }),
                    n = new ht;
                n.setAttribute("position", new Fe(e.vertices, 3)), e.colors.length > 0 && void 0 !== e.colors[0] && (n.setAttribute("color", new Fe(e.colors, 3)), t.vertexColors = !0);
                const i = new so(n, t);
                l.add(i)
            }
        return l
    }
}
const If = new Tn,
    ga = new U;
class xo extends h_ {
    constructor() {
        super(), this.isLineSegmentsGeometry = !0, this.type = "LineSegmentsGeometry";
        this.setIndex([0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5]), this.setAttribute("position", new Fe([-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], 3)), this.setAttribute("uv", new Fe([-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], 2))
    }
    applyMatrix4(t) {
        const e = this.attributes.instanceStart,
            n = this.attributes.instanceEnd;
        return void 0 !== e && (e.applyMatrix4(t), n.applyMatrix4(t), e.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
    }
    setPositions(t) {
        let e;
        t instanceof Float32Array ? e = t : Array.isArray(t) && (e = new Float32Array(t));
        const n = new Gc(e, 6, 1);
        return this.setAttribute("instanceStart", new Qn(n, 3, 0)), this.setAttribute("instanceEnd", new Qn(n, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this
    }
    setColors(t, e = 3) {
        let n;
        t instanceof Float32Array ? n = t : Array.isArray(t) && (n = new Float32Array(t));
        const i = new Gc(n, 2 * e, 1);
        return this.setAttribute("instanceColorStart", new Qn(i, e, 0)), this.setAttribute("instanceColorEnd", new Qn(i, e, e)), this
    }
    fromWireframeGeometry(t) {
        return this.setPositions(t.attributes.position.array), this
    }
    fromEdgesGeometry(t) {
        return this.setPositions(t.attributes.position.array), this
    }
    fromMesh(t) {
        return this.fromWireframeGeometry(new XS(t.geometry)), this
    }
    fromLineSegments(t) {
        const e = t.geometry;
        return this.setPositions(e.attributes.position.array), this
    }
    computeBoundingBox() {
        null === this.boundingBox && (this.boundingBox = new Tn);
        const t = this.attributes.instanceStart,
            e = this.attributes.instanceEnd;
        void 0 !== t && void 0 !== e && (this.boundingBox.setFromBufferAttribute(t), If.setFromBufferAttribute(e), this.boundingBox.union(If))
    }
    computeBoundingSphere() {
        null === this.boundingSphere && (this.boundingSphere = new Hn), null === this.boundingBox && this.computeBoundingBox();
        const t = this.attributes.instanceStart,
            e = this.attributes.instanceEnd;
        if (void 0 !== t && void 0 !== e) {
            const n = this.boundingSphere.center;
            this.boundingBox.getCenter(n);
            let i = 0;
            for (let s = 0, r = t.count; s < r; s++) ga.fromBufferAttribute(t, s), i = Math.max(i, n.distanceToSquared(ga)), ga.fromBufferAttribute(e, s), i = Math.max(i, n.distanceToSquared(ga));
            this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this)
        }
    }
    toJSON() {}
    applyMatrix(t) {
        return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."), this.applyMatrix4(t)
    }
}
class Nr extends It {
    constructor(t) {
        super({
            type: "LineMaterial",
            uniforms: Lc.clone(Lc.merge([Te.common, Te.fog, {
                worldUnits: {
                    value: 1
                },
                linewidth: {
                    value: 1
                },
                resolution: {
                    value: new Q(1, 1)
                },
                dashOffset: {
                    value: 0
                },
                dashScale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                gapSize: {
                    value: 1
                }
            }])),
            vertexShader: "\n\t\t\t\t#include <common>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\t\t\t\t#include <clipping_planes_pars_vertex>\n\n\t\t\t\tuniform float linewidth;\n\t\t\t\tuniform vec2 resolution;\n\n\t\t\t\tattribute vec3 instanceStart;\n\t\t\t\tattribute vec3 instanceEnd;\n\n\t\t\t\t#ifdef USE_COLOR\n\t\t\t\t\t#ifdef USE_LINE_COLOR_ALPHA\n\t\t\t\t\t\tvarying vec4 vLineColor;\n\t\t\t\t\t\tattribute vec4 instanceColorStart;\n\t\t\t\t\t\tattribute vec4 instanceColorEnd;\n\t\t\t\t\t#else\n\t\t\t\t\t\tvarying vec3 vLineColor;\n\t\t\t\t\t\tattribute vec3 instanceColorStart;\n\t\t\t\t\t\tattribute vec3 instanceColorEnd;\n\t\t\t\t\t#endif\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t\tvarying vec4 worldPos;\n\t\t\t\t\tvarying vec3 worldStart;\n\t\t\t\t\tvarying vec3 worldEnd;\n\n\t\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#else\n\n\t\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\tuniform float dashScale;\n\t\t\t\t\tattribute float instanceDistanceStart;\n\t\t\t\t\tattribute float instanceDistanceEnd;\n\t\t\t\t\tvarying float vLineDistance;\n\n\t\t\t\t#endif\n\n\t\t\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t\t\t// conservative estimate of the near plane\n\t\t\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#ifdef USE_COLOR\n\n\t\t\t\t\t\tvLineColor = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\t\t\t\t\t\tvUv = uv;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\t\t\t// camera space\n\t\t\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t\t\tworldStart = start.xyz;\n\t\t\t\t\t\tworldEnd = end.xyz;\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tvUv = uv;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\t\t\tif ( perspective ) {\n\n\t\t\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// clip space\n\t\t\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t\t\t// ndc space\n\t\t\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\t\t\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t\t\t\t\t// direction\n\t\t\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t\t\t\t\t// account for clip-space aspect ratio\n\t\t\t\t\tdir.x *= aspect;\n\t\t\t\t\tdir = normalize( dir );\n\n\t\t\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t\t\t// get the offset direction as perpendicular to the view vector\n\t\t\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\t\t\t\t\t\tvec3 offset;\n\t\t\t\t\t\tif ( position.y < 0.5 ) {\n\n\t\t\t\t\t\t\toffset = normalize( cross( start.xyz, worldDir ) );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\toffset = normalize( cross( end.xyz, worldDir ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// sign flip\n\t\t\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t\t\tfloat forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );\n\n\t\t\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t\t\t// won't be rendering the endcaps\n\t\t\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t\t\t// extend the line bounds to encompass  endcaps\n\t\t\t\t\t\t\tstart.xyz += - worldDir * linewidth * 0.5;\n\t\t\t\t\t\t\tend.xyz += worldDir * linewidth * 0.5;\n\n\t\t\t\t\t\t\t// shift the position of the quad so it hugs the forward edge of the line\n\t\t\t\t\t\t\toffset.xy -= dir * forwardOffset;\n\t\t\t\t\t\t\toffset.z += 0.5;\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// endcaps\n\t\t\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\n\n\t\t\t\t\t\t\toffset.xy += dir * 2.0 * forwardOffset;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// adjust for linewidth\n\t\t\t\t\t\toffset *= linewidth * 0.5;\n\n\t\t\t\t\t\t// set the world position\n\t\t\t\t\t\tworldPos = ( position.y < 0.5 ) ? start : end;\n\t\t\t\t\t\tworldPos.xyz += offset;\n\n\t\t\t\t\t\t// project the worldpos\n\t\t\t\t\t\tvec4 clip = projectionMatrix * worldPos;\n\n\t\t\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t\t\t// segments overlap neatly\n\t\t\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n\t\t\t\t\t\tclip.z = clipPose.z * clip.w;\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\t\t\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\t\t\tdir.x /= aspect;\n\t\t\t\t\t\toffset.x /= aspect;\n\n\t\t\t\t\t\t// sign flip\n\t\t\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t\t\t// endcaps\n\t\t\t\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\t\t\t\toffset += - dir;\n\n\t\t\t\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\t\t\t\toffset += dir;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// adjust for linewidth\n\t\t\t\t\t\toffset *= linewidth;\n\n\t\t\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\t\t\toffset /= resolution.y;\n\n\t\t\t\t\t\t// select end\n\t\t\t\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t\t\t\t// back to clip space\n\t\t\t\t\t\toffset *= clip.w;\n\n\t\t\t\t\t\tclip.xy += offset;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tgl_Position = clip;\n\n\t\t\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t\t#include <clipping_planes_vertex>\n\t\t\t\t\t#include <fog_vertex>\n\n\t\t\t\t}\n\t\t\t",
            fragmentShader: `\n\t\t\t\tuniform vec3 diffuse;\n\t\t\t\tuniform float opacity;\n\t\t\t\tuniform float linewidth;\n\n\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\tuniform float dashOffset;\n\t\t\t\t\tuniform float dashSize;\n\t\t\t\t\tuniform float gapSize;\n\n\t\t\t\t#endif\n\n\t\t\t\tvarying float vLineDistance;\n\n\t\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t\tvarying vec4 worldPos;\n\t\t\t\t\tvarying vec3 worldStart;\n\t\t\t\t\tvarying vec3 worldEnd;\n\n\t\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#else\n\n\t\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t#endif\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <fog_pars_fragment>\n\t\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t\t#include <clipping_planes_pars_fragment>\n\n\t\t\t\t#ifdef USE_COLOR\n\t\t\t\t\t#ifdef USE_LINE_COLOR_ALPHA\n\t\t\t\t\t\tvarying vec4 vLineColor;\n\t\t\t\t\t#else\n\t\t\t\t\t\tvarying vec3 vLineColor;\n\t\t\t\t\t#endif\n\t\t\t\t#endif\n\n\t\t\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n\t\t\t\t\tfloat mua;\n\t\t\t\t\tfloat mub;\n\n\t\t\t\t\tvec3 p13 = p1 - p3;\n\t\t\t\t\tvec3 p43 = p4 - p3;\n\n\t\t\t\t\tvec3 p21 = p2 - p1;\n\n\t\t\t\t\tfloat d1343 = dot( p13, p43 );\n\t\t\t\t\tfloat d4321 = dot( p43, p21 );\n\t\t\t\t\tfloat d1321 = dot( p13, p21 );\n\t\t\t\t\tfloat d4343 = dot( p43, p43 );\n\t\t\t\t\tfloat d2121 = dot( p21, p21 );\n\n\t\t\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\n\n\t\t\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\n\n\t\t\t\t\tmua = numer / denom;\n\t\t\t\t\tmua = clamp( mua, 0.0, 1.0 );\n\t\t\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\n\t\t\t\t\tmub = clamp( mub, 0.0, 1.0 );\n\n\t\t\t\t\treturn vec2( mua, mub );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tfloat alpha = opacity;\n\n\t\t\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n\t\t\t\t\t\tvec3 lineDir = worldEnd - worldStart;\n\t\t\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n\t\t\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\n\t\t\t\t\t\tvec3 p2 = rayEnd * params.y;\n\t\t\t\t\t\tvec3 delta = p1 - p2;\n\t\t\t\t\t\tfloat len = length( delta );\n\t\t\t\t\t\tfloat norm = len / linewidth;\n\n\t\t\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\t\t\tfloat dnorm = fwidth( norm );\n\t\t\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n\t\t\t\t\t\t\t#else\n\n\t\t\t\t\t\t\t\tif ( norm > 0.5 ) {\n\n\t\t\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\t\t\tfloat len2 = a * a + b * b;\n\t\t\t\t\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t#else\n\n\t\t\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\t\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\t\t\t\t\t#ifdef USE_COLOR\n\t\t\t\t\t\t#ifdef USE_LINE_COLOR_ALPHA\n\t\t\t\t\t\t\tdiffuseColor *= vLineColor;\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\tdiffuseColor.rgb *= vLineColor;\n\t\t\t\t\t\t#endif\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\t\t\tgl_FragColor = diffuseColor;\n\n\t\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t\t#include <${parseInt(ns.replace(/\D+/g,""))>=154?"colorspace_fragment":"encodings_fragment"}>\n\t\t\t\t\t#include <fog_fragment>\n\t\t\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t\t\t}\n\t\t\t`,
            clipping: !0
        }), this.isLineMaterial = !0, this.onBeforeCompile = function() {
            this.transparent ? this.defines.USE_LINE_COLOR_ALPHA = "1" : delete this.defines.USE_LINE_COLOR_ALPHA
        }, Object.defineProperties(this, {
            color: {
                enumerable: !0,
                get: function() {
                    return this.uniforms.diffuse.value
                },
                set: function(t) {
                    this.uniforms.diffuse.value = t
                }
            },
            worldUnits: {
                enumerable: !0,
                get: function() {
                    return "WORLD_UNITS" in this.defines
                },
                set: function(t) {
                    !0 === t ? this.defines.WORLD_UNITS = "" : delete this.defines.WORLD_UNITS
                }
            },
            linewidth: {
                enumerable: !0,
                get: function() {
                    return this.uniforms.linewidth.value
                },
                set: function(t) {
                    this.uniforms.linewidth.value = t
                }
            },
            dashed: {
                enumerable: !0,
                get: function() {
                    return "USE_DASH" in this.defines
                },
                set(t) {
                    !!t != "USE_DASH" in this.defines && (this.needsUpdate = !0), !0 === t ? this.defines.USE_DASH = "" : delete this.defines.USE_DASH
                }
            },
            dashScale: {
                enumerable: !0,
                get: function() {
                    return this.uniforms.dashScale.value
                },
                set: function(t) {
                    this.uniforms.dashScale.value = t
                }
            },
            dashSize: {
                enumerable: !0,
                get: function() {
                    return this.uniforms.dashSize.value
                },
                set: function(t) {
                    this.uniforms.dashSize.value = t
                }
            },
            dashOffset: {
                enumerable: !0,
                get: function() {
                    return this.uniforms.dashOffset.value
                },
                set: function(t) {
                    this.uniforms.dashOffset.value = t
                }
            },
            gapSize: {
                enumerable: !0,
                get: function() {
                    return this.uniforms.gapSize.value
                },
                set: function(t) {
                    this.uniforms.gapSize.value = t
                }
            },
            opacity: {
                enumerable: !0,
                get: function() {
                    return this.uniforms.opacity.value
                },
                set: function(t) {
                    this.uniforms.opacity.value = t
                }
            },
            resolution: {
                enumerable: !0,
                get: function() {
                    return this.uniforms.resolution.value
                },
                set: function(t) {
                    this.uniforms.resolution.value.copy(t)
                }
            },
            alphaToCoverage: {
                enumerable: !0,
                get: function() {
                    return "USE_ALPHA_TO_COVERAGE" in this.defines
                },
                set: function(t) {
                    !!t != "USE_ALPHA_TO_COVERAGE" in this.defines && (this.needsUpdate = !0), !0 === t ? (this.defines.USE_ALPHA_TO_COVERAGE = "", this.extensions.derivatives = !0) : (delete this.defines.USE_ALPHA_TO_COVERAGE, this.extensions.derivatives = !1)
                }
            }
        }), this.setValues(t)
    }
}
const pc = new ot,
    Lf = new U,
    Of = new U,
    qt = new ot,
    Zt = new ot,
    Jn = new ot,
    mc = new U,
    gc = new Xe,
    Jt = new S_,
    Bf = new U,
    va = new Tn,
    ya = new Hn,
    $n = new ot;
let ii, Ts;

function Uf(t, e, n) {
    return $n.set(0, 0, -e, 1).applyMatrix4(t.projectionMatrix), $n.multiplyScalar(1 / $n.w), $n.x = Ts / n.width, $n.y = Ts / n.height, $n.applyMatrix4(t.projectionMatrixInverse), $n.multiplyScalar(1 / $n.w), Math.abs(Math.max($n.x, $n.y))
}

function wE(t, e) {
    const n = t.matrixWorld,
        i = t.geometry,
        s = i.attributes.instanceStart,
        r = i.attributes.instanceEnd;
    for (let o = 0, a = Math.min(i.instanceCount, s.count); o < a; o++) {
        Jt.start.fromBufferAttribute(s, o), Jt.end.fromBufferAttribute(r, o), Jt.applyMatrix4(n);
        const i = new U,
            a = new U;
        ii.distanceSqToSegment(Jt.start, Jt.end, a, i), a.distanceTo(i) < .5 * Ts && e.push({
            point: a,
            pointOnLine: i,
            distance: ii.origin.distanceTo(a),
            object: t,
            face: null,
            faceIndex: o,
            uv: null,
            [$p]: null
        })
    }
}

function ME(t, e, n) {
    const i = e.projectionMatrix,
        s = t.material.resolution,
        r = t.matrixWorld,
        o = t.geometry,
        a = o.attributes.instanceStart,
        l = o.attributes.instanceEnd,
        c = Math.min(o.instanceCount, a.count),
        h = -e.near;
    ii.at(1, Jn), Jn.w = 1, Jn.applyMatrix4(e.matrixWorldInverse), Jn.applyMatrix4(i), Jn.multiplyScalar(1 / Jn.w), Jn.x *= s.x / 2, Jn.y *= s.y / 2, Jn.z = 0, mc.copy(Jn), gc.multiplyMatrices(e.matrixWorldInverse, r);
    for (let e = 0, o = c; e < o; e++) {
        if (qt.fromBufferAttribute(a, e), Zt.fromBufferAttribute(l, e), qt.w = 1, Zt.w = 1, qt.applyMatrix4(gc), Zt.applyMatrix4(gc), qt.z > h && Zt.z > h) continue;
        if (qt.z > h) {
            const t = qt.z - Zt.z,
                e = (qt.z - h) / t;
            qt.lerp(Zt, e)
        } else if (Zt.z > h) {
            const t = Zt.z - qt.z,
                e = (Zt.z - h) / t;
            Zt.lerp(qt, e)
        }
        qt.applyMatrix4(i), Zt.applyMatrix4(i), qt.multiplyScalar(1 / qt.w), Zt.multiplyScalar(1 / Zt.w), qt.x *= s.x / 2, qt.y *= s.y / 2, Zt.x *= s.x / 2, Zt.y *= s.y / 2, Jt.start.copy(qt), Jt.start.z = 0, Jt.end.copy(Zt), Jt.end.z = 0;
        const o = Jt.closestPointToPointParameter(mc, !0);
        Jt.at(o, Bf);
        const c = _i.lerp(qt.z, Zt.z, o),
            u = c >= -1 && c <= 1,
            d = mc.distanceTo(Bf) < .5 * Ts;
        if (u && d) {
            Jt.start.fromBufferAttribute(a, e), Jt.end.fromBufferAttribute(l, e), Jt.start.applyMatrix4(r), Jt.end.applyMatrix4(r);
            const i = new U,
                s = new U;
            ii.distanceSqToSegment(Jt.start, Jt.end, s, i), n.push({
                point: s,
                pointOnLine: i,
                distance: ii.origin.distanceTo(s),
                object: t,
                face: null,
                faceIndex: e,
                uv: null,
                [$p]: null
            })
        }
    }
}
class Eo extends be {
    constructor(t = new xo, e = new Nr({
        color: 16777215 * Math.random()
    })) {
        super(t, e), this.isLineSegments2 = !0, this.type = "LineSegments2"
    }
    computeLineDistances() {
        const t = this.geometry,
            e = t.attributes.instanceStart,
            n = t.attributes.instanceEnd,
            i = new Float32Array(2 * e.count);
        for (let t = 0, s = 0, r = e.count; t < r; t++, s += 2) Lf.fromBufferAttribute(e, t), Of.fromBufferAttribute(n, t), i[s] = 0 === s ? 0 : i[s - 1], i[s + 1] = i[s] + Lf.distanceTo(Of);
        const s = new Gc(i, 2, 1);
        return t.setAttribute("instanceDistanceStart", new Qn(s, 1, 0)), t.setAttribute("instanceDistanceEnd", new Qn(s, 1, 1)), this
    }
    raycast(t, e) {
        const n = this.material.worldUnits,
            i = t.camera;
        null === i && !n && console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');
        const s = void 0 !== t.params.Line2 && t.params.Line2.threshold || 0;
        ii = t.ray;
        const r = this.matrixWorld,
            o = this.geometry,
            a = this.material;
        let l, c;
        if (Ts = a.linewidth + s, null === o.boundingSphere && o.computeBoundingSphere(), ya.copy(o.boundingSphere).applyMatrix4(r), n) l = .5 * Ts;
        else {
            l = Uf(i, Math.max(i.near, ya.distanceToPoint(ii.origin)), a.resolution)
        }
        if (ya.radius += l, !1 !== ii.intersectsSphere(ya)) {
            if (null === o.boundingBox && o.computeBoundingBox(), va.copy(o.boundingBox).applyMatrix4(r), n) c = .5 * Ts;
            else {
                c = Uf(i, Math.max(i.near, va.distanceToPoint(ii.origin)), a.resolution)
            }
            va.expandByScalar(c), !1 !== ii.intersectsBox(va) && (n ? wE(this, e) : ME(this, i, e))
        }
    }
    onBeforeRender(t) {
        const e = this.material.uniforms;
        e && e.resolution && (t.getViewport(pc), this.material.uniforms.resolution.value.set(pc.z, pc.w))
    }
}
const nm = Math.sqrt(3),
    EE = .5 * (nm - 1),
    eo = (3 - nm) / 6,
    Nf = t => 0 | Math.floor(t),
    Ff = new Float64Array([1, 1, -1, 1, 1, -1, -1, -1, 1, 0, -1, 0, 1, 0, -1, 0, 0, 1, 0, -1, 0, 1, 0, -1]);

function TE(t = Math.random) {
    const e = CE(t),
        n = new Float64Array(e).map((t => Ff[t % 12 * 2])),
        i = new Float64Array(e).map((t => Ff[t % 12 * 2 + 1]));
    return function(t, s) {
        let r = 0,
            o = 0,
            a = 0;
        const l = (t + s) * EE,
            c = Nf(t + l),
            h = Nf(s + l),
            u = (c + h) * eo,
            d = t - (c - u),
            p = s - (h - u);
        let f, m;
        d > p ? (f = 1, m = 0) : (f = 0, m = 1);
        const g = d - f + eo,
            v = p - m + eo,
            y = d - 1 + 2 * eo,
            x = p - 1 + 2 * eo,
            b = 255 & c,
            A = 255 & h;
        let S = .5 - d * d - p * p;
        if (S >= 0) {
            const t = b + e[A];
            S *= S, r = S * S * (n[t] * d + i[t] * p)
        }
        let w = .5 - g * g - v * v;
        if (w >= 0) {
            const t = b + f + e[A + m];
            w *= w, o = w * w * (n[t] * g + i[t] * v)
        }
        let _ = .5 - y * y - x * x;
        if (_ >= 0) {
            const t = b + 1 + e[A + 1];
            _ *= _, a = _ * _ * (n[t] * y + i[t] * x)
        }
        return 70 * (r + o + a)
    }
}

function CE(t) {
    const e = new Uint8Array(512);
    for (let t = 0; t < 256; t++) e[t] = t;
    for (let n = 0; n < 255; n++) {
        const i = n + ~~(t() * (256 - n)),
            s = e[n];
        e[n] = e[i], e[i] = s
    }
    for (let t = 256; t < 512; t++) e[t] = e[t - 256];
    return e
}
var PE = Object.defineProperty,
    RE = (t, e, n) => e in t ? PE(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : t[e] = n,
    T = (t, e, n) => RE(t, "symbol" != typeof e ? e + "" : e, n);
const DE = Object.freeze(Object.defineProperty({
        __proto__: null,
        get Agent() {
            return kr
        },
        get Agent3d() {
            return ai
        },
        get AgentBinding() {
            return Xh
        },
        get AmbientLight() {
            return gg
        },
        get AnchorPoint2D() {
            return dm
        },
        get Attribution() {
            return ys
        },
        get Background() {
            return dl
        },
        get BlendFunction() {
            return Ae
        },
        get BloomEffect() {
            return Yh
        },
        get BlurEffect() {
            return mg
        },
        get BokehEffect() {
            return cg
        },
        get BrightnessContrastEffect() {
            return Qh
        },
        get CANVAS_CLASSNAME() {
            return ho
        },
        get CLOCK_FPS_DEFAULT() {
            return ka
        },
        get CLOCK_FPS_MAX() {
            return Uh
        },
        get CLOCK_FPS_MIN() {
            return Bh
        },
        get CP_COLOR() {
            return Mt
        },
        get CP_DIAL() {
            return _e
        },
        get CP_POSITION() {
            return co
        },
        get CP_ROTATION() {
            return um
        },
        get CP_ROTATION_LIMITS() {
            return Lh
        },
        get CP_UNITS_001() {
            return mn
        },
        get CP_UNITS_01() {
            return lt
        },
        get CP_UNITS_10() {
            return Is
        },
        get CP_UNITS_100() {
            return Ih
        },
        get CP_UNITS_1000() {
            return hm
        },
        get CanvasDisplay() {
            return ul
        },
        get CanvasMotif() {
            return bg
        },
        get ChromaticAberrationEffect() {
            return Jh
        },
        get Clock() {
            return zt
        },
        get Color() {
            return Qe
        },
        get ColorBackground() {
            return Kh
        },
        get Config() {
            return zm
        },
        get ControlPalette() {
            return qm
        },
        get DATASET_INSTANCE_KEY() {
            return Ss
        },
        get DATASET_SHOT_KEY() {
            return Dh
        },
        get DATASET_STAGE_KEY() {
            return bo
        },
        get DATASET_STATUS() {
            return Na
        },
        get DOM_AVAILABLE() {
            return Mn
        },
        get Demo() {
            return sg
        },
        get Display() {
            return pt
        },
        get Effect() {
            return sn
        },
        get ErmBackground() {
            return lg
        },
        get ErmSkyboxMotif() {
            return Ag
        },
        get FXAAEffect() {
            return eu
        },
        get FadeTexture() {
            return Dg
        },
        get FloorMotif() {
            return Sg
        },
        get GradientSkyboxMaterial() {
            return tu
        },
        get GradientSkyboxMotif() {
            return nu
        },
        get GridEffect() {
            return qh
        },
        get HemisphereLight() {
            return yg
        },
        get HueSaturationEffect() {
            return dg
        },
        get IS_IOS() {
            return Fa
        },
        get ImageMotif() {
            return _g
        },
        get InstancedMeshMotif() {
            return Rg
        },
        get KITS_ENDPOINT() {
            return Za
        },
        get Kit() {
            return eg
        },
        get LAYER_HITBOXES() {
            return mr
        },
        get LAYER_VISIBLE() {
            return lo
        },
        get LICENSE_3D_OCEAN_REGULAR() {
            return pm
        },
        get LICENSE_CC0() {
            return vm
        },
        get LICENSE_CC_BY_3() {
            return mm
        },
        get LICENSE_CC_BY_4() {
            return gm
        },
        get LICENSE_NASA_MEDIA() {
            return ym
        },
        get LabelMotif() {
            return wg
        },
        get LensDistortionEffect() {
            return $h
        },
        get Light() {
            return ts
        },
        get LineSegmentsMotif() {
            return Tg
        },
        get Logger() {
            return To
        },
        get MAT_BASIC() {
            return im
        },
        get MAT_LAMBERT() {
            return rm
        },
        get MAT_MATCAP() {
            return sm
        },
        get MAT_PHONG() {
            return om
        },
        get MAT_PHYSICAL() {
            return cm
        },
        get MAT_STANDARD() {
            return lm
        },
        get MAT_TOON() {
            return am
        },
        get MeshMotif() {
            return Ui
        },
        get ModelMotif() {
            return Mg
        },
        get Motif() {
            return xt
        },
        get NodeNetworkMotif() {
            return Eg
        },
        get NoiseEffect() {
            return Zh
        },
        get OFFSCREEN_CANVAS_AVAILABLE() {
            return Oh
        },
        get OffscreenCanvasDisplay() {
            return So
        },
        get OrbitCamera() {
            return ml
        },
        get Pass() {
            return pl
        },
        get PixelationEffect() {
            return ug
        },
        get PlinthGeometry() {
            return iu
        },
        get PlinthMotif() {
            return Cg
        },
        get Plugin() {
            return ng
        },
        get PluginRegistry() {
            return Ao
        },
        get PointCloudMotif() {
            return vl
        },
        get PointLight() {
            return xg
        },
        get PointerEventScreenMotif() {
            return Pg
        },
        get Post() {
            return fl
        },
        get PublicEventTarget() {
            return tl
        },
        get RenderManager() {
            return Wh
        },
        get SMAAEffect() {
            return pg
        },
        get SMAAPreset() {
            return Un
        },
        get SOURCE_3D_OCEAN() {
            return bm
        },
        get SOURCE_PEXELS() {
            return Am
        },
        get SOURCE_POLY_PIZZA() {
            return xm
        },
        get SOURCE_SKETCHFAB() {
            return Sm
        },
        get ScanlinesEffect() {
            return fg
        },
        get SceneController() {
            return jh
        },
        get Sequence() {
            return Fr
        },
        get SequenceStep() {
            return gr
        },
        get Shot() {
            return Gt
        },
        get SkyboxMotif() {
            return gl
        },
        get SpotLight() {
            return vg
        },
        get Stage() {
            return wn
        },
        get StageAttributionEvent() {
            return Ii
        },
        get StageBuilder() {
            return kn
        },
        get StageCanvasEvent() {
            return es
        },
        get StageContentEvent() {
            return Ct
        },
        get StageCustomEvent() {
            return Li
        },
        get StageEvent() {
            return _t
        },
        get StageEventTarget() {
            return el
        },
        get StageHoverEvent() {
            return Di
        },
        get StageSetupEvent() {
            return Ls
        },
        get VignetteEffect() {
            return hg
        },
        get WorkerDemo() {
            return rg
        },
        get WorkerInternal() {
            return Zm
        },
        get WorkerManager() {
            return $m
        },
        get addBarycentricCoordinates() {
            return Ym
        },
        get addIconToTpFolder() {
            return ti
        },
        get applyNulls() {
            return kh
        },
        get attachToWindow() {
            return Om
        },
        get bloatGeo() {
            return Qm
        },
        get camelToName() {
            return Em
        },
        get defaultConfig() {
            return nl
        },
        get defaultRenderTargetConfig() {
            return il
        },
        get elementInViewport() {
            return Im
        },
        get fa() {
            return ei
        },
        get filterDatasetByPrefix() {
            return ws
        },
        get filterObject() {
            return Fh
        },
        get geometryToLineGeometry() {
            return cl
        },
        get getAncestryDataset() {
            return _s
        },
        get getAssetPath() {
            return Bi
        },
        get getCookie() {
            return Dm
        },
        get getGuid() {
            return pi
        },
        get getPrefixedDataset() {
            return za
        },
        get hexToCol() {
            return Rt
        },
        get initBenchmarkMode() {
            return hl
        },
        get loadBitmap() {
            return Pr
        },
        get loadBitmapTexture() {
            return Vm
        },
        get loadDataTexture() {
            return ss
        },
        get loadGLB() {
            return al
        },
        get loadImage() {
            return ll
        },
        get loadModel() {
            return rl
        },
        get loadOBJ() {
            return ol
        },
        get loadSVG() {
            return Vh
        },
        get loadTexture() {
            return tn
        },
        get loadVideo() {
            return Hh
        },
        get mergeAgentActions() {
            return Rr
        },
        get meshToLineSegments() {
            return Km
        },
        get mirrorObject() {
            return Ja
        },
        get numToXYZ() {
            return gn
        },
        get objSnapshot() {
            return si
        },
        get objTrim() {
            return Lm
        },
        get odds() {
            return Rm
        },
        get onNextFrame() {
            return Ri
        },
        get processLazyLoadActions() {
            return sl
        },
        get publicStageEventMapKeys() {
            return $a
        },
        get rand() {
            return Pm
        },
        get randomPointInSphere() {
            return zh
        },
        get randomPointOnSphere() {
            return Bm
        },
        get restoreDatasetByPrefix() {
            return Xm
        },
        get roundObjectMembers() {
            return fn
        },
        get serialiseForTransfer() {
            return vn
        },
        get sleep() {
            return Nh
        },
        get tick() {
            return Tm
        },
        get vecToXYZ() {
            return Mm
        },
        get waitForEvent() {
            return Cm
        }
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    im = "basic",
    sm = "matcap",
    rm = "lambert",
    om = "phong",
    am = "toon",
    lm = "standard",
    cm = "physical",
    Za = "https://kits.plinth.digital/",
    lo = 0,
    mr = 1,
    bo = "plinthosStageKey",
    Dh = "plinthosShotKey",
    Ss = "plinthosInstanceKey",
    Na = "plinthosStatus",
    _e = {},
    mn = {
        step: .001
    },
    lt = {},
    Is = {},
    Ih = {},
    hm = {},
    Lh = {
        min: -2 * Math.PI,
        max: 2 * Math.PI
    },
    co = { ..._e,
        ...Is
    },
    um = { ..._e,
        ...lt,
        ...Lh
    },
    Mt = {
        color: {
            type: "float"
        },
        picker: "inline"
    },
    dm = {
        topLeft: {
            xAnchorPoint: 0,
            yAnchorPoint: 1
        },
        topCenter: {
            xAnchorPoint: .5,
            yAnchorPoint: 1
        },
        topRight: {
            xAnchorPoint: 1,
            yAnchorPoint: 1
        },
        middleLeft: {
            xAnchorPoint: 0,
            yAnchorPoint: .5
        },
        middleCenter: {
            xAnchorPoint: .5,
            yAnchorPoint: .5
        },
        middleRight: {
            xAnchorPoint: 1,
            yAnchorPoint: .5
        },
        bottomLeft: {
            xAnchorPoint: 0,
            yAnchorPoint: 0
        },
        bottomCenter: {
            xAnchorPoint: .5,
            yAnchorPoint: 0
        },
        bottomRight: {
            xAnchorPoint: 1,
            yAnchorPoint: 0
        }
    },
    Fa = /iPad|iPhone|iPod/.test(navigator.userAgent) && !globalThis.MSStream;
var kf;
const Mn = !!(typeof window < "u" && null != (kf = window.document) && kf.createElement),
    Oh = !(!Mn || !HTMLCanvasElement.prototype.transferControlToOffscreen);

function IE(t, e, n) {
    return Math.max(e, Math.min(n, t))
}

function LE(t, e, n, i, s) {
    return i + (t - e) * (s - i) / (n - e)
}

function fm(t, e, n) {
    return (1 - n) * t + n * e
}
class ys {
    constructor(t) {
        T(this, "assetName"), T(this, "assetUrl"), T(this, "authorName"), T(this, "authorUrl"), T(this, "licenseName"), T(this, "licenseUrl"), T(this, "sourceName"), T(this, "sourceUrl"), T(this, "modified"), this.assetName = t.assetName, this.assetUrl = t.assetUrl, this.authorName = t.authorName, this.authorUrl = t.authorUrl, this.licenseName = t.licenseName, this.licenseUrl = t.licenseUrl, this.sourceName = t.sourceName, this.sourceUrl = t.sourceUrl, this.modified = !!t.modified
    }
    get assetHtml() {
        return this.assetUrl ? `<a href="${this.assetUrl}" target="_blank">${this.assetName}</a>` : this.assetName
    }
    get authorHtml() {
        return this.authorUrl ? `<a href="${this.authorUrl}" target="_blank">${this.authorName}</a>` : this.authorName
    }
    get licenseHtml() {
        return `<a href="${this.licenseUrl}" target="_blank">${this.licenseName}</a>`
    }
    get sourceHtml() {
        return this.sourceName ? this.sourceUrl ? `<a href="${this.sourceUrl}" target="_blank">${this.sourceName}</a>` : this.sourceName : ""
    }
    get html() {
        return [this.modified ? "Modified" : "", this.assetHtml, `by ${this.authorHtml}`, `[${this.licenseHtml}]`, this.sourceHtml ? `via ${this.sourceHtml}` : ""].join(" ")
    }
}
const pm = {
        licenseName: "3docean Regular License",
        licenseUrl: "https://3docean.net/licenses/standard"
    },
    mm = {
        licenseName: "CC-BY 3.0",
        licenseUrl: "https://creativecommons.org/licenses/by/3.0/"
    },
    gm = {
        licenseName: "CC-BY 4.0",
        licenseUrl: "https://creativecommons.org/licenses/by/4.0/"
    },
    vm = {
        licenseName: "CC0 Public Domain",
        licenseUrl: "https://creativecommons.org/publicdomain/zero/1.0/"
    },
    ym = {
        licenseName: "NASA Media Usage Guidelines",
        licenseUrl: "https://www.nasa.gov/multimedia/guidelines/"
    },
    xm = {
        sourceName: "Poly Pizza",
        sourceUrl: "https://poly.pizza"
    },
    bm = {
        sourceName: "3docean",
        sourceUrl: "https://3docean.net"
    },
    Am = {
        sourceName: "Pexels",
        sourceUrl: "https://pexels.com"
    },
    Sm = {
        sourceName: "Sketchfab",
        sourceUrl: "https://sketchfab.com"
    },
    Bh = 10,
    Uh = 120,
    ka = 60,
    OE = new u_;
class zt {
    static get elapsed() {
        return this._elapsed
    }
    static get elapsedMs() {
        return 1e3 * this._elapsed
    }
    static get delta() {
        return this._delta
    }
    static get deltaMs() {
        return 1e3 * this._delta
    }
    static get time() {
        return this._time
    }
    static get captureMode() {
        return this._captureMode
    }
    static set captureMode(t) {
        this._captureMode = t, t || this.tick()
    }
    static get captureDelta() {
        return this._captureDelta
    }
    static get captureFps() {
        return this._captureFps
    }
    static set captureFps(t) {
        this._captureFps = Math.min(Math.max(Bh, t), Uh), this._captureDelta = 1 / this._captureFps
    }
    static tick() {
        if (this.captureMode) this._delta = this._captureDelta, this._elapsed += this._captureDelta, this._time += 1e3 * this._captureDelta;
        else {
            if (this.tickLockout) return;
            this.tickLockout = !0, this._delta = Math.min(OE.getDelta(), .1), this._elapsed += this._delta, this._time = Date.now(), requestAnimationFrame((() => {
                this.tickLockout = !1, this.tick()
            }))
        }
        MM(this.elapsedMs)
    }
}

function BE(t) {
    return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t
}

function xa(t) {
    throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')
}
T(zt, "_elapsed", 0), T(zt, "_delta", 0), T(zt, "_time", Date.now()), T(zt, "_captureMode", !1), T(zt, "_captureDelta", 1 / ka), T(zt, "_captureFps", ka), T(zt, "tickLockout", !1), zt.tick();
var _m = {
    exports: {}
};
_m.exports = function t(e, n, i) {
    function s(o, a) {
        if (!n[o]) {
            if (!e[o]) {
                var l = "function" == typeof xa && xa;
                if (!a && l) return l(o, !0);
                if (r) return r(o, !0);
                throw new Error("Cannot find module '" + o + "'")
            }
            a = n[o] = {
                exports: {}
            }, e[o][0].call(a.exports, (function(t) {
                return s(e[o][1][t] || t)
            }), a, a.exports, t, e, n, i)
        }
        return n[o].exports
    }
    for (var r = "function" == typeof xa && xa, o = 0; o < i.length; o++) s(i[o]);
    return s
}({
    1: [function(t, e, n) {
        (function(i, s, r, o, a, l, c, h, u) {
            var d = t("crypto");

            function p(t, e) {
                var n;
                return void 0 === (n = "passthrough" !== (e = g(t, e)).algorithm ? d.createHash(e.algorithm) : new x).write && (n.write = n.update, n.end = n.update), y(e, n).dispatch(t), n.update || n.end(""), n.digest ? n.digest("buffer" === e.encoding ? void 0 : e.encoding) : (t = n.read(), "buffer" !== e.encoding ? t.toString(e.encoding) : t)
            }(n = e.exports = p).sha1 = function(t) {
                return p(t)
            }, n.keys = function(t) {
                return p(t, {
                    excludeValues: !0,
                    algorithm: "sha1",
                    encoding: "hex"
                })
            }, n.MD5 = function(t) {
                return p(t, {
                    algorithm: "md5",
                    encoding: "hex"
                })
            }, n.keysMD5 = function(t) {
                return p(t, {
                    algorithm: "md5",
                    encoding: "hex",
                    excludeValues: !0
                })
            };
            var f = d.getHashes ? d.getHashes().slice() : ["sha1", "md5"],
                m = (f.push("passthrough"), ["buffer", "hex", "binary", "base64"]);

            function g(t, e) {
                var n = {};
                if (n.algorithm = (e = e || {}).algorithm || "sha1", n.encoding = e.encoding || "hex", n.excludeValues = !!e.excludeValues, n.algorithm = n.algorithm.toLowerCase(), n.encoding = n.encoding.toLowerCase(), n.ignoreUnknown = !0 === e.ignoreUnknown, n.respectType = !1 !== e.respectType, n.respectFunctionNames = !1 !== e.respectFunctionNames, n.respectFunctionProperties = !1 !== e.respectFunctionProperties, n.unorderedArrays = !0 === e.unorderedArrays, n.unorderedSets = !1 !== e.unorderedSets, n.unorderedObjects = !1 !== e.unorderedObjects, n.replacer = e.replacer || void 0, n.excludeKeys = e.excludeKeys || void 0, void 0 === t) throw new Error("Object argument required.");
                for (var i = 0; i < f.length; ++i) f[i].toLowerCase() === n.algorithm.toLowerCase() && (n.algorithm = f[i]);
                if (-1 === f.indexOf(n.algorithm)) throw new Error('Algorithm "' + n.algorithm + '"  not supported. supported values: ' + f.join(", "));
                if (-1 === m.indexOf(n.encoding) && "passthrough" !== n.algorithm) throw new Error('Encoding "' + n.encoding + '"  not supported. supported values: ' + m.join(", "));
                return n
            }

            function v(t) {
                if ("function" == typeof t) return null != /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(t))
            }

            function y(t, e, n) {
                function i(t) {
                    return e.update ? e.update(t, "utf8") : e.write(t, "utf8")
                }
                return n = n || [], {
                    dispatch: function(e) {
                        return this["_" + (null === (e = t.replacer ? t.replacer(e) : e) ? "null" : typeof e)](e)
                    },
                    _object: function(e) {
                        var s, o = Object.prototype.toString.call(e),
                            a = /\[object (.*)\]/i.exec(o);
                        if (a = (a = a ? a[1] : "unknown:[" + o + "]").toLowerCase(), 0 <= (o = n.indexOf(e))) return this.dispatch("[CIRCULAR:" + o + "]");
                        if (n.push(e), void 0 !== r && r.isBuffer && r.isBuffer(e)) return i("buffer:"), i(e);
                        if ("object" === a || "function" === a || "asyncfunction" === a) return o = Object.keys(e), t.unorderedObjects && (o = o.sort()), !1 === t.respectType || v(e) || o.splice(0, 0, "prototype", "__proto__", "constructor"), t.excludeKeys && (o = o.filter((function(e) {
                            return !t.excludeKeys(e)
                        }))), i("object:" + o.length + ":"), s = this, o.forEach((function(n) {
                            s.dispatch(n), i(":"), t.excludeValues || s.dispatch(e[n]), i(",")
                        }));
                        if (!this["_" + a]) {
                            if (t.ignoreUnknown) return i("[" + a + "]");
                            throw new Error('Unknown object type "' + a + '"')
                        }
                        this["_" + a](e)
                    },
                    _array: function(e, s) {
                        s = void 0 !== s ? s : !1 !== t.unorderedArrays;
                        var r = this;
                        if (i("array:" + e.length + ":"), !s || e.length <= 1) return e.forEach((function(t) {
                            return r.dispatch(t)
                        }));
                        var o = [];
                        return s = e.map((function(e) {
                            var i = new x,
                                s = n.slice();
                            return y(t, i, s).dispatch(e), o = o.concat(s.slice(n.length)), i.read().toString()
                        })), n = n.concat(o), s.sort(), this._array(s, !1)
                    },
                    _date: function(t) {
                        return i("date:" + t.toJSON())
                    },
                    _symbol: function(t) {
                        return i("symbol:" + t.toString())
                    },
                    _error: function(t) {
                        return i("error:" + t.toString())
                    },
                    _boolean: function(t) {
                        return i("bool:" + t.toString())
                    },
                    _string: function(t) {
                        i("string:" + t.length + ":"), i(t.toString())
                    },
                    _function: function(e) {
                        i("fn:"), v(e) ? this.dispatch("[native]") : this.dispatch(e.toString()), !1 !== t.respectFunctionNames && this.dispatch("function-name:" + String(e.name)), t.respectFunctionProperties && this._object(e)
                    },
                    _number: function(t) {
                        return i("number:" + t.toString())
                    },
                    _xml: function(t) {
                        return i("xml:" + t.toString())
                    },
                    _null: function() {
                        return i("Null")
                    },
                    _undefined: function() {
                        return i("Undefined")
                    },
                    _regexp: function(t) {
                        return i("regex:" + t.toString())
                    },
                    _uint8array: function(t) {
                        return i("uint8array:"), this.dispatch(Array.prototype.slice.call(t))
                    },
                    _uint8clampedarray: function(t) {
                        return i("uint8clampedarray:"), this.dispatch(Array.prototype.slice.call(t))
                    },
                    _int8array: function(t) {
                        return i("int8array:"), this.dispatch(Array.prototype.slice.call(t))
                    },
                    _uint16array: function(t) {
                        return i("uint16array:"), this.dispatch(Array.prototype.slice.call(t))
                    },
                    _int16array: function(t) {
                        return i("int16array:"), this.dispatch(Array.prototype.slice.call(t))
                    },
                    _uint32array: function(t) {
                        return i("uint32array:"), this.dispatch(Array.prototype.slice.call(t))
                    },
                    _int32array: function(t) {
                        return i("int32array:"), this.dispatch(Array.prototype.slice.call(t))
                    },
                    _float32array: function(t) {
                        return i("float32array:"), this.dispatch(Array.prototype.slice.call(t))
                    },
                    _float64array: function(t) {
                        return i("float64array:"), this.dispatch(Array.prototype.slice.call(t))
                    },
                    _arraybuffer: function(t) {
                        return i("arraybuffer:"), this.dispatch(new Uint8Array(t))
                    },
                    _url: function(t) {
                        return i("url:" + t.toString())
                    },
                    _map: function(e) {
                        return i("map:"), e = Array.from(e), this._array(e, !1 !== t.unorderedSets)
                    },
                    _set: function(e) {
                        return i("set:"), e = Array.from(e), this._array(e, !1 !== t.unorderedSets)
                    },
                    _file: function(t) {
                        return i("file:"), this.dispatch([t.name, t.size, t.type, t.lastModfied])
                    },
                    _blob: function() {
                        if (t.ignoreUnknown) return i("[blob]");
                        throw Error('Hashing Blob objects is currently not supported\n(see https://github.com/puleos/object-hash/issues/26)\nUse "options.replacer" or "options.ignoreUnknown"\n')
                    },
                    _domwindow: function() {
                        return i("domwindow")
                    },
                    _bigint: function(t) {
                        return i("bigint:" + t.toString())
                    },
                    _process: function() {
                        return i("process")
                    },
                    _timer: function() {
                        return i("timer")
                    },
                    _pipe: function() {
                        return i("pipe")
                    },
                    _tcp: function() {
                        return i("tcp")
                    },
                    _udp: function() {
                        return i("udp")
                    },
                    _tty: function() {
                        return i("tty")
                    },
                    _statwatcher: function() {
                        return i("statwatcher")
                    },
                    _securecontext: function() {
                        return i("securecontext")
                    },
                    _connection: function() {
                        return i("connection")
                    },
                    _zlib: function() {
                        return i("zlib")
                    },
                    _context: function() {
                        return i("context")
                    },
                    _nodescript: function() {
                        return i("nodescript")
                    },
                    _httpparser: function() {
                        return i("httpparser")
                    },
                    _dataview: function() {
                        return i("dataview")
                    },
                    _signal: function() {
                        return i("signal")
                    },
                    _fsevent: function() {
                        return i("fsevent")
                    },
                    _tlswrap: function() {
                        return i("tlswrap")
                    }
                }
            }

            function x() {
                return {
                    buf: "",
                    write: function(t) {
                        this.buf += t
                    },
                    end: function(t) {
                        this.buf += t
                    },
                    read: function() {
                        return this.buf
                    }
                }
            }
            n.writeToStream = function(t, e, n) {
                return void 0 === n && (n = e, e = {}), y(e = g(t, e), n).dispatch(t)
            }
        }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/fake_9a5aa49d.js", "/")
    }, {
        buffer: 3,
        crypto: 5,
        lYpoI2: 11
    }],
    2: [function(t, e, n) {
        (function(t, e, i, s, r, o, a, l, c) {
            ! function(t) {
                var e = typeof Uint8Array < "u" ? Uint8Array : Array;

                function n(t) {
                    return 43 === (t = t.charCodeAt(0)) || 45 === t ? 62 : 47 === t || 95 === t ? 63 : t < 48 ? -1 : t < 58 ? t - 48 + 26 + 26 : t < 91 ? t - 65 : t < 123 ? t - 97 + 26 : void 0
                }
                t.toByteArray = function(t) {
                    var i, s;
                    if (0 < t.length % 4) throw new Error("Invalid string. Length must be a multiple of 4");
                    var r = t.length,
                        o = (r = "=" === t.charAt(r - 2) ? 2 : "=" === t.charAt(r - 1) ? 1 : 0, new e(3 * t.length / 4 - r)),
                        a = 0 < r ? t.length - 4 : t.length,
                        l = 0;

                    function c(t) {
                        o[l++] = t
                    }
                    for (i = 0; i < a; i += 4, 0) c((16711680 & (s = n(t.charAt(i)) << 18 | n(t.charAt(i + 1)) << 12 | n(t.charAt(i + 2)) << 6 | n(t.charAt(i + 3)))) >> 16), c((65280 & s) >> 8), c(255 & s);
                    return 2 == r ? c(255 & (s = n(t.charAt(i)) << 2 | n(t.charAt(i + 1)) >> 4)) : 1 == r && (c((s = n(t.charAt(i)) << 10 | n(t.charAt(i + 1)) << 4 | n(t.charAt(i + 2)) >> 2) >> 8 & 255), c(255 & s)), o
                }, t.fromByteArray = function(t) {
                    var e, n, i, s, r = t.length % 3,
                        o = "";

                    function a(t) {
                        return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(t)
                    }
                    for (e = 0, i = t.length - r; e < i; e += 3) o += a((s = n = (t[e] << 16) + (t[e + 1] << 8) + t[e + 2]) >> 18 & 63) + a(s >> 12 & 63) + a(s >> 6 & 63) + a(63 & s);
                    switch (r) {
                        case 1:
                            o = (o += a((n = t[t.length - 1]) >> 2)) + a(n << 4 & 63) + "==";
                            break;
                        case 2:
                            o = (o = (o += a((n = (t[t.length - 2] << 8) + t[t.length - 1]) >> 10)) + a(n >> 4 & 63)) + a(n << 2 & 63) + "="
                    }
                    return o
                }
            }(void 0 === n ? this.base64js = {} : n)
        }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js", "/node_modules/gulp-browserify/node_modules/base64-js/lib")
    }, {
        buffer: 3,
        lYpoI2: 11
    }],
    3: [function(t, e, n) {
        (function(e, i, s, r, o, a, l, c, h) {
            var u = t("base64-js"),
                d = t("ieee754");

            function s(t, e, n) {
                if (!(this instanceof s)) return new s(t, e, n);
                var i, r, o, a, l = typeof t;
                if ("base64" === e && "string" == l)
                    for (t = (a = t).trim ? a.trim() : a.replace(/^\s+|\s+$/g, ""); t.length % 4 != 0;) t += "=";
                if ("number" == l) i = E(t);
                else if ("string" == l) i = s.byteLength(t, e);
                else {
                    if ("object" != l) throw new Error("First argument needs to be a number, array or string.");
                    i = E(t.length)
                }
                if (s._useTypedArrays ? r = s._augment(new Uint8Array(i)) : ((r = this).length = i, r._isBuffer = !0), s._useTypedArrays && "number" == typeof t.byteLength) r._set(t);
                else if (C(a = t) || s.isBuffer(a) || a && "object" == typeof a && "number" == typeof a.length)
                    for (o = 0; o < i; o++) s.isBuffer(t) ? r[o] = t.readUInt8(o) : r[o] = t[o];
                else if ("string" == l) r.write(t, 0, e);
                else if ("number" == l && !s._useTypedArrays && !n)
                    for (o = 0; o < i; o++) r[o] = 0;
                return r
            }

            function p(t, e, n, i) {
                var s;
                if (i || (N("boolean" == typeof n, "missing or invalid endian"), N(null != e, "missing offset"), N(e + 1 < t.length, "Trying to read beyond buffer length")), !((i = t.length) <= e)) return n ? (s = t[e], e + 1 < i && (s |= t[e + 1] << 8)) : (s = t[e] << 8, e + 1 < i && (s |= t[e + 1])), s
            }

            function f(t, e, n, i) {
                var s;
                if (i || (N("boolean" == typeof n, "missing or invalid endian"), N(null != e, "missing offset"), N(e + 3 < t.length, "Trying to read beyond buffer length")), !((i = t.length) <= e)) return n ? (e + 2 < i && (s = t[e + 2] << 16), e + 1 < i && (s |= t[e + 1] << 8), s |= t[e], e + 3 < i && (s += t[e + 3] << 24 >>> 0)) : (e + 1 < i && (s = t[e + 1] << 16), e + 2 < i && (s |= t[e + 2] << 8), e + 3 < i && (s |= t[e + 3]), s += t[e] << 24 >>> 0), s
            }

            function m(t, e, n, i) {
                if (i || (N("boolean" == typeof n, "missing or invalid endian"), N(null != e, "missing offset"), N(e + 1 < t.length, "Trying to read beyond buffer length")), !(t.length <= e)) return 32768 & (i = p(t, e, n, !0)) ? -1 * (65535 - i + 1) : i
            }

            function g(t, e, n, i) {
                if (i || (N("boolean" == typeof n, "missing or invalid endian"), N(null != e, "missing offset"), N(e + 3 < t.length, "Trying to read beyond buffer length")), !(t.length <= e)) return 2147483648 & (i = f(t, e, n, !0)) ? -1 * (4294967295 - i + 1) : i
            }

            function v(t, e, n, i) {
                return i || (N("boolean" == typeof n, "missing or invalid endian"), N(e + 3 < t.length, "Trying to read beyond buffer length")), d.read(t, e, n, 23, 4)
            }

            function y(t, e, n, i) {
                return i || (N("boolean" == typeof n, "missing or invalid endian"), N(e + 7 < t.length, "Trying to read beyond buffer length")), d.read(t, e, n, 52, 8)
            }

            function x(t, e, n, i, s) {
                if (s || (N(null != e, "missing value"), N("boolean" == typeof i, "missing or invalid endian"), N(null != n, "missing offset"), N(n + 1 < t.length, "trying to write beyond buffer length"), U(e, 65535)), !((s = t.length) <= n))
                    for (var r = 0, o = Math.min(s - n, 2); r < o; r++) t[n + r] = (e & 255 << 8 * (i ? r : 1 - r)) >>> 8 * (i ? r : 1 - r)
            }

            function b(t, e, n, i, s) {
                if (s || (N(null != e, "missing value"), N("boolean" == typeof i, "missing or invalid endian"), N(null != n, "missing offset"), N(n + 3 < t.length, "trying to write beyond buffer length"), U(e, 4294967295)), !((s = t.length) <= n))
                    for (var r = 0, o = Math.min(s - n, 4); r < o; r++) t[n + r] = e >>> 8 * (i ? r : 3 - r) & 255
            }

            function A(t, e, n, i, s) {
                s || (N(null != e, "missing value"), N("boolean" == typeof i, "missing or invalid endian"), N(null != n, "missing offset"), N(n + 1 < t.length, "Trying to write beyond buffer length"), O(e, 32767, -32768)), t.length <= n || x(t, 0 <= e ? e : 65535 + e + 1, n, i, s)
            }

            function S(t, e, n, i, s) {
                s || (N(null != e, "missing value"), N("boolean" == typeof i, "missing or invalid endian"), N(null != n, "missing offset"), N(n + 3 < t.length, "Trying to write beyond buffer length"), O(e, 2147483647, -2147483648)), t.length <= n || b(t, 0 <= e ? e : 4294967295 + e + 1, n, i, s)
            }

            function w(t, e, n, i, s) {
                s || (N(null != e, "missing value"), N("boolean" == typeof i, "missing or invalid endian"), N(null != n, "missing offset"), N(n + 3 < t.length, "Trying to write beyond buffer length"), B(e, 34028234663852886e22, -34028234663852886e22)), t.length <= n || d.write(t, e, n, i, 23, 4)
            }

            function _(t, e, n, i, s) {
                s || (N(null != e, "missing value"), N("boolean" == typeof i, "missing or invalid endian"), N(null != n, "missing offset"), N(n + 7 < t.length, "Trying to write beyond buffer length"), B(e, 17976931348623157e292, -17976931348623157e292)), t.length <= n || d.write(t, e, n, i, 52, 8)
            }
            n.Buffer = s, n.SlowBuffer = s, n.INSPECT_MAX_BYTES = 50, s.poolSize = 8192, s._useTypedArrays = function() {
                try {
                    var t = new ArrayBuffer(0),
                        e = new Uint8Array(t);
                    return e.foo = function() {
                        return 42
                    }, 42 === e.foo() && "function" == typeof e.subarray
                } catch {
                    return !1
                }
            }(), s.isEncoding = function(t) {
                switch (String(t).toLowerCase()) {
                    case "hex":
                    case "utf8":
                    case "utf-8":
                    case "ascii":
                    case "binary":
                    case "base64":
                    case "raw":
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return !0;
                    default:
                        return !1
                }
            }, s.isBuffer = function(t) {
                return !(null == t || !t._isBuffer)
            }, s.byteLength = function(t, e) {
                var n;
                switch (t += "", e || "utf8") {
                    case "hex":
                        n = t.length / 2;
                        break;
                    case "utf8":
                    case "utf-8":
                        n = P(t).length;
                        break;
                    case "ascii":
                    case "binary":
                    case "raw":
                        n = t.length;
                        break;
                    case "base64":
                        n = D(t).length;
                        break;
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        n = 2 * t.length;
                        break;
                    default:
                        throw new Error("Unknown encoding")
                }
                return n
            }, s.concat = function(t, e) {
                if (N(C(t), "Usage: Buffer.concat(list, [totalLength])\nlist should be an Array."), 0 === t.length) return new s(0);
                if (1 === t.length) return t[0];
                if ("number" != typeof e)
                    for (r = e = 0; r < t.length; r++) e += t[r].length;
                for (var n = new s(e), i = 0, r = 0; r < t.length; r++) {
                    var o = t[r];
                    o.copy(n, i), i += o.length
                }
                return n
            }, s.prototype.write = function(t, e, n, i) {
                isFinite(e) ? isFinite(n) || (i = n, n = void 0) : (c = i, i = e, e = n, n = c), e = Number(e) || 0;
                var r, o, a, l, c = this.length - e;
                switch ((!n || c < (n = Number(n))) && (n = c), i = String(i || "utf8").toLowerCase()) {
                    case "hex":
                        r = function(t, e, n, i) {
                            n = Number(n) || 0;
                            var r = t.length - n;
                            (!i || r < (i = Number(i))) && (i = r), N((r = e.length) % 2 == 0, "Invalid hex string"), r / 2 < i && (i = r / 2);
                            for (var o = 0; o < i; o++) {
                                var a = parseInt(e.substr(2 * o, 2), 16);
                                N(!isNaN(a), "Invalid hex string"), t[n + o] = a
                            }
                            return s._charsWritten = 2 * o, o
                        }(this, t, e, n);
                        break;
                    case "utf8":
                    case "utf-8":
                        o = this, a = e, l = n, r = s._charsWritten = I(P(t), o, a, l);
                        break;
                    case "ascii":
                    case "binary":
                        r = function(t, e, n, i) {
                            return s._charsWritten = I(function(t) {
                                for (var e = [], n = 0; n < t.length; n++) e.push(255 & t.charCodeAt(n));
                                return e
                            }(e), t, n, i)
                        }(this, t, e, n);
                        break;
                    case "base64":
                        o = this, a = e, l = n, r = s._charsWritten = I(D(t), o, a, l);
                        break;
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        r = function(t, e, n, i) {
                            return s._charsWritten = I(function(t) {
                                for (var e, n, i = [], s = 0; s < t.length; s++) e = (n = t.charCodeAt(s)) >> 8, n %= 256, i.push(n), i.push(e);
                                return i
                            }(e), t, n, i)
                        }(this, t, e, n);
                        break;
                    default:
                        throw new Error("Unknown encoding")
                }
                return r
            }, s.prototype.toString = function(t, e, n) {
                var i, s, r, o, a = this;
                if (t = String(t || "utf8").toLowerCase(), e = Number(e) || 0, (n = void 0 !== n ? Number(n) : a.length) === e) return "";
                switch (t) {
                    case "hex":
                        i = function(t, e, n) {
                            var i = t.length;
                            (!e || e < 0) && (e = 0), (!n || n < 0 || i < n) && (n = i);
                            for (var s = "", r = e; r < n; r++) s += R(t[r]);
                            return s
                        }(a, e, n);
                        break;
                    case "utf8":
                    case "utf-8":
                        i = function(t, e, n) {
                            var i = "",
                                s = "";
                            n = Math.min(t.length, n);
                            for (var r = e; r < n; r++) t[r] <= 127 ? (i += L(s) + String.fromCharCode(t[r]), s = "") : s += "%" + t[r].toString(16);
                            return i + L(s)
                        }(a, e, n);
                        break;
                    case "ascii":
                    case "binary":
                        i = function(t, e, n) {
                            var i = "";
                            n = Math.min(t.length, n);
                            for (var s = e; s < n; s++) i += String.fromCharCode(t[s]);
                            return i
                        }(a, e, n);
                        break;
                    case "base64":
                        s = a, o = n, i = 0 === (r = e) && o === s.length ? u.fromByteArray(s) : u.fromByteArray(s.slice(r, o));
                        break;
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        i = function(t, e, n) {
                            for (var i = t.slice(e, n), s = "", r = 0; r < i.length; r += 2) s += String.fromCharCode(i[r] + 256 * i[r + 1]);
                            return s
                        }(a, e, n);
                        break;
                    default:
                        throw new Error("Unknown encoding")
                }
                return i
            }, s.prototype.toJSON = function() {
                return {
                    type: "Buffer",
                    data: Array.prototype.slice.call(this._arr || this, 0)
                }
            }, s.prototype.copy = function(t, e, n, i) {
                if (e = e || 0, (i = i || 0 === i ? i : this.length) !== (n = n || 0) && 0 !== t.length && 0 !== this.length) {
                    N(n <= i, "sourceEnd < sourceStart"), N(0 <= e && e < t.length, "targetStart out of bounds"), N(0 <= n && n < this.length, "sourceStart out of bounds"), N(0 <= i && i <= this.length, "sourceEnd out of bounds"), i > this.length && (i = this.length);
                    var r = (i = t.length - e < i - n ? t.length - e + n : i) - n;
                    if (r < 100 || !s._useTypedArrays)
                        for (var o = 0; o < r; o++) t[o + e] = this[o + n];
                    else t._set(this.subarray(n, n + r), e)
                }
            }, s.prototype.slice = function(t, e) {
                var n = this.length;
                if (t = T(t, n, 0), e = T(e, n, n), s._useTypedArrays) return s._augment(this.subarray(t, e));
                for (var i = e - t, r = new s(i, void 0, !0), o = 0; o < i; o++) r[o] = this[o + t];
                return r
            }, s.prototype.get = function(t) {
                return console.log(".get() is deprecated. Access using array indexes instead."), this.readUInt8(t)
            }, s.prototype.set = function(t, e) {
                return console.log(".set() is deprecated. Access using array indexes instead."), this.writeUInt8(t, e)
            }, s.prototype.readUInt8 = function(t, e) {
                if (e || (N(null != t, "missing offset"), N(t < this.length, "Trying to read beyond buffer length")), !(t >= this.length)) return this[t]
            }, s.prototype.readUInt16LE = function(t, e) {
                return p(this, t, !0, e)
            }, s.prototype.readUInt16BE = function(t, e) {
                return p(this, t, !1, e)
            }, s.prototype.readUInt32LE = function(t, e) {
                return f(this, t, !0, e)
            }, s.prototype.readUInt32BE = function(t, e) {
                return f(this, t, !1, e)
            }, s.prototype.readInt8 = function(t, e) {
                if (e || (N(null != t, "missing offset"), N(t < this.length, "Trying to read beyond buffer length")), !(t >= this.length)) return 128 & this[t] ? -1 * (255 - this[t] + 1) : this[t]
            }, s.prototype.readInt16LE = function(t, e) {
                return m(this, t, !0, e)
            }, s.prototype.readInt16BE = function(t, e) {
                return m(this, t, !1, e)
            }, s.prototype.readInt32LE = function(t, e) {
                return g(this, t, !0, e)
            }, s.prototype.readInt32BE = function(t, e) {
                return g(this, t, !1, e)
            }, s.prototype.readFloatLE = function(t, e) {
                return v(this, t, !0, e)
            }, s.prototype.readFloatBE = function(t, e) {
                return v(this, t, !1, e)
            }, s.prototype.readDoubleLE = function(t, e) {
                return y(this, t, !0, e)
            }, s.prototype.readDoubleBE = function(t, e) {
                return y(this, t, !1, e)
            }, s.prototype.writeUInt8 = function(t, e, n) {
                n || (N(null != t, "missing value"), N(null != e, "missing offset"), N(e < this.length, "trying to write beyond buffer length"), U(t, 255)), e >= this.length || (this[e] = t)
            }, s.prototype.writeUInt16LE = function(t, e, n) {
                x(this, t, e, !0, n)
            }, s.prototype.writeUInt16BE = function(t, e, n) {
                x(this, t, e, !1, n)
            }, s.prototype.writeUInt32LE = function(t, e, n) {
                b(this, t, e, !0, n)
            }, s.prototype.writeUInt32BE = function(t, e, n) {
                b(this, t, e, !1, n)
            }, s.prototype.writeInt8 = function(t, e, n) {
                n || (N(null != t, "missing value"), N(null != e, "missing offset"), N(e < this.length, "Trying to write beyond buffer length"), O(t, 127, -128)), e >= this.length || (0 <= t ? this.writeUInt8(t, e, n) : this.writeUInt8(255 + t + 1, e, n))
            }, s.prototype.writeInt16LE = function(t, e, n) {
                A(this, t, e, !0, n)
            }, s.prototype.writeInt16BE = function(t, e, n) {
                A(this, t, e, !1, n)
            }, s.prototype.writeInt32LE = function(t, e, n) {
                S(this, t, e, !0, n)
            }, s.prototype.writeInt32BE = function(t, e, n) {
                S(this, t, e, !1, n)
            }, s.prototype.writeFloatLE = function(t, e, n) {
                w(this, t, e, !0, n)
            }, s.prototype.writeFloatBE = function(t, e, n) {
                w(this, t, e, !1, n)
            }, s.prototype.writeDoubleLE = function(t, e, n) {
                _(this, t, e, !0, n)
            }, s.prototype.writeDoubleBE = function(t, e, n) {
                _(this, t, e, !1, n)
            }, s.prototype.fill = function(t, e, n) {
                if (e = e || 0, n = n || this.length, N("number" == typeof(t = "string" == typeof(t = t || 0) ? t.charCodeAt(0) : t) && !isNaN(t), "value is not a number"), N(e <= n, "end < start"), n !== e && 0 !== this.length) {
                    N(0 <= e && e < this.length, "start out of bounds"), N(0 <= n && n <= this.length, "end out of bounds");
                    for (var i = e; i < n; i++) this[i] = t
                }
            }, s.prototype.inspect = function() {
                for (var t = [], e = this.length, i = 0; i < e; i++)
                    if (t[i] = R(this[i]), i === n.INSPECT_MAX_BYTES) {
                        t[i + 1] = "...";
                        break
                    }
                return "<Buffer " + t.join(" ") + ">"
            }, s.prototype.toArrayBuffer = function() {
                if (typeof Uint8Array > "u") throw new Error("Buffer.toArrayBuffer not supported in this browser");
                if (s._useTypedArrays) return new s(this).buffer;
                for (var t = new Uint8Array(this.length), e = 0, n = t.length; e < n; e += 1) t[e] = this[e];
                return t.buffer
            };
            var M = s.prototype;

            function T(t, e, n) {
                return "number" != typeof t ? n : e <= (t = ~~t) ? e : 0 <= t || 0 <= (t += e) ? t : 0
            }

            function E(t) {
                return (t = ~~Math.ceil(+t)) < 0 ? 0 : t
            }

            function C(t) {
                return (Array.isArray || function(t) {
                    return "[object Array]" === Object.prototype.toString.call(t)
                })(t)
            }

            function R(t) {
                return t < 16 ? "0" + t.toString(16) : t.toString(16)
            }

            function P(t) {
                for (var e = [], n = 0; n < t.length; n++) {
                    var i = t.charCodeAt(n);
                    if (i <= 127) e.push(t.charCodeAt(n));
                    else
                        for (var s = n, r = (55296 <= i && i <= 57343 && n++, encodeURIComponent(t.slice(s, n + 1)).substr(1).split("%")), o = 0; o < r.length; o++) e.push(parseInt(r[o], 16))
                }
                return e
            }

            function D(t) {
                return u.toByteArray(t)
            }

            function I(t, e, n, i) {
                for (var s = 0; s < i && !(s + n >= e.length || s >= t.length); s++) e[s + n] = t[s];
                return s
            }

            function L(t) {
                try {
                    return decodeURIComponent(t)
                } catch {
                    return "�"
                }
            }

            function U(t, e) {
                N("number" == typeof t, "cannot write a non-number as a number"), N(0 <= t, "specified a negative value for writing an unsigned value"), N(t <= e, "value is larger than maximum value for type"), N(Math.floor(t) === t, "value has a fractional component")
            }

            function O(t, e, n) {
                N("number" == typeof t, "cannot write a non-number as a number"), N(t <= e, "value larger than maximum allowed value"), N(n <= t, "value smaller than minimum allowed value"), N(Math.floor(t) === t, "value has a fractional component")
            }

            function B(t, e, n) {
                N("number" == typeof t, "cannot write a non-number as a number"), N(t <= e, "value larger than maximum allowed value"), N(n <= t, "value smaller than minimum allowed value")
            }

            function N(t, e) {
                if (!t) throw new Error(e || "Failed assertion")
            }
            s._augment = function(t) {
                return t._isBuffer = !0, t._get = t.get, t._set = t.set, t.get = M.get, t.set = M.set, t.write = M.write, t.toString = M.toString, t.toLocaleString = M.toString, t.toJSON = M.toJSON, t.copy = M.copy, t.slice = M.slice, t.readUInt8 = M.readUInt8, t.readUInt16LE = M.readUInt16LE, t.readUInt16BE = M.readUInt16BE, t.readUInt32LE = M.readUInt32LE, t.readUInt32BE = M.readUInt32BE, t.readInt8 = M.readInt8, t.readInt16LE = M.readInt16LE, t.readInt16BE = M.readInt16BE, t.readInt32LE = M.readInt32LE, t.readInt32BE = M.readInt32BE, t.readFloatLE = M.readFloatLE, t.readFloatBE = M.readFloatBE, t.readDoubleLE = M.readDoubleLE, t.readDoubleBE = M.readDoubleBE, t.writeUInt8 = M.writeUInt8, t.writeUInt16LE = M.writeUInt16LE, t.writeUInt16BE = M.writeUInt16BE, t.writeUInt32LE = M.writeUInt32LE, t.writeUInt32BE = M.writeUInt32BE, t.writeInt8 = M.writeInt8, t.writeInt16LE = M.writeInt16LE, t.writeInt16BE = M.writeInt16BE, t.writeInt32LE = M.writeInt32LE, t.writeInt32BE = M.writeInt32BE, t.writeFloatLE = M.writeFloatLE, t.writeFloatBE = M.writeFloatBE, t.writeDoubleLE = M.writeDoubleLE, t.writeDoubleBE = M.writeDoubleBE, t.fill = M.fill, t.inspect = M.inspect, t.toArrayBuffer = M.toArrayBuffer, t
            }
        }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/buffer/index.js", "/node_modules/gulp-browserify/node_modules/buffer")
    }, {
        "base64-js": 2,
        buffer: 3,
        ieee754: 10,
        lYpoI2: 11
    }],
    4: [function(t, e, n) {
        (function(n, i, s, r, o, a, l, c, h) {
            s = t("buffer").Buffer;
            var u = new s(4);
            u.fill(0), e.exports = {
                hash: function(t, e, n, i) {
                    for (var r = e(function(t, e) {
                            t.length % 4 != 0 && (n = t.length + (4 - t.length % 4), t = s.concat([t, u], n));
                            for (var n, i = [], r = e ? t.readInt32BE : t.readInt32LE, o = 0; o < t.length; o += 4) i.push(r.call(t, o));
                            return i
                        }(t = s.isBuffer(t) ? t : new s(t), i), 8 * t.length), o = (e = i, new s(n)), a = e ? o.writeInt32BE : o.writeInt32LE, l = 0; l < r.length; l++) a.call(o, r[l], 4 * l, !0);
                    return o
                }
            }
        }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/helpers.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify")
    }, {
        buffer: 3,
        lYpoI2: 11
    }],
    5: [function(t, e, n) {
        (function(e, i, s, r, o, a, l, c, h) {
            s = t("buffer").Buffer;
            var u = t("./sha"),
                d = t("./sha256"),
                p = t("./rng"),
                f = {
                    sha1: u,
                    sha256: d,
                    md5: t("./md5")
                },
                m = 64,
                g = new s(m);

            function v(t, e) {
                var n = f[t = t || "sha1"],
                    i = [];
                return n || y("algorithm:", t, "is not yet supported"), {
                    update: function(t) {
                        return s.isBuffer(t) || (t = new s(t)), i.push(t), t.length, this
                    },
                    digest: function(t) {
                        var r = s.concat(i);
                        return r = e ? function(t, e, n) {
                            s.isBuffer(e) || (e = new s(e)), s.isBuffer(n) || (n = new s(n)), e.length > m ? e = t(e) : e.length < m && (e = s.concat([e, g], m));
                            for (var i = new s(m), r = new s(m), o = 0; o < m; o++) i[o] = 54 ^ e[o], r[o] = 92 ^ e[o];
                            return n = t(s.concat([i, n])), t(s.concat([r, n]))
                        }(n, e, r) : n(r), i = null, t ? r.toString(t) : r
                    }
                }
            }

            function y() {
                var t = [].slice.call(arguments).join(" ");
                throw new Error([t, "we accept pull requests", "http://github.com/dominictarr/crypto-browserify"].join("\n"))
            }
            g.fill(0), n.createHash = function(t) {
                return v(t)
            }, n.createHmac = v, n.randomBytes = function(t, e) {
                if (!e || !e.call) return new s(p(t));
                try {
                    e.call(this, void 0, new s(p(t)))
                } catch (t) {
                    e(t)
                }
            };
            var x, b = ["createCredentials", "createCipher", "createCipheriv", "createDecipher", "createDecipheriv", "createSign", "createVerify", "createDiffieHellman", "pbkdf2"],
                A = function(t) {
                    n[t] = function() {
                        y("sorry,", t, "is not implemented yet")
                    }
                };
            for (x in b) A(b[x])
        }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/index.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify")
    }, {
        "./md5": 6,
        "./rng": 7,
        "./sha": 8,
        "./sha256": 9,
        buffer: 3,
        lYpoI2: 11
    }],
    6: [function(t, e, n) {
        (function(n, i, s, r, o, a, l, c, h) {
            var u = t("./helpers");

            function d(t, e) {
                t[e >> 5] |= 128 << e % 32, t[14 + (e + 64 >>> 9 << 4)] = e;
                for (var n = 1732584193, i = -271733879, s = -1732584194, r = 271733878, o = 0; o < t.length; o += 16) {
                    var a = n,
                        l = i,
                        c = s,
                        h = r;
                    n = f(n, i, s, r, t[o + 0], 7, -680876936), r = f(r, n, i, s, t[o + 1], 12, -389564586), s = f(s, r, n, i, t[o + 2], 17, 606105819), i = f(i, s, r, n, t[o + 3], 22, -1044525330), n = f(n, i, s, r, t[o + 4], 7, -176418897), r = f(r, n, i, s, t[o + 5], 12, 1200080426), s = f(s, r, n, i, t[o + 6], 17, -1473231341), i = f(i, s, r, n, t[o + 7], 22, -45705983), n = f(n, i, s, r, t[o + 8], 7, 1770035416), r = f(r, n, i, s, t[o + 9], 12, -1958414417), s = f(s, r, n, i, t[o + 10], 17, -42063), i = f(i, s, r, n, t[o + 11], 22, -1990404162), n = f(n, i, s, r, t[o + 12], 7, 1804603682), r = f(r, n, i, s, t[o + 13], 12, -40341101), s = f(s, r, n, i, t[o + 14], 17, -1502002290), n = m(n, i = f(i, s, r, n, t[o + 15], 22, 1236535329), s, r, t[o + 1], 5, -165796510), r = m(r, n, i, s, t[o + 6], 9, -1069501632), s = m(s, r, n, i, t[o + 11], 14, 643717713), i = m(i, s, r, n, t[o + 0], 20, -373897302), n = m(n, i, s, r, t[o + 5], 5, -701558691), r = m(r, n, i, s, t[o + 10], 9, 38016083), s = m(s, r, n, i, t[o + 15], 14, -660478335), i = m(i, s, r, n, t[o + 4], 20, -405537848), n = m(n, i, s, r, t[o + 9], 5, 568446438), r = m(r, n, i, s, t[o + 14], 9, -1019803690), s = m(s, r, n, i, t[o + 3], 14, -187363961), i = m(i, s, r, n, t[o + 8], 20, 1163531501), n = m(n, i, s, r, t[o + 13], 5, -1444681467), r = m(r, n, i, s, t[o + 2], 9, -51403784), s = m(s, r, n, i, t[o + 7], 14, 1735328473), n = g(n, i = m(i, s, r, n, t[o + 12], 20, -1926607734), s, r, t[o + 5], 4, -378558), r = g(r, n, i, s, t[o + 8], 11, -2022574463), s = g(s, r, n, i, t[o + 11], 16, 1839030562), i = g(i, s, r, n, t[o + 14], 23, -35309556), n = g(n, i, s, r, t[o + 1], 4, -1530992060), r = g(r, n, i, s, t[o + 4], 11, 1272893353), s = g(s, r, n, i, t[o + 7], 16, -155497632), i = g(i, s, r, n, t[o + 10], 23, -1094730640), n = g(n, i, s, r, t[o + 13], 4, 681279174), r = g(r, n, i, s, t[o + 0], 11, -358537222), s = g(s, r, n, i, t[o + 3], 16, -722521979), i = g(i, s, r, n, t[o + 6], 23, 76029189), n = g(n, i, s, r, t[o + 9], 4, -640364487), r = g(r, n, i, s, t[o + 12], 11, -421815835), s = g(s, r, n, i, t[o + 15], 16, 530742520), n = v(n, i = g(i, s, r, n, t[o + 2], 23, -995338651), s, r, t[o + 0], 6, -198630844), r = v(r, n, i, s, t[o + 7], 10, 1126891415), s = v(s, r, n, i, t[o + 14], 15, -1416354905), i = v(i, s, r, n, t[o + 5], 21, -57434055), n = v(n, i, s, r, t[o + 12], 6, 1700485571), r = v(r, n, i, s, t[o + 3], 10, -1894986606), s = v(s, r, n, i, t[o + 10], 15, -1051523), i = v(i, s, r, n, t[o + 1], 21, -2054922799), n = v(n, i, s, r, t[o + 8], 6, 1873313359), r = v(r, n, i, s, t[o + 15], 10, -30611744), s = v(s, r, n, i, t[o + 6], 15, -1560198380), i = v(i, s, r, n, t[o + 13], 21, 1309151649), n = v(n, i, s, r, t[o + 4], 6, -145523070), r = v(r, n, i, s, t[o + 11], 10, -1120210379), s = v(s, r, n, i, t[o + 2], 15, 718787259), i = v(i, s, r, n, t[o + 9], 21, -343485551), n = y(n, a), i = y(i, l), s = y(s, c), r = y(r, h)
                }
                return Array(n, i, s, r)
            }

            function p(t, e, n, i, s, r) {
                return y((e = y(y(e, t), y(i, r))) << s | e >>> 32 - s, n)
            }

            function f(t, e, n, i, s, r, o) {
                return p(e & n | ~e & i, t, e, s, r, o)
            }

            function m(t, e, n, i, s, r, o) {
                return p(e & i | n & ~i, t, e, s, r, o)
            }

            function g(t, e, n, i, s, r, o) {
                return p(e ^ n ^ i, t, e, s, r, o)
            }

            function v(t, e, n, i, s, r, o) {
                return p(n ^ (e | ~i), t, e, s, r, o)
            }

            function y(t, e) {
                var n = (65535 & t) + (65535 & e);
                return (t >> 16) + (e >> 16) + (n >> 16) << 16 | 65535 & n
            }
            e.exports = function(t) {
                return u.hash(t, d, 16)
            }
        }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/md5.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify")
    }, {
        "./helpers": 4,
        buffer: 3,
        lYpoI2: 11
    }],
    7: [function(t, e, n) {
        (function(t, n, i, s, r, o, a, l, c) {
            e.exports = function(t) {
                for (var e, n = new Array(t), i = 0; i < t; i++) !(3 & i) && (e = 4294967296 * Math.random()), n[i] = e >>> ((3 & i) << 3) & 255;
                return n
            }
        }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/rng.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify")
    }, {
        buffer: 3,
        lYpoI2: 11
    }],
    8: [function(t, e, n) {
        (function(n, i, s, r, o, a, l, c, h) {
            var u = t("./helpers");

            function d(t, e) {
                t[e >> 5] |= 128 << 24 - e % 32, t[15 + (e + 64 >> 9 << 4)] = e;
                for (var n, i, s, r = Array(80), o = 1732584193, a = -271733879, l = -1732584194, c = 271733878, h = -1009589776, u = 0; u < t.length; u += 16) {
                    for (var d = o, m = a, g = l, v = c, y = h, x = 0; x < 80; x++) {
                        r[x] = x < 16 ? t[u + x] : f(r[x - 3] ^ r[x - 8] ^ r[x - 14] ^ r[x - 16], 1);
                        var b = p(p(f(o, 5), (b = a, i = l, s = c, (n = x) < 20 ? b & i | ~b & s : !(n < 40) && n < 60 ? b & i | b & s | i & s : b ^ i ^ s)), p(p(h, r[x]), (n = x) < 20 ? 1518500249 : n < 40 ? 1859775393 : n < 60 ? -1894007588 : -899497514));
                        h = c, c = l, l = f(a, 30), a = o, o = b
                    }
                    o = p(o, d), a = p(a, m), l = p(l, g), c = p(c, v), h = p(h, y)
                }
                return Array(o, a, l, c, h)
            }

            function p(t, e) {
                var n = (65535 & t) + (65535 & e);
                return (t >> 16) + (e >> 16) + (n >> 16) << 16 | 65535 & n
            }

            function f(t, e) {
                return t << e | t >>> 32 - e
            }
            e.exports = function(t) {
                return u.hash(t, d, 20, !0)
            }
        }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify")
    }, {
        "./helpers": 4,
        buffer: 3,
        lYpoI2: 11
    }],
    9: [function(t, e, n) {
        (function(n, i, s, r, o, a, l, c, h) {
            function u(t, e) {
                var n = (65535 & t) + (65535 & e);
                return (t >> 16) + (e >> 16) + (n >> 16) << 16 | 65535 & n
            }

            function d(t, e) {
                var n, i = new Array(1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298),
                    s = new Array(1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225),
                    r = new Array(64);
                t[e >> 5] |= 128 << 24 - e % 32, t[15 + (e + 64 >> 9 << 4)] = e;
                for (var o, a, l = 0; l < t.length; l += 16) {
                    for (var c = s[0], h = s[1], d = s[2], p = s[3], g = s[4], v = s[5], y = s[6], x = s[7], b = 0; b < 64; b++) r[b] = b < 16 ? t[b + l] : u(u(u((a = r[b - 2], f(a, 17) ^ f(a, 19) ^ m(a, 10)), r[b - 7]), (a = r[b - 15], f(a, 7) ^ f(a, 18) ^ m(a, 3))), r[b - 16]), n = u(u(u(u(x, f(a = g, 6) ^ f(a, 11) ^ f(a, 25)), g & v ^ ~g & y), i[b]), r[b]), o = u(f(o = c, 2) ^ f(o, 13) ^ f(o, 22), c & h ^ c & d ^ h & d), x = y, y = v, v = g, g = u(p, n), p = d, d = h, h = c, c = u(n, o);
                    s[0] = u(c, s[0]), s[1] = u(h, s[1]), s[2] = u(d, s[2]), s[3] = u(p, s[3]), s[4] = u(g, s[4]), s[5] = u(v, s[5]), s[6] = u(y, s[6]), s[7] = u(x, s[7])
                }
                return s
            }
            var p = t("./helpers"),
                f = function(t, e) {
                    return t >>> e | t << 32 - e
                },
                m = function(t, e) {
                    return t >>> e
                };
            e.exports = function(t) {
                return p.hash(t, d, 32, !0)
            }
        }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha256.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify")
    }, {
        "./helpers": 4,
        buffer: 3,
        lYpoI2: 11
    }],
    10: [function(t, e, n) {
        (function(t, e, i, s, r, o, a, l, c) {
            n.read = function(t, e, n, i, s) {
                var r, o, a = 8 * s - i - 1,
                    l = (1 << a) - 1,
                    c = l >> 1,
                    h = -7,
                    u = n ? s - 1 : 0,
                    d = n ? -1 : 1;
                for (s = t[e + u], u += d, r = s & (1 << -h) - 1, s >>= -h, h += a; 0 < h; r = 256 * r + t[e + u], u += d, h -= 8);
                for (o = r & (1 << -h) - 1, r >>= -h, h += i; 0 < h; o = 256 * o + t[e + u], u += d, h -= 8);
                if (0 === r) r = 1 - c;
                else {
                    if (r === l) return o ? NaN : 1 / 0 * (s ? -1 : 1);
                    o += Math.pow(2, i), r -= c
                }
                return (s ? -1 : 1) * o * Math.pow(2, r - i)
            }, n.write = function(t, e, n, i, s, r) {
                var o, a, l = 8 * r - s - 1,
                    c = (1 << l) - 1,
                    h = c >> 1,
                    u = 23 === s ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
                    d = i ? 0 : r - 1,
                    p = i ? 1 : -1;
                for (r = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0, e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (a = isNaN(e) ? 1 : 0, o = c) : (o = Math.floor(Math.log(e) / Math.LN2), e * (i = Math.pow(2, -o)) < 1 && (o--, i *= 2), 2 <= (e += 1 <= o + h ? u / i : u * Math.pow(2, 1 - h)) * i && (o++, i /= 2), c <= o + h ? (a = 0, o = c) : 1 <= o + h ? (a = (e * i - 1) * Math.pow(2, s), o += h) : (a = e * Math.pow(2, h - 1) * Math.pow(2, s), o = 0)); 8 <= s; t[n + d] = 255 & a, d += p, a /= 256, s -= 8);
                for (o = o << s | a, l += s; 0 < l; t[n + d] = 255 & o, d += p, o /= 256, l -= 8);
                t[n + d - p] |= 128 * r
            }
        }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/ieee754/index.js", "/node_modules/gulp-browserify/node_modules/ieee754")
    }, {
        buffer: 3,
        lYpoI2: 11
    }],
    11: [function(t, e, n) {
        (function(t, n, i, s, r, o, a, l, c) {
            var h, u, d;

            function p() {}(t = e.exports = {}).nextTick = (u = typeof window < "u" && window.setImmediate, d = typeof window < "u" && window.postMessage && window.addEventListener, u ? function(t) {
                return window.setImmediate(t)
            } : d ? (h = [], window.addEventListener("message", (function(t) {
                var e = t.source;
                e !== window && null !== e || "process-tick" !== t.data || (t.stopPropagation(), 0 < h.length && h.shift()())
            }), !0), function(t) {
                h.push(t), window.postMessage("process-tick", "*")
            }) : function(t) {
                setTimeout(t, 0)
            }), t.title = "browser", t.browser = !0, t.env = {}, t.argv = [], t.on = p, t.addListener = p, t.once = p, t.off = p, t.removeListener = p, t.removeAllListeners = p, t.emit = p, t.binding = function(t) {
                throw new Error("process.binding is not supported")
            }, t.cwd = function() {
                return "/"
            }, t.chdir = function(t) {
                throw new Error("process.chdir is not supported")
            }
        }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/process/browser.js", "/node_modules/gulp-browserify/node_modules/process")
    }, {
        buffer: 3,
        lYpoI2: 11
    }]
}, {}, [1])(1);
var UE = _m.exports;
const wm = BE(UE);

function Rt(t, e = "Color") {
    /^[\da-fA-F]+$/.test(t) && (t = `#${t}`);
    const n = new Le(t);
    return yt("colorSpace") === rt && n.convertSRGBToLinear(), "#" === (t = `#${n.getHexString()}`)[0] && (t = t.substring(1)), t.length < 6 && (t = `${t[0]}${t[0]}${t[1]}${t[1]}${t[2]}${t[2]}`), t = t.substring(0, 6), {
        [`r${e}`]: parseInt(`${t[0]}${t[1]}`, 16) / 255,
        [`g${e}`]: parseInt(`${t[2]}${t[3]}`, 16) / 255,
        [`b${e}`]: parseInt(`${t[4]}${t[5]}`, 16) / 255
    }
}

function gn(t, e) {
    return e = e.charAt(0).toUpperCase() + e.slice(1), {
        [`x${e}`]: t,
        [`y${e}`]: t,
        [`z${e}`]: t
    }
}

function Mm(t, e) {
    return e = e.charAt(0).toUpperCase() + e.slice(1), {
        [`x${e}`]: t.x,
        [`y${e}`]: t.y,
        [`z${e}`]: t.z
    }
}

function Em(t) {
    return t.replace(/([A-Z])/g, " $1").trim()
}
async function Nh(t) {
    return new Promise((e => setTimeout(e, t)))
}
async function Tm() {
    return new Promise((t => setTimeout(t)))
}
async function Cm(t, e) {
    return new Promise((n => t.addEventListener(e, n, {
        once: !0
    })))
}

function Pm(t, e, n = !1) {
    const i = Math.abs(e - t),
        s = Math.random() * i + t;
    return n ? Math.round(s) : s
}

function Rm(t) {
    return 100 * Math.random() <= t
}

function Fh(t) {
    for (var e in t) void 0 === t[e] && delete t[e];
    return t
}

function Ja(t, e) {
    const n = {};
    for (var i in t) void 0 !== e[i] && (n[i] = e[i]);
    return n
}

function Dm(t) {
    var e;
    return (null == (e = document.cookie.match("(^|;)\\s*" + t + "\\s*=\\s*([^;]+)")) ? void 0 : e.pop()) || null
}

function Im(t) {
    const e = t.getBoundingClientRect();
    return e.top >= 0 && e.left >= 0 && e.bottom <= (window.innerHeight || document.documentElement.clientHeight) && e.right <= (window.innerWidth || document.documentElement.clientWidth)
}

function si(t) {
    return JSON.parse(JSON.stringify(t))
}

function Lm(t, e) {
    const n = Object.keys(e);
    for (let i = 0; i < n.length; i++) {
        const s = n[i];
        void 0 === t[s] && delete e[s]
    }
}

function pi(t) {
    const e = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789".split(""),
        n = ["_"];
    t || (t = 16);
    for (var i = 1; i < t; i++) n.push(e[Math.floor(Math.random() * e.length)]);
    return n.join("")
}

function kh(t, e) {
    const n = { ...t
    };
    for (let t in e) {
        const i = e[t];
        null === i ? n[t] = null : Array.isArray(i) || "object" == typeof i && (n[t] || (n[t] = {}), n[t] = kh(n[t], i))
    }
    return n
}

function Om(t, e) {
    window[t] = e
}

function Bm(t = 1) {
    let e = 2 * Math.PI * Math.random(),
        n = Math.acos(2 * Math.random() - 1),
        i = t * Math.sin(n) * Math.cos(e),
        s = t * Math.sin(n) * Math.sin(e),
        r = t * Math.cos(n);
    return new U(i, s, r)
}

function zh(t = 1, e = 0) {
    const n = t - e,
        i = Math.random() * Math.PI * 2,
        s = Math.acos(2 * Math.random() - 1),
        r = Math.pow(Math.random() * n, 1 / 3),
        o = (r + e) * Math.sin(s) * Math.cos(i),
        a = (r + e) * Math.sin(s) * Math.sin(i),
        l = (r + e) * Math.cos(s);
    return new U(o, a, l)
}

function fn(t, e = 2) {
    for (let n in t) "number" == typeof t[n] && (t[n] = parseFloat(t[n].toFixed(e)));
    return t
}
class Fr {
    constructor(t) {
        if (T(this, "id"), T(this, "name"), T(this, "key"), T(this, "steps", []), T(this, "notes"), T(this, "resetOnStart"), T(this, "prepareChecksum"), T(this, "isCore", !1), T(this, "checksum", ""), T(this, "_index", 0), T(this, "nextStepTime", 0), T(this, "shotData", {}), T(this, "loop", !0), T(this, "_isRunning", !1), this.id = t.id, this.key = t.key, this.name = t.name, this.notes = t.notes, this.resetOnStart = t.resetOnStart ? ? !1, this.loop = t.loop ? ? !0, this.prepareChecksum = t.prepareChecksum, this.isCore = !!t.isCore && !t.id, t.steps)
            for (let e in t.steps) this.addStep(new gr(t.steps[e]))
    }
    get currentStep() {
        return this.steps.length ? this.steps[this.index % this.steps.length] : null
    }
    get index() {
        return this._index
    }
    set index(t) {
        this.steps.length ? this._index = Math.max(0, t % this.steps.length) : this._index = 0
    }
    get shotInfo() {
        return this.currentStep ? {
            key: this.currentStep.shotKey,
            data: { ...this.currentStep.data,
                ...this.shotData
            }
        } : null
    }
    get isRunning() {
        return this._isRunning
    }
    get timeLeft() {
        return this.nextStepTime - zt.elapsed
    }
    get progress() {
        return 1 - this.timeLeft / (this.currentStep.seconds ? ? 1 / 0)
    }
    start(t = {}) {
        if (!this.steps.length) return;
        si(t);
        const e = wm(this.prepareChecksum ? this.prepareChecksum(t) : JSON.stringify(t));
        return (this.checksum !== e || !this.isRunning) && (this.checksum = e, this.shotData = t, this._isRunning = !0, this.resetOnStart && (this.index = 0), this.updateNextStepTime(), this.shotInfo ? ? !1)
    }
    stop() {
        this.nextStepTime = 1 / 0, this._isRunning = !1
    }
    reset() {
        this.shotData = {}, this.stop(), this.index = 0
    }
    tick() {
        return zt.elapsed >= this.nextStepTime ? this.nextStep() : this.isRunning
    }
    updateNextStepTime() {
        this.nextStepTime = zt.elapsed + this.currentStep.seconds
    }
    nextStep() {
        return this.index++, this.loop || 0 !== this.index ? (this.updateNextStepTime(), this.shotInfo ? ? !1) : (this.stop(), !1)
    }
    addStep(t) {
        t.sequence = this, this.steps.push(t)
    }
    deleteStep(t) {
        this.steps.length > 1 && this.steps.splice(t, 1)
    }
    moveStep(t, e) {
        const n = this.steps[t];
        n && (this.steps.splice(t, 1), this.steps.splice(t + e, 0, n))
    }
    get setupData() {
        return { ...this.id ? {
                id: this.id
            } : {},
            name: this.name,
            key: this.key,
            notes: this.notes,
            steps: this.steps.map((t => t.value))
        }
    }
    containsShotKey(t) {
        return !!this.steps.find((e => e.shotKey === t))
    }
}
class gr {
    constructor(t) {
        T(this, "sequence"), T(this, "shotKey"), T(this, "seconds"), T(this, "data"), T(this, "guid", pi(8)), this.shotKey = t.shotKey, this.seconds = t.seconds, this.data = t.data ? ? {}
    }
    get value() {
        return {
            shotKey: this.shotKey,
            seconds: this.seconds,
            params: this.data
        }
    }
}
class Gt {
    constructor({
        id: t,
        key: e,
        name: n,
        data: i,
        notes: s,
        stageAction: r,
        extend: o
    }) {
        T(this, "id"), T(this, "name"), T(this, "key"), T(this, "data"), T(this, "_extend"), T(this, "extendKey"), T(this, "notes"), T(this, "isDynamic"), T(this, "isCore", !1), T(this, "shotCallback"), this.id = t, this.name = n, this.key = e, this.notes = s, this.data = i ? ? {}, o instanceof Gt ? this.extend = o : "string" == typeof o && (this.extendKey = o), this.shotCallback = "function" == typeof r ? r : t => r, this.isDynamic = "function" == typeof r
    }
    get extend() {
        return this._extend
    }
    set extend(t) {
        t !== this && (this._extend || (this._extend = t))
    }
    static getChecksum(t) {
        const e = si(t);
        return delete e.key, delete e.checksum, delete e.timingFunction, wm(t.prepareChecksum ? t.prepareChecksum(e) : JSON.stringify(e))
    }
    value(t) {
        return this.shotCallback(t)
    }
    getStageAction(t, e = !1) {
        const n = this.compile(t, this.extend),
            i = n.onCompile;
        if (i && !e)
            for (let t of i) try {
                if (!t(n)) break
            } catch (t) {
                console.error(t)
            }
        return n.checksum = Gt.getChecksum(n), n
    }
    compile(t, e) {
        t.data = { ...(null == e ? void 0 : e.data) ? ? {},
            ...this.data ? ? {},
            ...t.data ? ? {}
        };
        const n = e ? e.getStageAction(t, !0) : {},
            i = this.value(t);
        return t.to = i, { ...n,
            ...i,
            key: this.key,
            checksum: "",
            tags: [...n.tags ? ? [], ...i.tags ? ? []],
            camera: { ...n.camera,
                ...i.camera
            },
            scene: { ...n.scene,
                ...i.scene
            },
            background: { ...n.background,
                ...i.background
            },
            methods: this.mergeMethods(n.methods, i.methods),
            lights: this.mergeLights(n.lights, i.lights),
            motifs: this.mergeMotifs(n.motifs, i.motifs),
            effects: this.mergeEffects(n.effects, i.effects),
            onShow: t => {
                i.onShow && i.onShow(t), n.onShow && n.onShow(t)
            },
            prepareChecksum: t => (n.prepareChecksum && (t = n.prepareChecksum(t)), i.prepareChecksum && (t = i.prepareChecksum(t)), t),
            onCompile: [...i.onCompile ? ? [], ...n.onCompile ? ? []],
            animate: (t, e) => !(i.animate && !i.animate(t, e)) && (!n.animate || n.animate(t, e))
        }
    }
    mergeMethods(t = {}, e = {}) {
        const n = [...Object.keys(t), ...Object.keys(e)],
            i = {};
        for (const s of n) t[s] && !e[s] ? i[s] = t[s] : e[s] && !t[s] ? i[s] = e[s] : i[s] = async (...n) => e[s](n) && t[s](n);
        return i
    }
    mergeMotifs(t = {}, e = {}) {
        const n = {},
            i = [...Object.keys(t || {}), ...Object.keys(e || {})];
        for (const s of i) "string" != typeof e[s] ? !0 !== e[s] ? !1 !== e[s] ? ("string" == typeof t[s] ? t[s] = {
            state: t[s]
        } : !0 === t[s] ? t[s] = {
            visible: !0
        } : !1 === t[s] && (t[s] = {
            visible: !1
        }), n[s] = {
            visible: !0,
            ...t[s],
            ...e[s]
        }) : n[s] = {
            visible: !1
        } : n[s] = {
            visible: !0
        } : n[s] = {
            state: e[s]
        };
        return n
    }
    mergeLights(t = {}, e = {}) {
        const n = {},
            i = [...Object.keys(t || {}), ...Object.keys(e || {})];
        for (const s of i) "string" != typeof e[s] ? !0 !== e[s] ? !1 !== e[s] ? ("string" == typeof t[s] ? t[s] = {
            state: t[s]
        } : !0 === t[s] ? t[s] = {
            visible: !0
        } : !1 === t[s] && (t[s] = {
            visible: !1
        }), n[s] = {
            visible: !0,
            ...t[s],
            ...e[s]
        }) : n[s] = {
            visible: !1
        } : n[s] = {
            visible: !0
        } : n[s] = {
            state: e[s]
        };
        return n
    }
    mergeEffects(t = {}, e = {}) {
        const n = {},
            i = [...Object.keys(t || {}), ...Object.keys(e || {})];
        for (const s of i) "string" != typeof e[s] ? ("string" == typeof t[s] && (t[s] = {
            state: t[s]
        }), n[s] = { ...t[s],
            ...e[s]
        }) : n[s] = {
            state: e[s]
        };
        return n
    }
}
const Um = class t {
    constructor(e) {
        if (T(this, "name"), T(this, "key"), T(this, "buildStage"), T(this, "configureDisplay"), T(this, "allowOffscreen"), T(this, "demoBackground"), this.name = e.name, this.key = e.key, this.buildStage = e.buildStage, this.configureDisplay = e.configureDisplay, this.allowOffscreen = e.allowOffscreen ? ? !0, this.demoBackground = e.demoBackground, t.instances[this.key]) throw new Error(`Duplicate StageBuilder key "${this.key}"!`);
        t.instances[this.key] = this
    }
    build(t) {
        const e = this.buildStage({ ...t,
            stageName: this.name,
            stageKey: this.key,
            parent: t.parent
        });
        return e.buildComplete = !0, e
    }
    static build(t, e) {
        return this.instances[t] ? this.instances[t].build(e) : (console.warn(`Attempting to build unknown stage with key "${t}"!`), null)
    }
};
T(Um, "instances", {});
let kn = Um;
const ho = "plinthos-canvas",
    NE = "running",
    FE = "stopped",
    kE = "stopping",
    Nm = EventTarget,
    Qc = class t extends Nm {
        constructor(e) {
            var n;
            super(), T(this, "stopAuthority", -1 / 0), T(this, "instanceKey"), T(this, "stageKey"), T(this, "stageName"), T(this, "_canvas"), T(this, "resizeObserver"), T(this, "options"), T(this, "l"), T(this, "_status"), T(this, "isRunning", !1), T(this, "isStopping", !1), T(this, "_shotKey"), T(this, "_debumpedBoundingClientRect"), T(this, "elementEventListeners", {}), T(this, "_pointerEventSurrogate", null), T(this, "_controller"), e.canvas instanceof HTMLCanvasElement || (e.canvas = document.createElement("canvas"));
            const {
                instanceKey: i,
                stageKey: s,
                canvas: r
            } = e;
            this.options = Object.freeze(e), this.elementEventListeners.mousemove = t => this.onMouseMove(t), this.elementEventListeners.mouseout = t => this.onMouseOut(t), this.elementEventListeners.click = t => this.onClick(t), this.elementEventListeners.contextmenu = t => this.onClick(t);
            const o = kn.instances[s];
            if (!o) throw new Error(`Attempting to build Display with invalid stage key: ${s}`);
            this.instanceKey = i, this.stageKey = s, this.stageName = o.name, this.resizeObserver = new ResizeObserver((() => {
                this.onResize()
            })), this.canvas = r, this.canvas.classList.contains(ho) || this.canvas.classList.add(ho), this.resizeObserver.observe(this.canvas), this.l = new To({
                name: i,
                background: "#006",
                color: "#acf",
                active: null == (n = e.options) ? void 0 : n.debug
            }), t.instances[i] = this, this.addEventListener("stopping", (t => {
                this.status = kE
            })), this.addEventListener("stop", (t => {
                this.isRunning = !1, this.status = FE
            })), this.addEventListener("start", (t => {
                this.isRunning = !0, this.status = NE
            })), this.addEventListener("shotchange", (t => {
                this.shotKey = t.shotKey
            })), this.addEventListener("hover", (t => {
                this.hover = t.hover
            }))
        }
        static addEventListener(t, e, n) {
            this.eventTarget.addEventListener(t, e, n)
        }
        static dispatchEvent(t) {
            return this.eventTarget.dispatchEvent(t)
        }
        static removeEventListener(t, e, n) {
            this.eventTarget.removeEventListener(t, e, n)
        }
        static get attribution() {
            const t = [];
            Object.values(this.instances).forEach((e => t.push(...e.attribution)));
            const e = [];
            return t.filter((t => !e.includes(t.html) && (e.push(t.html), !0)))
        }
        static get activeAttribution() {
            const t = [];
            Object.values(this.instances).forEach((e => {
                e.isRunning && t.push(...e.activeAttribution)
            }));
            const e = [];
            return t.filter((t => !e.includes(t.html) && (e.push(t.html), !0)))
        }
        get height() {
            var t;
            return (null == (t = this._canvas) ? void 0 : t.height) ? ? 0
        }
        get width() {
            var t;
            return (null == (t = this._canvas) ? void 0 : t.width) ? ? 0
        }
        get aspect() {
            var t, e;
            return ((null == (t = this._canvas) ? void 0 : t.width) ? ? 1) / ((null == (e = this._canvas) ? void 0 : e.height) ? ? 1)
        }
        get canvas() {
            return this._canvas
        }
        set canvas(t) {
            t !== this._canvas && (this._canvas && (this.removeEventListenersFromElement(this._canvas), this.resizeObserver.unobserve(this._canvas)), this._canvas = t, this.addEventListenersToElement(t), this.resizeObserver.observe(t), this.onSetCanvas(t), t.dataset[bo] = this.stageKey, t.dataset[Ss] = this.instanceKey, t.dataset[Na] = this.status, t.classList.add(ho), this.afterSetStopDelay(), t.id || (t.id = pi()))
        }
        afterSetStopDelay() {
            this.canvas && (this.canvas.style.transition = `opacity ${this.stopDelay??0}ms`, this.canvas.style.transitionTimingFunction = "ease-out")
        }
        static build(t) {
            const e = kn.instances[t.stageKey];
            if (!e) throw new Error(`Attempting to build display with unknown stage key: ${t.stageKey}`);
            return t.workerKey && Oh && e.allowOffscreen ? new So(t) : new ul(t)
        }
        get status() {
            return this._status
        }
        set status(t) {
            this._status = t, this.canvas.dataset[Na] = t
        }
        get shotKey() {
            return this._shotKey
        }
        set shotKey(t) {
            this._shotKey = t, this.canvas.dataset[Dh] = t
        }
        configureDisplay(t) {
            var e;
            const n = kn.instances[this.stageKey];
            null == (e = n.configureDisplay) || e.call(n, t, this)
        }
        get debumpedBoundingClientRect() {
            return this.canvas ? (this._debumpedBoundingClientRect || (this._debumpedBoundingClientRect = this.canvas.getBoundingClientRect(), setTimeout((() => this._debumpedBoundingClientRect = void 0), 200)), this._debumpedBoundingClientRect) : null
        }
        onMouseMove(t) {
            const e = this.debumpedBoundingClientRect,
                n = (t.clientX - e.left) / this.canvas.offsetWidth * 2 - 1,
                i = -(t.clientY - e.top) / this.canvas.offsetHeight * 2 + 1;
            this.handleMouseMove(t, n, i)
        }
        onClick(t) {
            t.preventDefault(), this.handleClick(t)
        }
        onMouseOut(t) {
            this.handleMouseOut()
        }
        addEventListenersToElement(t) {
            for (let e in this.elementEventListeners) t.addEventListener(e, this.elementEventListeners[e]);
            t.style.userSelect = "none"
        }
        removeEventListenersFromElement(t) {
            for (let e in this.elementEventListeners) t.removeEventListener(e, this.elementEventListeners[e]);
            t.style.userSelect = "", t.style.cursor = ""
        }
        get pointerEventSurrogate() {
            return this._pointerEventSurrogate
        }
        set pointerEventSurrogate(t) {
            this._pointerEventSurrogate && this.removeEventListenersFromElement(this.pointerEventSurrogate), this._pointerEventSurrogate = t, t && this.addEventListenersToElement(t)
        }
        get isIntersecting() {
            const t = this.debumpedBoundingClientRect;
            var e = document.documentElement;
            return t.right > 0 && t.bottom > 0 && t.left < (window.innerWidth ? ? e.clientWidth) && t.top < (window.innerHeight ? ? e.clientHeight)
        }
        set hover(t) {
            this.canvas.style.cursor = t ? "pointer" : "", this.pointerEventSurrogate && (this.pointerEventSurrogate.style.cursor = t ? "pointer" : "")
        }
        get controller() {
            if (!this._controller) {
                const t = this,
                    e = new tl,
                    n = {
                        get instanceKey() {
                            return t.instanceKey
                        },
                        get stageKey() {
                            return t.stageKey
                        },
                        get stageName() {
                            return t.stageName
                        },
                        get isOffscreen() {
                            return t instanceof So
                        },
                        start() {
                            t.start()
                        },
                        stop(e) {
                            t.stop(e)
                        },
                        pause() {
                            t.pause()
                        },
                        unpause() {
                            t.unpause()
                        },
                        get isRunning() {
                            return t.isRunning
                        },
                        get isStopping() {
                            return t.isStopping
                        },
                        get shotKey() {
                            return t.shotKey
                        },
                        show: async (e, n = {}, i = !0) => await t.setContent(e, {
                            start: i,
                            data: n
                        }),
                        smash: async (e, n = {}, i = !0) => await t.setContent(e, {
                            start: i,
                            data: n,
                            instant: !0
                        }),
                        get contentKey() {
                            return t.contentKey
                        },
                        set contentKey(e) {
                            t.contentKey = e
                        },
                        get bindings() {
                            return t.bindings
                        },
                        get userData() {
                            return t.userData
                        },
                        get shotData() {
                            return t.shotData
                        },
                        run: async (e, ...n) => t.run(e, ...n),
                        benchmark: async e => await t.benchmark(e),
                        get debug() {
                            return t.debug
                        },
                        set debug(e) {
                            t.debug = e
                        },
                        get pixelRatio() {
                            return t.pixelRatio
                        },
                        set pixelRatio(e) {
                            t.pixelRatio = e
                        },
                        get skipFrames() {
                            return t.skipFrames
                        },
                        set skipFrames(e) {
                            t.skipFrames = e
                        },
                        get pointerEventSurrogate() {
                            return t.pointerEventSurrogate
                        },
                        set pointerEventSurrogate(e) {
                            t.pointerEventSurrogate = e
                        },
                        get canvas() {
                            return t.canvas
                        },
                        set canvas(e) {
                            e && (t.canvas = e)
                        },
                        get isIntersecting() {
                            return t.isIntersecting
                        },
                        addEventListener(t, n, i) {
                            e.addEventListener(t, n, i)
                        },
                        removeEventListener(t, n, i) {
                            e.removeEventListener(t, n, i)
                        },
                        get attribution() {
                            return t.attribution
                        },
                        get activeAttribution() {
                            return t.activeAttribution
                        }
                    };
                for (let t of $a) this.addEventListener(t, (t => {
                    e.dispatchEvent(t.publicEvent) || t.preventDefault()
                }));
                this._controller = n
            }
            return this._controller
        }
        start(t) {
            if (!(((null == t ? void 0 : t.authority) ? ? 0) < this.stopAuthority)) return this.stopAuthority = -1 / 0, t && delete t.authority, this.handleStart(t)
        }
        stop(t) {
            const e = (null == t ? void 0 : t.authority) ? ? 0;
            return this.stopAuthority = Math.max(this.stopAuthority, e), t && delete t.authority, this.handleStop(t)
        }
        setContent(t, e) {
            const n = (null == e ? void 0 : e.authority) ? ? 0;
            return e.start && n < this.stopAuthority && delete e.start, e && delete e.authority, this.handleSetContent(t, e)
        }
    };
T(Qc, "instances", {}), T(Qc, "eventTarget", new Nm);
let pt = Qc;

function vn(t, e = 0) {
    const n = Array.isArray(t) ? [] : {};
    if (e < 0) return n;
    if (Array.isArray(t)) {
        if (!Array.isArray(n)) return;
        for (let i of t) switch (typeof i) {
            case "function":
                continue;
            case "object":
                n.push(vn(i, vc(i) ? 0 : e - 1));
                break;
            default:
                n.push(i)
        }
    } else
        for (let i in t) {
            const s = t[i];
            switch (typeof s) {
                case "function":
                    continue;
                case "object":
                    if (vc(s)) {
                        n[i] = null;
                        continue
                    }
                    n[i] = vn(s, vc(s) ? 0 : e - 1);
                    break;
                default:
                    n[i] = s
            }
        }
    return n
}

function vc(t) {
    return !!Mn && t instanceof HTMLElement
}
const $a = ["beforestart", "start", "starting", "hover", "beforestop", "stopping", "stop", "beforecontentchange", "contentchange", "beforeshotchange", "shotchange", "beforesequencechange", "sequencechange", "attributionchange", "loadstart", "loadend", "custom"],
    el = EventTarget,
    tl = EventTarget;
class _t extends Event {
    constructor(t, e, n) {
        n.offscreen && (n.cancelable = !1), super(t, n), T(this, "source"), T(this, "stage"), T(this, "display"), T(this, "stageKey"), T(this, "instanceKey"), T(this, "stageName"), T(this, "type"), T(this, "offscreen"), this.type = t, this.source = e, e instanceof wn ? (this.stageName = e.name, this.stageKey = e.key, this.stage = e) : (this.stageName = e.stageName, this.stageKey = e.stageKey, this.display = e), this.displayKey = this.instanceKey = e.instanceKey ? ? n.instanceKey, this.offscreen = n.offscreen ? ? !1
    }
    get publicEvent() {
        return new _t(this.type, this.display instanceof pt ? this.display.controller : this.display, this.publicTransferable)
    }
    get publicTransferable() {
        return {
            cancelable: this.cancelable,
            stageName: this.stageName,
            stageKey: this.stageKey,
            instanceKey: this.instanceKey,
            offscreen: this.offscreen
        }
    }
    get transferable() {
        return { ...this.publicTransferable,
            type: this.type,
            constructorName: this.constructor.name
        }
    }
}
class Ls extends _t {
    constructor(t, e) {
        super("newstage", t, e), T(this, "setup"), this.setup = e.setup
    }
}
class es extends _t {
    constructor(t, e) {
        super("attachcanvas", t, e), T(this, "canvas"), this.canvas = e.canvas
    }
    get publicEvent() {
        return new es(this.display instanceof pt ? this.display.controller : this.display, { ...super.publicTransferable,
            canvas: this.canvas
        })
    }
}
class Di extends _t {
    constructor(t, e) {
        super("hover", t, e), T(this, "hover"), this.hover = e.hover
    }
    get publicEvent() {
        return new Di(this.display instanceof pt ? this.display.controller : this.display, this.publicTransferable)
    }
    get publicTransferable() {
        return { ...super.publicTransferable,
            hover: this.hover
        }
    }
    get transferable() {
        return { ...super.transferable,
            hover: this.hover
        }
    }
}
class Ct extends _t {
    constructor(t, e, n) {
        var i, s;
        super(t, e, n), T(this, "content"), T(this, "key"), T(this, "contentKey"), T(this, "stageAction"), T(this, "shotKey"), T(this, "sequenceKey"), T(this, "shot"), T(this, "sequence"), T(this, "params"), T(this, "data"), this.content = n.content, this.contentKey = this.key = (null == (i = n.content) ? void 0 : i.key) ? ? n.key, this.stageAction = n.stageAction, this.params = n.params, this.data = (null == (s = n.params) ? void 0 : s.data) ? ? n.data, this.sequenceKey = n.sequenceKey, this.shotKey = n.shotKey, n.content instanceof Gt ? (this.shot = n.content, this.shotKey = n.content.key) : n.content instanceof Fr && (this.sequence = n.content, this.sequenceKey = n.content.key)
    }
    get publicEvent() {
        return new Ct(this.type, this.display instanceof pt ? this.display.controller : this.display, this.publicTransferable)
    }
    get publicTransferable() {
        return { ...super.publicTransferable,
            key: this.key,
            data: this.data,
            sequenceKey: this.sequenceKey,
            shotKey: this.sequenceKey
        }
    }
    get transferable() {
        return { ...super.transferable,
            key: this.key,
            data: vn(this.data, 2),
            sequenceKey: this.sequenceKey,
            shotKey: this.shotKey,
            params: vn(this.params, 3),
            stageAction: vn(this.stageAction, 3)
        }
    }
}
class Ii extends _t {
    constructor(t, e, n) {
        super(t, e, n), T(this, "attribution"), T(this, "activeAttribution"), T(this, "allAttribution"), T(this, "allActiveAttribution"), this.attribution = n.attribution, this.activeAttribution = n.activeAttribution, this.allAttribution = n.allAttribution, this.allActiveAttribution = n.allActiveAttribution
    }
    get publicEvent() {
        return new Ii(this.type, this.display instanceof pt ? this.display.controller : this.display, this.publicTransferable)
    }
    get publicTransferable() {
        return { ...super.publicTransferable,
            attribution: this.attribution,
            activeAttribution: this.activeAttribution,
            allAttribution: this.allAttribution,
            allActiveAttribution: this.allActiveAttribution
        }
    }
}
class Li extends _t {
    constructor(t, e, n) {
        super(t, e, n), T(this, "key"), T(this, "data"), this.key = n.key ? ? "custom", this.data = n.data
    }
    get publicEvent() {
        return new Li(this.type, this.display instanceof pt ? this.display.controller : this.display, this.publicTransferable)
    }
    get publicTransferable() {
        return { ...super.publicTransferable,
            key: this.key,
            data: this.data
        }
    }
    get transferable() {
        return { ...super.transferable,
            key: this.key,
            data: vn(this.data, 5)
        }
    }
}
const sr = class t extends el {
    constructor(e) {
        var n;
        super(), T(this, "name"), T(this, "key"), T(this, "instanceKey"), T(this, "resolution", new Q), T(this, "stopDelay", 0), T(this, "_hover", !1), T(this, "scene", new Bc), T(this, "renderManager"), T(this, "motifSpace", new Fn), T(this, "motifs", {}), T(this, "cameraController"), T(this, "sceneController"), T(this, "lightControllers"), T(this, "effectControllers"), T(this, "background"), T(this, "raycaster", new Kp), T(this, "mousePosition", new Q), T(this, "isMouseOver", !1), T(this, "bindingTargets", {}), T(this, "bindings", {}), T(this, "bindingsStore", {}), T(this, "guiBindings", {}), T(this, "guiBindingChanges", {}), T(this, "_buildComplete", !1), T(this, "_debug", !1), T(this, "l"), T(this, "_currentStageAction", null), T(this, "_currentSequence", null), T(this, "pendingShotKey"), T(this, "shots", {}), T(this, "sequences", {}), T(this, "outroTime", 0), T(this, "stopTimer"), T(this, "stopping", !1), T(this, "paused", !1), T(this, "_isRunning", !1), T(this, "_guiVisible", !0), T(this, "guiActive", !0), T(this, "debugGui", null), T(this, "sceneGui", null), T(this, "lightsGui", null), T(this, "cameraGui", null), T(this, "backgroundGui", null), T(this, "motifsGui", null), T(this, "effectsGui", null), T(this, "methodsGui", null), T(this, "bindingsGui", null), T(this, "shotDataGui", null), T(this, "methodsGuiParamJson", "[]"), T(this, "_isLoading", !1), T(this, "onRender"), T(this, "userData"), T(this, "methods"), T(this, "options", {}), T(this, "tweakpane"), T(this, "offsetHeight"), T(this, "offsetWidth"), T(this, "shotData", {}), T(this, "startPending", !1), T(this, "needsResize", !0), T(this, "skipFrames", 0), T(this, "skippedFrames", 0), T(this, "pendingDelta", 0), T(this, "pendingFrame", !1), T(this, "transients", {}), T(this, "contentDebump", null), T(this, "pendingDebumpedContent"), T(this, "hoverHandler", null), T(this, "updateAttributionLockout", !1);
        const {
            stageName: i,
            stageKey: s,
            instanceKey: r,
            canvas: o,
            cameraController: a,
            lightControllers: l,
            motifs: c,
            background: h,
            effectControllers: u,
            tweakpane: d,
            userData: p,
            shotData: f,
            methods: m,
            options: g,
            interceptEvents: v
        } = e;
        for (var y in this.name = i, this.key = s, this.instanceKey = r ? ? s, this.tweakpane = d, this.userData = p ? ? {}, this.shotData = f ? ? {}, this.methods = m ? ? {}, this.options = g ? ? {}, this.offsetWidth = o.width, this.offsetHeight = o.height, this.l = new To({
                name: this.instanceKey,
                color: "#111",
                background: "#ccc",
                active: !!this.options.debug
            }), this.debug = !!this.options.debug, this.l.log("Constructing stage", e), t.instances[this.instanceKey] && console.warn(`Colliding instance key "${this.instanceKey}" when buliding stage "${this.name}"`), t.instances[this.instanceKey] = this, this.interceptEvents = v, this.tweakpane && (this.debugGui = this.tweakpane.addFolder({
                title: "Debug",
                expanded: !1,
                hidden: !this.debug
            }), this.sceneGui = this.tweakpane.addFolder({
                title: "Scene",
                expanded: !1
            }), this.cameraGui = this.tweakpane.addFolder({
                title: "Camera",
                expanded: !1
            }), this.backgroundGui = this.tweakpane.addFolder({
                title: "Background",
                expanded: !1
            }), this.lightsGui = this.tweakpane.addFolder({
                title: "Lights",
                expanded: !1
            }), this.motifsGui = this.tweakpane.addFolder({
                title: "Motifs",
                expanded: !1
            }), this.effectsGui = this.tweakpane.addFolder({
                title: "Effects",
                expanded: !1
            }), this.methodsGui = this.tweakpane.addFolder({
                title: "Reactions",
                expanded: !1
            }), this.bindingsGui = this.tweakpane.addFolder({
                title: "Bindings",
                expanded: !1
            }), this.shotDataGui = this.tweakpane.addFolder({
                title: "Shot Data",
                expanded: !1
            })), this.sceneController = new jh(e.scene || {}), this.sceneController.stage = this, this.sceneGui && this.sceneController.initGui(this.sceneGui, !0), this.cameraController = a || new ml, this.cameraController.stage = this, this.scene.background = null, this.lightControllers = l, this.lightControllers) this.lightControllers[y].stage = this, this.lightsGui && this.lightControllers[y].initGui(this.lightsGui);
        for (var y in this.cameraGui && this.cameraController.initGui(this.cameraGui, !0), this.scene.add(this.motifSpace), c) this.addMotif(y, c[y]);
        for (var y in this.background = h || void 0, this.background ? (this.background.stage = this, this.backgroundGui && this.background.initGui(this.backgroundGui, !0)) : this.backgroundGui && (this.backgroundGui.hidden = !0), this.effectControllers = u, this.effectControllers) {
            const t = this.effectControllers[y];
            t.stage = this, this.effectsGui && t.initGui(this.effectsGui)
        }
        this.renderManager = new Wh({
            stage: this,
            effectControllers: u,
            parent: null == (n = this.options.parentStage) ? void 0 : n.renderManager,
            canvas: o,
            devicePixelRatio: this.options.devicePixelRatio,
            maxPixelRatio: this.options.maxPixelRatio,
            pixelRatio: this.options.pixelRatio
        }), this.tweakpane && this.initGui(), this.guiVisible = !1, this.raycaster.layers.set(mr), this.animate(), t.dispatchEvent(new Ls(this, {
            setup: e
        }))
    }
    static setContent(t, e, n = {}) {
        const i = this.instances[t];
        i && i.setContent(e, n)
    }
    static get isLoading() {
        return Object.values(this.instances).some((t => t.isLoading))
    }
    get texture() {
        return this.renderManager.texture ? ? null
    }
    get canvas() {
        return this.renderManager.canvas
    }
    set canvas(t) {
        t && (this.renderManager.canvas = t)
    }
    set hover(t) {
        t !== this._hover && (this._hover = t, this.dispatchEvent(new Di(this, {
            hover: t
        })))
    }
    get hover() {
        return this._hover
    }
    get bindingsDisabled() {
        return this.options.disableBindings ? ? !1
    }
    get buildComplete() {
        return this._buildComplete
    }
    set buildComplete(e) {
        this._buildComplete || (this._buildComplete = !0, t.dispatchEvent(new _t("afterbuild", this, {})))
    }
    get debug() {
        return this._debug
    }
    set debug(t) {
        this._debug = t, this.l.active = this._debug, this.renderManager && (this.renderManager.debug = t)
    }
    get currentStageAction() {
        return this._currentStageAction
    }
    set currentStageAction(t) {
        t && (this._currentStageAction = Object.freeze(t))
    }
    get contentKey() {
        return this.currentSequence ? this.currentSequence.key : this.shotKey
    }
    set contentKey(t) {
        this.setContent(t)
    }
    get contentName() {
        var t;
        return this.currentSequence ? this.currentSequence.name : (null == (t = this.shot) ? void 0 : t.name) ? ? ""
    }
    get shotKey() {
        var t;
        return (null == (t = this.currentStageAction) ? void 0 : t.key) || ""
    }
    get shot() {
        return this.shots[this.shotKey] || null
    }
    get currentSequence() {
        return this._currentSequence
    }
    get content() {
        return { ...this.shots,
            ...this.sequences
        }
    }
    get pixelRatio() {
        return this.renderManager.pixelRatio
    }
    set pixelRatio(t) {
        this.renderManager.pixelRatio = t
    }
    get isRunning() {
        return this._isRunning
    }
    get isStopping() {
        return this.stopping
    }
    pause() {
        this.paused = !0
    }
    unpause() {
        this.paused = !1, this.isRunning && !this.pendingFrame && this.animate()
    }
    get isLoading() {
        return this._isLoading
    }
    get methodKeys() {
        var t;
        return Object.keys({ ...this.methods,
            ...(null == (t = this.currentStageAction) ? void 0 : t.methods) ? ? {}
        })
    }
    get width() {
        var t;
        return null == (t = this.canvas) ? void 0 : t.width
    }
    get height() {
        var t;
        return null == (t = this.canvas) ? void 0 : t.height
    }
    set width(t) {
        this.offsetWidth = t, this.needsResize = !0
    }
    set height(t) {
        this.offsetHeight = t, this.needsResize = !0
    }
    get isLandscape() {
        return this.offsetWidth > this.offsetHeight
    }
    get isPortrait() {
        return this.offsetWidth < this.offsetHeight
    }
    get aspect() {
        return this.offsetWidth / this.offsetHeight
    }
    get camera() {
        return this.cameraController.camera
    }
    get agents() {
        return [this.cameraController, this.sceneController, ...this.background ? [this.background] : [], ...Object.values(this.effectControllers), ...Object.values(this.lightControllers), ...Object.values(this.motifs)]
    }
    static start(t) {
        this.instances[t] ? this.instances[t].start() : console.error(`Attempting to start non-existent stage ${t}`)
    }
    start() {
        if (this.dispatchEvent(new _t("requeststart", this, {})), !this._isRunning || this.isStopping) {
            if (!this.currentStageAction) return this.l.warn("Attempting to start with no content!"), void this.startWhenReady();
            if (clearTimeout(this.stopTimer), !this.dispatchEvent(new _t("beforestart", this, {
                    cancelable: !0
                }))) return void this.l.log(`Starting of stage "${this.key}" cancelled by event handler!`);
            if (this.guiVisible = !0, this._isRunning) return void(this.stopping && (this.stopping = !1, this.dispatchEvent(new _t("starting", this, {})), this.dispatchEvent(new _t("start", this, {}))));
            this.l.log("🟢 Starting"), this._isRunning = !0, this.dispatchEvent(new _t("starting", this, {})), this.resize(), this.animate(), this.dispatchEvent(new _t("start", this, {}))
        }
    }
    startWhenReady() {
        this.startPending || (this.startPending = !0, this.addEventListener("shotready", (() => {
            this.startPending && (this.startPending = !1, setTimeout((() => this.start())))
        }), {
            once: !0
        }))
    }
    static stop(t, e = 0) {
        if (t) {
            if (!this.instances[t]) return void console.error(`Attempting to stop non-existent stage ${t}`);
            this.instances[t].stop({
                delay: e
            })
        } else
            for (let t in this.instances) this.instances[t].stop({
                delay: e
            })
    }
    stop(t = {}) {
        const e = t.delay ? ? this.stopDelay,
            n = t.reset ? ? !1;
        if (this.startPending = !1, !this._isRunning || this.stopping) return;
        if (!this.dispatchEvent(new _t("beforestop", this, {
                cancelable: !0
            }))) return void this.l.log("Stopping cancelled by event handler!");
        this.l.log("🟠 Stopping"), this.stopping = !0;
        const i = () => {
            this.l.log("🔴 Stopped"), this._isRunning = !1, this.stopping = !1, n && this.reset(), this.dispatchEvent(new _t("stop", this, {}))
        };
        this.dispatchEvent(new _t("stopping", this, {})), e ? this.stopTimer = setTimeout(i, e) : i(), this.guiVisible = !1
    }
    reset() {
        return this._isRunning ? (this.l.warn("Cannot reset a running stage!"), !1) : (this.l.log("Resetting"), this._currentStageAction = null, !0)
    }
    async animate() {
        var t;
        if (this.skipFrames <= this.skippedFrames) {
            const e = zt.elapsed,
                n = zt.delta + this.pendingDelta;
            if (this.needsResize && this.resize(), this.currentSequence && !this.isStopping) {
                const t = this.currentSequence.tick();
                t instanceof Object ? this.setShot(t.key, {
                    data: t.data
                }) : t || (this._currentSequence = null)
            }
            this.isMouseOver && this.mouseOver(), this.cameraController.animateAgent(n, e);
            for (let t in this.motifs) {
                const i = this.motifs[t];
                i.visible && !i.parent && i.animateAgent(n, e)
            }
            for (let t in this.lightControllers) {
                const i = this.lightControllers[t];
                i.visible && !i.parent && i.animateAgent(n, e)
            }
            for (let t in this.effectControllers) this.effectControllers[t].animateAgent(n, e);
            this.sceneController.animateAgent(n, e), null != (t = this.currentStageAction) && t.animate && this.currentStageAction.animate(n, e), this.renderManager.render(n), this.onRender && await this.onRender(), this.skippedFrames = 0, this.pendingDelta = 0;
            for (let t in this.transients) delete this.transients[t]
        } else this.skippedFrames++, this.pendingDelta += zt.delta;
        this._isRunning && !this.pendingFrame && !this.paused && (this.pendingFrame = !0, requestAnimationFrame((() => {
            this.pendingFrame = !1, this.animate()
        }))), this.allocateBindings()
    }
    async benchmark(t = 10, e = 60) {
        const n = this.isRunning,
            i = this.skipFrames;
        this.skipFrames = 0, this.guiActive = !1, await this.stop({
            delay: 0
        }), zt.captureMode = !0;
        const s = [];
        t = Math.max(Math.min(t, 100), 1);
        for (var r = 0; r < t; r++) {
            const t = performance.now();
            for (var o = 0; o < e; o++) await this.animate(), zt.tick();
            s.push(performance.now() - t)
        }
        const a = s.reduce(((t, e) => t + e), 0) / s.length || 0,
            l = 1e3 / e * (1 + i),
            c = 100 - a / e / l * 100;
        this.guiActive = !0, this.skipFrames = i, zt.captureMode = !1, n && requestAnimationFrame((() => this.start()));
        const h = `hsl(${Math.round(LE(IE(c,0,100),0,100,0,120))}, 100%, 70%)`,
            u = c > 90 ? "A+" : c > 80 ? "A" : c > 70 ? "B+" : c > 60 ? "B" : c > 50 ? "C+" : c > 40 ? "C" : c > 30 ? "D+" : c > 20 ? "D" : c > 10 ? "E+" : c > 0 ? "E" : "F",
            d = {
                stageKey: this.key,
                health: c,
                average: a,
                target: l,
                iterations: t,
                min: Math.min(...s),
                max: Math.max(...s),
                samples: s,
                grade: u,
                color: h
            },
            p = { ...d,
                samples: null
            };
        return delete p.samples, console.table(p), d
    }
    resize(t) {
        var e, n, i, s, r, o, a, l, c, h;
        this.needsResize = !1, this.renderManager.resize(this.offsetWidth, this.offsetHeight), this.cameraController.onResize(), null == (n = (e = this.sceneController).onResize) || n.call(e), null == (s = null == (i = this.background) ? void 0 : i.onResize) || s.call(i);
        for (let t in this.lightControllers) this.lightControllers[t].visible && (null == (o = (r = this.lightControllers[t]).onResize) || o.call(r));
        for (let t in this.motifs) this.motifs[t].visible && (null == (l = (a = this.motifs[t]).onResize) || l.call(a));
        for (let t in this.effectControllers) this.effectControllers[t] && (null == (h = (c = this.effectControllers[t]).onResize) || h.call(c))
    }
    get contentKeys() {
        return [...Object.keys(this.shots), ...Object.keys(this.sequences)]
    }
    addShot(t) {
        return -1 !== this.contentKeys.indexOf(t.key) ? (this.l.warn(`Attempting to add shot with duplicate key "${t.key}"!`), !1) : (t.isCore = !this.buildComplete, t.extendKey && (t.extend = this.shots[t.extendKey], t.extend || this.l.warn(`Failed to extend shot "${t.name}" from non-existent / unavailable shot key "${t.extendKey}". Make sure that the base shot is added to the stage before the sub shot.`)), this.shots.default && (t.extend = this.shots.default), this.shots[t.key] = t, this.dispatchEvent(new Ct("addshot", this, {
            content: t
        })), !0)
    }
    removeShot(t) {
        const e = this.shots[t];
        if (!e.isCore) return !(!e || !e.id || (delete this.shots[t], this.shotKey === t && (this.contentKey = "default"), this.dispatchEvent(new Ct("removeshot", this, {
            content: e
        })), 0))
    }
    addSequence(t) {
        return -1 !== this.contentKeys.indexOf(t.key) ? (this.l.warn(`Attempting to add sequence with duplicate key "${t.key}"!`), !1) : (t.isCore = !this.buildComplete, this.sequences[t.key] = t, this.dispatchEvent(new Ct("addsequence", this, {
            content: t
        })), !0)
    }
    removeSequence(t) {
        const e = this.sequences[t];
        return !(!e || !e.id || (e.stop(), delete this.sequences[t], this.dispatchEvent(new Ct("removesequence", this, {
            content: e
        })), 0))
    }
    clearContentDebump() {
        clearTimeout(this.contentDebump), this.contentDebump = null
    }
    async setContent(t, e = {}) {
        const n = e.start ? ? !1,
            i = e.debump ? !0 === e.debump ? 200 : e.debump : 0;
        return n && (this.shots[t] || this.sequences[t]) && (this.isRunning || this.reset(), this.startWhenReady()), new Promise((async n => {
            const s = async s => {
                if (s) return void n(!1);
                this.pendingDebumpedContent = null;
                let r = !1;
                return this.shots[t] ? (this.stopSequence(), r = await this.setShot(t, e)) : this.sequences[t] ? r = await this.setSequence(t, e) : (this.l.warn(`No content found for stage "${this.name}" with key "${t}"!`), r = !1), r && i && (this.contentDebump = setTimeout((async () => {
                    this.clearContentDebump(), this.pendingDebumpedContent && n(await this.pendingDebumpedContent())
                }), i)), r
            };
            this.contentDebump ? (this.pendingDebumpedContent && this.pendingDebumpedContent(!0), this.pendingDebumpedContent = s) : n(await s())
        }))
    }
    getContentByKey(t) {
        return this.shots[t] ? ? this.sequences[t] ? ? null
    }
    async setSequence(t, e = {}) {
        var n;
        const i = this.sequences[t];
        if (!i) return this.l.warn(`Attempting to set unknown sequence "${t}" on stage "${this.key}"!`), !1;
        const s = e.data ? ? {};
        let r = !1;
        if (r = !this.dispatchEvent(new Ct("beforecontentchange", this, {
                cancelable: !0,
                content: i,
                data: s
            })) || r, r = !this.dispatchEvent(new Ct("beforesequencechange", this, {
                cancelable: !0,
                content: i,
                data: s
            })) || r, r) return !1;
        i.isRunning && (null == (n = this._currentSequence) ? void 0 : n.key) !== i.key && i.stop();
        const o = i.start(s);
        return !!o && (this._currentSequence && this._currentSequence.stop(), this._currentSequence = i, e.data = o.data, o && this.setShot(o.key, e), this.dispatchEvent(new Ct("sequencechange", this, {
            content: i
        })), this.dispatchEvent(new Ct("contentchange", this, {
            content: i
        })), !0)
    }
    stopSequence() {
        this._currentSequence && this._currentSequence.stop(), this._currentSequence = null
    }
    async setShot(e, n = {}) {
        var i, s, r, o, a, l, c, h, u, d;
        this.l.log("setShot", e);
        const p = { ...this.shotData,
            ...n.data ? ? {}
        };
        if (t.lockShot) return !1;
        if (!this.shots[e]) return this.l.log(`setShot on ${e} failed - stage ${this.key} has no such shot.`), !1;
        let f = !1;
        if (this.currentSequence || (f = !this.dispatchEvent(new Ct("beforecontentchange", this, {
                cancelable: !0,
                content: this.shots[e],
                data: p
            })) || f), f = !this.dispatchEvent(new Ct("beforeshotchange", this, {
                cancelable: !0,
                content: this.shots[e],
                data: p
            })) || f, f) return !1;
        const m = {
            from: this.currentStageAction,
            instant: n.instant ? ? !1,
            data: p
        };
        this.currentSequence && (m.sequence = this.currentSequence);
        const g = !!m.instant,
            v = this.shots[e];
        if (!v) return !1;
        const y = v.getStageAction(m);
        Object.freeze(m.data);
        const x = {
            content: v,
            params: m,
            stageAction: y,
            data: m.data
        };
        if (this.pendingShotKey = e, y.checksum === (null == (i = this.currentStageAction) ? void 0 : i.checksum) && !g) return this.l.log(`setShot on ${e} failed - same as current shot`), this.dispatchEvent(new Ct("shotready", this, x)), !1;
        this._isLoading = !0, this.dispatchEvent(new Ct("loadstart", this, x));
        const b = y.motifs || {},
            A = { ...(null == (s = y.defaults) ? void 0 : s.show) || {},
                visible: !0
            },
            S = (null == (r = y.defaults) ? void 0 : r.move) || {},
            w = (null == (o = y.defaults) ? void 0 : o.hide) || {},
            _ = [],
            M = {};
        for (var T in w.visible = !1, this.motifs) {
            const t = this.motifs[T],
                e = b[T];
            void 0 === e ? t.showByDefault ? M[T] = { ...A,
                ...g ? {
                    instant: !0
                } : {}
            } : M[T] = { ...w,
                ...g ? {
                    instant: !0
                } : {}
            } : !1 === e.visible ? M[T] = { ...e,
                ...w,
                ...g ? {
                    instant: !0
                } : {}
            } : t.active ? M[T] = { ...e,
                outroDelay: this.outroTime,
                ...S,
                ...g ? {
                    instant: !0
                } : {}
            } : M[T] = { ...e,
                outroDelay: this.outroTime,
                ...A,
                ...g ? {
                    instant: !0
                } : {}
            }
        }
        for (var T in M) !1 !== M[T].visible && _.push(this.motifs[T].init(t.firstContent));
        if (await Promise.all(_), this.pendingShotKey !== e) return this.l.log(`Aborting shot; ${e} didn't init in time.`), !1;
        t.firstContent && setTimeout((() => t.firstContent = !1), 500), this.currentStageAction = y;
        const E = [],
            C = [];
        for (let t in M) {
            const e = this.motifs[t],
                n = M[t];
            if (e.parent && !0 === n.visible && (!e.parent.visible || e.parent instanceof xt && !e.parent.active)) {
                const i = e.parent,
                    s = M[Object.keys(this.motifs).find((t => this.motifs[t] === i))];
                s.onStart = [...s.onStart ? ? [], t => {
                    "hide" !== t.actionKey && e.show(n)
                }], C.push(t)
            }
        }
        this.l.log("deleteActionsFor", C);
        for (let t of C) delete M[t];
        for (var R in M) {
            const t = this.motifs[R],
                e = M[R];
            !1 === e.visible && !1 === t.visible && !t.hasTweenType("show") && !t.hasPendingActionType("show") || E.push(t.change(e))
        }
        E.push(this.cameraController.change({ ...y.camera || {},
            delay: null != (a = y.camera) && a.delay ? y.camera.delay + this.outroTime : this.outroTime,
            ...g ? {
                instant: !0
            } : {}
        })), this.background && E.push(this.background.change({ ...y.background || {},
            delay: null != (l = y.background) && l.delay ? y.background.delay + this.outroTime : this.outroTime,
            ...g ? {
                instant: !0
            } : {}
        }));
        for (let t in this.lightControllers) {
            const e = (null == (c = y.lights) ? void 0 : c[t]) instanceof Object ? null == (h = y.lights) ? void 0 : h[t] : {};
            E.push(this.lightControllers[t].change({ ...e,
                delay: e.delay ? e.delay + this.outroTime : this.outroTime,
                ...g ? {
                    instant: !0
                } : {}
            }))
        }
        for (let t in this.effectControllers) {
            const e = (null == (u = y.effects) ? void 0 : u[t]) instanceof Object ? null == (d = y.effects) ? void 0 : d[t] : {};
            E.push(this.effectControllers[t].change({ ...e,
                delay: e.delay ? e.delay + this.outroTime : this.outroTime,
                ...g ? {
                    instant: !0
                } : {}
            }))
        }
        return E.push(this.sceneController.change({ ...y.scene || {},
            ...g ? {
                instant: !0
            } : {}
        })), y.onShow && y.onShow(y), this.outroTime = y.outroDuration || 0, this._isLoading = !1, this.rebuildMethodsGui(), this.dispatchEvent(new Ct("loadend", this, x)), this.dispatchEvent(new Ct("shotready", this, x)), this.dispatchEvent(new Ct("shotchange", this, x)), this.currentSequence || this.dispatchEvent(new Ct("contentchange", this, x)), !0
    }
    addMotif(t, e) {
        if (this.motifs[t]) throw new Error(`Duplicate motif key "${t}"!`);
        this.motifs[t] = e, e.stage = this, e.eager && e.init()
    }
    initGui() {
        if (!this.tweakpane) return;
        this.debugGui.element.classList.add("cp-section", "cp-salient"), this.sceneGui.element.classList.add("cp-section", "cp-salient"), this.cameraGui.element.classList.add("cp-section", "cp-salient"), this.backgroundGui.element.classList.add("cp-section", "cp-salient"), this.lightsGui.element.classList.add("cp-section", "cp-salient"), this.motifsGui.element.classList.add("cp-section", "cp-salient"), this.effectsGui.element.classList.add("cp-section", "cp-salient"), this.methodsGui.element.classList.add("cp-section", "cp-salient"), this.bindingsGui.element.classList.add("cp-section", "cp-salient"), this.shotDataGui.element.classList.add("cp-section", "cp-salient"), ti(this.debugGui, ei("fa fa-binary", "#0f0")), ti(this.lightsGui, ei("fa fa-lightbulb", "#fc6")), ti(this.effectsGui, ei("fa-solid fa-wand-magic-sparkles", "#c6f")), ti(this.motifsGui, ei("fa fa-cube", "#f77")), ti(this.methodsGui, ei("fa-solid fa-atom-simple", "#3fd")), ti(this.bindingsGui, ei("fa-solid fa-link", "#aaa")), ti(this.shotDataGui, ei("fa-solid fa-gear-code", "#fff"));
        const t = this.tweakpane.element.querySelector(".tp-rotv_t");
        t && t.addEventListener("contextmenu", (t => (console.info("All:", this), console.info("Salient state:", this.salientState), t.preventDefault(), !0)));
        const e = this,
            n = {
                get paramJson() {
                    return e.methodsGuiParamJson
                },
                set paramJson(t) {
                    e.methodsGuiParamJson = t
                }
            };
        this.methodsGui.addBinding(n, "paramJson", {
            label: "Parameters"
        }), this.rebuildMethodsGui(), this.debugGui.addBinding(this, "pixelRatio", {
            min: .1,
            max: 1
        }), this.debugGui.addBlade({
            view: "separator"
        }), this.debugGui.addButton({
            title: "Benchmark"
        }).on("click", (() => {
            this.benchmark()
        })), this.debugGui.addBlade({
            view: "separator"
        }), this.debugGui.addButton({
            title: "Copy Stage State"
        }).on("click", (() => {
            const t = this.state;
            for (let e in t) t[e] = fn(t[e]);
            console.info(t), navigator.clipboard.writeText(JSON.stringify(t, null, 2))
        })), this.debugGui.addButton({
            title: "Copy Stage Salient State"
        }).on("click", (() => {
            const t = this.salientState;
            for (let e in t) t[e] = fn(t[e]);
            console.info(t), navigator.clipboard.writeText(JSON.stringify(t, null, 2))
        })), this.debugGui.addButton({
            title: "Copy Stage Action State"
        }).on("click", (() => {
            const t = this.actionState;
            for (let e in t) t[e] = fn(t[e]);
            console.info(t), navigator.clipboard.writeText(JSON.stringify(t, null, 2))
        }));
        const i = this.bindingsGui.element.querySelector(".tp-fldv_b");
        i && i.addEventListener("contextmenu", (t => {
            console.info(this.bindings), t.preventDefault()
        })), this.options.disableBindings || (this.options.disableBindings = !1), this.bindingsGui.addBinding(this.options, "disableBindings", {
            label: "Manual Only"
        }).element.title = "Bindings are disconnected from their sources and can only be changed from the Control Palette", this.rebuildShotDataGui()
    }
    rebuildMethodsGui() {
        if (!this.methodsGui) return;
        this.methodsGui.children.forEach((t => {
            t.element.dataset.tpButton && t.dispose()
        }));
        const t = this.methodKeys;
        for (let e of t) this.methodsGui.addButton({
            title: e
        }).on("click", (() => {
            let t = null;
            try {
                const e = JSON.parse(this.methodsGuiParamJson);
                Array.isArray(e) && (t = e)
            } catch {}
            t || console.warn("Unable to parse reaction params!"), this.run(e, ...t ? ? [])
        })).element.dataset.tpButton = "1";
        this.methodsGui.hidden = !t.length
    }
    rebuildShotDataGui() {
        if (!this.shotDataGui) return;
        this.shotDataGui.children.forEach((t => {
            t.dispose()
        }));
        let t = !1;
        for (let e in this.shotData) {
            const n = this.shotDataGui.addBinding(this.shotData, e, {
                    view: "text"
                }),
                i = document.createElement("button");
            i.classList.add("tp-btnv_b"), i.style.width = "24px", i.style.height = "auto", i.style.marginLeft = "4px", i.innerHTML = '<i class="fa-solid fa-trash"></i>', i.onclick = t => {
                delete this.shotData[e], this.rebuildShotDataGui()
            }, n.element.appendChild(i), t = !0
        }
        t && this.shotDataGui.addBlade({
            view: "separator"
        });
        const e = {
            key: "",
            value: ""
        };
        this.shotDataGui.addBinding(e, "key", {
            view: "text"
        }), this.shotDataGui.addBinding(e, "value", {
            view: "text"
        }), this.shotDataGui.addButton({
            title: "Add"
        }).on("click", (t => {
            const {
                key: n,
                value: i
            } = e;
            this.shotData[n] || (this.shotData[n] = i, this.rebuildShotDataGui())
        }))
    }
    get guiVisible() {
        return this._guiVisible
    }
    set guiVisible(t) {
        if (this.tweakpane) {
            for (var e in this._guiVisible = t, this.lightsGui.hidden = !t, this.cameraGui.hidden = !t, this.motifsGui.hidden = !t, this.backgroundGui.hidden = !t || !this.background, this.sceneGui.hidden = !t, this.effectsGui.hidden = !t, this.bindingsGui.hidden = !t, this.methodsGui.hidden = !t || !this.methodKeys.length, this.shotDataGui.hidden = !t, this.cameraController.guiVisible = t, this.background && (this.background.guiVisible = t), this.motifs) this.motifs[e].guiVisible = t;
            for (var e in this.lightControllers) this.lightControllers[e].guiVisible = t;
            for (const e in this.effectControllers) this.effectControllers[e].guiVisible = t
        }
    }
    async run(t, ...e) {
        var n, i;
        const s = null == (i = null == (n = this.currentStageAction) ? void 0 : n.methods) ? void 0 : i[t],
            r = this.methods[t];
        if (s) try {
            if (!await s(...e)) return
        } catch {}
        if (r) try {
            if (!await r(...e)) return
        } catch {}
        const o = this.agents;
        for (let n = 0; n < o.length; n++) try {
            o[n].run(t, ...e)
        } catch {}
    }
    getStructuredState(t) {
        var e, n, i;
        const s = {};
        for (let e in this.lightControllers) this.lightControllers[e].visible && (s[e] = t(this.lightControllers[e]));
        const r = {};
        for (let s in this.motifs) {
            const o = this.motifs[s];
            if (!o.hasInit) continue;
            const a = t(o);
            if (!1 === o.visible) {
                if (!(o.showByDefault && (!o.parent || o.parent.visible) || null != (i = null == (n = null == (e = this.currentStageAction) ? void 0 : e.motifs) ? void 0 : n[s]) && i.visible)) continue;
                a.visible = !1
            } else delete a.visible;
            r[s] = a
        }
        const o = {};
        for (let e in this.effectControllers) o[e] = t(this.effectControllers[e]);
        return {
            camera: t(this.cameraController),
            scene: t(this.sceneController),
            background: this.background ? t(this.background) : void 0,
            lights: s,
            motifs: r,
            effects: o
        }
    }
    get state() {
        return this.getStructuredState((t => fn(t.agentState)))
    }
    get tweenState() {
        return this.getStructuredState((t => fn(t.tweenState)))
    }
    get defaultTweenState() {
        return this.getStructuredState((t => fn(t.defaultTweenState)))
    }
    get salientState() {
        return this.getStructuredState((t => fn(t.salientState)))
    }
    get salientTweenState() {
        return this.getStructuredState((t => fn(t.salientTweenState)))
    }
    get actionState() {
        return this.getStructuredState((t => fn(t.actionState)))
    }
    get actionTweenState() {
        return this.getStructuredState((t => fn(t.actionState)))
    }
    compile(t) {
        this.renderManager.compile(t)
    }
    static addEventListener(t, e, n) {
        this.eventTarget.addEventListener(t, e, n)
    }
    static dispatchEvent(t) {
        return this.eventTarget.dispatchEvent(t)
    }
    static removeEventListener(t, e, n) {
        this.eventTarget.removeEventListener(t, e, n)
    }
    projectionMatricUpdate() {
        this.dispatchEvent(new _t("projectionmatrixupdate", this, {}))
    }
    dispatchEvent(e) {
        let n = super.dispatchEvent(e);
        return this.interceptEvents && (n = n && this.interceptEvents(e)), n && t.dispatchEvent(e)
    }
    dispatchCustomEvent(t, e, n = !1) {
        return this.dispatchEvent(new Li("custom", this, {
            key: t,
            data: e,
            cancelable: n
        }))
    }
    onMouseMove(t, e, n) {
        this.isMouseOver = !0, this.mousePosition.x = t, this.mousePosition.y = e, this.mouseOver()
    }
    mouseOver() {
        this.isMouseOver = !0;
        const t = this.castRay(),
            e = null == t ? void 0 : t.object,
            n = null == t ? void 0 : t.intersection;
        e !== this.hoverHandler ? (this.hoverHandler && this.hoverHandler.dispatchEvent({
            type: "mouseOut"
        }), e && e.dispatchEvent({
            type: "mouseOver",
            intersection: n
        }), this.hoverHandler = e) : this.hoverHandler && e && e.dispatchEvent({
            type: "mouseMove",
            intersection: n
        })
    }
    onMouseOut() {
        this.hoverHandler && this.hoverHandler.dispatchEvent({
            type: "mouseOut"
        })
    }
    onClick(t) {
        const e = this.castRay();
        e && e.object.dispatchEvent({
            type: "click",
            mouseEvent: t,
            intersection: e.intersection
        })
    }
    castRay() {
        this.raycaster.setFromCamera(this.mousePosition, this.camera);
        const t = this.raycaster.intersectObjects(this.motifSpace.children, !0)[0];
        if (!t) return null;
        let e = t.object;
        do {
            if (e.userData.isHitGemometry) break;
            e = e.parent
        } while (e);
        return e ? {
            object: e,
            intersection: t
        } : null
    }
    addBindings(t) {
        for (let e = 0; e < t.length; e++) {
            const n = t[e],
                i = n.bindingKey;
            this.bindingTargets[i] || (this.bindingTargets[i] = []), this.bindingTargets[i].push(n)
        }
    }
    clearBindings(t) {
        for (let e in this.bindingTargets) this.bindingTargets[e] = this.bindingTargets[e].filter((e => e.target !== t))
    }
    allocateBindings() {
        const t = this.options.disableBindings ? this.guiBindingChanges : this.bindings;
        for (let e in t) {
            const n = t[e];
            if ("number" != typeof n) continue;
            if (this.bindingsGui) {
                const t = void 0 === this.guiBindings[e];
                this.guiBindings[e] = n, t && this.bindingsGui.addBinding(this.guiBindings, e, { ..._e,
                    ...lt
                }).on("change", (t => this.guiBindingChanges[e] = t.value)), this.bindingsGui.refresh()
            }
            this.bindingsStore[e] = n;
            const i = this.bindingTargets[e];
            if (i)
                for (let t of i) t.lerpTarget = n;
            delete this.bindings[e]
        }
    }
    getBinding(t) {
        return this.bindings[t] ? ? this.bindingsStore[t] ? ? 0
    }
    get attribution() {
        const t = [];
        return this.agents.forEach((e => {
            t.push(...e.attribution)
        })), t
    }
    get activeAttribution() {
        const t = [];
        return this.agents.forEach((e => {
            e instanceof xt && !e.active || e instanceof ts && !e.visible || t.push(...e.attribution)
        })), t
    }
    updateAttribution() {
        this.updateAttributionLockout || (this.updateAttributionLockout = !0, setTimeout((() => {
            this.updateAttributionLockout = !1, this.dispatchEvent(new Ii("attributionchange", this, {
                attribution: this.attribution,
                activeAttribution: this.activeAttribution,
                allAttribution: t.attribution,
                allActiveAttribution: t.activeAttribution
            }))
        }), 500))
    }
    static get attribution() {
        const t = [];
        return Object.values(this.instances).forEach((e => {
            e.agents.forEach((e => {
                t.push(...e.attribution)
            }))
        })), t
    }
    static get activeAttribution() {
        const t = [];
        return Object.values(this.instances).forEach((e => {
            e.isRunning && e.agents.forEach((e => {
                e instanceof xt && !e.active || e instanceof ts && !e.visible || t.push(...e.attribution)
            }))
        })), t
    }
};
T(sr, "firstContent", !0), T(sr, "instances", {}), T(sr, "lockShot", !1), T(sr, "eventTarget", new el), T(sr, "userData", {});
let wn = sr;
class To {
    constructor(t) {
        T(this, "name"), T(this, "color"), T(this, "background"), T(this, "active"), this.name = t.name, this.color = t.color ? ? "#fff", this.background = t.background ? ? "#000", this.active = t.active ? ? !0
    }
    get style() {
        return `color: ${this.color}; background: ${this.background}; font-weight: bold;`
    }
    log(...t) {
        this.active && console.log(`%c ${this.name} `, this.style, ...t)
    }
    info(...t) {
        this.active && console.info(`%c ${this.name} `, this.style, ...t)
    }
    warn(...t) {
        this.active && console.warn(`%c ${this.name} `, this.style, ...t)
    }
    error(...t) {
        this.active && console.error(`%c ${this.name} `, this.style, ...t)
    }
}
const nl = {
        assetPath: void 0,
        renderTargets: [],
        stageContent: {},
        lazyLoadInterval: 200,
        mutationObserverEnabled: !0,
        mutationObserverDebump: 200,
        intersectionObserverEnabled: !0,
        lazyLoadEnabled: !0,
        intersectionObserverPriority: "largest",
        dataAttributePrefix: "pd",
        debug: !1,
        staging: !1,
        disabled: !1,
        colorManagement: !0,
        colorSpace: rt
    },
    il = {
        start: !0,
        fadeDuration: 1e3,
        antialias: !1,
        windowVar: void 0,
        debug: !1,
        disableBindings: !1,
        background: !1,
        ioStarts: !0,
        ioStops: !0
    },
    vr = { ...nl,
        ...Mn ? window.PlinthosConfig : {}
    },
    qc = [];

function km() {
    return { ...vr
    }
}

function yt(t) {
    return vr[t]
}

function Gh(t, e) {
    return -1 !== qc.indexOf(t) ? (console.warn(`Attempting to set locked config variable "${t}" to "${e}"!`), !1) : (vr[t] = e, !0)
}

function Zc(t) {
    -1 !== qc.indexOf(t) && qc.push(t)
}
wn.addEventListener("afterbuild", (t => {
    var e, n;
    const i = t.stage;
    if (vr.stageContent[i.key]) {
        const t = null == (e = vr.stageContent[i.key]) ? void 0 : e.shots;
        t && t.forEach((t => {
            i.addShot(new Gt(t))
        }));
        const s = null == (n = vr.stageContent[i.key]) ? void 0 : n.sequences;
        s && s.forEach((t => {
            i.addSequence(new Fr(t))
        }))
    }
}));
const zm = Object.freeze(Object.defineProperty({
    __proto__: null,
    defaultConfig: nl,
    defaultRenderTargetConfig: il,
    getConfig: km,
    getValue: yt,
    lockValue: Zc,
    setValue: Gh
}, Symbol.toStringTag, {
    value: "Module"
}));
let zf, yr = [],
    Jc = !1,
    ba = !1;
const yc = {};

function sl(t) {
    t.forEach((t => {
        const e = wn.instances[t.instanceKey];
        if (!e) return;
        const n = [],
            i = e.getContentByKey(t.contentKey);
        i && (i instanceof Gt ? n.push(i.key) : i instanceof Fr && n.push(...i.steps.map((t => t.shotKey))), n.forEach((n => {
            const i = e.shots[n];
            if (!i) return;
            const s = `${e.instanceKey}__${i.key}`;
            yc[s] || (yc[s] = i.getStageAction({
                from: null,
                data: t.data
            }));
            const r = yc[s].motifs;
            if (r)
                for (let t in r) {
                    const n = e.motifs[t];
                    n && !n.hasInit && -1 === yr.indexOf(n) && yr.push(n)
                }
        })))
    })), yr.length && Gm()
}
async function Gm() {
    if (ba) return;
    ba = !0;
    const t = yt("lazyLoadInterval");
    for (; !Jc && yr.length;) {
        const t = yr.shift();
        if (t && !t.hasInit) {
            await t.init();
            break
        }
    }
    yr.length ? zf = setTimeout((() => {
        clearTimeout(zf), ba = !1, Gm()
    }), t) : ba = !1
}
wn.addEventListener("loadstart", (() => {
    Jc = !0
})), wn.addEventListener("loadend", (() => {
    Jc = !1
}));
class Ao {
    static register(t, e) {
        "getOffscreenWorker" === t && (this.getOffscreenWorker = e)
    }
}

function zE(t = !1) {
    const e = yt("assetPath"),
        n = yt("staging");
    return e && !t ? Hm(e) + "/" : `${Za}${yt("kitPath")}${n?"__STAG":""}/`
}

function Hm(t, e = !1) {
    return e && "/" === t[0] && (t = t.substring(1)), "/" === t[t.length - 1] && (t = t.substring(0, t.length - 1)), t
}

function Bi(t, e = !1) {
    return zE(e || En.includes(t)) + Hm(t, !0)
}
T(Ao, "getOffscreenWorker");
class ri {
    static get texture() {
        return this._textureLoader || (this._textureLoader = new Vp), this._textureLoader
    }
    static get obj() {
        return this._objLoader || (this._objLoader = new _E), this._objLoader
    }
    static get gltf() {
        return this._gltfLoader || (this._gltfLoader = new UM), this._gltfLoader
    }
    static get svg() {
        return this._svgLoader || (this._svgLoader = new Rh), this._svgLoader
    }
    static get bitmap() {
        return this._bitmapLoader || (this._bitmapLoader = new jp, this._bitmapLoader.setOptions({
            imageOrientation: "flipY"
        })), this._bitmapLoader
    }
}
T(ri, "_textureLoader"), T(ri, "_objLoader"), T(ri, "_gltfLoader"), T(ri, "_svgLoader"), T(ri, "_bitmapLoader");
const En = [];
async function rl(t) {
    const e = (t.split(".").pop() || "").toLowerCase();
    switch ("/" === t[0] && (t = t.substring(1)), e) {
        case "obj":
            return await ol(t);
        case "glb":
            return await al(t);
        default:
            throw new Error(`${t} has an unrecognised extension!`)
    }
}
const xc = {};

function ol(t) {
    return xc[t] ? xc[t] : xc[t] = new Promise(((e, n) => {
        ri.obj.load(Bi(t), (t => e(t.children[0])), void 0, (async function(i) {
            if (-1 === En.indexOf(t)) return console.log("Asset load failed - retrying"), En.push(t), await ol(t).then((t => e(t))).catch((t => n(t)));
            n(i)
        }))
    }))
}
const bc = {};
async function al(t) {
    return bc[t] ? (await bc[t]).clone(!0) : bc[t] = new Promise(((e, n) => {
        ri.gltf.load(Bi(t), (t => e(t.scene.children[0])), void 0, (async function(i) {
            if (-1 === En.indexOf(t)) return console.log("Asset load failed - retrying"), En.push(t), await al(t).then((t => e(t))).catch((t => n(t)));
            n(i)
        }))
    }))
}
async function tn(t, e) {
    e = e ? ? yt("colorSpace");
    const n = Mn ? await ll(t) : await Pr(t),
        i = new wt(n);
    return i.needsUpdate = !0, i.colorSpace = e, i
}
async function ss(t) {
    return await tn(t, "")
}
async function Vm(t, e) {
    return e = e ? ? yt("colorSpace"), new Promise(((n, i) => {
        ri.bitmap.load(Bi(t), (t => {
            const i = new Er(t);
            i.colorSpace = e, n(i)
        }))
    }))
}
const Ac = {};
async function ll(t) {
    return Ac[t] ? Ac[t] : Ac[t] = new Promise(((e, n) => {
        const i = new Image;
        i.crossOrigin = "anonymous", i.onload = () => e(i), i.onerror = async function(i) {
            if (-1 === En.indexOf(t)) return console.log("Image load failed - retrying"), En.push(t), await ll(t).then((t => e(t))).catch((t => n(t)));
            n(i)
        }, i.src = Bi(t)
    }))
}
const Sc = {};
async function Pr(t) {
    return Sc[t] ? Sc[t] : Sc[t] = new Promise(((e, n) => {
        ri.bitmap.load(Bi(t), e, void 0, (async function(i) {
            if (-1 === En.indexOf(t)) return console.log("Bitmap load failed - retrying"), En.push(t), await Pr(t).then((t => e(t))).catch((t => n(t)));
            n(i)
        }))
    }))
}
const _c = {};
async function Hh(t, e) {
    return _c[t] ? _c[t] : _c[t] = new Promise(((n, i) => {
        const s = document.createElement("video"),
            r = document.createElement("source");
        s.appendChild(r), s.crossOrigin = "anonymous", s.loop = !0, s.muted = !0, s.autoplay = !0, e && (r.type = e), s.playsInline = !0, s.playsinline = !0, s.setAttribute("playsInline", !0), s.setAttribute("playsinline", !0), s.style.display = "none", s.addEventListener("loadeddata", (t => {
            s.readyState >= 3 && n(s)
        })), s.addEventListener("progress", (t => {
            s.readyState >= 3 && n(s)
        })), r.addEventListener("error", (e => {
            -1 === En.indexOf(t) ? (console.log("Video load failed - retrying"), En.push(t), Hh(t).then((t => n(t))).catch((t => i(t)))) : i(e)
        })), r.src = Bi(t), s.load()
    }))
}
const wc = {};
async function Vh(t) {
    return wc[t] ? wc[t] : wc[t] = new Promise(((e, n) => {
        ri.svg.load(Bi(t), (t => {
            e(t)
        }), void 0, (async function(i) {
            if (-1 === En.indexOf(t)) return console.log("SVG load failed - retrying"), En.push(t), await Vh(t).then((t => e(t))).catch((t => n(t)));
            n(i)
        }))
    }))
}
const xr = {};

function Ri(t, e = "default", n = !1) {
    return n ? t() : (xr[e] || (xr[e] = []), Wm(), new Promise(((n, i) => {
        xr[e].unshift((async () => {
            n(await t())
        }))
    })))
}
let $c = !1;

function Wm() {
    $c || ($c = !0, requestAnimationFrame(GE))
}

function GE() {
    $c = !1;
    let t = !1;
    for (let e in xr) {
        const n = xr[e];
        n.length && n.pop()(), n.length ? t = !0 : delete xr[e]
    }
    t && Wm()
}

function _s(t, e) {
    if (!t) return {};
    let n = {};
    for (; t && (n = { ...t.dataset,
            ...n
        }, t.parentElement);) t = t.parentElement;
    e && (n = ws(n, e));
    for (let t in n) "" === n[t] && (n[t] = !0);
    return n
}

function za(t, e) {
    e = e.toLowerCase();
    const n = {};
    for (let i in t) i.substring(0, e.length) === e && i.length > e.length && i[e.length].toUpperCase() === i[e.length] && (n[i] = t[i]);
    return n
}

function ws(t, e) {
    e = e.toLowerCase();
    const n = {};
    for (let i in t)
        if (i.substring(0, e.length) === e && i.length > e.length) {
            let s = i.substring(e.length);
            s = s.charAt(0).toLocaleLowerCase() + s.substring(1), n[s] = t[i]
        }
    return jm(n)
}

function Xm(t, e) {
    e = e.toLowerCase();
    const n = {};
    for (let i in t) i.substring(0, e.length) === e && i.length > e.length && (n[e + i.charAt(0).toLocaleUpperCase() + i.substring(1)] = t[i]);
    return jm(n)
}

function jm(t) {
    const e = {};
    for (let n in t) {
        let i = t[n];
        if ("?" !== i[0]) {
            e[n] = i;
            continue
        }
        i = i.substring(1);
        const s = i.split(/\[(\d+)\]/);
        s.length % 2 && s.unshift("0");
        let r = 0;
        for (; s.length;) {
            const t = parseFloat(s.shift()),
                i = s.shift();
            isNaN(t) || window.innerWidth >= t && r <= t && (r = t, e[n] = i)
        }
    }
    return e
}

function ei(t, e = "inherit") {
    return `<i class="${t}" style="color:${e}"></i>`
}

function ti(t, e) {
    const n = t.element.querySelector(".tp-fldv_t");
    n && (n.innerHTML = `${e} ${n.innerHTML}`)
}

function cl(t, e) {
    const n = new xo,
        i = new Bp(t, e),
        s = new Float32Array(i.attributes.position.array);
    return i.dispose(), n.setPositions(s), n.computeVertexNormals(), n
}

function Km(t, e = {}, n) {
    const i = cl(t.geometry, n),
        s = new Nr(e),
        r = t.geometry,
        o = t.material;
    r.dispose(), o.dispose();
    const a = new Eo(i, s);
    return a.computeLineDistances(), a
}

function Ym(t, e = !1) {
    const n = (t.getIndex() || t.getAttribute("position")).count / 3,
        i = [];
    for (let t = 0; t < n; t++) {
        const n = e ? 1 : 0;
        t % 2 == 0 ? i.push(0, 0, 1, 0, 1, 0, 1, 0, n) : i.push(0, 1, 0, 0, 0, 1, 1, 0, n)
    }
    const s = new Float32Array(i),
        r = new Xt(s, 3);
    t.setAttribute("barycentric", r)
}

function Qm(t, e) {
    t.computeVertexNormals();
    const n = t.getAttribute("normal").array,
        i = t.getAttribute("position").array,
        s = [];
    for (var r = 0; r < n.length; r++) s.push(i[r] + n[r] * e);
    const o = new Float32Array(s);
    return t.setAttribute("position", new Xt(o, 3, !0)), t.computeVertexNormals(), t
}
class Wh {
    constructor(t) {
        T(this, "composer"), T(this, "stage"), T(this, "isChild", !1), T(this, "children", []), T(this, "devicePixelRatio"), T(this, "maxPixelRatio"), T(this, "needsResize", !1);
        const {
            stage: e,
            parent: n,
            effectControllers: i,
            canvas: s,
            multisampling: r = 32,
            maxPixelRatio: o = 3,
            devicePixelRatio: a,
            pixelRatio: l = 1
        } = t;
        this.devicePixelRatio = a ? ? (Mn ? window.devicePixelRatio : 1), this.maxPixelRatio = Fa ? 1 : Math.min(3, o), this.stage = e, this.composer = new L_(void 0, {
            multisampling: r
        }), n ? n.addChild(this) : this.initRenderer(s), this.isChild = !!n, this.initComposer(i), this.pixelRatio = l
    }
    get renderer() {
        return this.composer.getRenderer()
    }
    set renderer(t) {
        this.composer.setRenderer(t);
        for (const e of this.children) e.renderer = t
    }
    get canvas() {
        return this.renderer.domElement
    }
    set canvas(t) {
        this.isChild || this.initRenderer(t)
    }
    get multisampling() {
        return this.composer.multisampling
    }
    set multisampling(t) {
        this.composer.multisampling = t
    }
    get debug() {
        return this.renderer.debug.checkShaderErrors
    }
    set debug(t) {
        this.renderer.debug.checkShaderErrors = t
    }
    get texture() {
        return this.composer.outputBuffer.texture
    }
    get pixelRatio() {
        return this.renderer ? this.renderer.getPixelRatio() / this.devicePixelRatio : 1
    }
    set pixelRatio(t) {
        !Mn || this.isChild || !t || ((this.devicePixelRatio > 2 || Fa) && (t = Math.min(t, 1)), t = Math.min(this.maxPixelRatio, Math.max(.1, t) * this.devicePixelRatio), this.renderer && this.renderer.setPixelRatio(t), this.needsResize = !0)
    }
    render(t) {
        this.composer.render(t)
    }
    initComposer(t) {
        if (this.composer.passes.length) return;
        const e = [],
            n = [];
        this.composer.addPass(new jw(this.stage.scene, this.stage.camera));
        let i = !1;
        for (let s in t) {
            const r = t[s];
            if (r instanceof sn && r.isAntialiasing) {
                if (i) continue;
                this.multisampling = 0, i = !0
            }
            r instanceof sn ? r.isConvolution ? this.composer.addPass(new bf(this.stage.camera, r.effect)) : e.push(r.effect) : r instanceof pl && n.push(r.pass)
        }
        this.composer.addPass(new bf(this.stage.camera, ...e));
        for (let t of n) this.composer.addPass(t);
        this.isChild && this.composer.passes.forEach((t => t.renderToScreen = !1))
    }
    compile(t) {
        this.renderer.compile(t ? ? this.stage.scene, this.stage.camera, this.stage.scene)
    }
    initRenderer(t, e = {}) {
        var n;
        null == (n = this.renderer) || n.dispose(), this.renderer = new aS({
            alpha: !0,
            preserveDrawingBuffer: !1,
            canvas: t,
            ...e
        }), this.renderer.outputColorSpace = yt("colorSpace"), this.renderer.setClearColor(16777215, 0), this.renderer.shadowMap.enabled = !0, this.resize(t.width, t.height)
    }
    addChild(t) {
        t.renderer = this.renderer, this.children.push(t)
    }
    resize(t, e) {
        if (t > 0 || e > 0)
            if (this.isChild) {
                this.composer.inputBuffer.setSize(t, e), this.composer.outputBuffer.setSize(t, e);
                for (const n of this.composer.passes) n.setSize(t, e)
            } else this.canvas.width = t, this.canvas.height = e, this.renderer.setSize(t, e, !1), this.composer.setSize(t, e, !1)
    }
    getDataUrl() {
        if (!(this.canvas instanceof HTMLCanvasElement)) return !1;
        this.initRenderer(this.canvas, {
            preserveDrawingBuffer: !0
        }), this.render(0);
        const t = this.canvas.toDataURL();
        return this.initRenderer(this.canvas), t
    }
}
const HE = ".plinthos-benchmark-button {\n  all: unset;\n  font-family: sans-serif;\n  text-shadow: 0 0 0.5em #fff;\n  background: #fa3;\n  background: #3fa;\n  font-weight: bold;\n  height: 90px;\n  width: 90px;\n  color: #000;\n  border: 2px solid #000;\n  border-radius: 100px;\n  position: fixed;\n  z-index: 999999999;\n  bottom: 10px;\n  left: 10px;\n  padding: 1em;\n  text-align: center;\n  box-shadow: 1em -1em 2em inset rgba(0, 51, 0, 0.6666666667), -1em 1em 2em inset rgba(255, 255, 255, 0.4);\n}\n\n.plinthos-benchmark-veil {\n  all: unset;\n  z-index: 999999999;\n  position: fixed;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  background: rgba(0, 0, 0, 0.8);\n  padding: 2em 1em;\n  backdrop-filter: blur(2em);\n  -webkit-backdrop-filter: blur(2em);\n  color: #fff;\n  font-size: 12px;\n  font-family: sans-serif;\n  padding-bottom: 25vh;\n  overflow-y: auto;\n}\n.plinthos-benchmark-veil *,\n.plinthos-benchmark-veil *::before,\n.plinthos-benchmark-veil *::after {\n  all: unset;\n  box-sizing: border-box;\n  line-height: 1.5em;\n}\n.plinthos-benchmark-veil p {\n  display: block;\n  padding: 1em 0;\n}\n.plinthos-benchmark-veil table {\n  display: table;\n}\n.plinthos-benchmark-veil tr {\n  display: table-row;\n}\n.plinthos-benchmark-veil td {\n  display: table-cell;\n  padding: 0.1em 2em 0.1em 0;\n}\n.plinthos-benchmark-veil th {\n  display: table-cell;\n  font-weight: bold;\n}\n.plinthos-benchmark-veil h1 {\n  display: inline-block;\n  font-size: 3em;\n  margin: 1em 0;\n  font-weight: bold;\n}\n.plinthos-benchmark-veil h2 {\n  display: inline-block;\n  font-size: 2em;\n  margin: 1em 0 1ch;\n  font-weight: bold;\n}\n.plinthos-benchmark-veil th {\n  text-align: left;\n}";

function hl() {
    const t = document.createElement("button");
    t.innerHTML = "Start<br>Benchmark<br>Test", t.className = "plinthos-benchmark-button", document.body.appendChild(t);
    const e = HE,
        n = document.createElement("style");
    n.innerText = e, document.body.appendChild(n), t.addEventListener("click", (async e => {
        document.body.removeChild(t);
        const n = document.createElement("div");
        n.className = "plinthos-benchmark-veil", document.body.appendChild(n);
        const i = document.createElement("h1");
        i.innerHTML = "Benchmark", n.appendChild(i);
        const s = o("p", ["⌛ Benchmark in progress.", "❄️Your device may appear non-responsive during the test.", "⏱️ Depending on the complexity of the configuration and the device running the test, this could take up to a minute."].join("<br>"));
        n.append(s);
        const r = document.createElement("table");

        function o(t, e) {
            const n = document.createElement(t);
            return n.innerHTML = e, n
        }

        function a(t, e, n) {
            const i = document.createElement("tr"),
                s = document.createElement("td"),
                o = document.createElement("td");
            o.style.fontFamily = "monospace", s.innerHTML = t, "number" == typeof e && e % 1 && (e = e.toFixed(2)), o.innerHTML = e, n && (o.style.color = n), i.append(s, o), r.append(i)
        }
        n.appendChild(r);
        const l = performance.now();
        let c = 0;
        await Nh(1);
        for (let t in pt.instances) {
            const e = pt.instances[t];
            if (!e.isRunning) continue;
            const n = await e.benchmark(10),
                i = document.createElement("tr"),
                s = document.createElement("th");
            s.colSpan = 2, s.innerHTML = `<h2>${e.instanceKey} ( ${n.grade} )</h2>`, i.append(s), r.append(i), a("Stage key", e.stageKey), a("Shot key", e.shotKey), e.options.workerKey && a("Worker", e.options.workerKey), a("Health", `${n.health.toFixed(2)} <span style="color: white">( ${n.grade} )</span>`, n.color), a("Average", n.average), e.skipFrames && a("Skip Frames", e.skipFrames), a("Target", n.target), a("Resolution", `${e.width} * ${e.height}`), 1 !== e.pixelRatio && a("Pixel Ratio", e.pixelRatio), await new Promise((t => setTimeout(t, 300))), c++
        }
        document.scrollingElement.style.overflow = "hidden", n.insertBefore(o("p", ["✅ Benchmark completed successfully.", `📊 ${c} stage instances benchmarked`, `⏱️ Test time: ${((performance.now()-l)/1e3).toFixed(2)}s`].join("<br>")), s), n.removeChild(s), n.appendChild(o("p", "Refresh page to exit"))
    }))
}
class So extends pt {
    constructor(t) {
        if (super(t), T(this, "worker"), T(this, "_bindings", {}), T(this, "bindings"), T(this, "_userData", {}), T(this, "userData"), T(this, "_shotData", {}), T(this, "shotData"), T(this, "_attribution", []), T(this, "_activeAttribution", []), T(this, "_debug", !1), T(this, "_pixelRatio", 1), T(this, "_skipFrames", 0), T(this, "_stopDelay", 0), T(this, "_contentKey"), this.worker = Jm(t.workerKey), !this.worker) throw new Error("No Plugin found for getOffscreenWorker!");
        this.worker.addEventListener("message", (t => this.out(t)));
        const e = this.canvas.transferControlToOffscreen();
        delete t.tweakpane;
        const n = { ...t,
            canvas: e,
            userData: vn(t.userData ? ? {}, 5),
            shotData: vn(t.shotData ? ? {}, 5),
            instanceKey: this.instanceKey,
            options: { ...t.options ? ? {},
                devicePixelRatio : window.devicePixelRatio
            }
        };
        this._userData = t.userData ? ? {}, this._shotData = t.shotData ? ? {}, this._pixelRatio = t.options.pixelRatio ? ? 1, this.worker.postMessage({
            type: "buildStage",
            stageBuilderOptions: n,
            stageKey: this.stageKey
        }, [e]);
        let i = {},
            s = !1;
        this.bindings = new Proxy(this._bindings, {
            set: (t, e, n) => (i[e] = n, s || (setTimeout((() => {
                this.in("setBindings", {
                    bindings: i
                }), i = {}, s = !1
            }), 100), s = !0), !0),
            get: (t, e) => t[e] ? ? 0
        }), this.userData = new Proxy(this._userData, {
            set: (t, e, n) => (this.in("setUserData", {
                userData: {
                    [e]: n
                }
            }), !0),
            get: (t, e) => t[e] ? ? 0
        }), this.shotData = new Proxy(this._shotData, {
            set: (t, e, n) => (this.in("setShotData", {
                shotData: {
                    [e]: n
                }
            }), !0),
            get: (t, e) => t[e] ? ? 0
        }), this.configureDisplay(t)
    } in (t, e = {}, n) {
        e.type = t, e.instanceKey = this.instanceKey, this.worker.postMessage(e, n)
    }
    out(t) {
        if (t.data.instanceKey === this.instanceKey) switch (t.data.type) {
            case "event":
                this.handleStageEvent(t.data.event);
                break;
            case "attribution":
                this._attribution = t.data.attribution.map((t => new ys(t)))
        }
    }
    onSetCanvas(t) {
        if (!this.worker) return;
        const e = t.transferControlToOffscreen();
        this.in("setCanvas", {
            canvas: e
        }, [e])
    }
    handleStart(t) {
        return this.in("start")
    }
    handleStop(t) {
        return this.in("stop", {
            options: t
        })
    }
    pause() {
        this.in("pause")
    }
    unpause() {
        this.in("unpause")
    }
    reset() {
        return this.in("reset")
    }
    handleSetContent(t, e) {
        this.in("setContent", {
            contentKey: t,
            options: e
        })
    }
    onResize() {
        this.in("resize", {
            width: this.canvas.offsetWidth,
            height: this.canvas.offsetHeight
        })
    }
    lazyLoadActions(t) {
        for (let e of t) delete e.instigator;
        this.in("lazyLoadActions", {
            actions: vn(t, 3)
        })
    }
    run(t, ...e) {
        this.in("run", {
            methodName: t,
            methodArgs: vn(e, 5)
        })
    }
    async benchmark(t, e) {
        return new Promise((n => {
            const i = t => {
                "benchmark" === t.data.type && (this.worker.removeEventListener("message", i), n(t.data.results))
            };
            this.worker.addEventListener("message", i), this.in("benchmark", {
                iterations: t,
                targetFrameRate: e
            })
        }))
    }
    get attribution() {
        return this._attribution
    }
    get activeAttribution() {
        return this._activeAttribution
    }
    get debug() {
        return this._debug
    }
    set debug(t) {
        this._debug = t, this.l.active = t, this.in("setDebug", {
            debug: t
        })
    }
    get pixelRatio() {
        return this._pixelRatio
    }
    set pixelRatio(t) {
        this._pixelRatio = t, this.in("setPixelRatio", {
            pixelRatio: t
        })
    }
    get skipFrames() {
        return this._skipFrames
    }
    set skipFrames(t) {
        this._skipFrames = t, this.in("setSkipFrames", {
            skipFrames: t
        })
    }
    get stopDelay() {
        return this._stopDelay
    }
    set stopDelay(t) {
        this._stopDelay = t, this.in("setStopDelay", {
            stopDelay: t
        }), this.afterSetStopDelay()
    }
    get contentKey() {
        return this._contentKey
    }
    set contentKey(t) {
        this._contentKey = t, this.in("setContentKey", {
            contentKey: t
        })
    }
    handleMouseMove(t, e, n) {
        this.in("onMouseMove", {
            e: vn(t),
            x: e,
            y: n
        })
    }
    handleMouseOut() {
        this.in("onMouseOut")
    }
    handleClick(t) {
        this.in("onClick", {
            e: vn(t)
        })
    }
    handleStageEvent(t) {
        let e;
        const {
            type: n,
            constructorName: i
        } = t;
        switch (t.offscreen = !0, i) {
            case _t.name:
                e = new _t(n, this, { ...t
                });
                break;
            case Ls.name:
                e = new Ls(this, { ...t
                });
                break;
            case Di.name:
                e = new Di(this, { ...t
                });
                break;
            case es.name:
                e = new es(this, {
                    canvas: this.canvas,
                    ...t
                });
                break;
            case Ct.name:
                "contentchange" === t.type && t.key && (this._contentKey = t.key), e = new Ct(n, this, { ...t
                });
                break;
            case Ii.name:
                this._attribution = t.attribution.map((t => new ys(t))), this._activeAttribution = t.activeAttribution.map((t => new ys(t))), e = new Ii(n, this, { ...t,
                    attribution: t.attribution.map((t => new ys(t))),
                    activeAttribution: t.activeAttribution.map((t => new ys(t))),
                    allAttribution: pt.attribution,
                    allActiveAttribution: pt.activeAttribution
                });
                break;
            case Li.name:
                e = new Li(n, this, { ...t
                });
                break;
            default:
                return void this.l.error(`No relay case for event type "${i}" found!`)
        }
        this.dispatchEvent(e), pt.dispatchEvent(e)
    }
}
class ul extends pt {
    constructor(t) {
        super(t), T(this, "stage"), T(this, "bindings"), T(this, "userData"), T(this, "shotData"), wn.instances[this.instanceKey] ? (this.l.warn(`Stage instance with key "${this.instanceKey}" already exists! This Display will now adopt that Stage Instance.`), this.stage = wn.instances[this.instanceKey], this.stage.canvas = this.canvas) : this.stage = kn.build(this.stageKey, { ...t,
            interceptEvents: t => this.relayStageEvent(t)
        }), this.bindings = this.stage.bindings, this.userData = this.stage.userData, this.shotData = this.stage.userData, this.configureDisplay(t)
    }
    onSetCanvas(t) {
        this.stage && (this.stage.canvas = t)
    }
    handleStart() {
        return this.stage.start()
    }
    handleStop(t) {
        return this.stage.stop(t)
    }
    pause() {
        this.stage.pause()
    }
    unpause() {
        this.stage.unpause()
    }
    handleSetContent(t, e) {
        this.stage.setContent(t, e)
    }
    onResize() {
        this.stage.offsetHeight = this.canvas.offsetHeight, this.stage.offsetWidth = this.canvas.offsetWidth, this.stage.needsResize = !0
    }
    reset() {
        return this.stage.reset()
    }
    run(t, ...e) {
        this.stage.run(t, ...e)
    }
    async benchmark(t, e) {
        return this.stage.benchmark(t, e)
    }
    get debug() {
        var t;
        return (null == (t = this.stage) ? void 0 : t.debug) ? ? !1
    }
    set debug(t) {
        this.stage.debug = t
    }
    get pixelRatio() {
        var t;
        return (null == (t = this.stage) ? void 0 : t.pixelRatio) ? ? 1
    }
    set pixelRatio(t) {
        this.stage.pixelRatio = t
    }
    get skipFrames() {
        var t;
        return (null == (t = this.stage) ? void 0 : t.skipFrames) ? ? 0
    }
    set skipFrames(t) {
        this.stage.skipFrames = t
    }
    get stopDelay() {
        var t;
        return (null == (t = this.stage) ? void 0 : t.stopDelay) ? ? 0
    }
    set stopDelay(t) {
        this.stage.stopDelay = t, this.afterSetStopDelay()
    }
    get contentKey() {
        var t;
        return (null == (t = this.stage) ? void 0 : t.contentKey) ? ? ""
    }
    set contentKey(t) {
        this.stage.contentKey = t
    }
    get attribution() {
        var t;
        return (null == (t = this.stage) ? void 0 : t.attribution) ? ? []
    }
    get activeAttribution() {
        return this.stage.activeAttribution
    }
    handleMouseMove(t, e, n) {
        this.stage.onMouseMove(e, n, t)
    }
    handleClick(t) {
        this.stage.onClick(t)
    }
    handleMouseOut() {
        this.stage.isMouseOver = !1
    }
    relayStageEvent(t) {
        let e;
        switch (t.constructor.name) {
            case _t.name:
                e = new _t(t.type, this, t);
                break;
            case Ls.name:
                e = new Ls(this, t);
                break;
            case Di.name:
                e = new Di(this, t);
                break;
            case es.name:
                e = new es(this, t);
                break;
            case Ct.name:
                e = new Ct(t.type, this, t);
                break;
            case Ii.name:
                e = new Ii(t.type, this, t);
                break;
            case Li.name:
                e = new Li(t.type, this, t);
                break;
            default:
                return void this.l.error(`No relay case for event type "${t.constructor.name}" found!`)
        }
        return this.dispatchEvent(e) && pt.dispatchEvent(e)
    }
    saveImage() {
        if (!(this.stage && this.stage.canvas instanceof HTMLCanvasElement && Mn)) return;
        const t = document.createElement("a");
        t.download = `${this.stage.key}_${this.shotKey}.png`;
        const e = this.stage.renderManager.getDataUrl();
        e && (t.href = e, t.click())
    }
}
let rr;

function eh() {
    return rr
}
const VE = t => rr ? (console.warn("Attempting to initialise Control Palette a second time!"), rr) : (rr = t, rr.hidden = !1, rr),
    qm = Object.freeze(Object.defineProperty({
        __proto__: null,
        get: eh,
        init: VE
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    Gf = yt("colorManagement") ? ? !1;

function WE() {
    if (Mn) return;
    const t = self,
        e = new To({
            name: "Worker Internal",
            background: "#505",
            color: "#f6a"
        });
    wn.addEventListener("afterbuild", (e => {
        t.postMessage({
            type: "attribution",
            attribution: wn.attribution
        })
    })), t.onmessage = n => {
        const i = n.data.type,
            s = n.data.instanceKey,
            r = wn.instances[s];
        switch (i) {
            case "benchmark":
                !async function(e, n) {
                    const i = await n.benchmark(e.iterations, e.targetFrameRate);
                    t.postMessage({
                        type: "benchmark",
                        instanceKey: n.instanceKey,
                        results: i
                    })
                }(n.data, r);
                break;
            case "config":
                ! function(t) {
                    const e = t.config;
                    for (let t in e) Gh(t, e[t])
                }(n.data);
                break;
            case "test":
                o = n.data, console.log(o);
                break;
            case "lazyLoadActions":
                ! function(t) {
                    sl(t.actions)
                }(n.data);
                break;
            case "buildStage":
                ! function(n) {
                    var i, s;
                    const {
                        stageKey: r,
                        stageBuilderOptions: o
                    } = n;
                    e.active = !(null == (i = null == o ? void 0 : o.options) || !i.debug), null == (s = kn.instances[r]) || s.build({ ...o,
                        interceptEvents: e => (t.postMessage({
                            type: "event",
                            instanceKey: o.instanceKey,
                            event: e.transferable
                        }), !0)
                    })
                }(n.data);
                break;
            case "onClick":
                ! function(t, e) {
                    e.onClick(t.e)
                }(n.data, r);
                break;
            case "onMouseMove":
                ! function(t, e) {
                    e.onMouseMove(t.x, t.y, t.e)
                }(n.data, r);
                break;
            case "onMouseOut":
                n.data, r.isMouseOver = !1;
                break;
            case "resize":
                ! function(t, e) {
                    !t.width && t.height || (e.offsetHeight = t.height, e.offsetWidth = t.width, e.needsResize = !0)
                }(n.data, r);
                break;
            case "run":
                ! function(t, e) {
                    e.run(t.methodName, ...t.methodArgs)
                }(n.data, r);
                break;
            case "setBindings":
                ! function(t, e) {
                    for (let n in t.bindings) e.bindings[n] = t.bindings[n]
                }(n.data, r);
                break;
            case "setCanvas":
                ! function(t, e) {
                    e.canvas = t.canvas
                }(n.data, r);
                break;
            case "setContent":
                ! function(t, e) {
                    e.setContent(t.contentKey, t.options)
                }(n.data, r);
                break;
            case "setContentKey":
                ! function(t, e) {
                    e.contentKey = t.contentKey
                }(n.data, r);
                break;
            case "setDebug":
                ! function(t, n) {
                    n.debug = t.debug, e.active = t.debug
                }(n.data, r);
                break;
            case "setPixelRatio":
                ! function(t, e) {
                    e.pixelRatio = t.pixelRatio
                }(n.data, r);
                break;
            case "setShotData":
                ! function(t, e) {
                    for (let n in t.shotData) e.shotData[n] = t.shotData[n]
                }(n.data, r);
                break;
            case "setSkipFrames":
                ! function(t, e) {
                    e.skipFrames = t.skipFrames
                }(n.data, r);
                break;
            case "setStopDelay":
                ! function(t, e) {
                    e.stopDelay = t.stopDelay
                }(n.data, r);
                break;
            case "setUserData":
                ! function(t, e) {
                    for (let n in t.userData) e.userData[n] = t.userData[n]
                }(n.data, r);
                break;
            case "start":
                ! function(t, e) {
                    e.start()
                }(n.data, r);
                break;
            case "stop":
                ! function(t, e) {
                    e.stop(t.options)
                }(n.data, r);
                break;
            case "pause":
                ! function(t, e) {
                    e.pause()
                }(n.data, r);
                break;
            case "unpause":
                ! function(t, e) {
                    e.unpause()
                }(n.data, r);
                break;
            case "reset":
                ! function(t, e) {
                    e.reset()
                }(n.data, r)
        }
        var o
    }, t.addEventListener("install", (t => {
        console.log("install", t)
    }))
}
vt.enabled = Gf, Gh("colorSpace", Gf ? rt : Zn), Zc("colorManagement"), Zc("colorSpace");
const Zm = Object.freeze(Object.defineProperty({
        __proto__: null,
        init: WE
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    Mc = {};

function Jm(t) {
    var e;
    if (!Mc[t]) {
        const n = null == (e = Ao.getOffscreenWorker) ? void 0 : e.call(Ao);
        if (!n) throw new Error("No Plugin found for getOffscreenWorker!");
        n.postMessage({
            type: "config",
            config: km()
        }), Mc[t] = n
    }
    return Mc[t]
}
const $m = Object.freeze(Object.defineProperty({
        __proto__: null,
        getWorker: Jm
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    XE = "plinthos-auto-insert-canvas",
    jE = "plinthoskitready",
    Aa = -20,
    Sa = -10;
let Ec = null,
    _a = null;
const Kn = {
        ready: !1,
        displays: {},
        addEventListener(t, e, n) {
            th.addEventListener(t, e, n)
        },
        removeEventListener(t, e, n) {
            th.removeEventListener(t, e, n)
        },
        get attribution() {
            return pt.attribution
        },
        get activeAttribution() {
            return pt.activeAttribution
        },
        getAncestryDataset: t => _s(t, (yt("dataAttributePrefix") ? ? "pd").toLowerCase()),
        refresh: () => {},
        pause() {
            for (let t in this.displays) this.displays[t].pause()
        },
        unpause() {
            for (let t in this.displays) this.displays[t].unpause()
        },
        debug: {
            scroll: (t, e = 0) => {},
            userScroll: (t, e = 0) => {}
        }
    },
    th = new tl;
for (let t of $a) pt.addEventListener(t, (t => {
    th.dispatchEvent(t.publicEvent) || t.preventDefault()
}));
Mn && (window.Plinthos = Kn);
const KE = () => {
        if (yt("disabled")) return;
        const t = yt("debug"),
            e = (yt("dataAttributePrefix") ? ? "pd").toLowerCase(),
            n = `${e}Content`,
            i = `${e}Show`,
            s = `${e}Load`,
            r = `data-${e}-show`,
            o = `data-${e}-load`;
        try {
            ! function() {
                const t = yt("renderTargets");
                t && t.forEach((async t => {
                    var i;
                    let s;
                    const r = (t = {
                            instanceKey: t.stageKey,
                            ...il,
                            ...t
                        }).background,
                        o = t.canvasSelector;
                    if (r) {
                        if (s) return void(s.dataset[Ss] !== t.instanceKey && (S("Multiple stages are attempting to become the background!"), S(`${s.dataset[bo]} & ${t.canvasSelector}`)));
                        s = document.createElement("canvas"), s.id = XE, s.style.position = "fixed", s.style.height = "100vh", s.style.width = "100vw", s.style.top = "0", s.style.left = "0", s.style.zIndex = "-1", document.body.style.backgroundColor = "transparent", document.body.style.background = "none", document.body.children.length ? document.body.insertBefore(s, document.body.firstChild) : document.body.appendChild(s)
                    } else if (o && (s = document.querySelector(o)), (!s || "canvas" !== s.tagName.toLowerCase()) && (s = document.createElement("canvas")), s && s.dataset[Ss] && s.dataset[Ss] !== t.instanceKey) return S("Multiple stages attempting to use the same canvas!"), void S(`${s.dataset[bo]} & ${t.canvasSelector}`);
                    let a;
                    if (s instanceof HTMLCanvasElement || S(`Canvas with selector "${t.canvasSelector}" not found for stage key "${t.stageKey}"!`), pt.instances[t.instanceKey]) return a = pt.instances[t.instanceKey], void(a.canvas && S(`Duplicate stage instance key: "${t.instanceKey}"!`));
                    if (A(`Building stage instance "${t.instanceKey}".`), null != (i = t.userData) && i.kit && S('Plinthos Kit reserves userData key "kit" for internal use but it has been passed in with the Stage Builder parameters! Parameter value will be overridden.'), a = pt.build({
                            stageKey: t.stageKey,
                            workerKey: t.workerKey,
                            canvas: s,
                            instanceKey: t.instanceKey,
                            userData: { ...t.userData ? ? {},
                                kit : {}
                            },
                            options: {
                                debug: !!t.debug,
                                msaaSamples: t.msaaSamples,
                                pixelRatio: t.pixelRatio,
                                maxPixelRatio: t.maxPixelRatio,
                                disableBindings: !!t.disableBindings
                            }
                        }), t.fadeDuration && (a.isRunning || (s.style.opacity = "0"), s.offsetHeight, a.addEventListener("start", (() => a.canvas.style.opacity = "1")), a.addEventListener("stopping", (() => a.canvas.style.opacity = "0")), a.stopDelay = t.fadeDuration), !a) return void S(`Failed to build stage with key "${t.stageKey}"!`);
                    a.userData.kit.renderTargetConfig = t, Kn.displays[t.instanceKey] = a.controller, t.windowVar && (window[t.windowVar] = a.controller);
                    const l = !!t.start && (!t.ioStops || a.isIntersecting),
                        c = s.dataset[n] ? ? t.contentKey;
                    t.start && t.ioStarts && !a.isIntersecting && a.stop({
                        authority: Aa
                    }), c ? Ri((async () => {
                        a.setContent(c, {
                            start: l,
                            data: _s(a.canvas, e)
                        })
                    })) : l && a.start()
                }))
            }()
        } catch (e) {
            ! function(...e) {
                t && console.error("%c Kit ", "color: #fff; background: #048; font-weight: bold;", ...e)
            }(e)
        }(function() {
            if (!yt("mutationObserverEnabled")) return;
            const t = yt("mutationObserverDebump");
            if (Ec) return;
            let e = !1,
                n = !1,
                i = [];
            Ec = new MutationObserver((s => {
                for (let t of s) i.push(...t.addedNodes, ...t.removedNodes);
                e ? n = !0 : (e = !0, m(i), setTimeout((() => {
                    e = !1, n && (m(i), n = !1)
                }), t))
            })), Ec.observe(document.body, {
                subtree: !0,
                childList: !0
            })
        })(), l(), c(), g(), document.addEventListener("visibilitychange", (() => {
            document.hidden ? Kn.pause() : Kn.unpause()
        }));
        const a = yt("intersectionObserverPriority");

        function l() {
            const t = `data-${e}-apply-to-ancestor`,
                n = `data-${e}-apply-to-descendant`,
                i = `${e}ApplyToAncestor`,
                s = `${e}ApplyToDescendant`;

            function r(t, e) {
                for (let n in e) n === i || n === s || (t.dataset[n] = e[n])
            }
            const o = Array.from(document.querySelectorAll(`[${t}]`));
            for (let t of o) {
                const n = za(t.dataset, e),
                    s = n[i];
                if (s)
                    for (t = t.parentElement; t;) {
                        if (t.matches(s)) {
                            r(t, n);
                            break
                        }
                        t = t.parentElement
                    }
            }
            const a = Array.from(document.querySelectorAll(`[${n}]`));
            for (let t of a) {
                const n = za(t.dataset, e),
                    i = n[s],
                    o = t.querySelector(i);
                if (o) {
                    r(o, n);
                    break
                }
            }
        }

        function c() {
            yt("intersectionObserverEnabled") && (_a ? _a.disconnect() : _a = new IntersectionObserver(h, {
                threshold: Array.from(Array(20).keys()).map((t => t / 20))
            }), [...Array.from(document.querySelectorAll("[data-plinthos-stage-key]")), ...Array.from(document.querySelectorAll(`[${r}]`))].forEach((t => {
                "plinthos-auto-insert-canvas" !== t.id && _a.observe(t)
            })))
        }

        function h(t) {
            const n = [];
            for (let i of Array.from(t)) {
                const t = i.target,
                    s = ws(t.dataset, e);
                t.dataset.plinthosStageKey ? u(i) : s.show && n.push(i)
            }! function(t) {
                for (let n of t) {
                    const t = n.target;
                    if (!ws(t.dataset, e).show) return;
                    const i = t.dataset.plinthosId;
                    if (n.isIntersecting) {
                        if (!i || !d[i]) {
                            const t = new b(n);
                            d[t.id] = t
                        }
                    } else delete d[t.dataset.plinthosId]
                }! function() {
                    const t = {},
                        e = {};
                    p = Array.from(document.querySelectorAll("[data-plinthos-id]"));
                    for (let n of p) {
                        const i = d[n.dataset.plinthosId];
                        if (!i) continue;
                        i.updateBoudingRect();
                        const s = i.element,
                            r = f(i),
                            o = v(s);
                        for (let n of o) {
                            const i = n.instanceKey;
                            if (r > (t[i] ? ? -1 / 0)) t[i] = r;
                            else if (t[i] >= r) continue;
                            pt.instances[i] ? e[n.instanceKey] = n : S(`Unknown stage: "${i}"!`)
                        }
                    }
                    for (let t in e) {
                        const n = pt.instances[t],
                            i = e[t];
                        if (!n) return void S(`Unknown stage: "${t}"!`);
                        if (i.contentKey) {
                            if ("-" === i.contentKey) n.stop({
                                authority: Sa
                            });
                            else if ("_" === i.contentKey) n.stop({
                                reset: !0,
                                authority: Sa
                            });
                            else if ("+" === i.contentKey) n.isIntersecting && n.start({
                                authority: Sa
                            });
                            else {
                                if (n.userData.kit.instigator === i.instigator) continue;
                                n.setContent(i.contentKey, {
                                    start: n.isIntersecting,
                                    data: i.data,
                                    debump: 300,
                                    authority: Sa
                                });
                                const t = Array.from(document.querySelectorAll("[data-plinthos-instigator]"));
                                for (let e of t) {
                                    const t = e.dataset.plinthosInstigator.split(",");
                                    t.indexOf(i.instanceKey) > -1 && t.splice(t.indexOf(i.instanceKey), 1), t.length ? e.dataset.plinthosInstigator = t.join(",") : delete e.dataset.plinthosInstigator
                                }
                                if (i.instigator) {
                                    let t = [i.instanceKey];
                                    i.instigator.dataset.plinthosInstigator && (t = [...i.instigator.dataset.plinthosInstigator.split(","), ...t]), i.instigator.dataset.plinthosInstigator = t.join(",")
                                }
                            }
                            n.userData.kit.instigator = i.instigator
                        }
                    }
                }()
            }(n)
        }

        function u(t) {
            var e, n;
            const i = t.target,
                s = i.dataset[Ss];
            if (!s) return void S("A canvas without a stage is being observed", i);
            const r = pt.instances[s];
            r ? (!r.isRunning || r.isStopping) && t.isIntersecting && null != (e = r.userData.kit.renderTargetConfig) && e.ioStarts ? r.start({
                authority: Aa
            }) : r.isRunning && !t.isIntersecting && null != (n = r.userData.kit.renderTargetConfig) && n.ioStops && r.stop({
                delay: 0,
                authority: Aa
            }) : S(`Uknown stage key "${s}"`, i)
        }
        Kn.getAncestryDataset = function(t) {
            return _s(t, e)
        }, null !== new URLSearchParams(window.location.search).get("plinthos-benchmark") && hl();
        const d = {};
        let p = [];

        function f(t) {
            switch (a) {
                case "largest":
                    return t.intersectionAmount;
                case "highest":
                    return 0 - p.indexOf(t.element);
                case "lowest":
                    return p.indexOf(t.element);
                case "newest":
                    return t.intersectionTimestamp;
                case "oldest":
                    return 0 - t.intersectionTimestamp;
                default:
                    return 0
            }
        }

        function m(t) {
            A("Mutation Observer Refresh");
            let a = !t,
                h = !t,
                u = !t;
            if (t) {
                for (let e of t) e instanceof HTMLElement && (("CANVAS" === e.tagName || e.querySelector("canvas")) && (h = !0, a = !0), (e.dataset[i] || e.querySelector(`[${r}]`)) && (h = !0, u = !0), (e.dataset[s] || e.querySelector(`[${o}]`)) && (u = !0));
                t.length = 0
            }
            l(), a && function() {
                const t = yt("renderTargets");
                t && t.forEach((async t => {
                    if (!t.canvasSelector || t.background) return;
                    const i = document.querySelector(t.canvasSelector),
                        s = pt.instances[t.instanceKey];
                    if (!(i instanceof HTMLCanvasElement)) return void(s && !s.isIntersecting && s.stop({
                        delay: 0,
                        authority: Aa
                    }));
                    if (!s || s.canvas === i) return;
                    s.canvas = i;
                    const r = !!t.start && (!t.ioStops || s.isIntersecting);
                    let o = i.dataset[n];
                    if (!o && t.contentKey && !s.contentKey && (o = t.contentKey), o) {
                        s.reset();
                        let t = !1;
                        Ri((async () => {
                            t = await s.setContent(o, {
                                start: r,
                                data: _s(s.canvas, e),
                                instant: !0
                            }), t || S("Failed to set stage!")
                        }))
                    } else r && s.start()
                }))
            }(), h && c(), u && g()
        }

        function g() {
            if (!yt("lazyLoadEnabled")) return;
            const t = yt("lazyLoadInterval");
            setTimeout((() => {
                const t = function() {
                    const t = Array.from(document.querySelectorAll(`[${r}], [${o}]`)),
                        e = [];
                    return t.forEach((t => {
                        e.push(...v(t))
                    })), e
                }();
                sl(t);
                for (let e in pt.instances) {
                    const n = pt.instances[e];
                    n instanceof So && n.lazyLoadActions(t)
                }
            }), t)
        }

        function v(t) {
            const n = [],
                i = ws(t.dataset, e),
                s = _s(t, e);
            return n.push(... function(t, e, n) {
                const i = [];
                return t.split(";").forEach((t => {
                    var s, r;
                    const o = t.split("@"),
                        a = null == (s = o[0]) ? void 0 : s.trim(),
                        l = null == (r = o[1]) ? void 0 : r.trim();
                    l && a && i.push({
                        instigator: n,
                        instanceKey: l,
                        contentKey: a,
                        data: e
                    })
                })), i
            }(i.show ? ? i.load ? ? "", s, t)), n
        }
        Kn.refresh = m, Kn.ready = !0;
        const y = yt("kitPath");
        let x;
        y && (x = new Promise(((t, e) => {
            fetch(`${Za}${y}/buildInfo.json`).then((e => {
                if (e.ok) return e.json();
                t(void 0)
            })).then((e => {
                var n;
                t(null == (n = null == e ? void 0 : e.plinthosVersion) ? void 0 : n.replace(/[^\.\d]/g, ""))
            }))
        }))), Ri((async () => {
            try {
                Kn.version = await x
            } catch {
                console.warn("Plinthos version number unavailable!")
            }
            Object.freeze(Kn), document.dispatchEvent(new CustomEvent(jE, {})), setTimeout((() => {
                console.groupCollapsed("%c 3%cD %cVisuals by %c Plinth Digital %c ▼ ", "background: #111; color: #f66; padding: 6px 0;", "background: #111; color: #6af; padding: 6px 0;", "background: #111; color: #ddd; padding: 6px 0;", "background: #eee; color: #111; padding: 6px 0;", "background: #444; color: #ddd; padding: 6px 2px;"), console.log("🌐", "https://plinth.digital"), console.log("Made with ❤️ & 🧠 in Melbourne, Australia"), console.groupEnd()
            }), 1e3)
        }));
        class b {
            constructor(t) {
                T(this, "intersectionTimestamp"), T(this, "element"), T(this, "_boundingRect"), this.element = t.target, this._boundingRect = t.boundingClientRect, this.intersectionTimestamp = (new Date).getTime()
            }
            get boundingRect() {
                return this._boundingRect
            }
            get id() {
                let t = this.element.dataset.plinthosId;
                return t || (t = pi(), this.element.dataset.plinthosId = t), t
            }
            get dataset() {
                return ws(this.element.dataset, e)
            }
            get intersectionAmount() {
                let t;
                return t = this._boundingRect.top < 0 ? this._boundingRect.height + this._boundingRect.top : this._boundingRect.top + this._boundingRect.height > window.innerHeight ? window.innerHeight - this._boundingRect.top : this._boundingRect.height, Math.max(0, Math.min(t, this._boundingRect.height, window.innerHeight))
            }
            updateBoudingRect() {
                this._boundingRect = this.element.getBoundingClientRect()
            }
        }

        function A(...e) {
            t && console.log("%c Kit ", "color: #fff; background: #048; font-weight: bold;", ...e)
        }

        function S(...e) {
            t && console.warn("%c Kit ", "color: #fff; background: #048; font-weight: bold;", ...e)
        }
        Kn.debug.scroll = function t(e, n = 0) {
            document.scrollingElement.scrollTop += n, n < e && n++, document.scrollingElement.scrollTop < document.scrollingElement.scrollHeight - window.innerHeight && requestAnimationFrame((() => t(e, n)))
        }, Kn.debug.userScroll = async function(...t) {
            for (; t.length;) await e(t.shift(), t.shift(), t.shift());

            function e(t = 100, e = 150, n = null) {
                return console.table({
                    "Swipe start": "",
                    "Strength:": t,
                    "Max speed:": e,
                    "Duration:": n ? ? "Natural end"
                }), new Promise((i => {
                    let s = 0,
                        r = Math.abs(t),
                        o = e,
                        a = Math.sign(t),
                        l = null;

                    function c() {
                        console.log("swipe end"), l = !0, s = 0, r = 0, i()
                    }
                    n && (l = !1, setTimeout((() => c()), n)),
                        function t() {
                            s || (s = 1), document.scrollingElement.scrollTop += Math.min(s, o) * a, s === r && (r = 0), s < r ? s = Math.min(r, 2 * s) : s *= .95, s > .5 && !l ? requestAnimationFrame(t) : null === l && c()
                        }()
                }))
            }
        }
    },
    eg = Object.freeze(Object.defineProperty({
        __proto__: null,
        run: KE
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    YE = "plinthospluginready";
class tg extends Event {
    constructor() {
        super(YE, {}), T(this, "plinthos"), this.plinthos = DE
    }
}
const QE = () => {
        document.dispatchEvent(new tg)
    },
    ng = Object.freeze(Object.defineProperty({
        __proto__: null,
        PluginEvent: tg,
        run: QE
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    ig = '@charset "UTF-8";\n:root {\n  --gui-background: #111;\n  --gui-item: #222;\n  --gui-item-expanded: #444;\n  --gui-section: #aaa;\n  --gui-selected: #a63;\n  --gui-highlight: #fa3;\n  --gui-text-light: #eee;\n  --gui-text-dark: #111;\n  --gui-input-background: var(--gui-item);\n  --gui-input-color: var(--gui-text-light);\n  --gui-input-border: var(--gui-section);\n  --gui-button-background: #aaa;\n  --gui-button-background-hover: #ccc;\n  --gui-button-background-active: #eee;\n  --gui-button-color: var(--gui-text-dark);\n  --gui-button-background: #333;\n  --gui-button-background-hover: #444;\n  --gui-button-background-active: #555;\n  --gui-button-color: var(--gui-text-light);\n  --tp-folder-border: 2px;\n  --tp-folder-border-radius: 4px;\n  --tp-folder-margin: 2px;\n  --tp-section-background-color: var(--gui-section);\n  --tp-agent-color: var(--gui-text-dark);\n  --tp-agent-background-color: var(--gui-highlight);\n  --tp-base-background-color: var(--gui-background);\n  --tp-base-shadow-color: transparent;\n  --tp-button-background-color: var(--gui-button-background);\n  --tp-button-background-color-active: var(--gui-button-background-active);\n  --tp-button-background-color-focus: var(--gui-button-background-hover);\n  --tp-button-background-color-hover: var(--gui-button-background-hover);\n  --tp-button-foreground-color: var(--gui-button-color);\n  --tp-container-background-color: var(--gui-item);\n  --tp-container-background-color-active: var(--gui-item);\n  --tp-container-background-color-focus: var(--gui-item);\n  --tp-container-background-color-hover: var(--gui-item);\n  --tp-container-foreground-color: var(--gui-text-light);\n  --tp-groove-foreground-color: var(--gui-item);\n  --tp-input-background-color: transparent;\n  --tp-input-background-color-active: transparent;\n  --tp-input-background-color-focus: transparent;\n  --tp-input-background-color-hover: transparent;\n  --tp-input-foreground-color: var(--gui-input-color);\n  --tp-label-foreground-color: var(--gui-text-light);\n  --tp-monitor-background-color: transparent;\n  --tp-monitor-foreground-color: var(--gui-highlight);\n  --tp-font-family: sans-serif;\n  --tp-base-font-family: sans-serif;\n  --tp-blade-spacing: 4px;\n  --tp-blade-unit-size: 24px;\n  --cnt-usp: 4px;\n}\n\nbody .tp-rotv {\n  min-width: 344px;\n}\nbody .tp-rotv * {\n  box-sizing: border-box;\n}\nbody .tp-rotv .tp-colv:not(.tp-colv-expanded) .tp-colv_p {\n  overflow: hidden;\n}\nbody .tp-rotv .tp-lblv.tp-v-disabled * {\n  opacity: 1;\n}\nbody .tp-rotv .tp-lblv.tp-v-disabled .tp-lblv_l {\n  opacity: 1;\n}\nbody .tp-rotv .tp-lblv.tp-v-disabled .tp-lblv_l::after {\n  content: " 🔒";\n}\nbody .tp-rotv .tp-lblv.tp-v-disabled .tp-lblv_v .tp-txtv_i,\nbody .tp-rotv .tp-lblv.tp-v-disabled .tp-lblv_v .tp-p2dpv_p,\nbody .tp-rotv .tp-lblv.tp-v-disabled .tp-lblv_v .tp-colswv_sw {\n  color: var(--lbl-fg);\n}\nbody .tp-rotv .tp-lblv.tp-v-disabled .tp-lblv_v .tp-txtv_i:hover,\nbody .tp-rotv .tp-lblv.tp-v-disabled .tp-lblv_v .tp-p2dpv_p:hover,\nbody .tp-rotv .tp-lblv.tp-v-disabled .tp-lblv_v .tp-colswv_sw:hover {\n  background-color: var(--in-bg);\n}\nbody .tp-rotv .tp-fldv_b {\n  text-transform: capitalize;\n  transition: 0.3s all;\n  height: 28px;\n}\nbody .tp-rotv .tp-lblv_l {\n  text-transform: capitalize;\n  white-space: nowrap;\n  min-width: 120px;\n  flex-shrink: 0;\n}\nbody .tp-rotv .tp-lblv_v {\n  font-family: "Source Code Pro", monospace;\n  flex-grow: 1;\n}\nbody .tp-rotv .tp-lblv_v select,\nbody .tp-rotv .tp-lblv_v button {\n  font-family: sans-serif;\n  text-transform: capitalize;\n}\nbody .tp-rotv .tp-colswv_b,\nbody .tp-rotv .tp-ckbv_w {\n  border: 1px solid var(--gui-selected);\n  border-radius: 2px;\n  height: 20px;\n  width: 20px;\n}\nbody .tp-rotv .tp-colswv_b svg path,\nbody .tp-rotv .tp-ckbv_w svg path {\n  stroke: var(--gui-highlight);\n}\nbody .tp-rotv .tp-colswv {\n  height: 20px;\n  width: 20px;\n  margin-right: 4px;\n}\nbody .tp-rotv .tp-colswv .tp-colswv_sw {\n  height: 20px;\n  width: 20px;\n}\nbody .tp-rotv .tp-cntv {\n  margin-left: 0;\n}\nbody .tp-rotv .tp-v-lst {\n  margin-bottom: 0 !important;\n}\nbody .tp-rotv .tp-fldv {\n  font-size: 12px;\n  margin: 0 var(--tp-folder-margin);\n  transition: all 200ms;\n}\nbody .tp-rotv .tp-fldv > .tp-fldv_b > .tp-fldv_m, body .tp-rotv .tp-fldv > .tp-fldv_b > .tp-rotv_m, body .tp-rotv .tp-fldv > .tp-rotv_b > .tp-fldv_m, body .tp-rotv .tp-fldv > .tp-rotv_b > .tp-rotv_m {\n  background: none;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\nbody .tp-rotv .tp-fldv > .tp-fldv_b > .tp-fldv_m::before, body .tp-rotv .tp-fldv > .tp-fldv_b > .tp-fldv_m::after, body .tp-rotv .tp-fldv > .tp-fldv_b > .tp-rotv_m::before, body .tp-rotv .tp-fldv > .tp-fldv_b > .tp-rotv_m::after, body .tp-rotv .tp-fldv > .tp-rotv_b > .tp-fldv_m::before, body .tp-rotv .tp-fldv > .tp-rotv_b > .tp-fldv_m::after, body .tp-rotv .tp-fldv > .tp-rotv_b > .tp-rotv_m::before, body .tp-rotv .tp-fldv > .tp-rotv_b > .tp-rotv_m::after {\n  position: absolute;\n  content: "";\n  display: block;\n  background-color: currentColor;\n  transition: all 0.2s;\n}\nbody .tp-rotv .tp-fldv > .tp-fldv_b > .tp-fldv_m::before, body .tp-rotv .tp-fldv > .tp-fldv_b > .tp-rotv_m::before, body .tp-rotv .tp-fldv > .tp-rotv_b > .tp-fldv_m::before, body .tp-rotv .tp-fldv > .tp-rotv_b > .tp-rotv_m::before {\n  height: 8px;\n  width: 2px;\n}\nbody .tp-rotv .tp-fldv > .tp-fldv_b > .tp-fldv_m::after, body .tp-rotv .tp-fldv > .tp-fldv_b > .tp-rotv_m::after, body .tp-rotv .tp-fldv > .tp-rotv_b > .tp-fldv_m::after, body .tp-rotv .tp-fldv > .tp-rotv_b > .tp-rotv_m::after {\n  height: 2px;\n  width: 8px;\n}\nbody .tp-rotv .tp-fldv.tp-fldv-expanded > .tp-fldv_b > .tp-fldv_m::before, body .tp-rotv .tp-fldv.tp-fldv-expanded > .tp-fldv_b > .tp-rotv_m::before, body .tp-rotv .tp-fldv.tp-fldv-expanded > .tp-rotv_b > .tp-fldv_m::before, body .tp-rotv .tp-fldv.tp-fldv-expanded > .tp-rotv_b > .tp-rotv_m::before, body .tp-rotv .tp-fldv.tp-rotv-expanded > .tp-fldv_b > .tp-fldv_m::before, body .tp-rotv .tp-fldv.tp-rotv-expanded > .tp-fldv_b > .tp-rotv_m::before, body .tp-rotv .tp-fldv.tp-rotv-expanded > .tp-rotv_b > .tp-fldv_m::before, body .tp-rotv .tp-fldv.tp-rotv-expanded > .tp-rotv_b > .tp-rotv_m::before {\n  height: 2px;\n  width: 2px;\n}\nbody .tp-rotv .tp-fldv.tp-v-hidden + .tp-fldv {\n  margin-top: 0;\n}\nbody .tp-rotv .tp-fldv .tp-fldv_i {\n  display: none;\n}\nbody .tp-rotv .tp-fldv > .tp-fldv_c {\n  display: flex;\n  flex-direction: column;\n  padding-left: 0;\n  border: solid;\n  border-width: var(--tp-folder-border);\n  border-top-width: 0;\n  border-color: var(--cnt-bg);\n  border-radius: 0 0 var(--tp-folder-border-radius) var(--tp-folder-border-radius);\n}\nbody .tp-rotv .tp-fldv > .tp-fldv_b:hover {\n  border-color: var(--cnt-bg-h);\n}\nbody .tp-rotv .tp-fldv > .tp-fldv_b:focus {\n  border-color: var(--cnt-bg-f);\n}\nbody .tp-rotv .tp-fldv > .tp-fldv_b .tp-fldv_t {\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  overflow-x: hidden;\n  text-overflow: ellipsis;\n}\nbody .tp-rotv .tp-fldv > .tp-fldv_b .tp-fldv_t i {\n  flex-shrink: 0;\n  font-size: 16px;\n  transition: all 200ms;\n  display: inline-block;\n  width: 24px;\n  text-align: center;\n  margin-right: 8px;\n}\nbody .tp-rotv .tp-fldv.tp-fldv-expanded {\n  opacity: 1 !important;\n}\nbody .tp-rotv .tp-fldv.tp-fldv-expanded:not(.tp-v-fst) {\n  margin-top: 3px;\n}\nbody .tp-rotv .tp-fldv.tp-fldv-expanded:not(.tp-v-lst) {\n  margin-bottom: 3px;\n}\nbody .tp-rotv .tp-fldv.tp-fldv-expanded + .tp-fldv-expanded {\n  margin-top: 0;\n}\nbody .tp-rotv .tp-fldv.tp-fldv-expanded > .tp-fldv_b {\n  border-style: solid;\n  border-radius: var(--tp-folder-border-radius) var(--tp-folder-border-radius) 0 0;\n  background: var(--gui-item-expanded);\n  border-color: var(--gui-item-expanded);\n}\nbody .tp-rotv .tp-fldv.tp-fldv-expanded > .tp-fldv_b .tp-fldv_t i {\n  color: inherit !important;\n}\nbody .tp-rotv .tp-fldv.tp-fldv-expanded > .tp-fldv_c {\n  border-color: var(--gui-item-expanded);\n}\nbody .tp-rotv .tp-fldv.cp-faded {\n  opacity: 0.7;\n  order: 1;\n}\nbody .tp-rotv .tp-fldv.cp-faded i {\n  color: #aaa !important;\n}\nbody .tp-rotv .cp-section.tp-fldv-expanded > .tp-fldv_b {\n  color: var(--gui-text-dark);\n  font-weight: bold;\n  background: var(--tp-section-background-color);\n  border-color: var(--tp-section-background-color);\n}\nbody .tp-rotv .cp-section.tp-fldv-expanded > .tp-fldv_c {\n  border-color: var(--tp-section-background-color);\n}\nbody .tp-rotv .cp-agent.tp-fldv-expanded > .tp-fldv_b {\n  color: var(--gui-text-dark);\n  font-weight: bold;\n  background: var(--tp-agent-background-color);\n  border-color: var(--tp-agent-background-color);\n}\nbody .tp-rotv .cp-agent.tp-fldv-expanded > .tp-fldv_c {\n  border-color: var(--tp-agent-background-color);\n}\nbody .tp-rotv .tp-fldv_c > .tp-cntv + .tp-fldv:not(.tp-v-hidden, .tp-fldv-expanded) {\n  margin-top: 0;\n}\nbody .tp-rotv .tp-sprv {\n  margin: 4px 0 0 0;\n}\nbody .tp-rotv .tp-sprv hr.tp-sprv_r {\n  position: relative;\n  left: 5%;\n  width: 90%;\n  background: none;\n  border-color: var(--gui-item);\n  border-style: dotted;\n  border-width: 2px 0 0 0;\n  height: 0;\n}\nbody .tp-rotv .tp-ckrtxtv_r {\n  flex: 2;\n  cursor: ew-resize;\n}\nbody .tp-rotv .tp-ckrtxtv_r * {\n  cursor: ew-resize;\n}\nbody .tp-rotv .tp-btngridv {\n  gap: 4px;\n}\nbody .tp-rotv .tp-txtv_k::before {\n  opacity: 0.3;\n}\nbody .tp-rotv .tp-sldv_k::before {\n  background-color: var(--tp-button-background-color);\n}\nbody .tp-rotv .tp-sldv_k::after {\n  background-color: var(--tp-button-foreground-color) !important;\n}\nbody .tp-rotv .tp-btnv_b, body .tp-rotv .tp-btngridv .tp-btnv_b {\n  height: 24px;\n  border-radius: 4px;\n  position: relative;\n  transition: background-color, 300ms;\n  padding: 0;\n  margin: 0;\n}\nbody .tp-rotv .tp-lstv_s {\n  max-width: unset;\n  margin: 0;\n}\nbody .tp-rotv .tp-lstv_m {\n  display: none;\n}\n\n.input, .select, body .tp-rotv .tp-lstv_s, body .tp-rotv .tp-txtv_i {\n  color: var(--gui-input-color);\n  background-color: var(--gui-input-background);\n  border: 1px solid transparent;\n  border-radius: 2px;\n  font-weight: normal;\n  height: 20px;\n  padding: 0 8px;\n  outline: none;\n  line-height: 20px;\n  vertical-align: middle;\n  -webkit-appearance: textfield;\n  -moz-appearance: textfield;\n  appearance: textfield;\n  transition: all 300ms;\n}\n.input:hover, .select:hover, body .tp-rotv .tp-lstv_s:hover, body .tp-rotv .tp-txtv_i:hover, .input:active, .select:active, body .tp-rotv .tp-lstv_s:active, body .tp-rotv .tp-txtv_i:active {\n  border-color: var(--gui-selected);\n  background-color: var(--gui-item);\n}\n.input:focus, .select:focus, body .tp-rotv .tp-lstv_s:focus, body .tp-rotv .tp-txtv_i:focus {\n  border-color: var(--gui-highlight);\n  background-color: var(--gui-item);\n}\n.input::-webkit-inner-spin-button, .select::-webkit-inner-spin-button, body .tp-rotv .tp-lstv_s::-webkit-inner-spin-button, body .tp-rotv .tp-txtv_i::-webkit-inner-spin-button, .input::-webkit-outer-spin-button, .select::-webkit-outer-spin-button, body .tp-rotv .tp-lstv_s::-webkit-outer-spin-button, body .tp-rotv .tp-txtv_i::-webkit-outer-spin-button {\n  -webkit-appearance: none;\n}\n.input[type=number], [type=number].select, body .tp-rotv [type=number].tp-lstv_s, body .tp-rotv [type=number].tp-txtv_i {\n  font-family: "Source Code Pro", monospace;\n}\n.input:disabled, .select:disabled, body .tp-rotv .tp-lstv_s:disabled, body .tp-rotv .tp-txtv_i:disabled {\n  opacity: 0.5;\n  background-color: transparent;\n}\n\n.select, body .tp-rotv .tp-lstv_s {\n  position: relative;\n  appearance: none;\n  padding: 0 2em 0 1ch;\n  background-image: url("/svg/select-arrow.svg");\n  background-repeat: no-repeat;\n  background-position: right 6px top calc(50% + 2px);\n  background-size: 10px;\n}\n.select optgroup, body .tp-rotv .tp-lstv_s optgroup {\n  color: var(--gui-highlight);\n}\n.select option, body .tp-rotv .tp-lstv_s option {\n  color: var(--gui-text-light);\n}\n\nhtml,\nbody {\n  padding: 0;\n  margin: 0;\n  overflow: hidden;\n  /* font-family: monospace; */\n  font-family: sans-serif;\n  font-size: smaller;\n}\n\n#canvas {\n  height: 100vh;\n  width: 100vw;\n  -webkit-tap-highlight-color: transparent;\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n  outline: none !important;\n}\n\n#menu {\n  position: fixed;\n  top: 0;\n  right: 0;\n  display: flex;\n  flex-direction: column;\n  color: #fff;\n  background-color: rgba(0, 0, 0, 0.5333333333);\n  padding: 0;\n  padding-bottom: 1em;\n  margin: 0;\n  border-radius: 0 0 0 1em;\n  max-height: 100vh;\n  overflow: auto;\n}\n\n#cp-container {\n  position: fixed;\n  top: 0;\n  left: 0;\n  max-height: 100vh;\n  overflow-y: auto;\n  overflow-x: hidden;\n}\n\ndd {\n  cursor: pointer;\n  padding: 0.5ch 2em 0.5ch 3em;\n  margin: 0;\n  background-color: rgba(238, 238, 238, 0);\n  transition: all 500ms;\n}\ndd.current {\n  background-color: #eee;\n  color: #111;\n  font-weight: bold;\n}\ndd:hover {\n  text-decoration: underline;\n}\n\ndt {\n  margin-top: 1em;\n  font-weight: bold;\n  padding-left: 2em;\n}\n\n.tp-rotv {\n  min-width: 290px;\n  font-family: sans-serif !important;\n  font-size: small;\n}';

function qE(t = {}) {
    var e;
    const n = new URL(window.location.href),
        i = n.searchParams.get("s") ? ? t.stageKey ? ? Object.keys(kn.instances)[0];
    let s = n.searchParams.get("c") ? ? t.contentKey;
    const r = ((null == (e = n.searchParams.get("o")) ? void 0 : e.toLowerCase()) ? ? "").split(""),
        o = r.includes("g") || t.gui,
        a = r.includes("m") || t.menu,
        l = r.includes("d") || t.debug,
        c = r.includes("v") || t.globalVar,
        h = r.includes("b") || t.benchmark;

    function u(t, e, i) {
        const s = [];
        return t ? ? (t = n.searchParams.get("s")), t && s.push(`s=${t}`), e ? ? (e = v.contentKey), e && s.push(`c=${e}`), i ? ? (i = r.join("")), i && s.push(`o=${i}`), `?${s.join("&")}`
    }
    const d = document.createElement("style");
    d.innerText = ig;
    const p = document.querySelector("style");
    p ? p.parentElement.insertBefore(d, p) : document.body.appendChild(d);
    const f = document.createElement("canvas");
    if (f.id = "canvas", document.body.appendChild(f), o) {
        const t = document.createElement("link");
        t.rel = "stylesheet", t.href = "https://kit.fontawesome.com/1f4f944a28.css", t.crossOrigin = "anonymous", document.head.appendChild(t);
        const e = document.createElement("div");
        e.id = "cp-container", e.appendChild(eh().element), document.body.appendChild(e)
    }
    const m = pt.build({
            instanceKey: "demo",
            stageKey: i,
            tweakpane: o ? eh() : void 0,
            options: {
                debug: l,
                maxPixelRatio: 1.3
            },
            canvas: f
        }),
        g = kn.instances[i];
    g.demoBackground && (document.body.style.backgroundColor = g.demoBackground);
    const v = m.stage;
    if (c && (window.display = m, window.stage = v), h && hl(), document.onkeydown = function(t) {
            let e = !1;
            if (t.ctrlKey && "s" === t.key.toLowerCase() && (e = !0, m.saveImage()), e) return t.preventDefault(), !1
        }, setTimeout((() => {
            -1 === v.contentKeys.indexOf(s) && (s = Object.keys(v.shots)[0]), v.contentKey = s, v.start()
        })), a) {
        const t = document.createElement("div");
        t.id = "menu", document.body.appendChild(t);
        const e = document.createElement("dt");
        e.appendChild(document.createTextNode("Stages")), t.appendChild(e);
        for (let e in kn.instances) {
            const n = kn.instances[e],
                i = document.createElement("dd");
            i.appendChild(document.createTextNode(n.key)), t.appendChild(i), i.onclick = t => window.location.href = u(e, !1)
        }
        const n = document.createElement("dt");
        n.appendChild(document.createTextNode("Shots")), t.appendChild(n);
        for (let e in v.shots) {
            const n = v.shots[e],
                i = document.createElement("dd");
            i.title = n.key, i.dataset.shotKey = n.key, i.appendChild(document.createTextNode(n.name)), t.appendChild(i), i.onclick = t => {
                v.contentKey = e, history.replaceState({}, "", u(void 0, e))
            }
        }
        if (Object.keys(v.sequences).length) {
            const e = document.createElement("dt");
            e.appendChild(document.createTextNode("Sequences")), t.appendChild(e);
            for (let e in v.sequences) {
                const n = v.sequences[e],
                    i = document.createElement("dd");
                i.appendChild(document.createTextNode(n.name)), t.appendChild(i), i.onclick = t => {
                    v.contentKey = e, history.replaceState({}, "", u(void 0, e))
                }
            }
        }
        v.addEventListener("shotchange", (t => {
            var e;
            Array.from(document.querySelectorAll("dd.current")).forEach((t => t.classList.remove("current"))), null == (e = document.querySelector(`[data-shot-key="${t.shotKey}"]`)) || e.classList.add("current")
        }))
    }
}
const sg = Object.freeze(Object.defineProperty({
    __proto__: null,
    init: qE
}, Symbol.toStringTag, {
    value: "Module"
}));

function ZE() {
    const t = document.createElement("canvas"),
        e = document.createElement("canvas");
    document.body.append(t), document.body.append(e);
    const n = new ul({
        instanceKey: "onscreen",
        stageKey: "test",
        canvas: t
    });
    n.contentKey = "plinth", n.start(), n.pointerEventSurrogate = document.getElementById("on-pes");
    const i = pt.build({
        instanceKey: "offscreen",
        workerKey: "test",
        stageKey: "test",
        canvas: e,
        shotData: {
            floorColor: "#333"
        },
        options: {
            debug: !0
        }
    });
    i.contentKey = "plinth", i.start(), i.pointerEventSurrogate = document.getElementById("off-pes"), window.off = i.controller, window.on = n.controller;
    const s = document.createElement("div");
    s.id = "menu", document.body.appendChild(s);
    const r = document.createElement("style");
    r.innerText = ig;
    const o = document.querySelector("style");
    o ? o.parentElement.insertBefore(r, o) : document.body.appendChild(r);
    const a = n.stage,
        l = document.createElement("dt");
    l.appendChild(document.createTextNode("Shots")), s.appendChild(l);
    for (let t in a.shots) {
        const e = n.stage.shots[t],
            r = document.createElement("dd");
        r.title = e.key, r.dataset.shotKey = e.key, r.appendChild(document.createTextNode(e.name)), s.appendChild(r), r.onclick = e => {
            n.contentKey = t, i.contentKey = t
        }
    }
    if (Object.keys(a.sequences).length) {
        const t = document.createElement("dt");
        t.appendChild(document.createTextNode("Sequences")), s.appendChild(t);
        for (let t in a.sequences) {
            const e = a.sequences[t],
                r = document.createElement("dd");
            r.appendChild(document.createTextNode(e.name)), s.appendChild(r), r.onclick = e => {
                n.contentKey = t, i.contentKey = t
            }
        }
    }
    const c = "attributionchange";
    n.stage.addEventListener(c, (t => console.log(t))), n.addEventListener(c, (t => console.log(t))), n.controller.addEventListener(c, (t => console.log(t))), i.addEventListener(c, (t => console.log(t))), i.controller.addEventListener(c, (t => console.log(t)))
}
const rg = Object.freeze(Object.defineProperty({
        __proto__: null,
        init: ZE
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    Hf = ["name", "guiIcon", "guiIconColor", "attribution", "actionKey", "cancel", "duration", "delay", "outroDelay", "salientDuration", "timingFunction", "origin", "change", "instant", "includeDefaults", "animate", "onBefore", "onStart", "onComplete", "onCancel", "debug"];
class JE extends _M {
    constructor(t, e) {
        e._progress = 0, super(e), T(this, "id"), T(this, "type"), T(this, "_target"), T(this, "_ogTarget"), T(this, "_complete", !1), T(this, "_cancelled", !1), T(this, "_progress", 0), T(this, "_onCancelCallback"), T(this, "_externalOnUpdateCallback"), this.id = pi(), this.type = t
    }
    get target() {
        return this._target
    }
    get complete() {
        return this._complete
    }
    set complete(t) {
        this._complete = this._complete || t
    }
    get cancelled() {
        if (this._cancelled) return !0;
        for (var t in this._target)
            if ("number" == typeof this._target[t]) return !1;
        return Object.keys(this._ogTarget).length > Object.keys(this._target).length
    }
    get progress() {
        return this._progress
    }
    to(t, e) {
        return t._progress = 1, super.to(t, e).dynamic(!0).onStop((t => {
            this._cancelled && this._onCancelCallback && this._onCancelCallback(t)
        })), super.onUpdate(((t, e) => {
            var n;
            this._progress = t._progress, delete t._progress, null == (n = this._externalOnUpdateCallback) || n.call(this, t, e)
        })), this._target = t, this._ogTarget = si(t), this
    }
    cancel() {
        this._cancelled = !this.complete, this.stop(), wM(this)
    }
    onCancel(t) {
        return this._onCancelCallback = t, this
    }
    onUpdate(t) {
        return this._externalOnUpdateCallback = t, this
    }
}
class $E {
    constructor(t, e, n) {
        T(this, "id"), T(this, "type"), T(this, "omitTweenKeys", []), T(this, "timer"), T(this, "orderedAt"), this.type = t, this.id = pi(), this.timer = setTimeout((() => e(this.id, this.omitTweenKeys)), n), this.orderedAt = bs()
    }
    cancel() {
        clearTimeout(this.timer)
    }
}
const og = class t {
    constructor(e) {
        T(this, "isAgent", !0), T(this, "id", pi()), T(this, "options"), T(this, "name", "AGENT"), T(this, "attribution", []), T(this, "defaultAction"), T(this, "states"), T(this, "debug", !1), T(this, "gui"), T(this, "methodsGui"), T(this, "methodsGuiParamJson", "[]"), T(this, "statesGui"), T(this, "guiIcon", "fa fa-start"), T(this, "guiIconColor", "#fc6"), T(this, "guiConfig", {}), T(this, "animationSpeed"), T(this, "animationScale"), T(this, "animationOffset"), T(this, "tweens", {}), T(this, "tweenKeys"), T(this, "defaultChangeAction", {}), T(this, "pendingActions", {}), T(this, "defaultActionBindings"), T(this, "transients", {}), T(this, "userData"), T(this, "_stage"), T(this, "lastAction"), T(this, "tweenPropStatus", {}), T(this, "methods", {}), T(this, "defaultActionMethods"), T(this, "actionMethods"), T(this, "guiFolders", {}), T(this, "bindings", {}), T(this, "hasWarned", !1), T(this, "hasErrored", !1), this.options = Object.freeze({ ...e
        });
        const n = e.defaultAction ? ? {},
            i = n.change;
        delete n.change;
        const s = this.defineDefaultAction();
        let r;
        for (r in s) s[r] = n[r] ? ? s[r];
        this.defaultAction = Object.freeze(s), this.states = Object.freeze({ ...this.states,
            ...e.states ? ? {}
        }), this.defaultChangeAction = { ...this.defaultAction.change,
            ...i
        }, this.guiConfig = { ...this.defineGuiConfig(),
            ...e.guiConfig ? ? {}
        }, this.userData = n.userData ? ? {};
        const o = this.defineTweenKeys(),
            a = [...new Set(o)];
        o.length !== a.length && this.warn(`Check ${this.constructor.name} for duplicate tween keys!`);
        for (var l = 0; l < a.length; l++) {
            const t = a[l];
            if (-1 !== Hf.indexOf(t) && (this.warn(`${this.name} uses reserved action key ${t} as a tween key.`), a.splice(l, 1), l--), "number" != typeof this.defaultAction[t]) throw new Error(`Agent "${this.name}"tween prop "${t}" has non-numeric default. All default values for tween props must be numeric. Null is reserved for tween omission on change.`)
        }
        this.tweenKeys = a, this.applyOptions(e), this.animationScale = this.defaultAction.animationScale ? ? 1, this.animationSpeed = this.defaultAction.animationSpeed ? ? 1, this.animationOffset = this.defaultAction.animationOffset ? ? 0, n.animate && (this.defaultActionAnimate = n.animate), n.methods && (this.defaultActionMethods = n.methods), n.bindings && (this.defaultActionBindings = n.bindings), !this.animate && !n.animate && (this.guiConfig.animationSpeed = "hidden", this.guiConfig.animationScale = "hidden", this.guiConfig.animationOffset = "hidden"), t.agents.push(this)
    }
    get usingGui() {
        return !!this.gui
    }
    updateGui() {
        this.gui && this.gui.refresh()
    }
    get guiLabel() {
        return this.name
    }
    get guiVisible() {
        var t;
        return !(null != (t = this.gui) && t.hidden)
    }
    set guiVisible(t) {
        this.gui && (this.gui.hidden = !t)
    }
    get guiExpanded() {
        var t;
        return (null == (t = this.gui) ? void 0 : t.expanded) ? ? !1
    }
    set guiExpanded(t) {
        this.gui && (this.gui.expanded = t)
    }
    get guiFaded() {
        var t;
        return (null == (t = this.gui) ? void 0 : t.element.classList.contains("cp-faded")) || !1
    }
    set guiFaded(t) {
        this.gui && (t ? this.gui.element.classList.add("cp-faded") : this.gui.element.classList.remove("cp-faded"))
    }
    set stage(t) {
        this._stage || (this._stage = t, this.onSetStage && this.onSetStage(this._stage))
    }
    get stage() {
        return this._stage
    }
    clone(t) {
        var e;
        const n = new this.constructor({ ...this.options,
            ...t,
            defaultAction: { ...this.options.defaultAction ? ? {},
                ...t.defaultAction ? ? {}
            }
        });
        return null == (e = this.afterClone) || e.call(this, this, n), n
    }
    defineDefaultAction() {
        return {
            actionKey: "change",
            cancel: [],
            state: [],
            instant: !1,
            includeDefaults: !0,
            includeRedundant: !1,
            duration: 2e3,
            delay: 0,
            outroDelay: 0,
            salientDuration: null,
            timingFunction: yn.Quadratic.InOut,
            onBefore: [],
            onStart: [],
            onComplete: [],
            onCancel: [],
            origin: {},
            animationScale: 1,
            animationSpeed: 1,
            animationOffset: 0
        }
    }
    defineTweenKeys() {
        return ["animationSpeed", "animationScale", "animationOffset"]
    }
    defineGuiConfig() {
        return {}
    }
    applyOptions(t) {
        const e = [...this.tweenKeys];
        for (let n in t) {
            const i = n;
            if (-1 === e.indexOf(i)) switch (i) {
                case "defaultAction":
                case "guiConfig":
                case "states":
                case "parent":
                    break;
                default:
                    n in this && (this[i] = t[n])
            } else this.warn(`Action key "${i}" passed in as options on agent "${this.name}"!`)
        }
    }
    setTweenProps(t, e) {
        let n;
        for (n in t)
            if (this.tweenKeys.includes(n) && (!e || void 0 !== e[n])) try {
                this[n] = t[n]
            } catch (t) {
                this.error(t)
            }
        this.onSetTweenState && this.onSetTweenState(t), this.updateGui()
    }
    setBoundProp(t, e, n, i) {
        let s = !1;
        for (let e in this.tweens) {
            const r = this.tweens[e].target;
            if (void 0 !== r[t]) return s = !0, void(r[t] = fm(r[t], n, i))
        }
        s || (this[t] = e)
    }
    get agentState() {
        const t = {};
        let e;
        for (e in this.defaultAction) t[e] = this[e] ? ? this.defaultAction[e];
        return t
    }
    get tweenState() {
        const t = {};
        for (const e of this.tweenKeys) t[e] = this[e];
        return t
    }
    get defaultTweenState() {
        const t = {};
        for (const e of this.tweenKeys) t[e] = this.defaultAction[e];
        return t
    }
    get salientState() {
        const t = {},
            e = this.agentState;
        let n;
        for (n in e) e[n] !== this.defaultAction[n] && (t[n] = this[n]);
        return t
    }
    get salientTweenState() {
        const t = {},
            e = this.tweenState;
        for (let n of this.tweenKeys) e[n] !== this.defaultAction[n] && (t[n] = this[n]);
        return t
    }
    get actionState() {
        var t;
        const e = {},
            n = this.agentState;
        let i;
        for (i in n) n[i] !== this.defaultAction[i] && (e[i] = null === (null == (t = this.lastAction) ? void 0 : t[i]) || this.bindings[i] ? null : this[i]);
        return e
    }
    get actionTweenState() {
        var t;
        const e = {},
            n = this.agentState;
        for (let i of this.tweenKeys) n[i] !== this.defaultAction[i] && (e[i] = null === (null == (t = this.lastAction) ? void 0 : t[i]) ? null : this[i]);
        return e
    }
    tween(t, e, n = []) {
        const i = {};
        for (const t of this.tweenKeys) void 0 !== e[t] && (i[t] = e[t]);
        const s = new JE(t, i);
        return this.tweens[s.id] = s, s
    }
    cancelTweenById(t) {
        this.tweens[t] && (this.tweens[t].cancel(), delete this.tweens[t])
    }
    cancelTweensByType(...t) {
        for (const e of t) {
            for (let t in this.tweens)(this.tweens[t].type === e || "*" === e) && (this.tweens[t].cancel(), delete this.tweens[t]);
            for (let t in this.pendingActions) {
                const n = this.pendingActions[t];
                (n.type === e || "*" === e) && (n.cancel(), delete this.pendingActions[t])
            }
        }
    }
    cancelTweensByFilter(t) {
        for (let e in this.tweens) {
            const n = this.tweens[e];
            t(n) && (n.cancel(), delete this.tweens[e])
        }
    }
    cancelPendingActionsByFilter(t) {
        for (let e in this.pendingActions) {
            const n = this.pendingActions[e];
            t(n) && (n.cancel(), delete this.pendingActions[e])
        }
    }
    cancelPendingActionsByType(...t) {
        for (const e of t)
            for (let t in this.pendingActions) {
                const n = this.pendingActions[t];
                (n.type === e || "*" === e) && (n.cancel(), delete this.pendingActions[t])
            }
    }
    hasTweenType(...t) {
        for (const e of t)
            for (let t in this.tweens)
                if (this.tweens[t].type === e) return !0;
        return !1
    }
    hasPendingActionType(...t) {
        for (const e of t)
            for (let t in this.pendingActions)
                if (this.pendingActions[t].type === e) return !0;
        return !1
    }
    change(t) {
        t = Fh(t), this.log("pAction", si(t));
        for (const e of this.tweenKeys) {
            const n = e;
            switch (t[e]) {
                case void 0:
                    this.tweenPropStatus[n] = "default";
                    break;
                case null:
                    this.tweenPropStatus[n] = "ignored";
                    break;
                default:
                    this.tweenPropStatus[n] = t[e] === this.defaultAction[e] ? "default" : "set"
            }
        }
        let e = this.bindingListToAgentBindings({ ...this.defaultActionBindings,
            ...t.bindings
        });
        (null === t.bindings || !1 === t.includeDefaults) && (e = { ...this.bindings,
            ...e
        });
        const n = {};
        for (let t in e) {
            const i = e[t];
            n[t] = i.callback(this.stage.getBinding(i.bindingKey))
        }
        if ("string" == typeof t.state && (t.state = [t.state]), Array.isArray(t.state)) {
            t.state.reverse();
            for (let e of t.state) {
                const n = this.states[e];
                n && (t = Rr(n, t))
            }
        }
        const i = { ...this.defaultAction,
            ...this.defaultChangeAction
        };
        let s = {
            duration: i.duration,
            timingFunction: i.timingFunction,
            includeRedundant: i.includeRedundant,
            ...t,
            ...t.change,
            ...n
        };
        const r = s.includeDefaults ? ? i.includeDefaults;
        this.log("Include defaults?", r), s = Rr(r ? i : {}, s), this.log("Before actionCallback construction", this.debug && si(s));
        const o = bs(),
            a = (n, i = []) => {
                if (this.log(`Starting actionCallback ${s.actionKey}`, this.debug && si(s)), void 0 !== n && delete this.pendingActions[n], s.origin = { ...Ja(s, this.tweenState),
                        ...t.origin || {}
                    }, this.lastAction = si(s), s.instant && (s.includeRedundant = !0), this.onBeforeChange && s.onBefore.unshift((t => this.onBeforeChange(t))), this.onStartChange && s.onStart.unshift((t => this.onStartChange(t))), this.onCompleteChange && s.onComplete.unshift((t => this.onCompleteChange(t))), this.onCancelChange && s.onCancel.unshift((t => this.onCancelChange(t))), s.onBefore && !s.onBefore.every((t => t.call(this, s)))) return void this.log(`${this.name} failed an onBefore. Aborting.`);
                this.log("Cancelling", [...s.cancel]);
                const r = s.cancel.indexOf("*") > -1;
                this.cancelTweensByFilter((t => r || s.cancel.indexOf(t.type) > -1)), this.cancelPendingActionsByFilter((t => (r || s.cancel.indexOf(t.type) > -1) && t.orderedAt < o));
                let a = {};
                for (let t in this.tweens) a = { ...a,
                    ...this.tweens[t].target
                };
                for (const t in s) {
                    if (-1 !== Hf.indexOf(t)) continue;
                    let n = !!(-1 !== i.indexOf(t) || void 0 === s[t] || s[t] === s.origin[t] && s[t] === this[t] && void 0 === a[t] || null === s[t] || this.bindings[t] && e[t]);
                    if (!n) {
                        for (let e in this.tweens) {
                            const i = this.tweens[e];
                            if (-1 !== s.cancel.indexOf(i.type)) continue;
                            const r = this.tweens[e].target;
                            void 0 !== r[t] && (r[t] !== s[t] || s.includeRedundant ? (this.log(`Disregarding further instructions from action "${e}" for tween key "${t}" on account of conflict with "${s.actionKey}"`), delete r[t]) : (this.log(`Disregarding instructions from action "${e}" for tween key "${t}" on account of "${s.actionKey}" taking it to the same destination`), n = !0))
                        }
                        for (let e in this.pendingActions) {
                            const n = this.pendingActions[e];
                            n.orderedAt < o && n.omitTweenKeys.push(t)
                        }
                    }
                    n && (delete s[t], delete s.origin[t])
                }
                const l = {},
                    c = {};
                if (s.origin)
                    for (const t of this.tweenKeys) {
                        const e = void 0 === s[t],
                            n = s[t] === s.origin[t] && s[t] === this[t];
                        (e || n) && (delete s[t], delete s.origin[t]), void 0 !== s[t] && void 0 === s.origin[t] && (s.origin[t] = this[t]), l[t] = s.origin[t], c[t] = s[t]
                    }
                this.log("doing", si(s)), null === s.animate || !1 === s.includeDefaults || delete this.actionAnimate, s.animate && (this.actionAnimate = s.animate), null === s.methods || !1 === s.includeDefaults || delete this.actionMethods, s.methods && (this.actionMethods = s.methods), this.rebuildMethodsGui(), null === s.bindings || !1 === s.includeDefaults || this.clearBindings(), this.addBindings(e), this.userData = { ...this.userData,
                    ...s.userData ? ? {}
                };
                for (let t in this.userData) void 0 === this.userData[t] && delete this.userData[t];
                if (s.instant || !this.stage.isRunning) s.onStart && s.onStart.forEach((t => t.call(this, s))), this.setTweenProps(s, c), s.onComplete && s.onComplete.forEach((t => t.call(this, s)));
                else if (s.onComplete.length || Object.keys(s.origin).length) {
                    const t = this.tween(s.actionKey || "change", l, s.cancel).to(c, s.duration).easing(s.timingFunction).onUpdate((e => {
                        this.stage.isRunning ? this.setTweenProps(e, c) : (this.setTweenProps(c, c), t.complete = !0, this.cancelTweenById(t.id), s.onComplete && s.onComplete.forEach((t => t.call(this, s))))
                    }));
                    t.onStart((() => s.onStart && s.onStart.forEach((t => t.call(this, s))))), t.onComplete((() => {
                        t.cancelled || (t.complete = !0, this.cancelTweenById(t.id), s.onComplete && s.onComplete.forEach((t => t.call(this, s))))
                    })), t.onCancel((() => {
                        this.log("cancelled", s.actionKey), s.onCancel && s.onCancel.forEach((t => t.call(this, s)))
                    })), t.start(zt.elapsedMs)
                } else s.onStart && s.onStart.forEach((t => t.call(this, s)))
            },
            l = s.delay + (s.outroDelay ? ? 0);
        if (s.instant) return a(), 0;
        if (0 === l) this.log("skipping queue", s), a();
        else {
            this.log("queueing", s);
            const t = new $E(s.actionKey, a, l);
            this.pendingActions[t.id] = t
        }
        return s.delay + s.outroDelay + (null !== s.salientDuration ? s.salientDuration : s.duration)
    }
    reset() {
        this.change({ ...this.defaultAction,
            instant: !0
        })
    }
    get methodKeys() {
        return Object.keys({ ...this.methods,
            ...this.defaultActionMethods,
            ...this.actionMethods
        })
    }
    async run(t, ...e) {
        var n, i, s;
        const r = null == (n = this.methods) ? void 0 : n[t],
            o = null == (i = this.defaultActionMethods) ? void 0 : i[t],
            a = null == (s = this.actionMethods) ? void 0 : s[t];
        a && !await a.call(this, ...e) || o && !await o.call(this, ...e) || r && await r.call(this, ...e)
    }
    initGui(t, e = !1) {
        this.gui = e ? t : t.addFolder({
            title: this.guiLabel,
            expanded: !1
        }), ti(this.gui, ei(this.guiIcon, this.guiIconColor)), this.gui.element.setAttribute("style", `--tp-agent-background-color: ${this.guiIconColor}`), this.gui.element.classList.remove("cp-section"), this.gui.element.classList.add("cp-agent"), this.statesGui = this.addGuiFolder("States"), this.statesGui.addButton({
            title: "default"
        }).on("click", (() => {
            this.change({ ...this.defaultAction,
                visible: !0
            })
        }));
        const n = Object.keys(this.states);
        for (let t of n) this.statesGui.addButton({
            title: t
        }).on("click", (() => {
            const e = this.states[t];
            e && this.change(e)
        }));
        const i = this.statesGui.addFolder({
            title: "Copy",
            expanded: !1
        });
        i.addButton({
            title: "State"
        }).on("click", ((...t) => {
            const e = fn(this.agentState);
            console.log("State:", e), navigator.clipboard.writeText(JSON.stringify(e, null, 2))
        })).element.title = "Copy the current state of all action properties", i.addButton({
            title: "Salient State"
        }).on("click", ((...t) => {
            const e = fn(this.salientState);
            console.log("State:", e), navigator.clipboard.writeText(JSON.stringify(e, null, 2))
        })).element.title = "Copy the current state of all action properties excluding properties set to their default value", i.addButton({
            title: "Action State"
        }).on("click", ((...t) => {
            const e = fn(this.actionState);
            delete e.visible, console.log("State:", e), navigator.clipboard.writeText(JSON.stringify(e, null, 2))
        })).element.title = "Copy the current state of all action properties excluding properties set to their default value and retaining null values set by the most recent action or bindings", this.methodsGui = this.addGuiFolder("Reactions"), this.methodsGui.hidden = !0;
        const s = this,
            r = {
                get paramJson() {
                    return s.methodsGuiParamJson
                },
                set paramJson(t) {
                    s.methodsGuiParamJson = t
                }
            };
        this.methodsGui.addBinding(r, "paramJson", {
            label: "Parameters"
        }), this.buildGui();
        const o = this.gui.element.querySelector(".tp-fldv_t");
        o && o.addEventListener("contextmenu", (t => (console.info("All:", this), console.info("Default action:", this.defaultAction), console.info("Last action:", this.lastAction), console.info("State:", this.agentState), console.info("Tween State:", this.tweenState), console.info("Salient State:", this.salientState), console.info("Salient Tween State:", this.salientTweenState), console.info("Action State:", this.actionState), console.info("Action Tween State:", this.actionTweenState), console.info("Tween prop status:", this.tweenPropStatus), console.info("Tweens:", this.tweens), t.preventDefault(), !0))), this.gui.element.classList.remove("tp-v-lst"), this.rebuildMethodsGui()
    }
    buildGui() {
        var t;
        this.addGuiControl("Animation", "animationSpeed", {
            label: "Speed",
            ..._e
        }), this.addGuiControl("Animation", "animationScale", {
            label: "Scale",
            ..._e
        }), this.addGuiControl("Animation", "animationOffset", {
            label: "Offset",
            ..._e
        }), null != (t = this.stage) && t.debug && this.addGuiControl("Debug", "debug", {
            label: "Debug Mode"
        }), this.updateGui()
    }
    addGuiFolder(t) {
        const e = t.toLocaleLowerCase();
        if (!this.guiFolders[e]) {
            const n = [...Object.keys(this.guiFolders), e];
            n.sort(((t, e) => t.toLowerCase() > e.toLowerCase() ? 1 : -1)), this.guiFolders[e] = this.gui.addFolder({
                title: t,
                expanded: !1,
                index: n.indexOf(e)
            })
        }
        return this.guiFolders[e]
    }
    getGuiFolder(t) {
        return t ? this.guiFolders[t.toLowerCase()] ? ? !1 : this.gui ? ? !1
    }
    addGuiControl(t, e, n, i) {
        try {
            n || (n = {});
            const s = this.guiConfig[e] ? ? "visible";
            if ("hidden" === s) return !1;
            void 0 === n.disabled && (n.disabled = "disabled" === s);
            const r = "quick" !== s && t ? this.addGuiFolder(t) : this.gui;
            let o = this,
                a = e;
            this[e] instanceof Le && !(this[e] instanceof Qe) && this.warn(`Property "${String(e)}" is a Three Color object. Refactor to use Plinthos Color match GUI color to SRGB scene.`), this[e] instanceof Qe && (o = this[e], a = "guiColor", n = { ...Mt,
                label: e,
                ...n
            });
            const l = r.addBinding(o, a, n);
            return i && l.on("change", i), null != n && n.title && (l.element.title = `${n.title}`), "number" == typeof this[e] && -1 === this.tweenKeys.indexOf(e) && this.log(`Agent "${this.name}" has an unimplemented tween prop "${String(e)}"! This warning is appearing because it has a GUI control.`), l
        } catch (t) {
            return console.error(t), !1
        }
    }
    addGuiValueUnifier(t, e) {
        const n = this.getGuiFolder(t);
        n && n.addBlade({
            view: "buttongrid",
            size: [2, 1],
            cells: (t, e) => ({
                title: [
                    ["Unify +", "Unify -"]
                ][e][t]
            })
        }).on("click", (t => {
            const i = e.map((t => "number" == typeof this[t] ? this[t] : void 0));
            let s;
            switch (t.index[0]) {
                case 0:
                    s = Math.max(...i);
                    break;
                case 1:
                    s = Math.min(...i)
            }
            void 0 !== s && (e.forEach((t => {
                "number" == typeof this[t] && (this[t] = s)
            })), n.refresh())
        }))
    }
    addGuiSeparator(t) {
        const e = this.getGuiFolder(t);
        e && e.addBlade({
            view: "separator"
        })
    }
    rebuildMethodsGui() {
        if (!this.methodsGui) return;
        this.methodsGui.children.forEach((t => {
            t.element.dataset.tpButton && t.dispose()
        }));
        const t = this.methodKeys;
        for (let e of t) this.methodsGui.addButton({
            title: e
        }).on("click", (() => {
            let t = null;
            try {
                const e = JSON.parse(this.methodsGuiParamJson);
                Array.isArray(e) && (t = e)
            } catch {}
            t || this.warn("Unable to parse reaction params!"), this.run(e, ...t ? ? [])
        })).element.dataset.tpButton = "1";
        this.methodsGui.hidden = !t.length
    }
    animateAgent(t, e) {
        let n = !1,
            i = !0;
        if (this.actionAnimate) {
            n = !0;
            try {
                i = this.actionAnimate(t, e)
            } catch {}
        }
        if (this.defaultActionAnimate && i) {
            n = !0;
            try {
                i = this.defaultActionAnimate(t, e)
            } catch {}
        }
        if (this.animate && i) {
            n = !0;
            try {
                this.animate(t, e)
            } catch {}
        }
        for (var s in this.bindings) n = !0, this.bindings[s].lerp(t);
        this.gui && this.gui.expanded && this.stage.guiActive && n && this.gui.refresh(), this.afterUpdate && this.afterUpdate();
        for (let t in this.transients) delete this.transients[t]
    }
    bindingListToAgentBindings(t) {
        const e = {};
        for (let n in t) {
            if (!this.tweenKeys.find((t => t === n)) || null === t[n]) continue;
            let i, s, r;
            "string" == typeof t[n] ? i = t[n] : (i = t[n].key, s = t[n].callback, r = t[n].speed);
            const o = new Xh({
                agent: this,
                tweenKey: n,
                key: i,
                callback: s,
                speed: r
            });
            e[o.tweenKey] = o
        }
        return e
    }
    addBindings(t) {
        this.bindings = { ...this.bindings,
            ...t
        }, this.stage.clearBindings(this), this.stage.addBindings(Object.values(this.bindings))
    }
    clearBindings() {
        for (let t in this.bindings) delete this.bindings[t];
        this.stage.clearBindings(this)
    }
    log(...t) {
        this.debug && console.log(`%c ${this.name} `, `color: ${this.guiIconColor}; background: #111`, ...t)
    }
    warn(...t) {
        this.debug ? console.warn(`%c ${this.name} `, `color: ${this.guiIconColor}; background: #111`, ...t) : this.hasWarned || (this.hasWarned = !0, setTimeout((() => {
            console.log(`%c ${this.name} `, `color: ${this.guiIconColor}; background: #111`, "emitted a warning.")
        }), 1))
    }
    error(...t) {
        this.debug ? console.error(`%c ${this.name} `, `color: ${this.guiIconColor}; background: #111`, ...t) : this.hasErrored || (this.hasErrored = !0, setTimeout((() => {
            console.log(`%c ${this.name} `, `color: ${this.guiIconColor}; background: #111`, "emitted an error.")
        })))
    }
};
T(og, "agents", []);
let kr = og;
class Xh {
    constructor({
        agent: t,
        tweenKey: e,
        key: n,
        callback: i,
        speed: s
    }) {
        T(this, "agent"), T(this, "tweenKey"), T(this, "bindingKey"), T(this, "callback"), T(this, "speed", .1), T(this, "_lerpTarget", 0), this.agent = t, this.tweenKey = e, this.bindingKey = n, this.callback = i ? ? (t => t), this.speed = Math.max(.01, Math.min(.99, s ? ? .5)), this.lerpTarget = t.stage.getBinding(n)
    }
    get tweenValue() {
        return this.agent[this.tweenKey]
    }
    set lerpTarget(t) {
        this._lerpTarget = this.callback(t)
    }
    get target() {
        return this.agent
    }
    lerp(t) {
        let e = this.speed * this.speed * this.speed * t * 30;
        e = e > 1 ? 1 : e, this.agent.setBoundProp(this.tweenKey, fm(this.tweenValue, this._lerpTarget, e), this._lerpTarget, e)
    }
}

function Rr(...t) {
    let e = t.shift();
    for (let n of t) n && (e = { ...e,
        ...n,
        origin: { ...e.origin ? ? {},
            ...n.origin ? ? {}
        },
        onBefore: [...n.onBefore ? ? [], ...e.onBefore ? ? []],
        onStart: [...n.onStart ? ? [], ...e.onStart ? ? []],
        onComplete: [...n.onComplete ? ? [], ...e.onComplete ? ? []],
        onCancel: [...n.onCancel ? ? [], ...e.onCancel ? ? []],
        cancel: [...e.cancel ? ? [], ...n.cancel ? ? []],
        userData: { ...e.userData ? ? {},
            ...n.userData ? ? {}
        }
    });
    return e
}
const Tt = 2 * Math.PI;
class ai extends kr {
    constructor(t) {
        const e = t.parent,
            n = t.children;
        if (delete t.children, super(t), T(this, "name", "AGENT 3D"), T(this, "guiIcon", "fa fa-cube"), T(this, "inMotifSpace", !1), T(this, "allowOverrotation", !1), T(this, "obj3d"), T(this, "offsetContainer"), T(this, "_children", []), T(this, "_parent"), T(this, "_transformControlsMode", "translate"), T(this, "transformControls"), this.applyOptions(t), this.obj3d = new ct, this.offsetContainer = new Fn, this.offsetContainer.userData.agent = this, this.obj3d.add(this.offsetContainer), e && e instanceof ai && e.add(this), n)
            for (let t of n) t instanceof ai && this.add(t)
    }
    lookAt(t, e = !1) {
        (e ? this.offsetContainer : this.obj3d).lookAt(t)
    }
    defineDefaultAction() {
        return { ...super.defineDefaultAction(),
            xPosition: 0,
            yPosition: 0,
            zPosition: 0,
            xRotation: 0,
            yRotation: 0,
            zRotation: 0,
            xScale: 1,
            yScale: 1,
            zScale: 1,
            xPositionOffset: 0,
            yPositionOffset: 0,
            zPositionOffset: 0,
            xRotationOffset: 0,
            yRotationOffset: 0,
            zRotationOffset: 0,
            xScaleOffset: 1,
            yScaleOffset: 1,
            zScaleOffset: 1,
            visible: !1
        }
    }
    defineTweenKeys() {
        return [...super.defineTweenKeys(), "xPosition", "yPosition", "zPosition", "xRotation", "yRotation", "zRotation", "xScale", "yScale", "zScale", "xPositionOffset", "yPositionOffset", "zPositionOffset", "xRotationOffset", "yRotationOffset", "zRotationOffset", "xScaleOffset", "yScaleOffset", "zScaleOffset"]
    }
    get position() {
        return this.obj3d.position
    }
    set position(t) {
        this.obj3d.position.copy(t)
    }
    get xPosition() {
        return this.obj3d.position.x
    }
    get yPosition() {
        return this.obj3d.position.y
    }
    get zPosition() {
        return this.obj3d.position.z
    }
    set xPosition(t) {
        this.obj3d.position.x = t
    }
    set yPosition(t) {
        this.obj3d.position.y = t
    }
    set zPosition(t) {
        this.obj3d.position.z = t
    }
    get rotation() {
        return this.obj3d.rotation
    }
    set rotation(t) {
        this.obj3d.rotation.copy(t)
    }
    get xRotation() {
        return this.obj3d.rotation.x
    }
    get yRotation() {
        return this.obj3d.rotation.y
    }
    get zRotation() {
        return this.obj3d.rotation.z
    }
    set xRotation(t) {
        this.obj3d.rotation.x = this.allowOverrotation ? t : t > Math.PI ? t % Tt - Tt : t < -Math.PI ? t % Tt + Tt : t
    }
    set yRotation(t) {
        this.obj3d.rotation.y = this.allowOverrotation ? t : t > Math.PI ? t % Tt - Tt : t < -Math.PI ? t % Tt + Tt : t
    }
    set zRotation(t) {
        this.obj3d.rotation.z = this.allowOverrotation ? t : t > Math.PI ? t % Tt - Tt : t < -Math.PI ? t % Tt + Tt : t
    }
    get scale() {
        return this.obj3d.scale
    }
    set scale(t) {
        this.obj3d.scale.copy(t)
    }
    get xScale() {
        return this.obj3d.scale.x
    }
    get yScale() {
        return this.obj3d.scale.y
    }
    get zScale() {
        return this.obj3d.scale.z
    }
    set xScale(t) {
        this.obj3d.scale.x = t
    }
    set yScale(t) {
        this.obj3d.scale.y = t
    }
    set zScale(t) {
        this.obj3d.scale.z = t
    }
    get positionOffset() {
        return this.offsetContainer.position
    }
    set positionOffset(t) {
        this.offsetContainer.position.copy(t)
    }
    get xPositionOffset() {
        return this.offsetContainer.position.x
    }
    get yPositionOffset() {
        return this.offsetContainer.position.y
    }
    get zPositionOffset() {
        return this.offsetContainer.position.z
    }
    set xPositionOffset(t) {
        this.offsetContainer.position.x = t
    }
    set yPositionOffset(t) {
        this.offsetContainer.position.y = t
    }
    set zPositionOffset(t) {
        this.offsetContainer.position.z = t
    }
    get rotationOffset() {
        return this.offsetContainer.rotation
    }
    set rotationOffset(t) {
        this.offsetContainer.rotation.copy(t)
    }
    get xRotationOffset() {
        return this.offsetContainer.rotation.x
    }
    get yRotationOffset() {
        return this.offsetContainer.rotation.y
    }
    get zRotationOffset() {
        return this.offsetContainer.rotation.z
    }
    set xRotationOffset(t) {
        this.offsetContainer.rotation.x = this.allowOverrotation ? t : t > Math.PI ? t % Tt - Tt : t < -Math.PI ? t % Tt + Tt : t
    }
    set yRotationOffset(t) {
        this.offsetContainer.rotation.y = this.allowOverrotation ? t : t > Math.PI ? t % Tt - Tt : t < -Math.PI ? t % Tt + Tt : t
    }
    set zRotationOffset(t) {
        this.offsetContainer.rotation.z = this.allowOverrotation ? t : t > Math.PI ? t % Tt - Tt : t < -Math.PI ? t % Tt + Tt : t
    }
    get scaleOffset() {
        return this.offsetContainer.scale
    }
    set scaleOffset(t) {
        this.offsetContainer.scale.copy(t)
    }
    get xScaleOffset() {
        return this.offsetContainer.scale.x
    }
    get yScaleOffset() {
        return this.offsetContainer.scale.y
    }
    get zScaleOffset() {
        return this.offsetContainer.scale.z
    }
    set xScaleOffset(t) {
        this.offsetContainer.scale.x = t
    }
    set yScaleOffset(t) {
        this.offsetContainer.scale.y = t
    }
    set zScaleOffset(t) {
        this.offsetContainer.scale.z = t
    }
    get visible() {
        return this.obj3d.visible && (!this.parent || this.parent.visible)
    }
    set visible(t) {
        this.obj3d.visible = t, this.guiFaded = !t, this.updateGui()
    }
    add(t) {
        if (t instanceof ai) {
            if (t === this) return void console.warn(`Attepting to add ${this.name} to itself.`);
            this.offsetContainer.add(t.obj3d), t.refreshParent(), -1 === this._children.indexOf(t) && this._children.push(t), this.stage && (t.stage = this.stage)
        } else t instanceof ct ? this.offsetContainer.add(t) : console.warn(`An attempt was made to add the following to ${this.name} as a child:`, t)
    }
    remove(t) {
        this.offsetContainer.remove(t)
    }
    get parent() {
        return void 0 === this._parent && this.refreshParent(), this._parent
    }
    refreshParent() {
        let t = null;
        this.obj3d.traverseAncestors((e => {
            if (t) return;
            const n = e.userData.agent;
            n && n !== this && (t = n)
        })), this._parent = t
    }
    get children() {
        return [...this._children]
    }
    traverse(t) {
        ! function e(n) {
            if (!n.userData.traverseIgnore)
                for (let i of n.children) t(i), e(i)
        }(this.obj3d)
    }
    buildGui() {
        const t = t => {
                this.transformControlsActive ? this.transformControlsMode === t ? this.transformControlsActive = !1 : this.transformControlsMode = t : (this.transformControlsMode = t, this.transformControlsActive = !0)
            },
            e = (...t) => {
                for (let e of t)
                    if (["hidden", "disabled"].includes(this.guiConfig[e])) return !1;
                return !0
            },
            n = (...t) => {
                for (let e of t)
                    if (!["hidden", "disabled"].includes(this.guiConfig[e])) return !0;
                return !1
            };
        e("xPosition", "yPosition", "zPosition") ? this.addGuiControl("Position", "position", {
            label: "Base"
        }) : (this.addGuiControl("Position", "xPosition", {
            label: "X Base"
        }), this.addGuiControl("Position", "yPosition", {
            label: "Y Base"
        }), this.addGuiControl("Position", "zPosition", {
            label: "Z Base"
        })), this.addGuiSeparator("Position"), e("xPositionOffset", "yPositionOffset", "zPositionOffset") ? this.addGuiControl("Position", "positionOffset", {
            label: "Offset"
        }) : (this.addGuiControl("Position", "xPositionOffset", {
            label: "X offset"
        }), this.addGuiControl("Position", "yPositionOffset", {
            label: "Y offset"
        }), this.addGuiControl("Position", "zPositionOffset", {
            label: "Z offset"
        })), e("xRotation", "yRotation", "zRotation") ? this.addGuiControl("Orientation", "rotation", {
            label: "Base"
        }) : (this.addGuiControl("Orientation", "xRotation", {
            label: "X Base"
        }), this.addGuiControl("Orientation", "yRotation", {
            label: "Y Base"
        }), this.addGuiControl("Orientation", "zRotation", {
            label: "Z Base"
        })), this.addGuiSeparator("Orientation"), e("xRotationOffset", "yRotationOffset", "zRotationOffset") ? this.addGuiControl("Orientation", "rotationOffset", {
            label: "Offset"
        }) : (this.addGuiControl("Orientation", "xRotationOffset", {
            label: "X offset"
        }), this.addGuiControl("Orientation", "yRotationOffset", {
            label: "Y offset"
        }), this.addGuiControl("Orientation", "zRotationOffset", {
            label: "Z offset"
        })), e("xScale", "yScale", "zScale") ? this.addGuiControl("Scale", "scale", {
            label: "Base"
        }) : (this.addGuiControl("Scale", "xScale", {
            label: "X Base"
        }), this.addGuiControl("Scale", "yScale", {
            label: "Y Base"
        }), this.addGuiControl("Scale", "zScale", {
            label: "Z Base"
        })), this.addGuiValueUnifier("Scale", ["xScale", "yScale", "zScale"]), this.addGuiSeparator("Scale"), e("xScaleOffset", "yScaleOffset", "zScaleOffset") ? this.addGuiControl("Scale", "scaleOffset", {
            label: "Offset"
        }) : (this.addGuiControl("Scale", "xScaleOffset", {
            label: "X offset"
        }), this.addGuiControl("Scale", "yScaleOffset", {
            label: "Y offset"
        }), this.addGuiControl("Scale", "zScaleOffset", {
            label: "Z offset"
        })), this.addGuiValueUnifier("Scale", ["xScaleOffset", "yScaleOffset", "zScaleOffset"]);
        const i = [],
            s = [];
        n("xPosition", "yPosition", "zPosition") && (i.push("Translate"), s.push("translate")), n("xRotation", "yRotation", "zRotation") && (i.push("Rotate"), s.push("rotate")), n("xScale", "yScale", "zScale") && (i.push("Scale"), s.push("scale")), i.length > 1 && this.getGuiFolder().addBlade({
            view: "buttongrid",
            size: [i.length, 1],
            cells: (t, e) => ({
                title: [i][e][t]
            })
        }).on("click", (async e => t(s[e.index[0]]))), super.buildGui()
    }
    animateAgent(t, e) {
        super.animateAgent(t, e);
        for (let n of this.children) n.animateAgent(t, e)
    }
    onSetStage(t) {
        var e;
        null == (e = super.onSetStage) || e.call(this, t), this.parent || (this.inMotifSpace ? t.motifSpace.add(this.obj3d) : t.scene.add(this.obj3d))
    }
    get transformControlsMode() {
        return this._transformControlsMode
    }
    set transformControlsMode(t) {
        if (this._transformControlsMode = t, this.transformControls) {
            this.transformControls.setMode(t);
            const e = this.transformControls,
                n = this.guiConfig;
            switch (t) {
                case "translate":
                    e.showX = !("hidden" === n.xPosition || "disabled" === n.xPosition), e.showY = !("hidden" === n.yPosition || "disabled" === n.yPosition), e.showZ = !("hidden" === n.zPosition || "disabled" === n.zPosition);
                    break;
                case "rotate":
                    e.showX = !("hidden" === n.xRotation || "disabled" === n.xRotation), e.showY = !("hidden" === n.yRotation || "disabled" === n.yRotation), e.showZ = !("hidden" === n.zRotation || "disabled" === n.zRotation);
                    break;
                case "scale":
                    e.showX = !("hidden" === n.xScale || "disabled" === n.xScale), e.showY = !("hidden" === n.yScale || "disabled" === n.yScale), e.showZ = !("hidden" === n.zScale || "disabled" === n.zScale)
            }
        }
    }
    get transformControlsActive() {
        return !!this.transformControls
    }
    set transformControlsActive(t) {
        if (Mn)
            if (t) {
                if (this.stage.agents.forEach((t => {
                        t instanceof ai && (t.transformControlsActive = !1)
                    })), this.transformControls || !this.visible) return;
                this.transformControls = new CM(this.stage.camera, this.stage.canvas), this.transformControlsMode = this.transformControlsMode, this.transformControls.renderOrder = 1 / 0, this.transformControls.traverse((t => {
                    if (t.renderOrder = 1 / 0, t instanceof be) {
                        const e = t.material.color;
                        switch (t.material.transparent = !0, t.material.depthTest = !1, t.material.depthFunc = 1, t.renderOrder = 1 / 0, e.getHex()) {
                            case 16711680:
                                e.setRGB(1, 0, .1);
                                break;
                            case 65280:
                                e.setRGB(.1, .9, 0);
                                break;
                            case 255:
                                e.setRGB(0, .3, 1);
                                break;
                            case 16776960:
                                e.setRGB(1, .67, .2)
                        }
                    }
                })), this.transformControls.attach(this.obj3d), this.transformControls.addEventListener("dragging-changed", (t => {
                    this.stage.cameraController.orbitControlsEnabled = !t.value
                })), this.transformControls.addEventListener("change", (t => {
                    switch (this.transformControlsMode) {
                        case "translate":
                            this.getGuiFolder("Position").refresh();
                            break;
                        case "rotate":
                            this.getGuiFolder("Orientation").refresh();
                            break;
                        case "scale":
                            this.getGuiFolder("Scale").refresh()
                    }
                })), this.stage.scene.add(this.transformControls)
            } else this.transformControls && (this.stage.scene.remove(this.transformControls), this.transformControls.dispose(), delete this.transformControls)
    }
}
class Qe extends Le {
    constructor() {
        super(...arguments), T(this, "_guiColor"), T(this, "isPlinthosColor", !0)
    }
    get guiColor() {
        return this._guiColor || (this._guiColor = yt("colorManagement") ? new e1(this) : this), this._guiColor
    }
    static replaceColors(t) {
        for (let e in t) t[e] instanceof Le && !(t[e] instanceof Qe) && (t[e] = new Qe(t[e]))
    }
}
class e1 {
    constructor(t) {
        T(this, "pColor"), T(this, "c", new Le), this.pColor = t
    }
    get r() {
        return this.c.copyLinearToSRGB(this.pColor).r
    }
    set r(t) {
        this.c.r = t, this.pColor.copySRGBToLinear(this.c)
    }
    get g() {
        return this.c.copyLinearToSRGB(this.pColor).g
    }
    set g(t) {
        this.c.g = t, this.pColor.copySRGBToLinear(this.c)
    }
    get b() {
        return this.c.copyLinearToSRGB(this.pColor).b
    }
    set b(t) {
        this.c.b = t, this.pColor.copySRGBToLinear(this.c)
    }
}
class dl extends kr {
    constructor(t) {
        super(t), T(this, "name", "BACKGROUND"), T(this, "guiIcon", "fa fa-image"), T(this, "guiIconColor", "#6c6"), T(this, "col", new Qe)
    }
    get rColor() {
        return this.col.r
    }
    get gColor() {
        return this.col.g
    }
    get bColor() {
        return this.col.b
    }
    set rColor(t) {
        this.col.r = t
    }
    set gColor(t) {
        this.col.g = t
    }
    set bColor(t) {
        this.col.b = t
    }
    get color() {
        return this.col
    }
    set color(t) {
        this.col.r = t.r, this.col.g = t.g, this.col.b = t.b
    }
    defineTweenKeys() {
        return [...super.defineTweenKeys(), "rColor", "gColor", "bColor"]
    }
    defineDefaultAction() {
        return { ...super.defineDefaultAction(),
            rColor: 0,
            gColor: 0,
            bColor: 0,
            enabled: !0
        }
    }
    onStartChange(t) {
        var e;
        return !0 === t.enabled ? null == (e = this.onSetStage) || e.call(this, this.stage) : !1 === t.enabled && (this.stage.scene.background = null), !0
    }
    buildGui() {
        const t = {
            enabled: this.defaultAction.enabled
        };
        this.addGuiControl(null, "color", { ...Mt
        });
        const e = this.getGuiFolder();
        e && e.addBinding(t, "enabled").on("change", (e => {
            var n;
            t.enabled ? null == (n = this.onSetStage) || n.call(this, this.stage) : this.stage.scene.background = null
        })), super.buildGui()
    }
}
class fl extends kr {
    constructor() {
        super(...arguments), T(this, "name", "Post"), T(this, "guiIcon", "fa fa-wand-magic-sparkles"), T(this, "guiIconColor", "#c6f")
    }
}
class sn extends fl {
    constructor() {
        super(...arguments), T(this, "name", "Effect"), T(this, "effect"), T(this, "isAntialiasing", !1), T(this, "cachedBlendFunction", 0)
    }
    get opacity() {
        return this.effect.blendMode.opacity.value
    }
    set opacity(t) {
        !t && this.effect.blendMode.opacity.value ? (this.cachedBlendFunction = this.blendFunction, this.blendFunction = Ae.DST) : t && !this.effect.blendMode.opacity.value && (this.blendFunction = this.cachedBlendFunction), this.effect.blendMode.opacity.value = t
    }
    get blendFunction() {
        var t, e;
        return (null == (e = null == (t = this.effect) ? void 0 : t.blendMode) ? void 0 : e.blendFunction) ? ? this.cachedBlendFunction
    }
    set blendFunction(t) {
        this.effect ? this.effect.blendMode.blendFunction = t : this.cachedBlendFunction = t
    }
    get isUvTransform() {
        return -1 !== this.effect.getFragmentShader().search("uv=")
    }
    get isConvolution() {
        return -1 !== this.effect.getFragmentShader().search("inputBuffer")
    }
    defineDefaultAction() {
        return { ...super.defineDefaultAction(),
            opacity: 1
        }
    }
    defineTweenKeys() {
        return [...super.defineTweenKeys(), "opacity"]
    }
    buildGui() {
        super.buildGui(), this.addGuiControl("Blending", "opacity", {
            min: 0,
            max: 1
        }), this.addGuiControl("Blending", "blendFunction", {
            label: "Blend function",
            options: {
                Add: Ae.ADD,
                Alpha: Ae.ALPHA,
                Average: Ae.AVERAGE,
                Color: Ae.COLOR,
                "Color Burn": Ae.COLOR_BURN,
                "Color Dodge": Ae.COLOR_DODGE,
                Darken: Ae.DARKEN,
                Difference: Ae.DIFFERENCE,
                Divide: Ae.DIVIDE,
                DST: Ae.DST,
                Exclusion: Ae.EXCLUSION,
                "Hard Light": Ae.HARD_LIGHT,
                "Hard Mix": Ae.HARD_MIX,
                Hue: Ae.HUE,
                Invert: Ae.INVERT,
                "Invert RGB": Ae.INVERT_RGB,
                Lighten: Ae.LIGHTEN,
                "Linear Burn": Ae.LINEAR_BURN,
                "Linear Dodge": Ae.LINEAR_DODGE,
                "Linear Light": Ae.LINEAR_LIGHT,
                Luminosity: Ae.LUMINOSITY,
                Multiply: Ae.MULTIPLY,
                Negation: Ae.NEGATION,
                Normal: Ae.NORMAL,
                Overlay: Ae.OVERLAY,
                "Pin Light": Ae.PIN_LIGHT,
                Reflect: Ae.REFLECT,
                Screen: Ae.SCREEN,
                SRC: Ae.SRC,
                Saturation: Ae.SATURATION,
                "Soft Light": Ae.SOFT_LIGHT,
                Subtract: Ae.SUBTRACT,
                "Vivid Light": Ae.VIVID_LIGHT
            }
        })
    }
}
class pl extends fl {
    constructor() {
        super(...arguments), T(this, "name", "Pass"), T(this, "pass")
    }
    get enabled() {
        return this.pass.enabled
    }
    set enabled(t) {
        this.pass.enabled = t
    }
    defineDefaultAction() {
        return { ...super.defineDefaultAction(),
            opacity: 1
        }
    }
    defineTweenKeys() {
        return [...super.defineTweenKeys()]
    }
    buildGui() {
        super.buildGui(), this.addGuiControl(null, "enabled")
    }
}
class ts extends ai {
    constructor(t) {
        super(t), T(this, "name", "LIGHT"), T(this, "guiIcon", "fa fa-lightbulb"), T(this, "cachedIntensity", 3), T(this, "_color", new Qe), this.applyOptions(t), this.cachedIntensity = this.defaultAction.intensity
    }
    get intensity() {
        return this.obj3d.intensity
    }
    set intensity(t) {
        this.obj3d.intensity = t, t && (this.cachedIntensity = t), this.guiFaded = !t
    }
    get rColor() {
        return this.obj3d.color.r
    }
    get gColor() {
        return this.obj3d.color.g
    }
    get bColor() {
        return this.obj3d.color.b
    }
    set rColor(t) {
        this.obj3d.color.r = t
    }
    set gColor(t) {
        this.obj3d.color.g = t
    }
    set bColor(t) {
        this.obj3d.color.b = t
    }
    get color() {
        return this._color
    }
    set color(t) {
        this._color.copy(t)
    }
    get visible() {
        return this.obj3d.intensity > 0
    }
    set visible(t) {
        this.obj3d.intensity = t ? this.cachedIntensity || 1 : 0
    }
    defineDefaultAction() {
        return { ...super.defineDefaultAction(),
            intensity: 3,
            rColor: 1,
            gColor: 1,
            bColor: 1
        }
    }
    defineTweenKeys() {
        return [...super.defineTweenKeys(), "intensity", "rColor", "gColor", "bColor"]
    }
    buildGui() {
        this.addGuiControl("Appearance", "color", { ...Mt
        }, (() => {
            var t, e;
            "helper" in this && (null == (e = (t = this.helper).update) || e.call(t))
        })), this.addGuiControl("Appearance", "intensity", { ..._e,
            ...lt,
            min: 0
        }), super.buildGui(), this.addGuiControl(null, "visible", {
            label: "On"
        })
    }
}
class xt extends ai {
    constructor(t) {
        const e = t.defaultAction ? ? {},
            n = e.change;
        delete e.change;
        const i = e.show;
        delete e.show;
        const s = e.hide;
        delete e.hide;
        const r = e.move;
        delete e.move, super(t), T(this, "guiIconColor", "#f77"), T(this, "eager", !1), T(this, "inMotifSpace", !0), T(this, "isMotif", !0), T(this, "hitbox", new Fn), T(this, "hitboxMat", new At({
            wireframe: !0,
            depthTest: !1,
            transparent: !0,
            depthFunc: 1,
            fog: !1
        })), T(this, "intersection", null), T(this, "_active"), T(this, "_hasInit"), T(this, "_initPromise"), T(this, "defaultChangeAction", {}), T(this, "defaultShowAction", {}), T(this, "defaultHideAction", {}), T(this, "defaultMoveAction", {}), T(this, "hitboxPointer", !1), T(this, "enterFrom"), T(this, "exitTo"), this.defaultChangeAction = { ...this.defaultAction.change,
            ...n
        }, this.defaultShowAction = {
            actionKey: "show",
            cancel: ["move", "hide"],
            ...this.defaultAction.show,
            ...i
        }, this.defaultHideAction = {
            actionKey: "hide",
            cancel: [],
            ...this.defaultAction.hide,
            ...s
        }, this.defaultMoveAction = {
            actionKey: "move",
            cancel: ["hide"],
            ...this.defaultAction.move,
            ...r
        }, this.applyOptions(t), this.visible = !1, this._active = !1, this._hasInit = !1, this.enterFrom = this.defaultAction.enterFrom, this.exitTo = this.defaultAction.exitTo, this.renderOrder = this.defaultAction.renderOrder, this.hitboxMat.color = new Qe(this.hitboxMat.color), this.hitbox.layers.disableAll(), this.hitbox.userData.isHitGemometry = !0, this.hitbox.userData.traverseIgnore = !0, this.add(this.hitbox), this.hitbox.addEventListener("click", (t => this.onClick(t))), this.hitbox.addEventListener("mouseOver", (t => this.onMouseOver(t))), this.hitbox.addEventListener("mouseMove", (t => this.onMouseMove(t))), this.hitbox.addEventListener("mouseOut", (t => this.onMouseOut(t)))
    }
    get guiLabel() {
        let t = this.name;
        return this.parent && (t = `${t} ∈ ${this.parent.guiLabel}`), t
    }
    set hitGeometry(t) {
        if (this.hitbox)
            for (let e of t) this.addHitbox(e)
    }
    get active() {
        return this._active
    }
    set active(t) {}
    get hasInit() {
        return this._hasInit
    }
    get showByDefault() {
        return this.defaultAction.visible
    }
    get renderOrder() {
        return Math.max(Math.min(this.offsetContainer.renderOrder, Number.MAX_SAFE_INTEGER), Number.MIN_SAFE_INTEGER)
    }
    set renderOrder(t) {
        t = Math.max(Math.min(t, Number.MAX_SAFE_INTEGER), Number.MIN_SAFE_INTEGER), this.offsetContainer.renderOrder = t
    }
    get hitboxActive() {
        return this.hitbox.layers.isEnabled(mr)
    }
    set hitboxActive(t) {
        this._active && t ? this.hitbox.layers.enable(mr) : this.hitbox.layers.disable(mr)
    }
    get hitboxVisible() {
        return this.hitbox.layers.isEnabled(lo)
    }
    set hitboxVisible(t) {
        t ? this.hitbox.layers.enable(lo) : this.hitbox.layers.disable(lo)
    }
    get hitboxColor() {
        return this.hitboxMat.color
    }
    set hitboxColor(t) {
        this.hitboxMat.color.copy(t)
    }
    get materials() {
        const t = [];
        return this.obj3d.traverse((e => {
            e instanceof be && e.material && (e.material instanceof Array ? t.push(...e.material) : t.push(e.material))
        })), t
    }
    addHitbox(t) {
        const e = new be(t, this.hitboxMat);
        return e.layers = this.hitbox.layers, this.hitbox.add(e), e
    }
    addFittedHitbox(t) {
        t || (t = new Sn);
        const e = new Tn;
        this.runInWorldSpace((() => {
            e.setFromObject(this.obj3d)
        }));
        const n = e.min.sub(this.position).divide(this.scale),
            i = e.max.sub(this.position).divide(this.scale),
            s = (new U).subVectors(i, n);
        t.scale(s.x, s.y, s.z);
        const r = (new U).addVectors(i, n).divideScalar(2);
        return t.translate(r.x, r.y, r.z), this.addHitbox(t), t
    }
    runInWorldSpace(t) {
        const e = this.obj3d.parent;
        this.stage.scene.add(this.obj3d), t(), this.stage.scene.remove(this.obj3d), e && e.add(this.obj3d)
    }
    defineTweenKeys() {
        return [...super.defineTweenKeys(), "renderOrder"]
    }
    defineDefaultAction() {
        return { ...super.defineDefaultAction(),
            visible: !1,
            renderOrder: 0,
            enterFrom: {
                xScale: 0,
                yScale: 0,
                zScale: 0
            },
            exitTo: {
                xScale: 0,
                yScale: 0,
                zScale: 0
            },
            hitboxActive: !1,
            hitboxPointer: !1
        }
    }
    onSetStage(t) {
        var e;
        for (var n of (null == (e = super.onSetStage) || e.call(this, t), this.children)) n.stage = t;
        (this.parent && !(this.parent instanceof xt) || this.parent instanceof xt && this.parent.hasInit) && this.init()
    }
    afterInit() {}
    async init(t = !1) {
        return this._hasInit ? this : (this._initPromise || (this._initPromise = new Promise((async (e, n) => {
            for (var i in this.children) {
                const e = this.children[i];
                e instanceof xt && await Ri((async () => {
                    this.log("initChild", i), await e.init(t)
                }), void 0, t)
            }
            e(await Ri((async () => {
                try {
                    const e = await this.initMotif();
                    this.afterInitMotif && await Ri((async () => await this.afterInitMotif()), void 0, t);
                    try {
                        this.afterInit && await this.afterInit()
                    } catch (t) {
                        this.error(t)
                    }
                    return this.stage.compile(this.obj3d), e
                } catch (t) {
                    this.error(t)
                }
            }), void 0, t))
        })), this._initPromise.then((() => {
            this._hasInit = !0, this.setTweenProps({ ...this.defaultAction
            }), this.stage && this.stage.motifsGui && (this.initGui(this.stage.motifsGui), this.guiFaded = !0), this.parent && this.parent.visible && this.showByDefault && this.show({}), this.hitbox.children.length || this.addFittedHitbox()
        }))), this._initPromise)
    }
    change(t) {
        return this.hitboxPointer = t.hitboxPointer ? ? this.defaultAction.hitboxPointer, !1 === t.visible ? this.hide(t) : this.active ? t.actionKey ? super.change(t) : this.move(t) : this.show(t)
    }
    show(t) {
        if (!this.hasInit) return console.warn(`Attempting to show uninitialised motif "${this.name}"!`), 0;
        if (this.active) return this.move(t);
        const e = Rr(Ja(this.enterFrom, this.defaultAction), this.defaultChangeAction, this.defaultShowAction, t, t.show, {
            origin: { ...this.defaultAction,
                ...t,
                ...this.enterFrom,
                ...t.enterFrom || {}
            }
        });
        return e.onBefore.unshift((t => !this.parent || this.parent.visible && this.parent.active ? (this.visible && (t.origin = { ...this.tweenState
        }), !0) : (this.log("Blocking show due to invisible parent"), !1))), e.onStart.unshift((t => {
            for (var n in this._active = !0, this.visible = !0, this.hitboxActive = t.hitboxActive ? ? this.defaultAction.hitboxActive, this.log(e), this.onShow && this.onShow(e), this.children) {
                const t = this.children[n];
                t instanceof xt && t.showByDefault && !t.hasTweenType("show") && t.show({})
            }
            this.attribution.length && this.stage.updateAttribution()
        })), super.change(e)
    }
    hide(t) {
        if (!this.hasInit || !this.active && (!t.instant || !this.visible) || !this.active && this.visible && !this.hasTweenType("hide")) return this.cancelTweensByType("show"), 0;
        const e = Rr({
            includeDefaults: !1
        }, this.defaultChangeAction, this.defaultHideAction, this.exitTo, t, t.hide);
        return this.log(e), this.cancelPendingActionsByFilter((t => !0)), e.onStart.unshift((t => {
            for (var e of (this.log("Starting hide"), this._active = !1, this.hitboxActive = !1, this.transformControlsActive = !1, this.onHide && this.onHide(t), this.children)) e instanceof xt && e.hide({
                delay: 0,
                duration: Math.min(t.duration ? ? this.defaultAction.duration, e.defaultAction.duration ? ? 1 / 0)
            });
            this.attribution.length && this.stage.updateAttribution()
        })), e.onComplete.unshift((() => {
            for (var t of (this.visible = !1, this.transformControlsActive = !1, this.intersection = null, this.setTweenProps(this.defaultAction), this.children)) t instanceof xt && t.hide({
                instant: !0
            })
        })), e.onCancel.unshift((() => {
            this.log("Cancelling hide"), this._active = !0
        })), super.change(e)
    }
    move(t) {
        const e = {
            onBefore: [],
            onStart: [],
            ...this.defaultChangeAction,
            ...this.defaultMoveAction,
            ...t,
            ...t.move,
            actionKey: "move"
        };
        return e.onBefore.unshift((t => (this._active || this.log("Cancelling delayed Move because Hide has started."), this._active))), e.onStart.unshift((t => {
            this.active && (this.visible = !0), this.onMove && this.onMove(t), this.hitboxActive = t.hitboxActive ? ? this.defaultAction.hitboxActive
        })), super.change(e)
    }
    buildGui() {
        super.buildGui(), this.addGuiControl("Utilities", "transformControlsActive", {
            label: "Mouse Controls",
            title: "Click and drag to adjust"
        }), this.addGuiControl("Utilities", "hitboxActive", {
            label: "Use Hitbox",
            title: "Turn the hitbox on and off"
        }), this.addGuiControl("Utilities", "hitboxVisible", {
            label: "Show Hitbox",
            title: "Show / hide the area that registeres mouse clicks"
        }), this.addGuiControl("Utilities", "hitboxColor", {
            label: "Hitbox Color",
            title: "Set the color of the hitbox",
            ...Mt
        }, (() => this.hitboxVisible = !0)), this.addGuiControl("Utilities", "renderOrder", {
            label: "Render Order"
        }), this.getGuiFolder().addBlade({
            view: "buttongrid",
            size: [this.stage.debug ? 3 : 2, 1],
            cells: (t, e) => ({
                title: [
                    ["Show", "Hide", "Clone"]
                ][e][t]
            })
        }).on("click", (async t => {
            switch (t.index[0]) {
                case 0:
                    this.show({
                        delay: 0
                    });
                    break;
                case 1:
                    this.hide({
                        delay: 0
                    });
                    break;
                case 2:
                    const t = this.clone({
                        name: this.name + " clone",
                        defaultAction: { ...this.agentState,
                            visible: !1
                        }
                    });
                    this.stage.addMotif(`clone${pi()}`, t), await t.init(), t.show({
                        delay: 0,
                        instant: !0,
                        onStart: [() => {
                            t.transformControlsActive = !0, t.transformControlsMode = "translate"
                        }]
                    }), t.guiExpanded = !0
            }
        }))
    }
    async run(t, ...e) {
        this.active && await super.run(t, ...e)
    }
    onClick(t) {
        switch (this.guiExpanded = !0, t.mouseEvent.button) {
            case 0:
                this.run("click");
                break;
            case 2:
                this.run("rightClick")
        }
    }
    onMouseOver(t) {
        this.stage.hover = this.hitboxPointer, this.intersection = t.intersection, this.run("mouseOver")
    }
    onMouseMove(t) {
        this.intersection = t.intersection, this.run("mouseMove")
    }
    onMouseOut(t) {
        this.stage.hover = !1, this.intersection = null, this.run("mouseOut")
    }
}
class ml extends ai {
    constructor(t = {}) {
        switch (super(t), T(this, "name", "Camera"), T(this, "guiIcon", "fa fa-camera-movie"), T(this, "guiIconColor", "#ddd"), T(this, "cameraType", "perspective"), T(this, "obj3d", new Fn), T(this, "group"), T(this, "camera"), T(this, "target", new U), T(this, "helper", new M_(5, 16, 8, 64, 0, 16777215)), T(this, "scene"), T(this, "controlMode", 0), T(this, "controllerMode", !1), T(this, "orbitControls", null), T(this, "xTiltAmount"), T(this, "yTiltAmount"), T(this, "tiltTarget", new U), T(this, "xTiltFactor"), T(this, "yTiltFactor"), T(this, "tiltFactor"), T(this, "tiltGimme", .001), T(this, "_zoom", 1), T(this, "_xFocalPoint", 0), T(this, "_yFocalPoint", 0), T(this, "projectionMatrixUpdatePending", !1), T(this, "projectionMatrixUpdateDenied", !1), T(this, "initOrbitControlsActionId"), t.cameraType && (this.cameraType = t.cameraType), this.cameraType) {
            case "perspective":
            default:
                this.camera = new Pt;
                break;
            case "orthographic":
                this.camera = new Ci
        }
        this.obj3d.add(this.camera), this.group = this.obj3d, this.helper.visible = !1, this.helper.material.fog = !1, this.helper.geometry.rotateX(Math.PI / 2), this.setTweenProps(this.defaultTweenState)
    }
    get distanceToTarget() {
        return this.obj3d.position.distanceTo(this.target)
    }
    get orbitControlsEnabled() {
        var t;
        return !(null == (t = this.orbitControls) || !t.enabled)
    }
    set orbitControlsEnabled(t) {
        this.orbitControls && (this.orbitControls.enabled = t)
    }
    get xTilt() {
        return this.camera.position.x
    }
    get yTilt() {
        return this.camera.position.y
    }
    set xTilt(t) {
        this.camera.position.x = t
    }
    set yTilt(t) {
        this.camera.position.y = t
    }
    get xTarget() {
        return this.target.x
    }
    get yTarget() {
        return this.target.y
    }
    get zTarget() {
        return this.target.z
    }
    set xTarget(t) {
        this.target.x = t, this.helper.position.x = t, this.orbitControls && (this.orbitControls.target.x = t)
    }
    set yTarget(t) {
        this.target.y = t, this.helper.position.y = t, this.orbitControls && (this.orbitControls.target.y = t)
    }
    set zTarget(t) {
        this.target.z = t, this.helper.position.z = t, this.orbitControls && (this.orbitControls.target.z = t)
    }
    get targetVisible() {
        return this.helper.visible
    }
    set targetVisible(t) {
        this.helper.visible = t
    }
    get near() {
        return this.camera.near
    }
    set near(t) {
        this.camera.near !== t && (this.camera.near = t, this.updateProjectionMatrix())
    }
    get far() {
        return this.camera.far
    }
    set far(t) {
        this.camera.far !== t && (this.camera.far = t, this.updateProjectionMatrix())
    }
    get fov() {
        return this.camera instanceof Pt ? this.camera.fov : 2 * this.camera.top
    }
    set fov(t) {
        var e, n;
        if (this.camera instanceof Pt) {
            if (this.fov === t) return;
            this.camera.fov = t
        } else if (null != (e = this.stage) && e.width && null != (n = this.stage) && n.height) {
            const e = this.stage.width / this.stage.height;
            this.camera.top = t / 2, this.camera.bottom = -t / 2, this.camera.left = -t * e / 2, this.camera.right = t * e / 2
        }
        this.updateProjectionMatrix()
    }
    get zoom() {
        return this.camera.zoom
    }
    set zoom(t) {
        this.camera.zoom !== t && (this.camera.zoom = t, this._zoom = t, this.updateProjectionMatrix())
    }
    get xFocalPoint() {
        return this._xFocalPoint
    }
    set xFocalPoint(t) {
        t !== this._xFocalPoint && (this._xFocalPoint = t, this.onResize())
    }
    get yFocalPoint() {
        return this._yFocalPoint
    }
    set yFocalPoint(t) {
        t !== this._yFocalPoint && (this._yFocalPoint = t, this.onResize())
    }
    defineDefaultAction() {
        return { ...super.defineDefaultAction(),
            xPosition: 0,
            yPosition: 0,
            zPosition: 5,
            xRotation: 0,
            yRotation: 0,
            zRotation: 0,
            xTarget: 0,
            yTarget: 0,
            zTarget: 0,
            zoom: 1,
            near: .1,
            far: 2e4,
            fov: 50,
            xTiltAmount: 0,
            yTiltAmount: 0,
            xTiltFactor: 1,
            yTiltFactor: 1,
            tiltFactor: 1,
            xFocalPoint: 0,
            yFocalPoint: 0,
            timingFunction: yn.Quadratic.InOut,
            controlsElementId: !1,
            controlsEnablePan: !1,
            controlsEnableZoom: !0,
            controlsMinDistance: 0,
            controlsMaxDistance: 1 / 0,
            controlsMinAzimuth: 1 / 0,
            controlsMaxAzimuth: 1 / 0,
            controlsMinPolar: 0,
            controlsMaxPolar: Math.PI,
            controlsDamping: .1
        }
    }
    defineTweenKeys() {
        return [...super.defineTweenKeys(), "near", "far", "fov", "xTiltAmount", "yTiltAmount", "xTiltFactor", "yTiltFactor", "tiltFactor", "xFocalPoint", "yFocalPoint", "xTarget", "yTarget", "zTarget", "zoom"]
    }
    defineGuiConfig() {
        return { ...super.defineGuiConfig(),
            animationOffset: "hidden",
            animationScale: "hidden",
            animationSpeed: "hidden"
        }
    }
    buildGui() {
        this.addGuiControl(null, "controllerMode", {
            label: "Manual Control"
        }, (t => {
            if (t.value && !this.orbitControls) {
                if (!(this.stage.canvas instanceof HTMLCanvasElement)) return;
                this.change({
                    includeDefaults: !1,
                    controlsElementId: this.stage.canvas.id,
                    controlsEnablePan: !0,
                    duration: 100
                })
            } else !t.value && this.orbitControls && this.change({
                includeDefaults: !1,
                controlsElementId: !1,
                duration: 100
            })
        })), this.addGuiControl("Advanced", "fov", { ..._e,
            ...Is,
            min: -180,
            max: 180
        }), this.addGuiControl("Advanced", "near", { ..._e,
            ...Is,
            min: .1
        }), this.addGuiControl("Advanced", "far", { ..._e,
            ...Ih,
            min: .1,
            wide: !1
        }), this.addGuiControl("Advanced", "zoom", { ..._e,
            ...lt
        }), this.addGuiControl("Tilt", "xTilt", {
            label: "X",
            ..._e
        }), this.addGuiControl("Tilt", "yTilt", {
            label: "Y",
            ..._e
        }), this.addGuiSeparator("Tilt"), this.addGuiControl("Tilt", "tiltFactor", {
            label: "Tilt Factor",
            ..._e,
            ...lt
        }), this.addGuiControl("Tilt", "xTiltFactor", {
            label: "X Tilt Factor",
            ..._e,
            ...lt
        }), this.addGuiControl("Tilt", "yTiltFactor", {
            label: "Y Tilt Factor",
            ..._e,
            ...lt
        }), this.addGuiSeparator("Tilt"), this.addGuiControl("Target", "targetVisible", {
            label: "Visible"
        }), this.addGuiControl("Target", "xTarget", {
            label: "x",
            ..._e
        }), this.addGuiControl("Target", "yTarget", {
            label: "y",
            ..._e
        }), this.addGuiControl("Target", "zTarget", {
            label: "z",
            ..._e
        }), this.addGuiControl("Focal Point", "xFocalPoint", {
            label: "x",
            ..._e,
            ...lt
        }), this.addGuiControl("Focal Point", "yFocalPoint", {
            label: "y",
            ..._e,
            ...lt
        }), super.buildGui()
    }
    onResize() {
        if (!this.stage) return;
        const t = this.stage.offsetWidth,
            e = this.stage.offsetHeight;
        this.camera.setViewOffset(t, e, t * (-this._xFocalPoint / 2), e * (this._yFocalPoint / 2), t, e), this.camera instanceof Pt ? this.camera.aspect = t / e : this.camera instanceof Ci && (this.fov = this.fov), this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        this.projectionMatrixUpdatePending ? this.projectionMatrixUpdateDenied = !0 : (this.projectionMatrixUpdatePending = !0, Ri((async () => {
            this.projectionMatrixUpdatePending = !1, this.projectionMatrixUpdateDenied && (this.projectionMatrixUpdateDenied = !1, this.updateProjectionMatrix())
        }), this.id), this.camera.updateProjectionMatrix(), this.stage && this.stage.projectionMatricUpdate())
    }
    onSetStage(t) {
        this.scene = t.scene, t.scene.add(this.helper), t.scene.add(this.obj3d)
    }
    onBeforeChange(t) {
        return t.onStart || (t.onStart = []), t.onStart.unshift((() => {
            this.disposeOrbitControls()
        })), t.controlsElementId && this.initOrbitControls(t), !0
    }
    initOrbitControls(t) {
        var e;
        if (this.log("init orbit controls", t), !Mn || !t.controlsElementId) return;
        const n = document.getElementById(t.controlsElementId);
        if (n) {
            t.tiltFactor = 0;
            const i = { ...this.defaultAction,
                ...t
            };
            n !== (null == (e = this.orbitControls) ? void 0 : e.domElement) && this.disposeOrbitControls(), t.origin = this.tweenState;
            const s = pi();
            this.initOrbitControlsActionId = s, t.onComplete.unshift((() => {
                this.initOrbitControlsActionId === s && (this.tiltFactor || (this.obj3d === this.group && (this.camera.position.copy(this.group.position), this.camera.rotation.copy(this.group.rotation), this.group.remove(this.camera), this.scene.add(this.camera), this.obj3d = this.camera, this.controlMode = 1), this.orbitControls || (this.orbitControls = new OM(this.camera, n), this.controllerMode = !0), this.orbitControls.enablePan = i.controlsEnablePan, this.orbitControls.enableZoom = i.controlsEnableZoom, this.orbitControls.maxDistance = i.controlsMaxDistance, this.orbitControls.minDistance = i.controlsMinDistance, this.orbitControls.maxAzimuthAngle = i.controlsMaxAzimuth, this.orbitControls.minAzimuthAngle = i.controlsMinAzimuth, this.orbitControls.maxPolarAngle = i.controlsMaxPolar, this.orbitControls.minPolarAngle = i.controlsMinPolar, this.orbitControls.enableDamping = !!i.controlsDamping, this.orbitControls.dampingFactor = i.controlsDamping, this.orbitControls.target = this.target, this.orbitControls.update(), this.orbitControls.addEventListener("change", (t => {
                    this.camera.zoom !== this._zoom && (this._zoom = this.camera.zoom, this.updateProjectionMatrix())
                }))))
            }))
        } else this.disposeOrbitControls();
        return !0
    }
    disposeOrbitControls() {
        this.orbitControls && this.orbitControls.dispose(), this.orbitControls = null, this.controllerMode = !1, this.obj3d === this.camera && (this.group.position.copy(this.camera.position), this.group.rotation.copy(this.camera.rotation), this.camera.position.set(0, 0, 0), this.scene.remove(this.camera), this.group.add(this.camera), this.obj3d = this.group, this.controlMode = 0)
    }
    animate(t, e) {
        if (0 === this.controlMode && this.tiltFactor) {
            const t = .5 * this.obj3d.position.distanceTo(this.target);
            this.camera.position.set(this.xTiltAmount * this.tiltFactor * this.xTiltFactor * t, this.yTiltAmount * this.tiltFactor * this.yTiltFactor * t, 0)
        }
        this.orbitControls && this.orbitControls.enableDamping && this.orbitControls.update(), this.group.lookAt(this.target), this.camera.lookAt(this.target), this.helper.visible && this.helper.lookAt(this.obj3d.position)
    }
}
class jh extends kr {
    constructor(t) {
        super(t), T(this, "name", "Scene Controller"), T(this, "guiIcon", "fa fa-mountain-sun"), T(this, "guiIconColor", "#2cf"), T(this, "scene"), T(this, "xRotationSpeed", 0), T(this, "yRotationSpeed", 0), T(this, "zRotationSpeed", 0), T(this, "fogDistance", 0), T(this, "fogDepth", 10), T(this, "_fogColor", new Qe)
    }
    get fog() {
        return this.scene.fog
    }
    get fogColor() {
        return this._fogColor
    }
    set fogColor(t) {
        this._fogColor.copy(t)
    }
    get rFogColor() {
        return this.fogColor.r
    }
    get gFogColor() {
        return this.fogColor.g
    }
    get bFogColor() {
        return this.fogColor.b
    }
    set rFogColor(t) {
        this.fogColor.r = t
    }
    set gFogColor(t) {
        this.fogColor.g = t
    }
    set bFogColor(t) {
        this.fogColor.b = t
    }
    get xRotation() {
        return this.stage.motifSpace.rotation.x
    }
    get yRotation() {
        return this.stage.motifSpace.rotation.y
    }
    get zRotation() {
        return this.stage.motifSpace.rotation.z
    }
    set xRotation(t) {
        this.stage.motifSpace.rotation.x = t
    }
    set yRotation(t) {
        this.stage.motifSpace.rotation.y = t
    }
    set zRotation(t) {
        this.stage.motifSpace.rotation.z = t
    }
    defineDefaultAction() {
        return { ...super.defineDefaultAction(),
            fogDistance: 20,
            fogDepth: 100,
            rFogColor: 0,
            gFogColor: 0,
            bFogColor: 0,
            xRotation: 0,
            yRotation: 0,
            zRotation: 0,
            xRotationSpeed: 0,
            yRotationSpeed: 0,
            zRotationSpeed: 0
        }
    }
    defineTweenKeys() {
        return [...super.defineTweenKeys(), "fogDistance", "fogDepth", "rFogColor", "gFogColor", "bFogColor", "xRotation", "yRotation", "zRotation", "xRotationSpeed", "yRotationSpeed", "zRotationSpeed"]
    }
    onSetStage(t) {
        this.scene = t.scene, this.scene.fog || (this.scene.fog = new mh("#111"), this.scene.fog.color = this.fogColor), this.setTweenProps(this.defaultAction)
    }
    animate(t, e) {
        this.xRotationSpeed && (this.stage.motifSpace.rotation.x += this.xRotationSpeed * t, this.stage.motifSpace.rotation.x > Math.PI && (this.stage.motifSpace.rotation.x -= 2 * Math.PI), this.stage.motifSpace.rotation.x < -Math.PI && (this.stage.motifSpace.rotation.x += 2 * Math.PI)), this.yRotationSpeed && (this.stage.motifSpace.rotation.y += this.yRotationSpeed * t, this.stage.motifSpace.rotation.y > Math.PI && (this.stage.motifSpace.rotation.y -= 2 * Math.PI), this.stage.motifSpace.rotation.y < -Math.PI && (this.stage.motifSpace.rotation.y += 2 * Math.PI)), this.zRotationSpeed && (this.stage.motifSpace.rotation.z += this.zRotationSpeed * t, this.stage.motifSpace.rotation.z > Math.PI && (this.stage.motifSpace.rotation.z -= 2 * Math.PI), this.stage.motifSpace.rotation.z < -Math.PI && (this.stage.motifSpace.rotation.z += 2 * Math.PI)), this.fog.near = this.stage.cameraController.distanceToTarget + this.fogDistance, this.fog.far = this.fog.near + this.fogDepth
    }
    buildGui() {
        this.addGuiControl("Fog", "fogDistance", {
            label: "Distance",
            title: "The distance between the camera target and the start of the fog",
            ..._e
        }), this.addGuiControl("Fog", "fogDepth", {
            label: "Depth",
            title: "The distance between the start of the fog and full fog opacity",
            ..._e
        }), this.addGuiControl("Fog", "fogColor", {
            label: "Color",
            ...Mt
        }), this.addGuiControl("Orientation", "xRotation", { ..._e,
            label: "x Orientation"
        }), this.addGuiControl("Orientation", "yRotation", { ..._e,
            label: "y Orientation"
        }), this.addGuiControl("Orientation", "zRotation", { ..._e,
            label: "z Orientation"
        }), this.addGuiSeparator("Orientation"), this.addGuiControl("Orientation", "xRotationSpeed", { ..._e,
            label: "x Rotation"
        }), this.addGuiControl("Orientation", "yRotationSpeed", { ..._e,
            label: "y Rotation"
        }), this.addGuiControl("Orientation", "zRotationSpeed", { ..._e,
            label: "z Rotation"
        }), super.buildGui()
    }
}
class Kh extends dl {
    constructor(t = {}) {
        super(t), T(this, "name", "Color Background"), this.setTweenProps(this.defaultAction)
    }
    onSetStage(t) {
        t.scene.background = this.color
    }
}
class lg extends dl {
    constructor(t = {}) {
        super(t), T(this, "name", "ERM Background"), T(this, "path", "starmap-small.jpg"), T(this, "texture", new vh), T(this, "scene"), t.path && (this.path = t.path), this.setTweenProps(this.defaultAction), tn(this.path).then((t => {
            t.mapping = uo, this.scene && (this.scene.background = t, this.scene.environment = t)
        }))
    }
    defineDefaultAction() {
        return { ...super.defineDefaultAction()
        }
    }
    onSetStage(t) {
        this.texture && (t.scene.background = this.texture, t.scene.environment = this.texture), this.scene = t.scene
    }
    buildGui() {
        const t = this.getGuiFolder();
        t && t.addBinding(this.texture, "format", {
            label: "Format",
            options: {
                AlphaFormat: op,
                RedFormat: sh,
                RedIntegerFormat: rh,
                RGFormat: cp,
                RGIntegerFormat: oh,
                RGBAFormat: Nn,
                RGBAIntegerFormat: ah,
                LuminanceFormat: ap,
                LuminanceAlphaFormat: lp,
                DepthFormat: Ms,
                DepthStencilFormat: Ps
            }
        }).on("change", (t => {
            this.texture.needsUpdate = !0
        })), super.buildGui()
    }
}
class Yh extends sn {
    constructor(t) {
        super(t), T(this, "name", "Bloom Effect"), T(this, "guiIcon", "fa fa-sparkle"), T(this, "disabledState", {
            intensity: 0
        }), this.effect = new Rw({
            mipmapBlur: !0
        }), this.applyOptions(t)
    }
    get intensity() {
        return this.effect.intensity
    }
    get radius() {
        return this.effect.blurPass.scale
    }
    get threshold() {
        return this.effect.luminanceMaterial.threshold
    }
    get smoothing() {
        return this.effect.luminanceMaterial.smoothing
    }
    set intensity(t) {
        this.effect.intensity = t
    }
    set radius(t) {
        var e;
        this.effect.blurPass.scale = t, void 0 !== (null == (e = this.effect.mipmapBlurPass) ? void 0 : e.radius) && (this.effect.mipmapBlurPass.radius = t)
    }
    set threshold(t) {
        this.effect.luminanceMaterial.threshold = t
    }
    set smoothing(t) {
        this.effect.luminanceMaterial.smoothing = t
    }
    defineTweenKeys() {
        return [...super.defineTweenKeys(), "threshold", "intensity", "radius", "smoothing"]
    }
    defineDefaultAction() {
        return { ...super.defineDefaultAction(),
            intensity: 1,
            radius: .5,
            threshold: .5,
            smoothing: 0
        }
    }
    buildGui() {
        this.addGuiControl(null, "intensity", { ..._e,
            ...lt,
            min: 0
        }), this.addGuiControl(null, "radius", {
            min: 0,
            max: .99
        }), this.addGuiControl(null, "threshold", {
            min: 0,
            max: 1
        }), this.addGuiControl(null, "smoothing", {
            min: 0,
            max: 1
        }), super.buildGui()
    }
}
const Vf = 1e3,
    Wf = 2e4;
class cg extends sn {
    constructor(t) {
        super(t), T(this, "name", "Bokeh Effect"), T(this, "guiIcon", "fa fa-camera"), T(this, "focusOffset", 0), T(this, "blurCoeff", 0), this.blendFunction = Ae.NORMAL, this.applyOptions(t)
    }
    get aperture() {
        var t;
        return (null == (t = this.effect.cocMaterial.uniforms.focusRange) ? void 0 : t.value) * Vf
    }
    get focus() {
        var t;
        return (null == (t = this.effect.cocMaterial.uniforms.focusDistance) ? void 0 : t.value) * Wf
    }
    get blur() {
        return this.effect.bokehScale * this.blurCoeff
    }
    get kernelSize() {
        return this.effect.blurPass.kernelSize
    }
    set aperture(t) {
        this.effect.cocMaterial.uniforms.focusRange.value = t / Vf
    }
    set focus(t) {
        this.effect.cocMaterial.uniforms.focusDistance.value = t / Wf
    }
    set blur(t) {
        this.effect.bokehScale = t / (this.blurCoeff || Number.EPSILON)
    }
    set kernelSize(t) {
        this.effect.blurPass.kernelSize = t
    }
    defineTweenKeys() {
        return [...super.defineTweenKeys(), "aperture", "focusOffset", "blur"]
    }
    defineDefaultAction() {
        return { ...super.defineDefaultAction(),
            aperture: 1,
            focusOffset: 0,
            blur: 2
        }
    }
    onSetStage(t) {
        this.effect = new Hw(t.camera, {
            focusDistance: 0,
            focalLength: .048,
            bokehScale: 2,
            blendFunction: this.blendFunction
        })
    }
    onResize() {
        const t = this.blur;
        this.blurCoeff = 1e3 / this.stage.canvas.height || 1, this.blur = t
    }
    buildGui() {
        this.addGuiControl(null, "aperture", { ..._e,
            ...lt,
            min: 0
        }), this.addGuiControl(null, "focusOffset", { ..._e,
            ...lt
        }), this.addGuiControl(null, "blur", {
            label: "blur",
            ..._e,
            ...lt,
            min: 0
        }), this.addGuiControl(null, "kernelSize", {
            options: {
                "Very small": hn.VERY_SMALL,
                Small: hn.SMALL,
                Medium: hn.MEDIUM,
                Large: hn.LARGE,
                "Very large": hn.VERY_LARGE,
                Huge: hn.HUGE
            }
        }), super.buildGui()
    }
    animate(t, e) {
        this.focus = this.stage.cameraController.distanceToTarget + this.focusOffset
    }
}
class hg extends sn {
    constructor(t) {
        super(t), T(this, "name", "Vignette Effect"), T(this, "guiIcon", "fa fa-aperture"), T(this, "technique"), T(this, "disabledState", {}), this.effect = new gM({
            technique: "eskil" === this.technique ? vs.ESKIL : vs.DEFAULT
        }), this.applyOptions(t)
    }
    get offset() {
        return this.effect.offset
    }
    set offset(t) {
        this.effect.offset = t
    }
    get darkness() {
        return this.effect.darkness
    }
    set darkness(t) {
        this.effect.darkness = t
    }
    defineTweenKeys() {
        return [...super.defineTweenKeys(), "offset", "darkness"]
    }
    defineDefaultAction() {
        return { ...super.defineDefaultAction(),
            offset: 0,
            darkness: 1
        }
    }
    buildGui() {
        this.addGuiControl(null, "offset", { ..._e,
            ...lt
        }), this.addGuiControl(null, "darkness", { ..._e,
            ...lt,
            min: 0
        }), super.buildGui()
    }
}
class ug extends sn {
    constructor(t) {
        super(t), T(this, "name", "Pixelation Effect"), T(this, "guiIcon", "fa fa-grid-2"), T(this, "disabledState", {}), this.effect = new iM, this.applyOptions(t)
    }
    get size() {
        return this.effect.granularity
    }
    set size(t) {
        this.effect.granularity = t
    }
    defineTweenKeys() {
        return [...super.defineTweenKeys(), "size"]
    }
    defineDefaultAction() {
        return { ...super.defineDefaultAction(),
            size: 0
        }
    }
    buildGui() {
        this.addGuiControl(null, "size", { ..._e,
            step: 1,
            min: 1
        }), super.buildGui()
    }
}
class Qh extends sn {
    constructor(t) {
        super(t), T(this, "name", "Brightness & Contrast Effect"), T(this, "guiIcon", "fa fa-circle-half-stroke"), T(this, "disabledState", {}), this.effect = new Iw, this.applyOptions(t)
    }
    get brightness() {
        return this.effect.brightness
    }
    set brightness(t) {
        this.effect.brightness = t
    }
    get contrast() {
        return this.effect.contrast
    }
    set contrast(t) {
        this.effect.contrast = t
    }
    defineTweenKeys() {
        return [...super.defineTweenKeys(), "brightness", "contrast"]
    }
    defineDefaultAction() {
        return { ...super.defineDefaultAction(),
            brightness: 0,
            contrast: 0
        }
    }
    buildGui() {
        this.addGuiControl(null, "brightness", {
            min: -1,
            max: 1
        }), this.addGuiControl(null, "contrast", {
            min: -1,
            max: 1
        }), super.buildGui()
    }
}
class dg extends sn {
    constructor(t) {
        super(t), T(this, "name", "Hue Saturation Effect"), T(this, "guiIcon", "fa fa-palette"), T(this, "disabledState", {}), this.effect = new qw, this.applyOptions(t)
    }
    get hue() {
        return this.effect.hue
    }
    set hue(t) {
        this.effect.hue = t
    }
    get saturation() {
        return this.effect.saturation
    }
    set saturation(t) {
        this.effect.saturation = t
    }
    defineTweenKeys() {
        return [...super.defineTweenKeys(), "hue", "saturation"]
    }
    defineDefaultAction() {
        return { ...super.defineDefaultAction(),
            hue: 0,
            saturation: 0
        }
    }
    buildGui() {
        this.addGuiControl(null, "hue", { ..._e
        }), this.addGuiControl(null, "saturation", {
            min: -1,
            max: 1
        }), super.buildGui()
    }
}
class qh extends sn {
    constructor(t) {
        super(t), T(this, "name", "Grid Effect"), T(this, "guiIcon", "fa fa-table-cells"), T(this, "disabledState", {}), this.effect = new Yw({
            blendFunction: Ae.MULTIPLY
        }), this.applyOptions(t)
    }
    get scale() {
        return this.effect.scale
    }
    set scale(t) {
        this.effect.scale = t
    }
    get linewidth() {
        return this.effect.lineWidth
    }
    set linewidth(t) {
        this.effect.lineWidth = t
    }
    defineTweenKeys() {
        return [...super.defineTweenKeys(), "scale", "linewidth"]
    }
    defineDefaultAction() {
        return { ...super.defineDefaultAction(),
            scale: 1,
            linewidth: 1,
            opacity: .5
        }
    }
    buildGui() {
        this.addGuiControl(null, "scale", { ..._e,
            ...lt
        }), this.addGuiControl(null, "linewidth", { ..._e,
            ...lt,
            min: 0
        }), super.buildGui()
    }
}
class Zh extends sn {
    constructor(t) {
        super(t), T(this, "name", "Noise Effect"), T(this, "guiIcon", "fa fa-tv-retro"), T(this, "disabledState", {}), this.effect = new tM({
            blendFunction: Ae.MULTIPLY
        }), this.applyOptions(t)
    }
    get premultiply() {
        var t;
        return (null == (t = this.effect) ? void 0 : t.premultiply) ? ? !1
    }
    set premultiply(t) {
        this.effect && (this.effect.premultiply = t)
    }
    defineTweenKeys() {
        return [...super.defineTweenKeys()]
    }
    defineDefaultAction() {
        return { ...super.defineDefaultAction(),
            opacity: .5
        }
    }
    buildGui() {
        this.addGuiControl(null, "premultiply"), super.buildGui()
    }
}
class fg extends sn {
    constructor(t) {
        super(t), T(this, "name", "Scanlines Effect"), T(this, "guiIcon", "fa fa-tv-retro"), T(this, "disabledState", {}), this.effect = new rM({
            blendFunction: Ae.MULTIPLY
        }), this.applyOptions(t)
    }
    get density() {
        return this.effect.density
    }
    set density(t) {
        this.effect.density = t
    }
    get scrollSpeed() {
        return this.effect.scrollSpeed
    }
    set scrollSpeed(t) {
        this.effect.scrollSpeed = t
    }
    defineTweenKeys() {
        return [...super.defineTweenKeys(), "density", "scrollSpeed"]
    }
    defineDefaultAction() {
        return { ...super.defineDefaultAction(),
            density: .2,
            scrollSpeed: .05,
            opacity: .2
        }
    }
    buildGui() {
        this.addGuiControl(null, "density", { ..._e,
            ...lt
        }), this.addGuiControl(null, "scrollSpeed", { ..._e,
            ...mn
        }), super.buildGui()
    }
}
class Jh extends sn {
    constructor(t) {
        super(t), T(this, "name", "Chromatic Aberration Effect"), T(this, "guiIcon", "fa fa-circles-overlap"), T(this, "radialModulation", !1), T(this, "disabledState", {}), this.effect = new Bw({
            radialModulation: this.radialModulation,
            modulationOffset: 0
        }), this.applyOptions(t)
    }
    get modulationOffset() {
        return this.effect.modulationOffset ? ? 0
    }
    set modulationOffset(t) {
        this.effect.modulationOffset = t
    }
    get offset() {
        return this.effect.offset
    }
    set offset(t) {
        this.effect.offset.copy(t)
    }
    get xOffset() {
        return this.effect.offset.x
    }
    set xOffset(t) {
        this.effect.offset.x = t
    }
    get yOffset() {
        return this.effect.offset.y
    }
    set yOffset(t) {
        this.effect.offset.y = t
    }
    defineTweenKeys() {
        return [...super.defineTweenKeys(), "modulationOffset", "xOffset", "yOffset"]
    }
    defineDefaultAction() {
        return { ...super.defineDefaultAction(),
            modulationOffset: 0,
            xOffset: .01,
            yOffset: .01
        }
    }
    buildGui() {
        this.radialModulation && this.addGuiControl(null, "modulationOffset", { ..._e,
            ...lt,
            max: 1.5
        }), this.addGuiControl(null, "xOffset", { ..._e,
            ...mn
        }), this.addGuiControl(null, "yOffset", { ..._e,
            ...mn
        }), super.buildGui()
    }
}
class $h extends sn {
    constructor(t) {
        super(t), T(this, "name", "Fish Eye Effect"), T(this, "guiIcon", "fa fa-fish"), T(this, "principlePoint", new Q(0, 0)), T(this, "focalLength", new Q(1, 1)), T(this, "disabledState", {}), this.effect = new Jw({
            principalPoint: new Q,
            focalLength: new Q,
            distortion: new Q
        }), this.applyOptions(t)
    }
    get xDistortion() {
        return this.effect.distortion.x
    }
    set xDistortion(t) {
        this.effect.distortion.x = t
    }
    get yDistortion() {
        return this.effect.distortion.y
    }
    set yDistortion(t) {
        this.effect.distortion.y = t
    }
    get xFocalLength() {
        return this.effect.focalLength.x
    }
    set xFocalLength(t) {
        this.effect.focalLength.x = t
    }
    get yFocalLength() {
        return this.effect.focalLength.y
    }
    set yFocalLength(t) {
        this.effect.focalLength.y = t
    }
    get xPrinciplePoint() {
        return this.effect.principalPoint.x
    }
    set xPrinciplePoint(t) {
        this.effect.principalPoint.x = t
    }
    get yPrinciplePoint() {
        return this.effect.principalPoint.y
    }
    set yPrinciplePoint(t) {
        this.effect.principalPoint.y = t
    }
    defineTweenKeys() {
        return [...super.defineTweenKeys(), "xDistortion", "yDistortion", "xFocalLength", "yFocalLength", "xPrinciplePoint", "yPrinciplePoint"]
    }
    defineDefaultAction() {
        return { ...super.defineDefaultAction(),
            xDistortion: -.2,
            yDistortion: -.2,
            xFocalLength: 1,
            yFocalLength: 1,
            xPrinciplePoint: 0,
            yPrinciplePoint: 0
        }
    }
    buildGui() {
        this.addGuiControl(null, "xDistortion", { ..._e,
            ...mn
        }), this.addGuiControl(null, "yDistortion", { ..._e,
            ...mn
        }), this.addGuiSeparator(null), this.addGuiControl(null, "xFocalLength", { ..._e,
            ...mn
        }), this.addGuiControl(null, "yFocalLength", { ..._e,
            ...mn
        }), this.addGuiSeparator(null), this.addGuiControl(null, "xPrinciplePoint", { ..._e,
            ...mn
        }), this.addGuiControl(null, "yPrinciplePoint", { ..._e,
            ...mn
        }), super.buildGui()
    }
}
class eu extends sn {
    constructor(t) {
        super(t), T(this, "name", "FXAA Effect"), T(this, "guiIcon", "fa fa-wave-triangle"), T(this, "isAntialiasing", !0), T(this, "disabledState", {}), this.effect = new Xw, this.applyOptions(t)
    }
    get maxEdgeThreshold() {
        return this.effect.maxEdgeThreshold
    }
    set maxEdgeThreshold(t) {
        this.effect.maxEdgeThreshold = t
    }
    get minEdgeThreshold() {
        return this.effect.minEdgeThreshold
    }
    set minEdgeThreshold(t) {
        this.effect.minEdgeThreshold = t
    }
    get subpixelQuality() {
        return this.effect.subpixelQuality
    }
    set subpixelQuality(t) {
        this.effect.subpixelQuality = t
    }
    get samples() {
        return this.effect.samples
    }
    set samples(t) {
        this.effect.samples = t
    }
    defineTweenKeys() {
        return [...super.defineTweenKeys(), "maxEdgeThreshold", "minEdgeThreshold", "subpixelQuality", "samples"]
    }
    defineDefaultAction() {
        return { ...super.defineDefaultAction(),
            minEdgeThreshold: .0312,
            maxEdgeThreshold: .125,
            subpixelQuality: .75,
            samples: 8
        }
    }
    buildGui() {
        this.addGuiControl(null, "maxEdgeThreshold", {
            min: 0,
            max: 1
        }), this.addGuiControl(null, "minEdgeThreshold", {
            min: 0,
            max: 1
        }), this.addGuiControl(null, "subpixelQuality", {
            min: 0,
            max: 1
        }), this.addGuiControl(null, "samples", {
            min: 0,
            max: 16,
            step: 1
        }), super.buildGui()
    }
}
class pg extends sn {
    constructor(t) {
        super(t), T(this, "name", "SMAA Effect"), T(this, "guiIcon", "fa fa-wave-triangle"), T(this, "isAntialiasing", !0), T(this, "_preset", Un.MEDIUM), this.effect = new pM, this.applyOptions(t)
    }
    get preset() {
        return this._preset
    }
    set preset(t) {
        this._preset = t, this.effect && this.effect.applyPreset(t)
    }
    defineTweenKeys() {
        return [...super.defineTweenKeys()]
    }
    defineDefaultAction() {
        return { ...super.defineDefaultAction()
        }
    }
    buildGui() {
        this.addGuiControl(null, "preset", {
            label: "Quality",
            options: {
                Low: Un.LOW,
                Medium: Un.MEDIUM,
                High: Un.HIGH,
                Ultra: Un.ULTRA
            }
        }), super.buildGui()
    }
}
class mg extends pl {
    constructor(t) {
        super(t), T(this, "name", "Blur Effect"), T(this, "guiIcon", "fa fa-aperture"), T(this, "disabledState", {}), this.pass = new Ph({}), this.applyOptions(t)
    }
    get amount() {
        return this.pass.scale
    }
    set amount(t) {
        this.pass.scale = t
    }
    get kernelSize() {
        return this.pass.kernelSize
    }
    set kernelSize(t) {
        this.pass.kernelSize = t
    }
    defineTweenKeys() {
        return [...super.defineTweenKeys(), "amount"]
    }
    defineDefaultAction() {
        return { ...super.defineDefaultAction(),
            amount: 0
        }
    }
    onResize() {
        this.pass.resolution.height = this.stage.height, this.pass.resolution.width = this.stage.width
    }
    buildGui() {
        this.addGuiControl(null, "amount", {
            min: 0,
            ..._e
        }), this.addGuiControl(null, "kernelSize", {
            options: {
                "Very small": hn.VERY_SMALL,
                Small: hn.SMALL,
                Medium: hn.MEDIUM,
                Large: hn.LARGE,
                "Very large": hn.VERY_LARGE,
                Huge: hn.HUGE
            }
        }), super.buildGui()
    }
}
class gg extends ts {
    constructor(t) {
        super(t), T(this, "name", "Ambient Light"), T(this, "guiIcon", "fa fa-sun"), T(this, "obj3d", new c_), this.obj3d.color = this.color
    }
    defineGuiConfig() {
        return { ...super.defineGuiConfig(),
            xRotation: "hidden",
            yRotation: "hidden",
            zRotation: "hidden",
            xRotationOffset: "hidden",
            yRotationOffset: "hidden",
            zRotationOffset: "hidden",
            xScale: "hidden",
            yScale: "hidden",
            zScale: "hidden",
            xScaleOffset: "hidden",
            yScaleOffset: "hidden",
            zScaleOffset: "hidden",
            xPosition: "hidden",
            yPosition: "hidden",
            zPosition: "hidden",
            xPositionOffset: "hidden",
            yPositionOffset: "hidden",
            zPositionOffset: "hidden"
        }
    }
}
class vg extends ts {
    constructor(t) {
        t.targetInMotifSpace = t.targetInMotifSpace ? ? t.inMotifSpace ? ? !1, super(t), T(this, "name", "Spotlight"), T(this, "guiIcon", "fa fa-flashlight"), T(this, "targetInMotifSpace", !1), T(this, "obj3d", new Wp), T(this, "helper"), T(this, "target"), this.applyOptions(t), this.light.color = this.color, this.light.castShadow = !0, this.light.angle = .2 * Math.PI, this.light.shadow.camera.near = .1, this.light.shadow.camera.far = 1e3, this.light.shadow.mapSize.width = 2048, this.light.shadow.mapSize.height = 2048, this.target = this.light.target, this.helper = new __(this.light), this.helper.visible = !1, this.rebuildHelper()
    }
    get light() {
        return this.obj3d
    }
    get xTarget() {
        return this.target.position.x
    }
    get yTarget() {
        return this.target.position.y
    }
    get zTarget() {
        return this.target.position.z
    }
    set xTarget(t) {
        this.target.position.x = t
    }
    set yTarget(t) {
        this.target.position.y = t
    }
    set zTarget(t) {
        this.target.position.z = t
    }
    get distance() {
        return this.obj3d.distance
    }
    get angle() {
        return this.obj3d.angle
    }
    get penumbra() {
        return this.obj3d.penumbra
    }
    get decay() {
        return this.obj3d.decay
    }
    set distance(t) {
        this.obj3d.distance = t
    }
    set angle(t) {
        this.obj3d.angle = t
    }
    set penumbra(t) {
        this.obj3d.penumbra = t
    }
    set decay(t) {
        this.obj3d.decay = t
    }
    get helperVisible() {
        return this.helper.visible
    }
    set helperVisible(t) {
        this.helper.visible = t
    }
    defineDefaultAction() {
        return { ...super.defineDefaultAction(),
            xTarget: 0,
            yTarget: 0,
            zTarget: 0,
            distance: 0,
            angle: Math.PI / 3,
            penumbra: 0,
            intensity: 200,
            decay: 2
        }
    }
    defineTweenKeys() {
        return [...super.defineTweenKeys(), "xTarget", "yTarget", "zTarget", "distance", "angle", "penumbra", "decay"]
    }
    defineGuiConfig() {
        return { ...super.defineGuiConfig(),
            xRotation: "hidden",
            yRotation: "hidden",
            zRotation: "hidden",
            xRotationOffset: "hidden",
            yRotationOffset: "hidden",
            zRotationOffset: "hidden",
            xScale: "hidden",
            yScale: "hidden",
            zScale: "hidden",
            xScaleOffset: "hidden",
            yScaleOffset: "hidden",
            zScaleOffset: "hidden"
        }
    }
    rebuildHelper() {
        const t = new Bp(new ja(1, 1, 16));
        t.translate(0, -.5, 0), t.rotateX(-Math.PI / 2), this.helper.cone.geometry.dispose(), this.helper.cone.geometry = t, this.helper.update()
    }
    buildGui() {
        this.addGuiControl(null, "helperVisible", {
            label: "helper"
        }), this.addGuiControl("Target", "xTarget", { ...co
        }, (() => this.helper.update())), this.addGuiControl("Target", "yTarget", { ...co
        }, (() => this.helper.update())), this.addGuiControl("Target", "zTarget", { ...co
        }, (() => this.helper.update())), this.addGuiControl("Advanced", "distance", { ..._e,
            ...Is,
            min: 0
        }, (() => this.helper.update())), this.addGuiControl("Advanced", "angle", {
            min: 0,
            max: Math.PI / 2
        }, (() => this.helper.update())), this.addGuiControl("Advanced", "penumbra", {
            min: 0,
            max: 1
        }, (() => this.helper.update())), this.addGuiControl("Advanced", "decay", { ..._e,
            min: 0
        }, (() => this.helper.update())), super.buildGui()
    }
    animate(t, e) {
        var n;
        null == (n = super.animate) || n.call(this, t, e), this.helperVisible && this.helper.update()
    }
    onSetStage(t) {
        super.onSetStage(t), t.scene.add(this.helper), this.targetInMotifSpace ? t.motifSpace.add(this.target) : t.scene.add(this.target)
    }
}
class yg extends ts {
    constructor(t) {
        super(t), T(this, "name", "Hemisphere Light"), T(this, "guiIcon", "fa fa-light-ceiling"), T(this, "obj3d", new s_), T(this, "_groundColor", new Qe), this.obj3d.color = this.color, this.obj3d.groundColor = this.groundColor, this.applyOptions(t)
    }
    get rGroundColor() {
        return this._groundColor.r
    }
    get gGroundColor() {
        return this._groundColor.g
    }
    get bGroundColor() {
        return this._groundColor.b
    }
    set rGroundColor(t) {
        this._groundColor.r = t
    }
    set gGroundColor(t) {
        this._groundColor.g = t
    }
    set bGroundColor(t) {
        this._groundColor.b = t
    }
    get groundColor() {
        return this._groundColor
    }
    set groundColor(t) {
        this._groundColor.copy(t)
    }
    defineTweenKeys() {
        return [...super.defineTweenKeys(), "rGroundColor", "gGroundColor", "bGroundColor"]
    }
    defineDefaultAction() {
        return { ...super.defineDefaultAction(),
            yPosition: 1,
            rGroundColor: 1,
            gGroundColor: 1,
            bGroundColor: 1
        }
    }
    defineGuiConfig() {
        return { ...super.defineGuiConfig(),
            xRotation: "hidden",
            yRotation: "hidden",
            zRotation: "hidden",
            xScale: "hidden",
            yScale: "hidden",
            zScale: "hidden",
            xPosition: "hidden",
            zPosition: "hidden"
        }
    }
    buildGui() {
        this.addGuiControl("Appearance", "groundColor", {
            label: "Ground",
            ...Mt
        }), super.buildGui()
    }
}
class xg extends ts {
    constructor(t) {
        super(t), T(this, "name", "Point Light"), T(this, "guiIcon", "fa fa-sparkle"), T(this, "obj3d", new Xp), T(this, "helper"), this.applyOptions(t), this.obj3d.color = this.color, this.helper = new w_(this.obj3d), this.helper.visible = !1
    }
    get distance() {
        return this.obj3d.distance
    }
    set distance(t) {
        this.obj3d.distance = t
    }
    get decay() {
        return this.obj3d.decay
    }
    set decay(t) {
        this.obj3d.decay = t
    }
    get helperVisible() {
        return this.helper.visible
    }
    set helperVisible(t) {
        this.helper.visible = t
    }
    defineTweenKeys() {
        return [...super.defineTweenKeys(), "distance", "decay"]
    }
    defineDefaultAction() {
        return { ...super.defineDefaultAction(),
            distance: 0,
            intensity: 100,
            decay: 2
        }
    }
    buildGui() {
        this.addGuiControl(null, "helperVisible", {
            label: "helper"
        }), this.addGuiControl("Appearance", "distance", { ..._e
        }), this.addGuiControl("Appearance", "decay", { ..._e,
            ...lt
        }), super.buildGui()
    }
    defineGuiConfig() {
        return { ...super.defineGuiConfig(),
            xRotation: "hidden",
            yRotation: "hidden",
            zRotation: "hidden",
            xRotationOffset: "hidden",
            yRotationOffset: "hidden",
            zRotationOffset: "hidden",
            xScale: "hidden",
            yScale: "hidden",
            zScale: "hidden",
            xScaleOffset: "hidden",
            yScaleOffset: "hidden",
            zScaleOffset: "hidden"
        }
    }
    onSetStage(t) {
        super.onSetStage(t), t.scene.add(this.helper)
    }
}
const Xf = .95,
    jf = .975,
    t1 = .999;
class gl extends xt {
    constructor(t) {
        super(t), T(this, "name", "Sky"), T(this, "guiIcon", "fa fa-cloud-sun"), T(this, "segments", 16), T(this, "inMotifSpace", !1), T(this, "mesh"), T(this, "material"), T(this, "scaleAdjustment"), T(this, "_color", new Qe), this.scaleAdjustment = this.defaultAction.scaleAdjustment, this.applyOptions(t)
    }
    get color() {
        return this._color
    }
    set color(t) {
        this._color.copy(t)
    }
    get rColor() {
        return this._color.r
    }
    get gColor() {
        return this._color.g
    }
    get bColor() {
        return this._color.b
    }
    set rColor(t) {
        this._color.r = t
    }
    set gColor(t) {
        this._color.g = t
    }
    set bColor(t) {
        this._color.b = t
    }
    get transparent() {
        return this.material.transparent
    }
    set transparent(t) {
        this.material.transparent = t
    }
    get opacity() {
        return this.material.opacity
    }
    set opacity(t) {
        this.material.opacity = t, this.transparent = t < 1
    }
    defineDefaultAction() {
        return { ...super.defineDefaultAction(),
            rColor: 1,
            gColor: 1,
            bColor: 1,
            xScale: 1e3,
            yScale: 1e3,
            zScale: 1e3,
            scaleAdjustment: jf,
            opacity: 1,
            renderOrder: -1 / 0,
            enterFrom: {
                scaleAdjustment: Xf,
                opacity: 0
            },
            exitTo: {
                scaleAdjustment: t1
            }
        }
    }
    defineTweenKeys() {
        return [...super.defineTweenKeys(), "rColor", "gColor", "bColor", "opacity", "scaleAdjustment"]
    }
    defineGuiConfig() {
        return { ...super.defineGuiConfig(),
            xRotation: "disabled",
            yRotation: "disabled",
            zRotation: "disabled",
            xPosition: "disabled",
            yPosition: "disabled",
            zPosition: "disabled",
            xScale: "hidden",
            yScale: "hidden",
            zScale: "hidden",
            animationOffset: "hidden",
            animationScale: "hidden",
            animationSpeed: "hidden"
        }
    }
    async initMotif() {
        const t = new Or(1, 2 * this.segments, this.segments);
        if (!this.material) {
            const t = new At({
                fog: !1,
                side: Bt,
                transparent: !0
            });
            t.color = this.color, this.material = t
        }
        return this.mesh = new be(t, this.material), this.add(this.mesh), this
    }
    onBeforeChange(t) {
        return "hide" === t.actionKey && this.scaleAdjustment < jf && (t.scaleAdjustment = Xf, t.opacity = 0, t.origin.opacity = this.opacity), !0
    }
    buildGui() {
        this.addGuiControl("Appearance", "color", { ...Mt
        }), this.addGuiControl("Appearance", "opacity", {
            min: 0,
            max: 1
        }), super.buildGui()
    }
    animate(t, e) {
        this.obj3d.position.set(this.stage.cameraController.xPosition, this.stage.cameraController.yPosition, this.stage.cameraController.zPosition), this.obj3d.rotation.copy(this.stage.motifSpace.rotation);
        const n = this.stage.camera.far * this.scaleAdjustment;
        this.xScale !== n && (this.xScale = this.yScale = this.zScale = n, this.renderOrder = 0 - this.scaleAdjustment)
    }
}
class bg extends xt {
    constructor(t) {
        super(t), T(this, "name", "Canvas"), T(this, "skipFrames", 0), T(this, "_ppu", 100), T(this, "_canvas"), T(this, "texture"), T(this, "material"), T(this, "mesh"), T(this, "skippedFrames", 0), this.applyOptions(t)
    }
    get ppu() {
        return this._ppu
    }
    set ppu(t) {
        this._ppu = t, this.mesh && this.canvas && (this.mesh.scale.x = this.canvas.width / this.ppu, this.mesh.scale.y = this.canvas.height / this.ppu)
    }
    get canvas() {
        return this._canvas
    }
    set canvas(t) {
        this.texture && this.texture.dispose(), this._canvas = t, this.texture = new Er(t), this.texture.colorSpace = yt("colorSpace"), this.material && (this.material.map = this.texture, this.texture.needsUpdate = !0, this.material.needsUpdate = !0), this.mesh && (this.mesh.scale.x = t.width / this.ppu, this.mesh.scale.y = t.height / this.ppu)
    }
    defineDefaultAction() {
        return { ...super.defineDefaultAction()
        }
    }
    defineTweenKeys() {
        return [...super.defineTweenKeys()]
    }
    async initMotif() {
        const t = new Ot;
        return this.material = new At({
            map: this.texture
        }), this.mesh = new be(t, this.material), this.add(this.mesh), this.canvas && (this.canvas = this.canvas), this
    }
    animate(t, e) {
        this.skipFrames && this.skippedFrames < this.skipFrames ? this.skippedFrames++ : (this.skippedFrames = 0, this.texture && (this.texture.needsUpdate = !0))
    }
    buildGui() {
        super.buildGui()
    }
}
class Ag extends gl {
    constructor(t) {
        t.texturePath && ("/" === t.texturePath[0] || "\\" === t.texturePath[0]) && (t.texturePath = t.texturePath.substring(1)), super(t), T(this, "name", "Erm Sky"), T(this, "guiIcon", "fa fa-cloud-sun"), T(this, "texturePath"), t.texturePath && (this.texturePath = t.texturePath), this.applyOptions(t)
    }
    defineDefaultAction() {
        return { ...super.defineDefaultAction()
        }
    }
    defineTweenKeys() {
        return [...super.defineTweenKeys()]
    }
    async initMotif() {
        if (await super.initMotif(), this.texturePath) {
            const t = await tn(this.texturePath);
            t.mapping = uo, this.material.map = t
        }
        return this
    }
    buildGui() {
        super.buildGui(), this.texturePath && this.addGuiControl("Appearance", "texturePath", {
            label: "Image",
            disabled: !0
        })
    }
}
class Sg extends xt {
    constructor(t) {
        super(t), T(this, "name", "Floor"), T(this, "texturePath", null), T(this, "circular", !1), T(this, "mesh"), T(this, "_color", new Qe), t.texturePath && (this.texturePath = t.texturePath), this.circular = !!t.circular
    }
    get material() {
        return this.mesh.material
    }
    get color() {
        return this._color
    }
    set color(t) {
        this._color.copy(t)
    }
    get rColor() {
        return this.material.color.r
    }
    get gColor() {
        return this.material.color.g
    }
    get bColor() {
        return this.material.color.b
    }
    set rColor(t) {
        this.material.color.r = t
    }
    set gColor(t) {
        this.material.color.g = t
    }
    set bColor(t) {
        this.material.color.b = t
    }
    get textureRepeat() {
        var t;
        return (null == (t = this.mesh.material.map) ? void 0 : t.repeat.x) || 0
    }
    set textureRepeat(t) {
        var e;
        null == (e = this.mesh.material.map) || e.repeat.set(t, t)
    }
    defineDefaultAction() {
        return { ...super.defineDefaultAction(),
            rColor: .4,
            gColor: .4,
            bColor: .4,
            xScale: 10,
            zScale: 10,
            textureRepeat: 4
        }
    }
    defineTweenKeys() {
        return [...super.defineTweenKeys(), "rColor", "gColor", "bColor", "textureRepeat"]
    }
    async initMotif() {
        let t;
        this.texturePath && (t = await tn(this.texturePath), t.wrapS = $i, t.wrapT = $i, t.minFilter = Vt, t.magFilter = Vt, t.repeat.set(this.defaultAction.textureRepeat, this.defaultAction.textureRepeat), t.center.x = .5, t.center.y = .5);
        const e = this.circular ? new Sh(1, 40) : new Ot,
            n = new kp({});
        return n.color = this.color, t && (n.map = t), this.mesh = new be(e, n), this.mesh.receiveShadow = !0, this.mesh.rotation.x = -Math.PI / 2, this.add(this.mesh), this
    }
    buildGui() {
        this.addGuiControl("Appearance", "color", { ...Mt
        }), this.texturePath && this.addGuiControl("Apperance", "textureRepeat", { ..._e,
            min: 0
        }), super.buildGui()
    }
}
const n1 = "#define GLSLIFY 1\nvarying vec2 vUvs;\nvarying vec4 vColor;\n\nuniform vec3 zenithColor;\nuniform vec3 horizonColor;\nuniform vec3 nadirColor;\n\nuniform float zenithOffset;\nuniform float horizonOffset;\nuniform float nadirOffset;\n\nuniform float opacity;\n\nfloat inverseLerp(float v, float minValue, float maxValue) {\n  return (v - minValue) / (maxValue - minValue);\n}\n\nfloat remap(float v, float inMin, float inMax, float outMin, float outMax) {\n  float t = inverseLerp(v, inMin, inMax);\n  return mix(outMin, outMax, t);\n}\n\nvoid main() {\n\n  vec3 color = vColor.rgb;\n\n  float hHeight = clamp(remap(horizonOffset, -1.0, 1.0, 0.0, 1.0), 0.0, 1.0);\n\n  float nHeight = clamp(remap(nadirOffset, 0.0, 1.0, 0.0, hHeight), 0.0, hHeight);\n  float zHeight = clamp(remap(1.0 - zenithOffset, 0.0, 1.0, hHeight, 1.0), hHeight, 1.0);\n\n  if (vUvs.y < hHeight) {\n    color = mix(nadirColor, horizonColor, smoothstep(nHeight, hHeight, vUvs.y));\n  } else {\n    color = mix(horizonColor, zenithColor, smoothstep(hHeight, zHeight, vUvs.y));\n  }\n\n  gl_FragColor = vec4(color.rgb * opacity, opacity);\n}",
    i1 = "#define GLSLIFY 1\nvarying vec2 vUvs;\nvarying vec4 vColor;\n\nvoid main() {\t\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  vUvs = uv;\n}";
class tu extends It {
    constructor() {
        super({
            uniforms: {
                zenithColor: {
                    value: new Qe("#aaa")
                },
                horizonColor: {
                    value: new Qe("#666")
                },
                nadirColor: {
                    value: new Qe("#444")
                },
                zenithOffset: {
                    value: 0
                },
                nadirOffset: {
                    value: 0
                },
                horizonOffset: {
                    value: 0
                },
                opacity: {
                    get value() {
                        return t.opacity
                    }
                }
            },
            fragmentShader: n1,
            vertexShader: i1,
            side: Bt,
            transparent: !0
        }), T(this, "color", new Qe);
        const t = this
    }
    get zenith() {
        return this.uniforms.zenithColor.value
    }
    set zenith(t) {
        this.uniforms.zenithColor.value = t
    }
    get horizon() {
        return this.uniforms.horizonColor.value
    }
    set horizon(t) {
        this.uniforms.horizonColor.value = t
    }
    get nadir() {
        return this.uniforms.nadirColor.value
    }
    set nadir(t) {
        this.uniforms.nadirColor.value = t
    }
    get zenithOffset() {
        return this.uniforms.zenithOffset.value
    }
    set zenithOffset(t) {
        this.uniforms.zenithOffset.value = t
    }
    get horizonOffset() {
        return this.uniforms.horizonOffset.value
    }
    set horizonOffset(t) {
        this.uniforms.horizonOffset.value = t
    }
    get nadirOffset() {
        return this.uniforms.nadirOffset.value
    }
    set nadirOffset(t) {
        this.uniforms.nadirOffset.value = t
    }
}
class nu extends gl {
    constructor(t) {
        super(t), T(this, "name", "Gradient Sky"), T(this, "guiIcon", "fa fa-cloud-sun"), T(this, "texturePath"), T(this, "zenith", new Qe), T(this, "horizon", new Qe), T(this, "nadir", new Qe), this.applyOptions(t)
    }
    get rZenith() {
        return this.zenith.r
    }
    set rZenith(t) {
        this.zenith.r = t
    }
    get gZenith() {
        return this.zenith.g
    }
    set gZenith(t) {
        this.zenith.g = t
    }
    get bZenith() {
        return this.zenith.b
    }
    set bZenith(t) {
        this.zenith.b = t
    }
    get rHorizon() {
        return this.horizon.r
    }
    set rHorizon(t) {
        this.horizon.r = t
    }
    get gHorizon() {
        return this.horizon.g
    }
    set gHorizon(t) {
        this.horizon.g = t
    }
    get bHorizon() {
        return this.horizon.b
    }
    set bHorizon(t) {
        this.horizon.b = t
    }
    get rNadir() {
        return this.nadir.r
    }
    set rNadir(t) {
        this.nadir.r = t
    }
    get gNadir() {
        return this.nadir.g
    }
    set gNadir(t) {
        this.nadir.g = t
    }
    get bNadir() {
        return this.nadir.b
    }
    set bNadir(t) {
        this.nadir.b = t
    }
    get zenithOffset() {
        return this.material.zenithOffset
    }
    set zenithOffset(t) {
        this.material.zenithOffset = t
    }
    get horizonOffset() {
        return this.material.horizonOffset
    }
    set horizonOffset(t) {
        this.material.horizonOffset = t
    }
    get nadirOffset() {
        return this.material.nadirOffset
    }
    set nadirOffset(t) {
        this.material.nadirOffset = t
    }
    defineDefaultAction() {
        return { ...super.defineDefaultAction(),
            rZenith: .2,
            gZenith: .2,
            bZenith: .2,
            rHorizon: .3,
            gHorizon: .3,
            bHorizon: .3,
            rNadir: .1,
            gNadir: .1,
            bNadir: .1,
            zenithOffset: 0,
            horizonOffset: 0,
            nadirOffset: 0
        }
    }
    defineTweenKeys() {
        return [...super.defineTweenKeys(), "rZenith", "gZenith", "bZenith", "rHorizon", "gHorizon", "bHorizon", "rNadir", "gNadir", "bNadir", "zenithOffset", "horizonOffset", "nadirOffset"]
    }
    defineGuiConfig() {
        return { ...super.defineGuiConfig(),
            rColor: "hidden",
            gColor: "hidden",
            bColor: "hidden"
        }
    }
    async initMotif() {
        return this.material = new tu, this.material.zenith = this.zenith, this.material.horizon = this.horizon, this.material.nadir = this.nadir, await super.initMotif(), this
    }
    buildGui() {
        super.buildGui(), this.addGuiControl("Appearance", "zenith", { ...Mt
        }), this.addGuiControl("Appearance", "zenithOffset", {
            min: 0,
            max: 1
        }), this.addGuiControl("Appearance", "horizon", { ...Mt
        }), this.addGuiControl("Appearance", "horizonOffset", {
            min: -1,
            max: 1
        }), this.addGuiControl("Appearance", "nadir", { ...Mt
        }), this.addGuiControl("Appearance", "nadirOffset", {
            min: 0,
            max: 1
        })
    }
}
class _g extends xt {
    constructor(t) {
        super(t), T(this, "name", "Image"), T(this, "guiIcon", "fa fa-image"), T(this, "preserveTextureOnUpdate", !1), T(this, "preload", !0), T(this, "imagePaths"), T(this, "ppu", 100), T(this, "images", {}), T(this, "textures", {}), T(this, "_imagePath"), T(this, "_imageKey", null), T(this, "anchorPoint", new Q), T(this, "mat"), T(this, "mesh"), T(this, "col", new Qe), this.applyOptions(t)
    }
    get imagePath() {
        return this._imagePath
    }
    set imagePath(t) {
        !t || t === this._imagePath || (this._imagePath = t, this.updateImage())
    }
    get imageKey() {
        return this._imageKey
    }
    set imageKey(t) {
        const e = this.imagePaths[t];
        !e || e === this._imagePath || (this._imageKey = t, this.imagePath = e, this.updateImage())
    }
    get xAnchorPoint() {
        return this.anchorPoint.x
    }
    set xAnchorPoint(t) {
        this.anchorPoint.x = t, this.mesh.position.x = (.5 - t) * this.mesh.scale.x
    }
    get yAnchorPoint() {
        return this.anchorPoint.y
    }
    set yAnchorPoint(t) {
        this.anchorPoint.y = t, this.mesh.position.y = (.5 - t) * this.mesh.scale.y
    }
    get material() {
        return this.mat
    }
    get rColor() {
        return this.col.r
    }
    get gColor() {
        return this.col.g
    }
    get bColor() {
        return this.col.b
    }
    set rColor(t) {
        this.col.r = t
    }
    set gColor(t) {
        this.col.g = t
    }
    set bColor(t) {
        this.col.b = t
    }
    get color() {
        return this.col
    }
    set color(t) {
        this.col.r = t.r, this.col.g = t.g, this.col.b = t.b
    }
    get opacity() {
        return this.mesh.material.opacity
    }
    set opacity(t) {
        this.mesh.material.opacity = t
    }
    get alphaTest() {
        return this.mesh.material.alphaTest
    }
    set alphaTest(t) {
        this.mesh.material.alphaTest = t
    }
    defineDefaultAction() {
        return { ...super.defineDefaultAction(),
            imagePath: "",
            imageKey: null,
            rColor: 1,
            gColor: 1,
            bColor: 1,
            xAnchorPoint: .5,
            yAnchorPoint: .5,
            opacity: 1
        }
    }
    defineTweenKeys() {
        return [...super.defineTweenKeys(), "rColor", "gColor", "bColor", "opacity", "xAnchorPoint", "yAnchorPoint"]
    }
    onStartChange(t) {
        return t.imagePath ? this.imagePath = t.imagePath : t.imageKey && (this.imageKey = t.imageKey), !0
    }
    async updateImage() {
        if (!this.imagePath) return;
        const t = this.imagePath,
            e = this.images[this.imagePath] ? ? await Pr(`${this.imagePath}`),
            n = this.textures[this.imagePath] ? ? new wt(e);
        if (this.images[this.imagePath] || (this.images[this.imagePath] = e), n.colorSpace = yt("colorSpace"), this.imagePath !== t) return void this.log(`${t} did not load in time and was superceded.`);
        this.preserveTextureOnUpdate ? this.textures[this.imagePath] || (this.textures[this.imagePath] = n) : this.mat.map && this.mat.map.dispose(), this.mat.map = n, n.needsUpdate = !0;
        const i = e.width / this.ppu,
            s = e.height / this.ppu;
        this.mesh.scale.x = i, this.mesh.scale.y = s, new Q, this.xAnchorPoint = this.xAnchorPoint, this.yAnchorPoint = this.yAnchorPoint
    }
    async initMotif() {
        if (this.mat = new At({
                transparent: !0,
                side: 2
            }), this.mat.color = this.color, this.preload)
            for (let t in this.imagePaths) {
                const e = this.imagePaths[t];
                this.images[e] || (this.images[e] = await Pr(e))
            }
        return this.mesh = new be(new Ot, this.mat), this.mesh.receiveShadow = !0, this.add(this.mesh), this.defaultAction.imagePath ? this.imagePath = this.defaultAction.imagePath : this.defaultAction.imageKey && (this.imageKey = this.defaultAction.imageKey), this
    }
    buildGui() {
        this.addGuiControl("Appearance", "color", { ...Mt
        }), this.addGuiControl("Appearance", "opacity", {
            min: 0,
            max: 1
        }), this.addGuiControl("Appearance", "alphaTest", {
            min: 0,
            max: 1
        }), super.buildGui(), this.addGuiSeparator("Position"), this.addGuiControl("Position", "xAnchorPoint", {
            label: "x Anchor Point",
            ..._e
        }), this.addGuiControl("Position", "yAnchorPoint", {
            label: "y Anchor Point",
            ..._e
        })
    }
}
class wg extends xt {
    constructor(t) {
        var e;
        if (t.name = `Label (${(null==(e=t.defaultAction)?void 0:e.text.replace("\n"," "))||""})`, super(t), T(this, "renderMode", "sprite"), T(this, "name", "Label"), T(this, "guiIcon", "fa-solid fa-font"), T(this, "strokeWidth", 5), T(this, "bold", !1), T(this, "fontFamily", "arial"), T(this, "sizeAttenuation", !1), T(this, "highFPS", !1), T(this, "dpi", 100), T(this, "sprite"), T(this, "spriteMat"), T(this, "mesh"), T(this, "meshMat"), T(this, "map"), T(this, "alphaMap"), T(this, "color", new Qe), T(this, "strokeColor", new Qe), T(this, "mapCanvas"), T(this, "alphaCanvas"), T(this, "_text"), T(this, "anchorPoint", new Q), this._text = this.defaultAction.text, this.dpi = this.defaultAction.dpi ? ? 100, this.applyOptions(t), "sprite" === this.renderMode) {
            const t = this.guiConfig;
            t.xRotation = "hidden", t.yRotation = "hidden", t.zRotation = "hidden", t.xRotationOffset = "hidden", t.yRotationOffset = "hidden", t.zRotationOffset = "hidden"
        }
        this.mapCanvas = new OffscreenCanvas(1, 1), this.alphaCanvas = new OffscreenCanvas(1, 1)
    }
    get text() {
        return this._text
    }
    set text(t) {
        t !== this._text && (this._text = t, this.redraw())
    }
    get mat() {
        return "sprite" === this.renderMode ? this.spriteMat : this.meshMat
    }
    get rColor() {
        return this.color.r
    }
    get gColor() {
        return this.color.g
    }
    get bColor() {
        return this.color.b
    }
    set rColor(t) {
        this.color.r !== t && (this.color.r = t, this.redraw())
    }
    set gColor(t) {
        this.color.g !== t && (this.color.g = t, this.redraw())
    }
    set bColor(t) {
        this.color.b !== t && (this.color.b = t, this.redraw())
    }
    get rStrokeColor() {
        return this.strokeColor.r
    }
    get gStrokeColor() {
        return this.strokeColor.g
    }
    get bStrokeColor() {
        return this.strokeColor.b
    }
    set rStrokeColor(t) {
        this.strokeColor.r !== t && (this.strokeColor.r = t, this.redraw())
    }
    set gStrokeColor(t) {
        this.strokeColor.g !== t && (this.strokeColor.g = t, this.redraw())
    }
    set bStrokeColor(t) {
        this.strokeColor.b !== t && (this.strokeColor.b = t, this.redraw())
    }
    get xLabelScale() {
        return "sprite" === this.renderMode ? this.sprite.scale.x : this.mesh.scale.x
    }
    set xLabelScale(t) {
        "sprite" === this.renderMode ? this.sprite.scale.x = t : this.mesh.scale.x = t
    }
    get yLabelScale() {
        return "sprite" === this.renderMode ? this.sprite.scale.y : this.mesh.scale.y
    }
    set yLabelScale(t) {
        "sprite" === this.renderMode ? this.sprite.scale.y = t : this.mesh.scale.y = t
    }
    get xAnchorPoint() {
        return this.anchorPoint.x
    }
    set xAnchorPoint(t) {
        this.anchorPoint.x = t, "mesh" === this.renderMode && (this.mesh.position.x = (.5 - t) * this.mesh.scale.x)
    }
    get yAnchorPoint() {
        return this.anchorPoint.y
    }
    set yAnchorPoint(t) {
        this.anchorPoint.y = t, "mesh" === this.renderMode && (this.mesh.position.y = (.5 - t) * this.mesh.scale.y)
    }
    get opacity() {
        return this.mat.opacity
    }
    set opacity(t) {
        this.mat.opacity = t
    }
    defineDefaultAction() {
        return { ...super.defineDefaultAction(),
            text: " ",
            rColor: 0,
            gColor: 0,
            bColor: 0,
            rStrokeColor: 1,
            gStrokeColor: 1,
            bStrokeColor: 1,
            xAnchorPoint: .5,
            yAnchorPoint: .5,
            opacity: 1,
            dpi: 100,
            change: {
                text: null
            },
            enterFrom: {
                opacity: 0
            },
            exitTo: {
                opacity: 0
            }
        }
    }
    defineTweenKeys() {
        return [...super.defineTweenKeys(), "rColor", "gColor", "bColor", "rStrokeColor", "gStrokeColor", "bStrokeColor", "xAnchorPoint", "yAnchorPoint", "opacity"]
    }
    async initMotif() {
        return this.map = this.getMap(), this.alphaMap = this.getAlphaMap(), "sprite" === this.renderMode ? (this.spriteMat = new Tp({
            map: this.map,
            alphaMap: this.alphaMap,
            fog: !1,
            sizeAttenuation: this.sizeAttenuation,
            alphaTest: .001
        }), this.spriteMat.depthWrite = !1, this.sprite = new lS(this.spriteMat), this.anchorPoint = this.sprite.center, this.add(this.sprite)) : (this.meshMat = new At({
            map: this.map,
            alphaMap: this.alphaMap,
            fog: !1,
            transparent: !0,
            alphaTest: .001
        }), this.mesh = new be(new Ot, this.meshMat), this.add(this.mesh)), this.drawText(), this
    }
    getMap() {
        const t = new Er(this.mapCanvas);
        return t.colorSpace = yt("colorSpace"), t
    }
    getAlphaMap() {
        const t = new Er(this.alphaCanvas);
        return t.colorSpace = "", t
    }
    onResize() {
        this.visible && this.redraw()
    }
    onStartChange(t) {
        return t.text && (this.text = t.text), t.dpi && (this.dpi = t.dpi), !0
    }
    onShow() {
        this.redraw()
    }
    onSetStage(t) {
        super.onSetStage(t), t.addEventListener("projectionmatrixupdate", (() => {
            this.redraw()
        }))
    }
    redraw() {
        this.transients.redraw = !0
    }
    afterUpdate() {
        this.transients.redraw && this.drawText()
    }
    drawText() {
        if (!this.hasInit) return;
        const t = this.mapCanvas,
            e = this.alphaCanvas,
            n = t.getContext("2d"),
            i = e.getContext("2d"),
            s = Math.max(this.dpi, 10),
            r = s,
            o = this.strokeWidth * s * .01,
            a = `${this.bold?"bold":""} ${r}px ${this.fontFamily}`,
            l = this.text.split("\n");
        n.font = a;
        let c = 0,
            h = [],
            u = 0,
            d = 0;
        for (let t = 0; t < l.length; t++) {
            const e = n.measureText(l[t]);
            u = e.fontBoundingBoxAscent, d = e.fontBoundingBoxDescent, h.push(e.width), e.width > c && (c = e.width)
        }
        e.width = c + 2 * o, e.height = 2 * o + l.length * r + d, t.width = o ? e.width : 1, t.height = o ? e.height : 1;
        let p, f, m = !1;
        if (this.sprite && !this.sprite.material.sizeAttenuation) {
            const t = this.stage.height;
            let n = 1 / this.stage.cameraController.zoom * this.stage.cameraController.fov;
            n *= "perspective" === this.stage.cameraController.cameraType ? .0015 : .1;
            const i = e.height / l.length / t * .001 * n;
            p = e.width * i, f = e.height * i
        } else p = e.width / s, f = e.height / s;
        this.xLabelScale !== p && (this.xLabelScale = p, m = !0), this.yLabelScale !== f && (this.yLabelScale = f, m = !0), m && (this.map.dispose(), this.map = this.getMap(), this.mat.map = this.map, this.alphaMap.dispose(), this.alphaMap = this.getAlphaMap(), this.mat.alphaMap = this.alphaMap), n.font = i.font = a, n.lineJoin = i.lineJoin = "round", n.miterLimit = i.miterLimit = 4, n.lineWidth = i.lineWidth = 2 * o, n.fillStyle = `#${this.color.getHexString()}`, n.strokeStyle = `#${this.strokeColor.getHexString()}`, i.fillStyle = "#000", i.fillRect(0, 0, e.width, e.height), i.fillStyle = "#fff", i.strokeStyle = "#fff";
        const g = o,
            v = u + n.lineWidth / 2;
        if (n.fillStyle = o ? `#${this.strokeColor.getHexString()}` : `#${this.color.getHexString()}`, n.fillRect(0, 0, e.width, e.height), o)
            for (let t = 0; t < l.length; t++) {
                const e = g + (c - h[t]) / 2,
                    n = v + t * r;
                i.strokeText(l[t], e, n)
            }
        n.fillStyle = `#${this.color.getHexString()}`;
        for (let t = 0; t < l.length; t++) {
            const e = g + (c - h[t]) / 2,
                s = v + t * r;
            o && n.fillText(l[t], e, s), i.fillText(l[t], e, s)
        }
        this.map.needsUpdate = !0, this.alphaMap.needsUpdate = !0, this.xAnchorPoint = this.xAnchorPoint, this.yAnchorPoint = this.yAnchorPoint
    }
    buildGui() {
        this.color, this.strokeColor, this._text, this.addGuiControl(null, "text", {}, (() => {
            this.onStartChange({
                text: this.text
            }), this.redraw()
        })), this.addGuiControl("Appearance", "color", {
            label: "Text",
            ...Mt
        }, (() => this.transients.redraw = !0)), this.addGuiControl("Appearance", "strokeColor", {
            label: "Outline",
            ...Mt
        }, (() => this.transients.redraw = !0)), this.addGuiControl("Appearance", "opacity", {
            min: 0,
            max: 1
        }), this.addGuiControl("Appearance", "dpi", {
            label: "DPI",
            min: 10,
            ..._e,
            CP_UNITS_01: lt
        }, (() => this.transients.redraw = !0)), super.buildGui(), this.addGuiSeparator("Position"), this.addGuiControl("Position", "xAnchorPoint", {
            label: "x Anchor Point",
            ..._e
        }), this.addGuiControl("Position", "yAnchorPoint", {
            label: "y Anchor Point",
            ..._e
        }), this.addGuiSeparator("Position")
    }
}
class Ui extends xt {
    constructor(t) {
        super(t), T(this, "name", "Mesh"), T(this, "mesh", new be), T(this, "color", new Qe), this.applyOptions(t)
    }
    set rColor(t) {
        this.color.r = t
    }
    set gColor(t) {
        this.color.g = t
    }
    set bColor(t) {
        this.color.b = t
    }
    get rColor() {
        return this.color.r
    }
    get gColor() {
        return this.color.g
    }
    get bColor() {
        return this.color.b
    }
    get material() {
        return this.mesh.material
    }
    set material(t) {
        t.color && (t.color = this.color), this.mesh.material = t
    }
    get geometry() {
        return this.mesh.geometry
    }
    set geometry(t) {
        this.mesh.geometry = t
    }
    defineDefaultAction() {
        return { ...super.defineDefaultAction(),
            rColor: 1,
            gColor: 1,
            bColor: 1
        }
    }
    defineTweenKeys() {
        return [...super.defineTweenKeys(), "rColor", "gColor", "bColor"]
    }
    async initMotif() {
        return this.add(this.mesh), this
    }
    buildGui() {
        this.addGuiControl("Appearance", "color"), super.buildGui()
    }
}
class Mg extends xt {
    constructor(t) {
        super(t), T(this, "name", "Model"), T(this, "modelPath"), T(this, "materialCallback"), T(this, "vertexColors"), T(this, "model"), this.applyOptions(t)
    }
    get modelPosition() {
        return this.model.position
    }
    set modelPosition(t) {
        this.model.position.copy(t)
    }
    get xModelPosition() {
        return this.model.position.x
    }
    get yModelPosition() {
        return this.model.position.y
    }
    get zModelPosition() {
        return this.model.position.z
    }
    set xModelPosition(t) {
        this.model.position.x = t
    }
    set yModelPosition(t) {
        this.model.position.y = t
    }
    set zModelPosition(t) {
        this.model.position.z = t
    }
    get modelRotation() {
        return this.model.rotation
    }
    set modelRotation(t) {
        this.model.rotation.copy(t)
    }
    get xModelRotation() {
        return this.model.rotation.x
    }
    get yModelRotation() {
        return this.model.rotation.y
    }
    get zModelRotation() {
        return this.model.rotation.z
    }
    set xModelRotation(t) {
        this.model.rotation.x = t
    }
    set yModelRotation(t) {
        this.model.rotation.y = t
    }
    set zModelRotation(t) {
        this.model.rotation.z = t
    }
    get modelScale() {
        return this.model.scale
    }
    set modelScale(t) {
        this.model.scale.copy(t)
    }
    get xModelScale() {
        return this.model.scale.x
    }
    get yModelScale() {
        return this.model.scale.y
    }
    get zModelScale() {
        return this.model.scale.z
    }
    set xModelScale(t) {
        this.model.scale.x = t
    }
    set yModelScale(t) {
        this.model.scale.y = t
    }
    set zModelScale(t) {
        this.model.scale.z = t
    }
    defineTweenKeys() {
        return [...super.defineTweenKeys(), "xModelPosition", "yModelPosition", "zModelPosition", "xModelRotation", "yModelRotation", "zModelRotation", "xModelScale", "yModelScale", "zModelScale"]
    }
    defineDefaultAction() {
        return { ...super.defineDefaultAction(),
            xModelPosition: 0,
            yModelPosition: 0,
            zModelPosition: 0,
            xModelRotation: 0,
            yModelRotation: 0,
            zModelRotation: 0,
            xModelScale: 1,
            yModelScale: 1,
            zModelScale: 1
        }
    }
    async initMotif() {
        return this.modelPath ? this.model = await rl(this.modelPath) : console.warn(`No model path provided for motif "${this.name}"!`), this.model instanceof ct || (console.warn(`No model file found for motif "${this.name}" ("${this.modelPath}" failed to load)!`), this.model = new be), this.add(this.model), this.materialCallback && this.traverse((async t => {
            t instanceof be && (t.material, t.material = await this.materialCallback(t.material), t.material.needsUpdate = !0)
        })), this
    }
}
class vl extends xt {
    constructor(t) {
        super(t), T(this, "name", "Point Cloud"), T(this, "guiIcon", "fa-solid fa-cloud"), T(this, "imagePath", null), T(this, "round", !1), T(this, "formation", "cube"), T(this, "radius", 1), T(this, "innerRadius", 0), T(this, "movement", "simplex"), T(this, "mesh"), T(this, "noiseGen"), T(this, "geometry", new ht), T(this, "positions", []), T(this, "tAnimation", 0), this.applyOptions(t)
    }
    get material() {
        return this.mesh.material
    }
    get opacity() {
        return this.material.opacity
    }
    set opacity(t) {
        this.material.opacity = t
    }
    get size() {
        return this.material.size
    }
    set size(t) {
        this.material.size = t
    }
    get rColor() {
        return this.material.color.r
    }
    get gColor() {
        return this.material.color.g
    }
    get bColor() {
        return this.material.color.b
    }
    set rColor(t) {
        this.material.color.r = t
    }
    set gColor(t) {
        this.material.color.g = t
    }
    set bColor(t) {
        this.material.color.b = t
    }
    get color() {
        return this.material.color
    }
    set color(t) {
        this.material.color.copy(t)
    }
    get count() {
        return this.positions.length / 3
    }
    set count(t) {
        const e = Math.floor(t) - this.count;
        if (e > 0)
            for (let t = 0; t < e; t++) this.positions.push(_i.randFloatSpread(1), _i.randFloatSpread(1), _i.randFloatSpread(1));
        else {
            const t = 3 * -e;
            this.positions.splice(this.positions.length - t, t)
        }
    }
    defineTweenKeys() {
        return [...super.defineTweenKeys(), "rColor", "gColor", "bColor", "opacity", "size", "count"]
    }
    defineDefaultAction() {
        return { ...super.defineDefaultAction(),
            count: 500,
            rColor: 1,
            gColor: 1,
            bColor: 1,
            opacity: 1,
            size: 1,
            fog: !1,
            enterFrom: {
                size: 0,
                opacity: 0
            },
            exitTo: {
                opacity: 0,
                size: 0
            }
        }
    }
    async initMotif() {
        switch (this.noiseGen = TE(), this.formation) {
            case "cube":
                this.setPositionsCube();
                break;
            case "tube":
                this.setPositionsTube();
                break;
            case "sphere":
                this.setPositionsSphere();
                break;
            default:
                this.setPositionsCustom()
        }
        const t = new xs({
            transparent: !0,
            opacity: this.defaultAction.opacity,
            fog: this.defaultAction.fog,
            color: new Qe(this.defaultAction.rColor, this.defaultAction.gColor, this.defaultAction.bColor),
            size: this.defaultAction.size,
            alphaTest: .01
        });
        if (Qe.replaceColors(t), this.imagePath) {
            const e = await ss(this.imagePath);
            e && (t.alphaMap = e, e.needsUpdate = !0, t.needsUpdate = !0)
        }
        return this.mesh = new so(this.geometry, t), this.count = this.defaultAction.count, this.add(this.mesh), this
    }
    animate(t, e) {
        switch (this.movement) {
            case "simplex":
            case "simplexRound":
                return this.movementSimplex(t, e);
            case "orbit":
            case "orbitSimplex":
                return this.movementOrbit(t, e);
            default:
                return this.movementCustom(t, e)
        }
    }
    buildGui() {
        this.addGuiControl("Appearance", "count", {
            min: 1,
            step: 1,
            ..._e,
            ...Is
        }), this.addGuiControl("Appearance", "color", { ...Mt
        }), this.addGuiControl("Appearance", "opacity", {
            min: 0,
            max: 1
        }), this.addGuiControl("Appearance", "size", {
            min: 0,
            ..._e,
            ...lt
        }), super.buildGui()
    }
    setPositionsCube() {
        this.radius, this.innerRadius;
        for (let t = 0; t < this.defaultAction.count; t++) {
            let t = _i.randFloatSpread(this.radius),
                e = _i.randFloatSpread(this.radius),
                n = _i.randFloatSpread(this.radius);
            this.positions.push(t, e, n)
        }
    }
    setPositionsTube() {
        const t = this.radius - this.innerRadius;
        for (let e = 0; e < this.defaultAction.count; e++) {
            const e = Math.pow(Math.random() * t, .5),
                n = 0,
                i = Math.random() * Math.PI * 2;
            this.positions.push((e + this.innerRadius) * Math.cos(i) - n * Math.sin(i), _i.randFloatSpread(this.radius), (e + this.innerRadius) * Math.sin(i) + n * Math.cos(i))
        }
    }
    setPositionsSphere() {
        this.radius, this.innerRadius;
        for (let t = 0; t < this.defaultAction.count; t++) {
            const t = zh(this.radius, this.innerRadius);
            this.positions.push(t.x, t.y, t.z)
        }
    }
    setPositionsCustom() {
        if (!(this.formation instanceof Function)) throw new Error("Custom Point Cloud formation is missing a valid callback!");
        for (let t = 0; t < this.defaultAction.count; t++) {
            const e = this.formation(t);
            this.positions.push(e.x, e.y, e.z)
        }
    }
    movementSimplex(t, e) {
        const n = [],
            i = this.animationScale;
        this.tAnimation += t * this.animationSpeed;
        for (var s = 0; s < this.positions.length; s += 3) {
            const t = this.positions[s + 0] + this.noiseGen(s + 0, .1 * this.tAnimation),
                e = this.positions[s + 1] + this.noiseGen(s + 1, .1 * this.tAnimation),
                r = this.positions[s + 2] + this.noiseGen(s + 2, .1 * this.tAnimation),
                o = "simplexRound" === this.movement ? 1 / Math.cbrt(t * t + e * e + r * r) : 1;
            n.push(t * o * i, e * o * i, r * o * i)
        }
        this.geometry.setAttribute("position", new Fe(n, 3)), this.geometry.computeVertexNormals()
    }
    movementOrbit(t, e) {
        const n = [];
        this.tAnimation += t * this.animationSpeed;
        for (var i = 0; i < this.positions.length; i += 3) {
            const t = this.positions[i + 0],
                e = this.positions[i + 1],
                s = this.positions[i + 2],
                r = Math.sqrt(t * t + s * s),
                o = this.tAnimation / r * .1;
            n.push(t * Math.cos(o) - s * Math.sin(o), "orbitSimplex" === this.movement ? e + this.noiseGen(i + 1, .1 * this.tAnimation) * r : e, t * Math.sin(o) + s * Math.cos(o))
        }
        this.geometry.setAttribute("position", new Fe(n, 3)), this.geometry.computeVertexNormals()
    }
    movementCustom(t, e) {
        if (!(this.movement instanceof Function)) throw new Error("Custom Point Cloud movement is not a valid callback!");
        const n = [];
        for (var i = 0; i < this.positions.length; i += 3) {
            const s = this.positions[i + 0],
                r = this.positions[i + 1],
                o = this.positions[i + 2],
                a = this.movement(new U(s, r, o), t, e);
            n.push(a.x, a.y, a.z)
        }
        this.geometry.setAttribute("position", new Fe(n, 3)), this.geometry.computeVertexNormals()
    }
}
class Eg extends vl {
    constructor(t) {
        super(t), T(this, "name", "Node Network"), T(this, "threshold"), T(this, "dropoff"), T(this, "linesMesh"), this.threshold = this.defaultAction.threshold, this.dropoff = this.defaultAction.dropoff, this.defaultAction.count, this.applyOptions(t)
    }
    get linewidth() {
        return this.linesMesh.material.linewidth
    }
    set linewidth(t) {
        this.linesMesh.material.linewidth = t
    }
    defineDefaultAction() {
        return { ...super.defineDefaultAction(),
            count: 10,
            threshold: 1,
            dropoff: .5,
            size: .5,
            linewidth: .1,
            enterFrom: {
                opacity: 0,
                linewidth: 0,
                size: 0
            },
            exitTo: {
                opacity: 0,
                linewidth: 0,
                size: 0
            }
        }
    }
    defineTweenKeys() {
        return [...super.defineTweenKeys(), "threshold", "dropoff", "linewidth"]
    }
    async initMotif() {
        await super.initMotif();
        const t = new xo;
        t.setPositions(new Float32Array(3e3)), t.setColors(new Float32Array(3e3));
        const e = new Nr({
            vertexColors: !0,
            worldUnits: !0,
            linewidth: .1,
            blending: 2,
            blendSrc: $f,
            blendDst: Ea,
            depthWrite: !1,
            transparent: !0,
            fog: this.defaultAction.fog
        });
        return this.linesMesh = new Eo(t, e), this.linesMesh.renderOrder = 999, this.add(this.linesMesh), this
    }
    animate(t, e) {
        const n = [],
            i = [],
            s = [],
            r = this.rColor,
            o = this.gColor,
            a = this.bColor,
            l = 1 / this.dropoff,
            c = this.animationScale;
        this.tAnimation += t * this.animationSpeed * .1;
        for (var h = 0; h < this.positions.length; h += 3) {
            const t = h + 0,
                e = h + 1,
                d = h + 2,
                p = this.positions[t] + this.noiseGen(t, this.tAnimation) * c,
                f = this.positions[e] + this.noiseGen(e, this.tAnimation) * c,
                m = this.positions[d] + this.noiseGen(d, this.tAnimation) * c;
            n.push(p, f, m);
            for (var u = 0; u <= h; u += 3) {
                const t = u + 1,
                    e = u + 2,
                    c = n[u + 0],
                    h = n[t],
                    d = n[e],
                    g = p - c,
                    v = f - h,
                    y = m - d,
                    x = Math.sqrt(g * g + v * v + y * y);
                if (x <= this.threshold) {
                    const t = l - x * l / this.threshold;
                    s.push(t * r), s.push(t * o), s.push(t * a), s.push(t * r), s.push(t * o), s.push(t * a), i.push(p), i.push(f), i.push(m), i.push(c), i.push(h), i.push(d)
                }
            }
        }
        const d = this.linesMesh;
        d.geometry.dispose(), d.geometry = new xo, d.geometry.setPositions(new Float32Array(i)), d.geometry.setColors(new Float32Array(s)), d.geometry.computeVertexNormals(), d.computeLineDistances(), this.geometry.setAttribute("position", new Fe(n, 3)), this.geometry.computeVertexNormals()
    }
    buildGui() {
        this.addGuiControl("Lines", "threshold", { ..._e,
            min: 0,
            step: .01
        }), this.addGuiControl("Lines", "dropoff", {
            min: .01,
            max: 1
        }), this.addGuiControl("Lines", "linewidth", { ..._e,
            ...lt,
            min: 0
        }), super.buildGui()
    }
}
class Tg extends xt {
    constructor(t) {
        super(t), T(this, "name", "Line Segments"), T(this, "guiIcon", "fa fa-scribble"), T(this, "mesh", new Eo), this.applyOptions(t)
    }
    get mat() {
        return this.mesh.material
    }
    get color() {
        return this.mesh.material.color
    }
    set rColor(t) {
        this.color.r = t
    }
    set gColor(t) {
        this.color.g = t
    }
    set bColor(t) {
        this.color.b = t
    }
    get rColor() {
        return this.color.r
    }
    get gColor() {
        return this.color.g
    }
    get bColor() {
        return this.color.b
    }
    set opacity(t) {
        this.mat.opacity = t
    }
    set linewidth(t) {
        this.mat.linewidth = t
    }
    set gapSize(t) {
        this.mat.gapSize = t
    }
    set dashSize(t) {
        this.mat.dashSize = t
    }
    set dashScale(t) {
        this.mat.dashScale = t
    }
    set dashOffset(t) {
        this.mat.dashOffset = t
    }
    get opacity() {
        return this.mat.opacity
    }
    get linewidth() {
        return this.mat.linewidth
    }
    get gapSize() {
        return this.mat.gapSize
    }
    get dashSize() {
        return this.mat.dashSize
    }
    get dashScale() {
        return this.mat.dashScale
    }
    get dashOffset() {
        return this.mat.dashOffset
    }
    defineDefaultAction() {
        return { ...super.defineDefaultAction(),
            rColor: 1,
            gColor: 1,
            bColor: 1,
            opacity: 1,
            linewidth: .1,
            gapSize: 1,
            dashSize: 1,
            dashScale: 1,
            dashOffset: 0,
            enterFrom: {
                linewidth: 0
            },
            exitTo: {
                linewidth: 0
            }
        }
    }
    defineTweenKeys() {
        return [...super.defineTweenKeys(), "rColor", "gColor", "bColor", "opacity", "linewidth", "gapSize", "dashSize", "dashScale", "dashOffset"]
    }
    async initMotif() {
        const t = new Nr({
            linewidth: this.defaultAction.linewidth,
            worldUnits: !0,
            fog: !0,
            transparent: !0,
            dashed: !0,
            dashSize: 1,
            dashScale: 1,
            gapSize: 1,
            dashOffset: 0,
            opacity: this.defaultAction.opacity,
            color: new Qe(this.defaultAction.rColor, this.defaultAction.gColor, this.defaultAction.bColor)
        });
        return Qe.replaceColors(t), this.mesh.material = t, this.add(this.mesh), this
    }
    setPositions(t) {
        this.mesh.geometry.setPositions(t), this.mesh.computeLineDistances()
    }
    buildGui() {
        this.addGuiControl("Appearance", "color", { ...Mt
        }), this.addGuiControl("Appearance", "linewidth", { ..._e,
            ...mn
        }), this.addGuiControl("Appearance", "opacity", {
            min: 0,
            max: 1
        }), this.addGuiControl("Dash", "dashSize", { ..._e,
            min: 0
        }), this.addGuiControl("Dash", "gapSize", { ..._e,
            min: 0
        }), this.addGuiControl("Dash", "dashScale", { ..._e
        }), this.addGuiControl("Dash", "dashOffset", { ..._e
        }), super.buildGui()
    }
}
class iu extends Ah {
    constructor() {
        const t = Math.SQRT2 / 2,
            e = t - .1,
            n = t - .2;
        super([new Q(0, 0), new Q(t, 0), new Q(t, .2), new Q(e, .3), new Q(n, .3), new Q(n, .5), new Q(n, .7), new Q(e, .8), new Q(e, .9), new Q(n, .9), new Q(n, 1), new Q(0, 1)], 4, Math.PI / 4)
    }
}
class Cg extends xt {
    constructor(t) {
        super(t), T(this, "name", "Plinth"), T(this, "_color", new Qe), T(this, "lineMesh", new Eo), this.add(this.lineMesh), this.applyOptions(t)
    }
    get color() {
        return this._color
    }
    set color(t) {
        this._color.copy(t)
    }
    set rColor(t) {
        this.color.r = t
    }
    set gColor(t) {
        this.color.g = t
    }
    set bColor(t) {
        this.color.b = t
    }
    get rColor() {
        return this.color.r
    }
    get gColor() {
        return this.color.g
    }
    get bColor() {
        return this.color.b
    }
    get opacity() {
        return this.lineMesh.material.opacity
    }
    set opacity(t) {
        this.lineMesh.material.opacity = t
    }
    get linewidth() {
        return this.lineMesh.material.linewidth
    }
    set linewidth(t) {
        this.lineMesh.material.linewidth = t
    }
    get dashSize() {
        return this.lineMesh.material.dashSize
    }
    set dashSize(t) {
        this.lineMesh.material.dashSize = t
    }
    get dashGapSize() {
        return this.lineMesh.material.gapSize
    }
    set dashGapSize(t) {
        this.lineMesh.material.gapSize = t, this.lineMesh.material.dashed = t > 0
    }
    get dashScale() {
        return this.lineMesh.material.dashScale
    }
    set dashScale(t) {
        this.lineMesh.material.dashScale = t
    }
    get dashOffset() {
        return this.lineMesh.material.dashOffset
    }
    set dashOffset(t) {
        this.lineMesh.material.dashOffset = t
    }
    defineDefaultAction() {
        return { ...super.defineDefaultAction(),
            rColor: 1,
            gColor: 1,
            bColor: 1,
            opacity: 1,
            dashSize: 1,
            dashGapSize: 0,
            dashOffset: 0,
            dashScale: 1,
            linewidth: .03,
            enterFrom: {
                yScale: 0,
                linewidth: 0,
                opacity: 0
            },
            exitTo: {
                yScale: 0,
                linewidth: 0,
                opacity: 0
            }
        }
    }
    defineTweenKeys() {
        return [...super.defineTweenKeys(), "rColor", "gColor", "bColor", "opacity", "linewidth", "dashSize", "dashGapSize", "dashScale", "dashOffset"]
    }
    async initMotif() {
        const t = new Nr({
            linewidth: this.defaultAction.linewidth,
            worldUnits: !0,
            fog: !0,
            transparent: !0,
            opacity: this.defaultAction.opacity
        });
        t.color = this.color, this.lineMesh.material = t;
        const e = new iu;
        return this.lineMesh.geometry = cl(e), this.lineMesh.computeLineDistances(), this
    }
    buildGui() {
        this.addGuiControl("Appearance", "color", { ...Mt
        }), this.addGuiControl("Appearance", "linewidth", { ..._e,
            ...lt,
            min: 0
        }), this.addGuiControl("Appearance", "dashSize", { ..._e,
            ...lt,
            min: 0
        }), this.addGuiControl("Appearance", "dashGapSize", { ..._e,
            ...lt,
            min: 0
        }), this.addGuiControl("Appearance", "dashScale", { ..._e,
            ...lt,
            min: 0
        }), this.addGuiControl("Appearance", "dashOffset", { ..._e,
            ...lt
        }), this.addGuiControl("Appearance", "opacity", {
            min: 0,
            max: 1
        }), super.buildGui()
    }
}
class Pg extends xt {
    constructor(t) {
        super(t), T(this, "name", "PointerEventScreen"), this.applyOptions(t)
    }
    defineDefaultAction() {
        return { ...super.defineDefaultAction(),
            hitboxActive: !0
        }
    }
    defineTweenKeys() {
        return [...super.defineTweenKeys()]
    }
    async initMotif() {
        return this.hitbox.children.length || this.addHitbox(new Ot), this
    }
    buildGui() {
        super.buildGui()
    }
}
class Rg extends xt {
    constructor(t) {
        super(t), T(this, "name", "Instanced Mesh"), T(this, "guiIcon", "fa fa-cubes"), T(this, "mesh"), T(this, "maxCount", 50), T(this, "paragon", new ct), T(this, "color", new Qe), T(this, "instanceScale", 1), T(this, "defaultGeo", new ht), T(this, "defaultMat", new At), this.applyOptions(t)
    }
    get instanceMatrix() {
        return this.mesh.instanceMatrix
    }
    getMatrixAt(t, e) {
        this.mesh.getMatrixAt(t, e)
    }
    setMatrixAt(t, e) {
        this.mesh.setMatrixAt(t, e)
    }
    get instanceColor() {
        return this.mesh.instanceColor
    }
    getColorAt(t, e) {
        this.mesh.getColorAt(t, e)
    }
    setColorAt(t, e) {
        this.mesh.setColorAt(t, e)
    }
    set rColor(t) {
        this.color.r = t
    }
    set gColor(t) {
        this.color.g = t
    }
    set bColor(t) {
        this.color.b = t
    }
    get rColor() {
        return this.color.r
    }
    get gColor() {
        return this.color.g
    }
    get bColor() {
        return this.color.b
    }
    get material() {
        return this.mesh.material
    }
    set material(t) {
        this.defaultMat && (this.defaultMat.dispose(), this.defaultMat = null), t.color && (t.color = this.color), this.mesh.material = t
    }
    get geometry() {
        return this.mesh.geometry
    }
    set geometry(t) {
        this.defaultGeo && (this.defaultGeo.dispose(), this.defaultGeo = null), this.mesh.geometry = t
    }
    get count() {
        return this.mesh.count
    }
    set count(t) {
        this.mesh.count = t
    }
    defineDefaultAction() {
        return { ...super.defineDefaultAction(),
            rColor: 1,
            gColor: 1,
            bColor: 1,
            instanceScale: 1,
            count: 50
        }
    }
    defineTweenKeys() {
        return [...super.defineTweenKeys(), "rColor", "gColor", "bColor", "instanceScale"]
    }
    async initMotif() {
        return this.mesh = new Rp(this.defaultGeo, this.defaultMat, this.maxCount), this.add(this.mesh), this
    }
    buildGui() {
        this.addGuiControl("Appearance", "color"), this.addGuiControl("Formation", "count", {
            min: 0,
            max: this.maxCount
        }), this.addGuiControl("Scale", "instanceScale", {
            label: "Instance",
            min: 0,
            ..._e
        }), this.addGuiSeparator("Scale"), super.buildGui()
    }
}
class Dg extends Er {
    constructor(t, e, n, i) {
        const s = new OffscreenCanvas(e ? ? t.width, n ? ? t.height);
        super(s), T(this, "layers", []), T(this, "canvas"), T(this, "duration", 1e3), T(this, "ctx"), this.canvas = s, this.ctx = this.canvas.getContext("2d"), this.colorSpace = yt("colorSpace"), this.duration = Math.max(i ? ? 1e3, 0), this.layers.push(new Kf(t, 1)), this.ctx.drawImage(t, 0, 0, this.canvas.width, this.canvas.height)
    }
    addLayer(t, e = !1) {
        this.layers.length && this.layers[this.layers.length - 1].image === t || this.layers.push(new Kf(t, e ? 1 : 0))
    }
    update(t) {
        if (1 === this.layers.length && 1 === this.layers[0].opacity) return;
        let e;
        for (let n = 0; n < this.layers.length; n++) {
            const i = this.layers[n];
            this.duration ? i.opacity += 1e3 / this.duration * t : i.opacity = 1, i.opacity >= 1 && (i.opacity = 1, e = n), this.ctx.globalAlpha = i.opacity, this.ctx.drawImage(i.image, 0, 0, this.canvas.width, this.canvas.height)
        }
        e && this.layers.splice(0, e), this.needsUpdate = !0
    }
}
class Kf {
    constructor(t, e = 0) {
        T(this, "image"), T(this, "opacity"), this.image = t, this.opacity = e
    }
}
const v1 = Object.freeze(Object.defineProperty({
        __proto__: null,
        Agent: kr,
        Agent3d: ai,
        AgentBinding: Xh,
        AmbientLight: gg,
        AnchorPoint2D: dm,
        Attribution: ys,
        Background: dl,
        BlendFunction: Ae,
        BloomEffect: Yh,
        BlurEffect: mg,
        BokehEffect: cg,
        BrightnessContrastEffect: Qh,
        CANVAS_CLASSNAME: ho,
        CLOCK_FPS_DEFAULT: ka,
        CLOCK_FPS_MAX: Uh,
        CLOCK_FPS_MIN: Bh,
        CP_COLOR: Mt,
        CP_DIAL: _e,
        CP_POSITION: co,
        CP_ROTATION: um,
        CP_ROTATION_LIMITS: Lh,
        CP_UNITS_001: mn,
        CP_UNITS_01: lt,
        CP_UNITS_10: Is,
        CP_UNITS_100: Ih,
        CP_UNITS_1000: hm,
        CanvasDisplay: ul,
        CanvasMotif: bg,
        ChromaticAberrationEffect: Jh,
        Clock: zt,
        Color: Qe,
        ColorBackground: Kh,
        Config: zm,
        ControlPalette: qm,
        DATASET_INSTANCE_KEY: Ss,
        DATASET_SHOT_KEY: Dh,
        DATASET_STAGE_KEY: bo,
        DATASET_STATUS: Na,
        DOM_AVAILABLE: Mn,
        Demo: sg,
        Display: pt,
        Effect: sn,
        ErmBackground: lg,
        ErmSkyboxMotif: Ag,
        FXAAEffect: eu,
        FadeTexture: Dg,
        FloorMotif: Sg,
        GradientSkyboxMaterial: tu,
        GradientSkyboxMotif: nu,
        GridEffect: qh,
        HemisphereLight: yg,
        HueSaturationEffect: dg,
        IS_IOS: Fa,
        ImageMotif: _g,
        InstancedMeshMotif: Rg,
        KITS_ENDPOINT: Za,
        Kit: eg,
        LAYER_HITBOXES: mr,
        LAYER_VISIBLE: lo,
        LICENSE_3D_OCEAN_REGULAR: pm,
        LICENSE_CC0: vm,
        LICENSE_CC_BY_3: mm,
        LICENSE_CC_BY_4: gm,
        LICENSE_NASA_MEDIA: ym,
        LabelMotif: wg,
        LensDistortionEffect: $h,
        Light: ts,
        LineSegmentsMotif: Tg,
        Logger: To,
        MAT_BASIC: im,
        MAT_LAMBERT: rm,
        MAT_MATCAP: sm,
        MAT_PHONG: om,
        MAT_PHYSICAL: cm,
        MAT_STANDARD: lm,
        MAT_TOON: am,
        MeshMotif: Ui,
        ModelMotif: Mg,
        Motif: xt,
        NodeNetworkMotif: Eg,
        NoiseEffect: Zh,
        OFFSCREEN_CANVAS_AVAILABLE: Oh,
        OffscreenCanvasDisplay: So,
        OrbitCamera: ml,
        Pass: pl,
        PixelationEffect: ug,
        PlinthGeometry: iu,
        PlinthMotif: Cg,
        Plugin: ng,
        PluginRegistry: Ao,
        PointCloudMotif: vl,
        PointLight: xg,
        PointerEventScreenMotif: Pg,
        Post: fl,
        PublicEventTarget: tl,
        RenderManager: Wh,
        SMAAEffect: pg,
        SMAAPreset: Un,
        SOURCE_3D_OCEAN: bm,
        SOURCE_PEXELS: Am,
        SOURCE_POLY_PIZZA: xm,
        SOURCE_SKETCHFAB: Sm,
        ScanlinesEffect: fg,
        SceneController: jh,
        Sequence: Fr,
        SequenceStep: gr,
        Shot: Gt,
        SkyboxMotif: gl,
        SpotLight: vg,
        Stage: wn,
        StageAttributionEvent: Ii,
        StageBuilder: kn,
        StageCanvasEvent: es,
        StageContentEvent: Ct,
        StageCustomEvent: Li,
        StageEvent: _t,
        StageEventTarget: el,
        StageHoverEvent: Di,
        StageSetupEvent: Ls,
        VignetteEffect: hg,
        WorkerDemo: rg,
        WorkerInternal: Zm,
        WorkerManager: $m,
        addBarycentricCoordinates: Ym,
        addIconToTpFolder: ti,
        applyNulls: kh,
        attachToWindow: Om,
        bloatGeo: Qm,
        camelToName: Em,
        defaultConfig: nl,
        defaultRenderTargetConfig: il,
        elementInViewport: Im,
        fa: ei,
        filterDatasetByPrefix: ws,
        filterObject: Fh,
        geometryToLineGeometry: cl,
        getAncestryDataset: _s,
        getAssetPath: Bi,
        getCookie: Dm,
        getGuid: pi,
        getPrefixedDataset: za,
        hexToCol: Rt,
        initBenchmarkMode: hl,
        loadBitmap: Pr,
        loadBitmapTexture: Vm,
        loadDataTexture: ss,
        loadGLB: al,
        loadImage: ll,
        loadModel: rl,
        loadOBJ: ol,
        loadSVG: Vh,
        loadTexture: tn,
        loadVideo: Hh,
        mergeAgentActions: Rr,
        meshToLineSegments: Km,
        mirrorObject: Ja,
        numToXYZ: gn,
        objSnapshot: si,
        objTrim: Lm,
        odds: Rm,
        onNextFrame: Ri,
        processLazyLoadActions: sl,
        publicStageEventMapKeys: $a,
        rand: Pm,
        randomPointInSphere: zh,
        randomPointOnSphere: Bm,
        restoreDatasetByPrefix: Xm,
        roundObjectMembers: fn,
        serialiseForTransfer: vn,
        sleep: Nh,
        tick: Tm,
        vecToXYZ: Mm,
        waitForEvent: Cm
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    Yf = new Ui({
        name: "Zeppy Float",
        guiIcon: "fa-solid fa-user-astronaut",
        defaultAction: {
            enterFrom: {
                yPosition: -10
            },
            exitTo: {
                yPosition: 10
            },
            show: {
                delay: 500,
                timingFunction: yn.Quadratic.Out
            },
            hide: {
                timingFunction: yn.Quadratic.In
            },
            animate(t, e) {
                return this.yPositionOffset = .2 * Math.sin(e / 3), this.zRotationOffset = .1 * Math.sin(e / 2), this.userData.camera && this.lookAt(this.userData.camera.getWorldPosition(this.userData.lookAt)), !0
            },
            userData: {
                lookAt: new U
            }
        },
        async afterInit() {
            this.geometry = new Ot(1.5, 682 * .003), this.material = new At({
                map: await tn("zeppy-float.png"),
                alphaMap: await ss("zeppy-float-alpha.png"),
                transparent: !0,
                alphaTest: .001
            })
        }
    }),
    Qf = new Ui({
        name: "Zeppy Profile",
        guiIcon: "fa-solid fa-user-astronaut",
        defaultAction: {
            duration: 2500,
            xPosition: 1,
            yPosition: -.7,
            zPosition: .5,
            enterFrom: {
                xPosition: 5,
                zPosition: 4
            },
            exitTo: {
                xPosition: 5,
                zPosition: 4
            },
            animate(t, e) {
                return this.userData.camera && this.lookAt(this.userData.camera.getWorldPosition(this.userData.lookAt)), !0
            },
            userData: {
                lookAt: new U
            }
        },
        async afterInit() {
            this.geometry = new Ot(2.241, 1252 * .003), this.material = new At({
                map: await tn("profile.png"),
                alphaMap: await ss("profile-alpha.png"),
                transparent: !0,
                alphaTest: .001,
                polygonOffset: !0,
                polygonOffsetFactor: -10,
                polygonOffsetUnits: 10
            })
        }
    }),
    qf = new Ui({
        name: "Zeppy Back",
        guiIcon: "fa-solid fa-user-astronaut",
        defaultAction: {
            duration: 2500,
            xPosition: -.08,
            yPosition: -.8,
            zPosition: .5,
            ...gn(1.2, "Scale"),
            enterFrom: {
                yPosition: -5,
                zPosition: 4
            },
            exitTo: {
                yPosition: -5,
                zPosition: 4
            },
            animate(t, e) {
                return this.userData.camera && this.lookAt(this.userData.camera.getWorldPosition(this.userData.lookAt)), !0
            },
            userData: {
                lookAt: new U
            }
        },
        async afterInit() {
            this.geometry = new Ot(1.6575, 2.235), this.material = new At({
                map: await tn("zeppy-back.png"),
                alphaMap: await ss("zeppy-back-alpha.png"),
                transparent: !0,
                alphaTest: .001
            })
        }
    }),
    s1 = new Ui({
        name: "Zeppy Controls",
        guiIcon: "fa-solid fa-user-astronaut",
        defaultAction: {
            duration: 2500,
            xPosition: -.08,
            yPosition: -.55,
            zPosition: .5,
            enterFrom: {
                xPosition: 5,
                zPosition: 4
            },
            exitTo: {
                xPosition: 5,
                zPosition: 4
            },
            renderOrder: 300,
            animate(t, e) {
                return this.lookAt(this.stage.camera.getWorldPosition(this.userData.lookAt)), !0
            },
            userData: {
                lookAt: new U
            }
        },
        async afterInit() {
            this.geometry = new Ot(938 * .002, 2.47), this.material = new At({
                map: await tn("zeppy-controls.png"),
                alphaMap: await ss("zeppy-controls-alpha.png"),
                transparent: !0,
                alphaTest: .001,
                depthTest: !1
            })
        }
    }),
    r1 = new Ui({
        name: "Spaceship Window",
        guiIcon: "fa-solid fa-user-astronaut",
        defaultAction: {
            duration: 2500,
            xPosition: -.08,
            yPosition: -.9,
            zPosition: -1,
            enterFrom: {
                zPosition: 4
            },
            exitTo: {
                zPosition: 4
            },
            userData: {
                lookAt: new U
            }
        },
        async afterInit() {
            this.geometry = new Ot(8, 8), this.material = new At({
                map: await tn("window2.png"),
                alphaMap: await ss("window2-alpha.png"),
                transparent: !0,
                alphaTest: .001
            });
            const t = new _h(5, 30, 4, 1, Math.PI / 4),
                e = new At({
                    color: "#162324"
                }),
                n = new be(t, e);
            this.add(n)
        }
    });

function Ig(t, e, n, i, s) {
    return i + (t - e) * (s - i) / (n - e)
}

function Zf(t) {
    return t * (.5 - Math.random())
}
class o1 extends xt {
    constructor(t) {
        super(t), st(this, "name", "Line Matrix"), st(this, "beams", 50), st(this, "mesh", new Eo), this.applyOptions(t)
    }
    get mat() {
        return this.mesh.material
    }
    get color() {
        return this.mesh.material.color
    }
    set rColor(t) {
        this.color.r = t
    }
    set gColor(t) {
        this.color.g = t
    }
    set bColor(t) {
        this.color.b = t
    }
    get rColor() {
        return this.color.r
    }
    get gColor() {
        return this.color.g
    }
    get bColor() {
        return this.color.b
    }
    set opacity(t) {
        this.mat.opacity = t
    }
    set linewidth(t) {
        this.mat.linewidth = t
    }
    set gapSize(t) {
        this.mat.gapSize = t
    }
    set dashSize(t) {
        this.mat.dashSize = t
    }
    set dashScale(t) {
        this.mat.dashScale = t
    }
    set dashOffset(t) {
        this.mat.dashOffset = t
    }
    get opacity() {
        return this.mat.opacity
    }
    get linewidth() {
        return this.mat.linewidth
    }
    get gapSize() {
        return this.mat.gapSize
    }
    get dashSize() {
        return this.mat.dashSize
    }
    get dashScale() {
        return this.mat.dashScale
    }
    get dashOffset() {
        return this.mat.dashOffset
    }
    defineDefaultAction() {
        return { ...super.defineDefaultAction(),
            rColor: 1,
            gColor: 1,
            bColor: 1,
            opacity: 1,
            linewidth: .1,
            gapSize: 1,
            dashSize: 1,
            dashScale: 1,
            dashOffset: 0,
            renderOrder: 1,
            enterFrom: {
                linewidth: .05,
                ...Rt("#000")
            },
            exitTo: {
                linewidth: .05,
                ...Rt("#000")
            }
        }
    }
    defineTweenKeys() {
        return [...super.defineTweenKeys(), "rColor", "gColor", "bColor", "opacity", "linewidth", "gapSize", "dashSize", "dashScale", "dashOffset"]
    }
    defineGuiConfig() {
        return { ...super.defineGuiConfig(),
            dashOffset: "hidden"
        }
    }
    async initMotif() {
        const t = new Nr({
            linewidth: this.defaultAction.linewidth,
            worldUnits: !0,
            fog: !0,
            transparent: !0,
            dashed: !0,
            dashSize: 1,
            dashScale: 1,
            gapSize: 1,
            dashOffset: 0,
            opacity: this.defaultAction.opacity,
            blending: 2,
            color: new Qe(this.defaultAction.rColor, this.defaultAction.gColor, this.defaultAction.bColor)
        });
        Qe.replaceColors(t), this.mesh.material = t;
        const e = [];
        for (let t = 0; t < this.beams; t++) {
            const t = Zf(1),
                n = Zf(1);
            e.push(t, -1, n), e.push(t, 1, n)
        }
        const n = new xo;
        return n.setPositions(e), this.mesh.geometry = n, this.mesh.computeLineDistances(), this.add(this.mesh), this
    }
    buildGui() {
        this.addGuiControl("Appearance", "color", { ...Mt
        }), this.addGuiControl("Appearance", "linewidth", { ..._e,
            ...mn
        }), this.addGuiControl("Appearance", "opacity", {
            min: 0,
            max: 1
        }), this.addGuiControl("Dash", "dashSize", { ..._e,
            min: 0
        }), this.addGuiControl("Dash", "gapSize", { ..._e,
            min: 0
        }), this.addGuiControl("Dash", "dashScale", { ..._e
        }), this.addGuiControl("Dash", "dashOffset", { ..._e
        }), super.buildGui()
    }
    animate(t, e) {
        this.dashOffset = (e + this.animationOffset) * this.animationSpeed % (this.dashSize + this.gapSize)
    }
}
class a1 extends Ui {
    constructor(t) {
        super(t), st(this, "name", "Halo"), st(this, "color", new Qe), st(this, "alphaMap"), st(this, "canvas", new OffscreenCanvas(1, 200)), st(this, "ctx"), st(this, "_offset", 0), st(this, "gradientFunction", yn.Exponential.In), st(this, "v3Lookat", new U), this.applyOptions(t)
    }
    requestRedraw() {
        this.transients.redraw = !0
    }
    get offset() {
        return this._offset
    }
    set offset(t) {
        this._offset = t, this.requestRedraw()
    }
    get opacity() {
        return this.material.opacity
    }
    set opacity(t) {
        this.material.opacity = t, this.requestRedraw()
    }
    defineDefaultAction() {
        return { ...super.defineDefaultAction(),
            offset: 0,
            renderOrder: 100,
            opacity: 1,
            enterFrom: { ...Rt("#000")
            },
            exitTo: { ...Rt("#000")
            }
        }
    }
    defineTweenKeys() {
        return [...super.defineTweenKeys(), "offset", "opacity"]
    }
    async initMotif() {
        return super.initMotif(), this.geometry = new ja(1, 1, 60, void 0, !0), this.geometry.translate(0, .5, 0), this.geometry.rotateX(-Math.PI / 2), this.alphaMap = new Er(this.canvas), this.material = new At({
            blending: 2,
            alphaMap: this.alphaMap,
            transparent: !0,
            side: Bt,
            fog: !1
        }), this.ctx = this.canvas.getContext("2d"), this.redraw(), this
    }
    redraw() {
        const t = this.ctx.createLinearGradient(0, 0, 0, 200),
            e = new Qe;
        t.addColorStop(0, "#fff"), t.addColorStop(this.offset, "#fff");
        for (let n = .1; n < 1; n += .1) e.setHSL(0, 0, this.gradientFunction(n)), t.addColorStop(Ig(n, 1, 0, this.offset, 1), `#${e.getHexString()}`);
        t.addColorStop(1, "#000"), this.ctx.fillStyle = t, this.ctx.fillRect(0, 0, 1, 200), this.alphaMap.needsUpdate = !0, this.material.needsUpdate = !0
    }
    buildGui() {
        super.buildGui(), this.addGuiControl("Appearance", "opacity", {
            min: 0,
            max: 1
        }), this.addGuiControl("Appearance", "offset", {
            min: 0,
            max: 1
        })
    }
    animate(t, e) {
        this.lookAt(this.stage.camera.getWorldPosition(this.v3Lookat)), this.transients.redraw && this.redraw()
    }
}
class Lg extends xt {
    constructor(t) {
        super(t), st(this, "name", "Planet"), st(this, "guiIcon", "fa-planet-ringed fa-solid"), st(this, "surfaceMatcapPath", "planet-matcap.png"), st(this, "cloudsAlphaMatcapPath", "alpha-matcap.png"), st(this, "cloudsMapPath", "clouds.png"), st(this, "cloudsRepeat", 1), st(this, "partial", !1), st(this, "surfaceColor", new Qe), st(this, "cloudColor", new Qe), st(this, "cloudMaterial"), this.applyOptions(t)
    }
    get rSurfaceColor() {
        return this.surfaceColor.r
    }
    get gSurfaceColor() {
        return this.surfaceColor.g
    }
    get bSurfaceColor() {
        return this.surfaceColor.b
    }
    set rSurfaceColor(t) {
        this.surfaceColor.r = t
    }
    set gSurfaceColor(t) {
        this.surfaceColor.g = t
    }
    set bSurfaceColor(t) {
        this.surfaceColor.b = t
    }
    get rCloudColor() {
        return this.cloudColor.r
    }
    get gCloudColor() {
        return this.cloudColor.g
    }
    get bCloudColor() {
        return this.cloudColor.b
    }
    set rCloudColor(t) {
        this.cloudColor.r = t
    }
    set gCloudColor(t) {
        this.cloudColor.g = t
    }
    set bCloudColor(t) {
        this.cloudColor.b = t
    }
    set cloudOffset(t) {
        this.cloudMaterial.map.offset.y = t
    }
    get cloudOffset() {
        return this.cloudMaterial.map.offset.y
    }
    defineDefaultAction() {
        return { ...super.defineDefaultAction(),
            rSurfaceColor: 1,
            gSurfaceColor: 1,
            bSurfaceColor: 1,
            rCloudColor: .6,
            gCloudColor: .6,
            bCloudColor: .6
        }
    }
    defineTweenKeys() {
        return [...super.defineTweenKeys(), "rSurfaceColor", "gSurfaceColor", "bSurfaceColor", "rCloudColor", "gCloudColor", "bCloudColor"]
    }
    async initMotif() {
        const t = this.partial ? new Or(1, 64, 32, 0, Math.PI, Math.PI - 2, 2) : new Qa(1, 6),
            e = new zc({
                matcap: await tn(this.surfaceMatcapPath)
            });
        e.color = this.surfaceColor;
        const n = await tn(this.cloudsMapPath);
        n.repeat.set(this.cloudsRepeat, this.cloudsRepeat), n.wrapS = n.wrapT = 1e3;
        const i = new zc({
            matcap: await tn(this.cloudsAlphaMatcapPath),
            blending: 3,
            transparent: !0,
            map: n,
            polygonOffset: !0,
            polygonOffsetFactor: -1
        });
        return i.color = this.cloudColor, this.cloudMaterial = i, this.add(new be(t, e)), this.add(new be(t, i)), this
    }
    buildGui() {
        this.addGuiControl("Appearance", "surfaceColor", { ...Mt
        }), this.addGuiControl("Appearance", "cloudColor", { ...Mt
        }), super.buildGui()
    }
}
const l1 = "#define GLSLIFY 1\nuniform vec3 iColor; // Inner\nuniform vec3 oColor; // Outer\n\nuniform float iStrength;\nuniform float oStrength;\n\nuniform float glow;\n// uniform float coefficient;\nuniform float power;\n\nvarying vec3 vVertexNormal;\nvarying vec3 vVertexWorldPosition;\nvarying vec4 vFragColor;\n\nvoid main(){\n    vec3 worldCameraToVertex= vVertexWorldPosition - cameraPosition;\n    vec3 viewCameraToVertex\t= (viewMatrix * vec4(worldCameraToVertex, 0.0)).xyz;\n    viewCameraToVertex= normalize(viewCameraToVertex);\n\n    float angle = pow(0.1 + dot(vVertexNormal, viewCameraToVertex), power);\n    float opacity = smoothstep(iStrength, oStrength, angle);\n\n    vec3 fColor = mix(oColor, iColor, smoothstep(0.0, glow, opacity));\n    fColor = mix(vec3(0.0), fColor, opacity);\n\n    gl_FragColor = vec4(fColor, 1.0);\n}",
    c1 = "#define GLSLIFY 1\nvarying vec3\tvVertexWorldPosition;\nvarying vec3\tvVertexNormal;\n\nvarying vec4\tvFragColor;\n\nvoid main(){\n    vVertexNormal = normalize(normalMatrix * normal);\n    vVertexWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\n\n    // set gl_Position\n    gl_Position\t= projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}";
class h1 extends It {
    get iStrength() {
        return this.uniforms.iStrength.value
    }
    set iStrength(t) {
        this.uniforms.iStrength.value = t
    }
    get oStrength() {
        return this.uniforms.oStrength.value
    }
    set oStrength(t) {
        this.uniforms.oStrength.value = t
    }
    get power() {
        return this.uniforms.power.value
    }
    set power(t) {
        this.uniforms.power.value = t
    }
    get innerColor() {
        return this.uniforms.iColor.value
    }
    set innerColor(t) {
        this.uniforms.iColor.value = t
    }
    get outerColor() {
        return this.uniforms.oColor.value
    }
    set outerColor(t) {
        this.uniforms.oColor.value = t
    }
    get glow() {
        return this.uniforms.glow.value
    }
    set glow(t) {
        this.uniforms.glow.value = t
    }
    constructor() {
        super({
            uniforms: {
                iColor: {
                    value: new Qe("#fff")
                },
                oColor: {
                    value: new Qe("#fff")
                },
                glow: {
                    value: .2
                },
                power: {
                    value: 2
                },
                iStrength: {
                    value: .2
                },
                oStrength: {
                    value: .9
                }
            },
            fragmentShader: l1,
            vertexShader: c1,
            side: Bt,
            blending: 2,
            transparent: !0,
            depthWrite: !1
        })
    }
}
class Og extends xt {
    constructor(t) {
        super(t), st(this, "name", "Atmousphere"), st(this, "inner", new Qe), st(this, "outer", new Qe), st(this, "material"), this.applyOptions(t)
    }
    get rInner() {
        return this.inner.r
    }
    get gInner() {
        return this.inner.g
    }
    get bInner() {
        return this.inner.b
    }
    set rInner(t) {
        this.inner.r = t
    }
    set gInner(t) {
        this.inner.g = t
    }
    set bInner(t) {
        this.inner.b = t
    }
    get rOuter() {
        return this.outer.r
    }
    get gOuter() {
        return this.outer.g
    }
    get bOuter() {
        return this.outer.b
    }
    set rOuter(t) {
        this.outer.r = t
    }
    set gOuter(t) {
        this.outer.g = t
    }
    set bOuter(t) {
        this.outer.b = t
    }
    get innerStrength() {
        return this.material.iStrength
    }
    set innerStrength(t) {
        this.material.iStrength = t
    }
    get outerStrength() {
        return this.material.oStrength
    }
    set outerStrength(t) {
        this.material.oStrength = t
    }
    get power() {
        return this.material.power
    }
    set power(t) {
        this.material.power = t
    }
    get glow() {
        return this.material.glow
    }
    set glow(t) {
        this.material.glow = t
    }
    defineDefaultAction() {
        return { ...super.defineDefaultAction(),
            rInner: 1,
            gInner: 1,
            bInner: 1,
            rOuter: 0,
            gOuter: 1,
            bOuter: 1,
            innerStrength: .2,
            outerStrength: .9,
            power: 2,
            enterFrom: { ...Rt("#000", "Inner"),
                ...Rt("#000", "Outer")
            },
            exitTo: { ...Rt("#000", "Inner"),
                ...Rt("#000", "Outer")
            }
        }
    }
    defineTweenKeys() {
        return [...super.defineTweenKeys(), "rInner", "gInner", "bInner", "rOuter", "gOuter", "bOuter", "innerStrength", "power"]
    }
    async initMotif() {
        const t = new Qa(1, 6);
        this.material = new h1, this.material.innerColor = this.inner, this.material.outerColor = this.outer;
        const e = new be(t, this.material);
        return this.add(e), this
    }
    buildGui() {
        this.addGuiControl("Appearance", "inner", { ...Mt
        }), this.addGuiControl("Appearance", "outer", { ...Mt
        }), this.addGuiControl("Appearance", "innerStrength", {
            min: 0,
            max: 1
        }), this.addGuiControl("Appearance", "outerStrength", {
            min: 0,
            max: 1
        }), this.addGuiControl("Appearance", "power", {
            min: 0,
            max: 5
        }), this.addGuiControl("Appearance", "glow", {
            min: 0,
            max: 1
        }), super.buildGui()
    }
}
class u1 extends xt {
    constructor(t) {
        super(t), st(this, "name", "Window"), st(this, "guiIcon", "fa-light fa-square"), st(this, "color", new Qe), st(this, "frameMesh"), st(this, "wallMesh"), st(this, "_radius", .2), st(this, "_height", 1), st(this, "_width", 1), st(this, "_thickness", .02), this.applyOptions(t)
    }
    get frameGeometry() {
        return this.frameMesh.geometry
    }
    set frameGeometry(t) {
        var e;
        null != (e = this.frameMesh) && e.geometry && this.frameMesh.geometry.dispose(), this.frameMesh.geometry = t
    }
    get material() {
        return this.frameMesh.material
    }
    get wallGeometry() {
        return this.wallMesh.geometry
    }
    set wallGeometry(t) {
        var e;
        null != (e = this.wallMesh) && e.geometry && this.wallMesh.geometry.dispose(), this.wallMesh.geometry = t
    }
    get rColor() {
        return this.color.r
    }
    get gColor() {
        return this.color.g
    }
    get bColor() {
        return this.color.b
    }
    set rColor(t) {
        this.color.r = t
    }
    set gColor(t) {
        this.color.g = t
    }
    set bColor(t) {
        this.color.b = t
    }
    get radius() {
        return this._radius
    }
    set radius(t) {
        this._radius = t, this.requestQueueRebuild()
    }
    get height() {
        return this._height
    }
    set height(t) {
        this._height = t, this.requestQueueRebuild()
    }
    get width() {
        return this._width
    }
    set width(t) {
        this._width = t, this.requestQueueRebuild()
    }
    get thickness() {
        return this._thickness
    }
    set thickness(t) {
        this._thickness = t, this.requestQueueRebuild()
    }
    defineDefaultAction() {
        return { ...super.defineDefaultAction(),
            rColor: 1,
            gColor: 1,
            bColor: 1,
            height: 1,
            width: 1,
            radius: .15,
            thickness: .02,
            zPosition: -1,
            renderOrder: 200,
            enterFrom: {
                yPosition: -1,
                zPosition: 4
            },
            exitTo: {
                yPosition: -1,
                zPosition: 4
            }
        }
    }
    defineTweenKeys() {
        return [...super.defineTweenKeys(), "rColor", "gColor", "bColor", "height", "width", "radius", "thickness"]
    }
    async initMotif() {
        const t = new At({
            depthTest: !1,
            transparent: !0
        });
        t.color = this.color, this.frameMesh = new be(void 0, t), this.frameMesh.scale.setScalar(3.64), this.frameMesh.position.y = -1.75, this.add(this.frameMesh), this.frameMesh.renderOrder = 1, this.wallMesh = new be(void 0, new At({
            color: "#162324",
            depthTest: !1,
            transparent: !0
        })), this.wallMesh.position.z = -.01, this.wallMesh.scale.setScalar(3.64), this.wallMesh.position.y = -1.75, this.wallMesh.renderOrder = 0, this.rebuildGeometry(), this.add(this.wallMesh);
        const e = new be(new Ot(1.507, .438), new At({
            map: await tn("console-shifted.png"),
            alphaMap: await tn("console-alpha.png"),
            transparent: !0,
            alphaTest: .01,
            depthTest: !1
        }));
        return e.scale.setScalar(3), e.position.set(0, -1.25, .01), this.add(e), e.renderOrder = 2, this
    }
    requestQueueRebuild() {
        this.transients.needsRebuild = !0
    }
    rebuildGeometry() {
        const t = new Ji,
            e = new Ji,
            n = new Ji,
            i = this.width / 2,
            s = Math.min(this.radius, i, this.height),
            r = this.height - s,
            o = this.thickness;
        t.moveTo(-i, 0), t.lineTo(-i, r), t.absarc(-i + s, r, s, Math.PI, .5 * Math.PI, !0), t.absarc(i - s, r, s, .5 * Math.PI, 0, !0), t.lineTo(i, 0), t.lineTo(i + o, 0), t.absarc(i - s, r, s + o, 0, .5 * Math.PI, !1), t.absarc(-i + s, r, s + o, .5 * Math.PI, Math.PI, !1), t.lineTo(-i - o, 0), t.closePath(), e.moveTo(-i - o / 2, 0), e.lineTo(-i - o / 2, r), e.absarc(-i + s, r, s + o / 2, Math.PI, .5 * Math.PI, !0), e.absarc(i - s, r, s + o / 2, .5 * Math.PI, 0, !0), e.lineTo(i + o / 2, 0), e.closePath(), n.moveTo(-50, -50), n.lineTo(50, -50), n.lineTo(50, 50), n.lineTo(-50, 50), n.closePath(), n.holes.push(e), this.frameGeometry = new Ba(t), this.wallGeometry = new Ba(n)
    }
    animate(t, e) {
        this.transients.needsRebuild && this.rebuildGeometry()
    }
    buildGui() {
        this.addGuiControl("Appearance", "color", { ...Mt
        }), this.addGuiControl("Geometry", "width", {
            min: .01,
            ...lt
        }), this.addGuiControl("Geometry", "height", {
            min: .01,
            ...lt
        }), this.addGuiControl("Geometry", "radius", {
            min: .01,
            ...lt
        }), this.addGuiControl("Geometry", "thickness", {
            min: .01,
            ...mn
        }), super.buildGui()
    }
}
const d1 = new Lg({
        defaultAction: {
            duration: 3500,
            ...gn(5, "Scale"),
            zPosition: -20,
            xRotation: .3,
            zRotation: .6,
            change: {
                yRotationOffset: null
            },
            enterFrom: {
                xPosition: -40,
                yPosition: 0,
                zPosition: 0,
                ...gn(0, "Scale")
            },
            exitTo: {
                xPosition: -40,
                yPosition: 0,
                zPosition: 0,
                ...gn(0, "Scale")
            },
            show: {
                timingFunction: yn.Quadratic.Out
            },
            hide: {
                timingFunction: yn.Quadratic.In
            },
            animate(t, e) {
                return this.yRotationOffset -= .3 * t * this.animationSpeed, !0
            }
        }
    }),
    f1 = new Lg({
        name: "Big Planet",
        surfaceMatcapPath: "big-planet-matcap.png",
        cloudsAlphaMatcapPath: "alpha-big-planet-matcap.png",
        cloudsMapPath: "clouds-big-planet.png",
        cloudsRepeat: 6,
        partial: !0,
        defaultAction: {
            duration: 3e3,
            ...gn(28, "Scale"),
            yPosition: -32,
            zPosition: -10,
            xRotation: -Math.PI / 2,
            show: {
                timingFunction: yn.Quadratic.Out
            },
            hide: {
                timingFunction: yn.Quadratic.In
            },
            animate(t, e) {
                return this.cloudOffset += .04 * t * this.animationSpeed, !0
            }
        },
        children: [new Og({
            defaultAction: {
                visible: !0,
                ...Rt("#00fff6", "Inner"),
                ...Rt("#2fc7ff", "Outer"),
                innerStrength: .2,
                outerStrength: .9,
                power: 2,
                ...gn(1.2, "Scale")
            }
        })]
    });
new Og({});
const p1 = new Ui({
    name: "Spaceship",
    guiIcon: "fa-solid fa-starfighter",
    async afterInit() {
        const t = await rl("spaceship-smooth.glb");
        this.geometry = t.geometry, this.geometry.scale(.5, .5, .5), this.material = new zc({
            flatShading: !1,
            matcap: await tn("metal-matcap.png")
        })
    },
    defaultAction: {
        animate(t, e) {
            return this.zRotationOffset += .5 * t, !0
        }
    }
});

function Tc(t, e, n) {
    return Math.max(e, Math.min(n, t))
}
new kn({
    name: "Zeppy",
    key: "zeppy",
    buildStage(t) {
        const e = {};
        e.sky = new nu({
            defaultAction: { ...Rt("#162324", "Zenith"),
                ...Rt("#162324", "Horizon"),
                ...Rt("#162324", "Nadir")
            }
        }), e.zeppyFloat = Yf, e.zeppyProfile = Qf, e.zeppyBack = qf, e.zeppyControls = s1, e.spaceshipWindow = r1, e.beams = new o1({
            beams: 60,
            defaultAction: {
                yScale: 30,
                xScale: 30,
                zScale: 20,
                zPosition: -9,
                ...Rt("#487c74"),
                dashSize: .3,
                gapSize: 9.2,
                dashScale: .9,
                linewidth: .05,
                animationSpeed: .3
            }
        }), e.beams2 = e.beams.clone({
            beams: 20,
            defaultAction: { ...Rt("#999"),
                animationSpeed: .7
            }
        }), e.stars = new vl({
            name: "Stars",
            guiIcon: "fa-solid fa-star",
            imagePath: "/star2.png",
            defaultAction: {
                count: 150,
                size: 1,
                animationSpeed: 0,
                xScale: 70,
                yScale: 80,
                zScale: 20,
                yPosition: 10,
                zPosition: -80
            }
        }), e.planet = d1, e.bigPlanet = f1, e.spaceship = p1, e.window = new u1({}), e.halo = new a1({
            defaultAction: {
                duration: 2e3,
                ...gn(2, "Scale"),
                opacity: 1,
                offset: .2,
                ...Rt("#107368"),
                animate(t, n) {
                    return this.scale.setScalar(2 * e.planet.xScale), this.position.copy(e.planet.position), !0
                }
            }
        });
        const n = new wn({ ...t,
            scene: {
                defaultAction: { ...Rt("#444", "FogColor"),
                    fogDistance: 10,
                    fogDepth: 250
                }
            },
            effectControllers: {
                bc: new Qh({}),
                grid: new qh({
                    blendFunction: Ae.OVERLAY,
                    states: {
                        off: {
                            opacity: 0
                        }
                    },
                    defaultAction: {
                        duration: 1e3,
                        opacity: .15,
                        linewidth: .001,
                        scale: 3
                    }
                }),
                chrom: new Jh({
                    states: {
                        off: {
                            xOffset: 0,
                            yOffset: 0
                        }
                    },
                    defaultAction: {
                        duration: 1e3,
                        xOffset: .001,
                        yOffset: .001
                    }
                }),
                noise: new Zh({
                    premultiply: !0,
                    blendFunction: Ae.ADD,
                    states: {
                        off: {
                            opacity: 0
                        }
                    },
                    defaultAction: {
                        duration: 1e3,
                        opacity: .15
                    }
                }),
                lens: new $h({
                    states: {
                        off: {
                            xDistortion: 0,
                            yDistortion: 0,
                            xFocalLength: 1,
                            yFocalLength: 1
                        }
                    },
                    defaultAction: {
                        duration: 1e3,
                        xDistortion: .03,
                        yDistortion: .03,
                        xFocalLength: .93,
                        yFocalLength: .93
                    }
                }),
                FXAA: new eu({
                    defaultAction: {
                        samples: 16
                    }
                }),
                bloom: new Yh({
                    defaultAction: {
                        threshold: .5,
                        intensity: 1,
                        radius: .7
                    }
                })
            },
            background: new Kh({
                defaultAction: { ...Rt("#444")
                }
            }),
            cameraController: new ml({
                defaultAction: {
                    tiltFactor: 1,
                    bindings: {
                        xTiltAmount: {
                            key: "xMouse",
                            speed: .3
                        },
                        yTiltAmount: {
                            key: "yMouse",
                            speed: .3,
                            callback: t => t / 4
                        }
                    }
                }
            }),
            lightControllers: {},
            motifs: e
        });
        Yf.userData.camera = n.camera, Qf.userData.camera = n.camera, qf.userData.camera = n.camera, n.addShot(new Gt({
            name: "Default",
            key: "default",
            stageAction: t => {
                let {
                    xFocalPoint: e = 0,
                    yFocalPoint: i = 0,
                    crt: s,
                    brightness: r = 0,
                    contrast: o = 0
                } = t.data;
                return r = parseFloat(r), o = parseFloat(o), e = parseFloat(e), i = parseFloat(i), "false" === s && (s = !1), {
                    scene: {
                        yRotation: null
                    },
                    camera: {
                        fov: n.isLandscape ? 50 : 70,
                        xFocalPoint: e,
                        yFocalPoint: i
                    },
                    motifs: {
                        sky: !0
                    },
                    effects: {
                        noise: {
                            opacity: s ? .6 : void 0
                        },
                        bc: {
                            brightness: r,
                            contrast: o
                        },
                        bloom: {
                            intensity: s ? 2 : void 0
                        },
                        grid: s ? {} : "off",
                        chrom: s ? {
                            xOffset: n.isLandscape ? .001 : 0,
                            yOffset: n.isPortrait ? .002 : 0
                        } : "off",
                        lens: s ? {} : "off"
                    }
                }
            }
        }));
        const i = new Gt({
            key: "space",
            name: "Space",
            stageAction: t => (t.data, {
                motifs: {
                    planet: n.isLandscape ? {
                        xPosition: -12,
                        yPosition: 4,
                        zPosition: -30
                    } : {
                        xPosition: -5,
                        yPosition: 10,
                        zPosition: -30
                    },
                    bigPlanet: {
                        yPosition: -34
                    },
                    halo: !0,
                    stars: !0
                },
                camera: {
                    zPosition: 4,
                    bindings: {
                        xTiltAmount: {
                            key: "xMouse",
                            speed: .3,
                            callback: t => .4 * t
                        }
                    }
                }
            })
        });
        n.addShot(i);
        const s = new Gt({
            key: "profile",
            name: "Profile",
            stageAction: t => {
                let {
                    brightness: e = 0
                } = t.data;
                return e = parseFloat(e), {
                    motifs: {
                        planet: n.isLandscape ? {
                            xPosition: -12,
                            yPosition: 4,
                            zPosition: -30
                        } : {
                            xPosition: -5,
                            yPosition: 10,
                            zPosition: -30
                        },
                        halo: !0,
                        zeppyProfile: {
                            rColor: e + 1,
                            gColor: e + 1,
                            bColor: e + 1,
                            ...n.isLandscape ? {
                                xPosition: 1.5
                            } : {
                                xPosition: .5,
                                yPosition: -1.5
                            }
                        },
                        stars: !0
                    },
                    camera: {
                        zPosition: 4,
                        bindings: {
                            xTiltAmount: {
                                key: "xMouse",
                                speed: .3,
                                callback: t => .4 * t
                            }
                        }
                    }
                }
            }
        });
        n.addShot(s);
        const r = new Gt({
            key: "controls",
            name: "Controls",
            stageAction: t => ({
                defaults: {
                    delay: 2e3
                },
                motifs: {
                    sky: { ...Rt("#000", "Zenith"),
                        ...Rt("#000", "Horizon"),
                        ...Rt("#000", "Nadir")
                    },
                    planet: n.isLandscape ? {
                        xPosition: -12,
                        yPosition: 4,
                        zPosition: -30
                    } : {
                        xPosition: -9,
                        yPosition: 4,
                        zPosition: -30
                    },
                    halo: !0,
                    zeppyControls: n.isPortrait ? {
                        yPosition: -1,
                        ...gn(1.25, "Scale")
                    } : {},
                    window: { ...n.isLandscape ? { ...gn(1.1, "Scale"),
                            thickness: .006
                        } : {},
                        ...n.aspect < 1 ? {
                            height: 1.4,
                            yPosition: -.7
                        } : {},
                        ...n.aspect < .7 ? {
                            height: 1.5,
                            yPosition: -.7,
                            ...gn(.9, "Scale")
                        } : {},
                        ...n.aspect < .6 ? {
                            height: 1.5,
                            yPosition: -1,
                            ...gn(.7, "Scale")
                        } : {}
                    },
                    stars: !0
                },
                camera: {
                    zPosition: 4,
                    bindings: {
                        xTiltAmount: {
                            key: "xMouse",
                            speed: .3,
                            callback: t => .5 * t
                        },
                        yTiltAmount: {
                            key: "yMouse",
                            speed: .3,
                            callback: t => .5 * t
                        },
                        xTiltFactor: {
                            key: "heroOffset",
                            speed: .4,
                            callback: t => Ig(Tc(t, 0, .4), 0, .4, .7, .2)
                        },
                        yTiltFactor: {
                            key: "heroOffset",
                            speed: .4,
                            callback: t => Tc(.5 * (1 - t), .2, .7)
                        },
                        yFocalPoint: {
                            key: "heroOffset",
                            speed: 1,
                            callback: t => Tc(2 * -t, -2, 0)
                        }
                    }
                }
            })
        });
        n.addShot(r);
        const o = new Gt({
            key: "back",
            name: "Back",
            stageAction: t => {
                let {
                    brightness: e = 0
                } = t.data;
                return e = parseFloat(e), {
                    motifs: {
                        planet: n.isLandscape ? {
                            yPosition: 13,
                            zPosition: -50
                        } : {
                            yPosition: 14,
                            zPosition: -30
                        },
                        halo: !0,
                        stars: !0,
                        zeppyBack: {
                            rColor: e + 1,
                            gColor: e + 1,
                            bColor: e + 1,
                            yPosition: n.isPortrait ? -1.2 : void 0,
                            ...gn(n.isPortrait ? 1.5 : 1.2, "Scale")
                        },
                        bigPlanet: !0,
                        atmousphere: !0
                    },
                    camera: {
                        zPosition: 4,
                        bindings: {
                            xTiltAmount: {
                                key: "xMouse",
                                speed: .3,
                                callback: t => .5 * t
                            }
                        }
                    }
                }
            }
        });
        n.addShot(o);
        const a = new Gt({
            key: "back-tilt",
            name: "Back Tilt",
            extend: o,
            stageAction: {
                camera: {
                    bindings: {
                        xTiltAmount: {
                            key: "xMouse",
                            speed: .3,
                            callback: t => .5 * t
                        }
                    }
                }
            }
        });
        n.addShot(a);
        const l = new Gt({
            key: "profile-tilt",
            name: "Profile Tilt",
            extend: s,
            stageAction: {
                camera: {
                    bindings: {
                        xTiltAmount: {
                            key: "xMouse",
                            speed: .3,
                            callback: t => .5 * t
                        }
                    }
                }
            }
        });
        n.addShot(l);
        const c = new Gt({
            key: "float-planet",
            name: "Float Planet",
            stageAction: t => ({
                motifs: {
                    zeppyFloat: !0,
                    stars: !0,
                    bigPlanet: {
                        animationSpeed: 8
                    }
                },
                camera: {
                    zPosition: 4,
                    bindings: {
                        xTiltAmount: "no"
                    }
                }
            })
        });
        n.addShot(c);
        const h = new Gt({
            key: "float",
            name: "Float",
            stageAction: t => ({
                motifs: {
                    zeppyFloat: !0,
                    beams: !0,
                    beams2: !0
                },
                camera: {
                    zPosition: 4
                }
            })
        });
        n.addShot(h);
        const u = new Gt({
            key: "float-beams",
            name: "Float Beams Only",
            stageAction: t => ({
                motifs: {
                    beams: !0,
                    beams2: !0
                },
                camera: {
                    zPosition: 4
                }
            })
        });
        n.addShot(u);
        const d = new Gt({
            key: "spaceship",
            name: "Spaceship",
            stageAction: t => ({
                motifs: {
                    spaceship: {
                        xRotation: -.4,
                        yRotation: -1,
                        zPosition: -6
                    },
                    bigPlanet: !0,
                    stars: !0
                },
                camera: {
                    zPosition: 4
                }
            })
        });
        return n.addShot(d), n.addSequence(new Fr({
            name: "Reel",
            key: "reel",
            steps: [new gr({
                shotKey: "profile",
                seconds: 5
            }), new gr({
                shotKey: "back",
                seconds: 5
            }), new gr({
                shotKey: "float",
                seconds: 5
            })]
        })), n
    },
    configureDisplay(t, e) {
        let n = !1;
        window.addEventListener("mousemove", (t => {
            n || (e.bindings.xMouse = t.x / window.innerWidth * 2 - 1, e.bindings.yMouse = t.y / window.innerHeight * 2 - 1)
        })), window.addEventListener("deviceorientation", (t => {
            (t.alpha || t.beta || t.gamma) && (n = !0, e.bindings.xMouse = 0 - Math.min(1, Math.max(-1, t.gamma / 90)), e.bindings.yMouse = Math.min(1, Math.max(-1, t.beta / 90 * 2 - 1)))
        })), e.bindings.yMouse = 0, e.bindings.xMouse = 0, window.addEventListener("scroll", (t => {
            const n = document.scrollingElement;
            e.bindings.xScroll = n.scrollLeft / (n.scrollWidth - n.clientWidth || 1), e.bindings.yScroll = n.scrollTop / (n.scrollHeight - n.clientHeight || 1)
        }));
        const i = document.scrollingElement;
        e.bindings.xScroll = i.scrollLeft / (i.scrollWidth - i.clientWidth || 1), e.bindings.yScroll = i.scrollTop / (i.scrollHeight - i.clientHeight || 1), e.bindings.heroOffset = 0, e.bindings.brightness = 0, e.bindings.contrast = 0, e.bindings.zeppyBrightness = 1
    }
});
export {
    qm as H, Bi as N, Zm as V, eg as Z, ng as e, Ao as l, v1 as p
};